<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-01-25 二 15:54 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Tensorflow Lite Internal</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wei Sun (孙伟)" />
<link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
<link rel = "icon" href = "/icon.png"  type = "image/x-icon">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Tensorflow Lite Internal</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org85f0999">1. TFLite Internal</a>
<ul>
<li><a href="#org2319025">1.1. Overview</a>
<ul>
<li><a href="#org8ab9fe0">1.1.1. BuiltinOpResolver</a></li>
<li><a href="#org9fe6990">1.1.2. InterpreterBuilder</a></li>
<li><a href="#orgc2315fb">1.1.3. AllocateTensors</a></li>
<li><a href="#org73baa19">1.1.4. Interpreter.Invoke</a></li>
</ul>
</li>
<li><a href="#org1148c58">1.2. TFLite Delegate</a>
<ul>
<li><a href="#orgba15b7d">1.2.1. A Simple Model</a></li>
<li><a href="#org4652499">1.2.2. MyDelegate</a></li>
<li><a href="#org9f69a0c">1.2.3. ModifyGraphWithDelegate</a></li>
<li><a href="#org97aa361">1.2.4. ReplaceNodeSubsetsWithDelegateKernels</a></li>
<li><a href="#orgd59f5a5">1.2.5. PartitionGraphIntoIndependentNodeSubsets</a></li>
<li><a href="#orgb3dfeda">1.2.6. Delegate 与 Custom Op 的区别</a></li>
<li><a href="#orgccda650">1.2.7. Flex Delegate</a></li>
</ul>
</li>
<li><a href="#org0f18681">1.3. TFLite Format</a></li>
<li><a href="#org1f37f79">1.4. TFLite Quantization Details</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org85f0999" class="outline-2">
<h2 id="org85f0999"><span class="section-number-2">1</span> TFLite Internal</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org2319025" class="outline-3">
<h3 id="org2319025"><span class="section-number-3">1.1</span> Overview</h3>
<div class="outline-text-3" id="text-1-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #757575;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span><span style="color: #757575;">,</span> <span style="color: #b58900;">char</span>* <span style="color: #268bd2;">argv</span>[]<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>argc != 2<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        fprintf<span style="color: #757575;">(</span>stderr<span style="color: #757575;">,</span> <span style="color: #2aa198;">"square &lt;tflite model&gt;\n"</span><span style="color: #757575;">)</span>;
        <span style="color: #859900;">return</span> 1;
    <span style="color: #757575;">}</span>
    <span style="color: #859900;">const</span> <span style="color: #b58900;">char</span>* <span style="color: #268bd2;">filename</span> = argv[1];

    <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">unique_ptr</span>&lt;<span style="color: #268bd2; font-weight: bold;">tflite</span>::FlatBufferModel&gt; <span style="color: #268bd2;">model</span> =
            <span style="color: #268bd2; font-weight: bold;">tflite</span>::<span style="color: #268bd2; font-weight: bold;">FlatBufferModel</span>::BuildFromFile<span style="color: #757575;">(</span>filename<span style="color: #757575;">)</span>;

    <span style="color: #268bd2; font-weight: bold;">tflite</span>::<span style="color: #268bd2; font-weight: bold;">ops</span>::<span style="color: #268bd2; font-weight: bold;">builtin</span>::<span style="color: #b58900;">BuiltinOpResolver</span> <span style="color: #268bd2;">resolver</span>;
    <span style="color: #b58900;">InterpreterBuilder</span> <span style="color: #268bd2;">builder</span><span style="color: #757575;">(</span>*model<span style="color: #757575;">,</span> resolver<span style="color: #757575;">)</span>;
    <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">unique_ptr</span>&lt;Interpreter&gt; <span style="color: #268bd2;">interpreter</span>;
    builder<span style="color: #757575;">(</span>&amp;interpreter<span style="color: #757575;">)</span>;

    interpreter-&gt;AllocateTensors<span style="color: #757575;">()</span>;
    <span style="color: #b58900;">float</span>* <span style="color: #268bd2;">input</span> = interpreter-&gt;typed_input_tensor&lt;<span style="color: #b58900;">float</span>&gt;<span style="color: #757575;">(</span>0<span style="color: #757575;">)</span>;
    input[0] = 10;
    interpreter-&gt;Invoke<span style="color: #757575;">()</span>;
    <span style="color: #b58900;">float</span>* <span style="color: #268bd2;">output</span> = interpreter-&gt;typed_output_tensor&lt;<span style="color: #b58900;">float</span>&gt;<span style="color: #757575;">(</span>0<span style="color: #757575;">)</span>;
    printf<span style="color: #757575;">(</span><span style="color: #2aa198;">"%f\n"</span><span style="color: #757575;">,</span> output[0]<span style="color: #757575;">)</span>;

    <span style="color: #859900;">return</span> 0;
<span style="color: #757575;">}</span>
</pre>
</div>
</div>

<div id="outline-container-org8ab9fe0" class="outline-4">
<h4 id="org8ab9fe0"><span class="section-number-4">1.1.1</span> BuiltinOpResolver</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
注册各个 op 对应的 Invoke 函数, 例如 abs 最终会对应 AbsEval, 后者最终会调用 std::abs
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #268bd2; font-weight: bold;">BuiltinOpResolver</span>::<span style="color: #268bd2;">BuiltinOpResolver</span><span style="color: #757575;">()</span> <span style="color: #757575;">{</span>
    AddBuiltin<span style="color: #757575;">(</span>BuiltinOperator_ABS<span style="color: #757575;">,</span> Register_ABS<span style="color: #757575;">())</span>;
    AddBuiltin<span style="color: #757575;">(</span>BuiltinOperator_RELU<span style="color: #757575;">,</span> Register_RELU<span style="color: #757575;">(),</span> 1<span style="color: #757575;">,</span> 2<span style="color: #757575;">)</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">...</span>
    AddBuiltin<span style="color: #757575;">(</span>BuiltinOperator_MAX_POOL_2D<span style="color: #757575;">,</span> Register_MAX_POOL_2D<span style="color: #757575;">(),</span> 1<span style="color: #757575;">,</span> 3<span style="color: #757575;">)</span>;
    AddBuiltin<span style="color: #757575;">(</span>BuiltinOperator_L2_POOL_2D<span style="color: #757575;">,</span> Register_L2_POOL_2D<span style="color: #757575;">())</span>;
    AddBuiltin<span style="color: #757575;">(</span>BuiltinOperator_CONV_2D<span style="color: #757575;">,</span> Register_CONV_2D<span style="color: #757575;">(),</span> 1<span style="color: #757575;">,</span> 5<span style="color: #757575;">)</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">....</span>
    AddBuiltin<span style="color: #757575;">(</span>BuiltinOperator_FULLY_CONNECTED<span style="color: #757575;">,</span> Register_FULLY_CONNECTED<span style="color: #757575;">(),</span> 1<span style="color: #757575;">,</span>
               9<span style="color: #757575;">)</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">...</span>
<span style="color: #757575;">}</span>

<span style="color: #b58900;">void</span> <span style="color: #268bd2; font-weight: bold;">MutableOpResolver</span>::<span style="color: #268bd2;">AddBuiltin</span><span style="color: #757575;">(</span><span style="color: #268bd2; font-weight: bold;">tflite</span>::<span style="color: #b58900;">BuiltinOperator</span> <span style="color: #268bd2;">op</span><span style="color: #757575;">,</span>
                                   <span style="color: #859900;">const</span> <span style="color: #b58900;">TfLiteRegistration</span>* <span style="color: #268bd2;">registration</span><span style="color: #757575;">,</span>
                                   <span style="color: #b58900;">int</span> <span style="color: #268bd2;">version</span><span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
    <span style="color: #b58900;">TfLiteRegistration</span> <span style="color: #268bd2;">new_registration</span> = *registration;
    new_registration.custom_name = <span style="color: #268bd2; font-weight: bold;">nullptr</span>;
    new_registration.builtin_code = op;
    new_registration.version = version;
    <span style="color: #859900;">auto</span> <span style="color: #268bd2;">op_key</span> = <span style="color: #268bd2; font-weight: bold;">std</span>::make_pair<span style="color: #757575;">(</span>op<span style="color: #757575;">,</span> version<span style="color: #757575;">)</span>;
    builtins_[op_key] = new_registration;
<span style="color: #757575;">}</span>

<span style="color: #b58900;">TfLiteRegistration</span>* <span style="color: #268bd2;">Register_ABS</span><span style="color: #757575;">()</span> <span style="color: #757575;">{</span>
    <span style="color: #859900;">static</span> <span style="color: #b58900;">TfLiteRegistration</span> <span style="color: #268bd2;">r</span> = <span style="color: #757575;">{</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">init</span>
        <span style="color: #268bd2; font-weight: bold;">nullptr</span><span style="color: #757575;">,</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">free</span>
        <span style="color: #268bd2; font-weight: bold;">nullptr</span><span style="color: #757575;">,</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">prepare</span>
        <span style="color: #268bd2; font-weight: bold;">elementwise</span>::<span style="color: #b58900;">GenericPrepare</span>&lt;<span style="color: #268bd2; font-weight: bold;">elementwise</span>::IsNumericSupportedType<span style="color: #757575;">,</span>
                                    <span style="color: #268bd2; font-weight: bold;">elementwise</span>::kAbsName&gt;<span style="color: #757575;">,</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">invoke</span>
        <span style="color: #268bd2; font-weight: bold;">elementwise</span>::AbsEval<span style="color: #757575;">}</span>;
    <span style="color: #859900;">return</span> &amp;r;
<span style="color: #757575;">}</span>

<span style="color: #b58900;">TfLiteStatus</span> <span style="color: #268bd2;">AbsEval</span><span style="color: #757575;">(</span><span style="color: #b58900;">TfLiteContext</span>* <span style="color: #268bd2;">context</span><span style="color: #757575;">,</span> <span style="color: #b58900;">TfLiteNode</span>* <span style="color: #268bd2;">node</span><span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
    <span style="color: #859900;">return</span> EvalNumeric<span style="color: #757575;">(</span>context<span style="color: #757575;">,</span> node<span style="color: #757575;">,</span> <span style="color: #268bd2; font-weight: bold;">std</span>::abs<span style="color: #757575;">)</span>;
<span style="color: #757575;">}</span>

<span style="color: #859900;">inline</span> <span style="color: #b58900;">TfLiteStatus</span> <span style="color: #268bd2;">EvalNumeric</span><span style="color: #757575;">(</span><span style="color: #b58900;">TfLiteContext</span>* <span style="color: #268bd2;">context</span><span style="color: #757575;">,</span> <span style="color: #b58900;">TfLiteNode</span>* <span style="color: #268bd2;">node</span><span style="color: #757575;">,</span>
                                <span style="color: #b58900;">float</span> <span style="color: #268bd2;">float_func</span><span style="color: #757575;">(</span><span style="color: #b58900;">float</span><span style="color: #757575;">))</span> <span style="color: #757575;">{</span>
    <span style="color: #859900;">return</span> EvalImpl&lt;<span style="color: #b58900;">float</span>&gt;<span style="color: #757575;">(</span>context<span style="color: #757575;">,</span> node<span style="color: #757575;">,</span> float_func<span style="color: #757575;">,</span> kTfLiteFloat32<span style="color: #757575;">)</span>;
<span style="color: #757575;">}</span>

<span style="color: #859900;">template</span> &lt;<span style="color: #859900;">typename</span> <span style="color: #b58900;">T</span>&gt;
<span style="color: #859900;">inline</span> <span style="color: #b58900;">TfLiteStatus</span> <span style="color: #268bd2;">EvalImpl</span><span style="color: #757575;">(</span><span style="color: #b58900;">TfLiteContext</span>* <span style="color: #268bd2;">context</span><span style="color: #757575;">,</span> <span style="color: #b58900;">TfLiteNode</span>* <span style="color: #268bd2;">node</span><span style="color: #757575;">,</span>
                             <span style="color: #b58900;">T</span> <span style="color: #268bd2;">func</span><span style="color: #757575;">(</span><span style="color: #b58900;">T</span><span style="color: #757575;">),</span> <span style="color: #b58900;">TfLiteType</span> <span style="color: #268bd2;">expected_type</span><span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
    <span style="color: #859900;">const</span> <span style="color: #b58900;">TfLiteTensor</span>* <span style="color: #268bd2;">input</span> = GetInput<span style="color: #757575;">(</span>context<span style="color: #757575;">,</span> node<span style="color: #757575;">,</span> 0<span style="color: #757575;">)</span>;
    <span style="color: #b58900;">TfLiteTensor</span>* <span style="color: #268bd2;">output</span> = GetOutput<span style="color: #757575;">(</span>context<span style="color: #757575;">,</span> node<span style="color: #757575;">,</span> 0<span style="color: #757575;">)</span>;
    TF_LITE_ENSURE_TYPES_EQ<span style="color: #757575;">(</span>context<span style="color: #757575;">,</span> input-&gt;type<span style="color: #757575;">,</span> expected_type<span style="color: #757575;">)</span>;
    <span style="color: #859900;">const</span> <span style="color: #b58900;">int64_t</span> <span style="color: #268bd2;">num_elements</span> = NumElements<span style="color: #757575;">(</span>input<span style="color: #757575;">)</span>;
    <span style="color: #859900;">const</span> <span style="color: #b58900;">T</span>* <span style="color: #268bd2;">in_data</span> = GetTensorData&lt;<span style="color: #b58900;">T</span>&gt;<span style="color: #757575;">(</span>input<span style="color: #757575;">)</span>;
    <span style="color: #b58900;">T</span>* <span style="color: #268bd2;">out_data</span> = GetTensorData&lt;<span style="color: #b58900;">T</span>&gt;<span style="color: #757575;">(</span>output<span style="color: #757575;">)</span>;
    <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #b58900;">int64_t</span> <span style="color: #268bd2;">i</span> = 0; i &lt; num_elements; ++i<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! out_data[i] = std::abs(in_data[i])</span>
        out_data[i] = func<span style="color: #757575;">(</span>in_data[i]<span style="color: #757575;">)</span>;
    <span style="color: #757575;">}</span>
    <span style="color: #859900;">return</span> kTfLiteOk;
<span style="color: #757575;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org9fe6990" class="outline-4">
<h4 id="org9fe6990"><span class="section-number-4">1.1.2</span> InterpreterBuilder</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
生成 interpreter, 主要是根据 model 中的 operator 及 resolver 中的 registration
生成 graph 及其中的 node 以便执行. 另外会用 delegate 把 graph 分割为不同的
subgraph 以分别执行.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #b58900;">TfLiteStatus</span> <span style="color: #268bd2; font-weight: bold;">InterpreterBuilder</span>::<span style="color: #859900;">operator</span><span style="color: #757575;">()(</span>
    <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">unique_ptr</span>&lt;Interpreter&gt;* <span style="color: #268bd2;">interpreter</span><span style="color: #757575;">,</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">num_threads</span><span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! &#26597;&#25214; resolver &#20013;&#35760;&#24405;&#30340; registration</span>
    BuildLocalIndexToRegistrationMapping<span style="color: #757575;">()</span>;

    <span style="color: #859900;">auto</span>* <span style="color: #268bd2;">subgraphs</span> = model_-&gt;subgraphs<span style="color: #757575;">()</span>;
    <span style="color: #859900;">auto</span>* <span style="color: #268bd2;">buffers</span> = model_-&gt;buffers<span style="color: #757575;">()</span>;

    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>subgraphs-&gt;size<span style="color: #757575;">()</span> &gt; 1<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        <span style="color: #757575;">(</span>*interpreter<span style="color: #757575;">)</span>-&gt;AddSubgraphs<span style="color: #757575;">(</span>subgraphs-&gt;size<span style="color: #757575;">()</span> - 1<span style="color: #757575;">)</span>;
    <span style="color: #757575;">}</span>

    <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">subgraph_index</span> = 0; subgraph_index &lt; subgraphs-&gt;size<span style="color: #757575;">()</span>;
         ++subgraph_index<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        <span style="color: #859900;">const</span> <span style="color: #268bd2; font-weight: bold;">tflite</span>::<span style="color: #b58900;">SubGraph</span>* <span style="color: #268bd2;">subgraph</span> = <span style="color: #757575;">(</span>*subgraphs<span style="color: #757575;">)</span>[subgraph_index];
        <span style="color: #268bd2; font-weight: bold;">tflite</span>::<span style="color: #b58900;">Subgraph</span>* <span style="color: #268bd2;">modified_subgraph</span> =
            <span style="color: #757575;">(</span>*interpreter<span style="color: #757575;">)</span>-&gt;subgraph<span style="color: #757575;">(</span>subgraph_index<span style="color: #757575;">)</span>;
        <span style="color: #859900;">auto</span> <span style="color: #268bd2;">operators</span> = subgraph-&gt;operators<span style="color: #757575;">()</span>;
        <span style="color: #859900;">auto</span> <span style="color: #268bd2;">tensors</span> = subgraph-&gt;tensors<span style="color: #757575;">()</span>;

        modified_subgraph-&gt;AddTensors<span style="color: #757575;">(</span>tensors-&gt;size<span style="color: #757575;">())</span>;

        modified_subgraph-&gt;SetInputs<span style="color: #757575;">(</span>
            FlatBufferIntArrayToVector<span style="color: #757575;">(</span>subgraph-&gt;inputs<span style="color: #757575;">()))</span>;
        modified_subgraph-&gt;SetOutputs<span style="color: #757575;">(</span>
            FlatBufferIntArrayToVector<span style="color: #757575;">(</span>subgraph-&gt;outputs<span style="color: #757575;">()))</span>;

        <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! &#26681;&#25454; operator &#29983;&#25104; node &#21450; execution_plan</span>
        ParseNodes<span style="color: #757575;">(</span>operators<span style="color: #757575;">,</span> modified_subgraph<span style="color: #757575;">)</span>;
        ParseTensors<span style="color: #757575;">(</span>buffers<span style="color: #757575;">,</span> tensors<span style="color: #757575;">,</span> modified_subgraph<span style="color: #757575;">)</span>;

        <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">vector</span>&lt;<span style="color: #b58900;">int</span>&gt; <span style="color: #268bd2;">variables</span>;
        <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">i</span> = 0; i &lt; modified_subgraph-&gt;tensors_size<span style="color: #757575;">()</span>; ++i<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
            <span style="color: #859900;">auto</span>* <span style="color: #268bd2;">tensor</span> = modified_subgraph-&gt;tensor<span style="color: #757575;">(</span>i<span style="color: #757575;">)</span>;
            <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>tensor-&gt;is_variable<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
                variables.push_back<span style="color: #757575;">(</span>i<span style="color: #757575;">)</span>;
            <span style="color: #757575;">}</span>
        <span style="color: #757575;">}</span>
        modified_subgraph-&gt;SetVariables<span style="color: #757575;">(</span><span style="color: #268bd2; font-weight: bold;">std</span>::move<span style="color: #757575;">(</span>variables<span style="color: #757575;">))</span>;
    <span style="color: #757575;">}</span>

    <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! &#26159;&#21542;&#20351;&#29992; flex delegate &#25903;&#25345; tensorflow op (&#32780;&#19981;&#26159; tflite builtin op)</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">https://www.tensorflow.org/lite/guide/ops_select?hl=zh-cn</span>
    ApplyDelegates<span style="color: #757575;">(</span>interpreter-&gt;get<span style="color: #757575;">(),</span> num_threads<span style="color: #757575;">)</span>
<span style="color: #757575;">}</span>
</pre>
</div>
</div>

<div id="outline-container-orgdeba14a" class="outline-5">
<h5 id="orgdeba14a"><span class="section-number-5">1.1.2.1</span> BuildLocalIndexToRegistrationMapping</h5>
<div class="outline-text-5" id="text-1-1-2-1">
<p>
查找之前 BuiltinOpResolver 注册的 registration
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #b58900;">TfLiteStatus</span> <span style="color: #268bd2; font-weight: bold;">InterpreterBuilder</span>::<span style="color: #268bd2;">BuildLocalIndexToRegistrationMapping</span><span style="color: #757575;">()</span> <span style="color: #757575;">{</span>
    unresolved_custom_ops_.clear<span style="color: #757575;">()</span>;

    <span style="color: #859900;">auto</span> <span style="color: #268bd2;">opcodes</span> = model_-&gt;operator_codes<span style="color: #757575;">()</span>;

    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">num_custom_ops</span> = 0;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">builtin_code &#38500;&#20102;&#27491;&#24120;&#30340;&#22914; BuiltinOperator_ABS &#20043;&#31867;&#30340;, &#36824;&#21253;&#21547;&#20004;&#31181;&#29305;&#27530;&#30340;&#20540;:</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">BuiltinOperator\_CUSTOM</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">BuiltinOperator\_DELEGATE</span>
    <span style="color: #586e75;">//</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20854;&#20013;&#23545;&#20110; BuiltinOperator_CUSTOM, OperatorCode.custom_code (&#19968;&#20010; string)</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#29992;&#26469;&#21306;&#21035;&#36825;&#20010; custom op &#20855;&#20307;&#26159;&#20160;&#20040;.</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#23545;&#20110; custom op, BuiltinOpResolver &#21487;&#20197;&#36890;&#36807; AddCustom &#28155;&#21152;&#23545;&#23427;&#30340;&#25903;&#25345;,</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#25110;&#32773; delegate &#20063;&#21487;&#20197;&#25903;&#25345;&#23427;, &#20294; delegate &#30340;&#25903;&#25345;&#24182;&#19981;&#20250;&#22312; resolver &#20013;&#20307;&#29616;,</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#25152;&#20197;&#19979;&#38754;&#30340;&#20195;&#30721;&#20250;&#26377; unresolved_custom_ops_</span>

    <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #859900;">const</span> <span style="color: #b58900;">OperatorCode</span>* <span style="color: #268bd2;">opcode</span> : *opcodes<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>opcode-&gt;builtin_code<span style="color: #757575;">()</span> == BuiltinOperator_CUSTOM<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
            num_custom_ops++;
        <span style="color: #757575;">}</span>
    <span style="color: #757575;">}</span>
    unresolved_custom_ops_.reserve<span style="color: #757575;">(</span>num_custom_ops<span style="color: #757575;">)</span>;
    <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #859900;">const</span> <span style="color: #b58900;">OperatorCode</span>* <span style="color: #268bd2;">opcode</span> : *opcodes<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        <span style="color: #859900;">const</span> <span style="color: #b58900;">TfLiteRegistration</span>* <span style="color: #268bd2;">registration</span> = <span style="color: #268bd2; font-weight: bold;">nullptr</span>;
        <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! &#26597;&#25214; builtin_code &#21644; custom_code</span>
        status = GetRegistrationFromOpCode<span style="color: #757575;">(</span>opcode<span style="color: #757575;">,</span> op_resolver_<span style="color: #757575;">,</span> error_reporter_<span style="color: #757575;">,</span>
                                           &amp;registration<span style="color: #757575;">)</span>;
        <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! op &#22312; resolver &#20013;&#25214;&#19981;&#21040; registration, &#20132;&#32473; delegate</span>
        <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>status != kTfLiteOk<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
            <span style="color: #859900;">const</span> <span style="color: #859900;">auto</span>* <span style="color: #268bd2;">op_name</span> = opcode-&gt;custom_code<span style="color: #757575;">()</span>-&gt;c_str<span style="color: #757575;">()</span>;
            unresolved_custom_ops_.push_back<span style="color: #757575;">(</span>CreateUnresolvedCustomOp<span style="color: #757575;">(</span>op_name<span style="color: #757575;">))</span>;
            registration = &amp;unresolved_custom_ops_.back<span style="color: #757575;">()</span>;
            has_flex_op_ |= IsFlexOp<span style="color: #757575;">(</span>op_name<span style="color: #757575;">)</span>;
            status = kTfLiteOk;
        <span style="color: #757575;">}</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! registration &#25353;&#39034;&#24207;&#35760;&#24405;&#19979;&#26469;</span>
        flatbuffer_op_index_to_registration_.push_back<span style="color: #757575;">(</span>registration<span style="color: #757575;">)</span>;
    <span style="color: #757575;">}</span>
    <span style="color: #859900;">return</span> status;
<span style="color: #757575;">}</span>

<span style="color: #268bd2; font-weight: bold;">GetRegistrationFromOpCode</span>:
    *registration = op_resolver.FindOp<span style="color: #757575;">(</span>builtin_code<span style="color: #757575;">,</span> version<span style="color: #757575;">)</span>;
        <span style="color: #859900;">return</span> builtins_.find<span style="color: #757575;">(</span><span style="color: #268bd2; font-weight: bold;">std</span>::make_pair<span style="color: #757575;">(</span>op<span style="color: #757575;">,</span> version<span style="color: #757575;">))</span>;
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>not_found_in_builtins<span style="color: #757575;">)</span>:
        <span style="color: #859900;">const</span> <span style="color: #b58900;">char</span>* <span style="color: #268bd2;">name</span> = opcode-&gt;custom_code<span style="color: #757575;">()</span>-&gt;c_str<span style="color: #757575;">()</span>;
        *registration = op_resolver.FindOp<span style="color: #757575;">(</span>name<span style="color: #757575;">,</span> version<span style="color: #757575;">)</span>;
        <span style="color: #859900;">return</span> custom_ops_.find<span style="color: #757575;">(</span><span style="color: #268bd2; font-weight: bold;">std</span>::make_pair<span style="color: #757575;">(</span>op<span style="color: #757575;">,</span> version<span style="color: #757575;">))</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-org6dea4ae" class="outline-5">
<h5 id="org6dea4ae"><span class="section-number-5">1.1.2.2</span> ParseNode</h5>
<div class="outline-text-5" id="text-1-1-2-2">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #b58900;">TfLiteStatus</span> <span style="color: #268bd2; font-weight: bold;">InterpreterBuilder</span>::<span style="color: #268bd2;">ParseNodes</span><span style="color: #757575;">(</span>
    <span style="color: #859900;">const</span> <span style="color: #268bd2; font-weight: bold;">flatbuffers</span>::<span style="color: #b58900;">Vector</span>&lt;<span style="color: #268bd2; font-weight: bold;">flatbuffers</span>::<span style="color: #b58900;">Offset</span>&lt;Operator&gt;&gt;* <span style="color: #268bd2;">operators</span><span style="color: #757575;">,</span>
    <span style="color: #b58900;">Subgraph</span>* <span style="color: #268bd2;">subgraph</span><span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">Reduce the number of redundant allocations</span>
    subgraph-&gt;ReserveNodes<span style="color: #757575;">(</span>operators-&gt;size<span style="color: #757575;">())</span>;

    <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">i</span> = 0; i &lt; operators-&gt;size<span style="color: #757575;">()</span>; ++i<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        <span style="color: #859900;">const</span> <span style="color: #859900;">auto</span>* <span style="color: #268bd2;">op</span> = operators-&gt;Get<span style="color: #757575;">(</span>i<span style="color: #757575;">)</span>;
        <span style="color: #b58900;">int</span> <span style="color: #268bd2;">index</span> = op-&gt;opcode_index<span style="color: #757575;">()</span>;

        <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! &#25214;&#21040; registration</span>
        <span style="color: #859900;">const</span> <span style="color: #b58900;">TfLiteRegistration</span>* <span style="color: #268bd2;">registration</span> =
            flatbuffer_op_index_to_registration_[index];

        <span style="color: #b58900;">BuiltinOperator</span> <span style="color: #268bd2;">op_type</span> =
            <span style="color: #859900;">static_cast</span>&lt;<span style="color: #b58900;">BuiltinOperator</span>&gt;<span style="color: #757575;">(</span>registration-&gt;builtin_code<span style="color: #757575;">)</span>;

        <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>op_type == BuiltinOperator_CUSTOM<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
            subgraph-&gt;AddNodeWithParameters<span style="color: #757575;">(</span>
                FlatBufferIntArrayToVector<span style="color: #757575;">(</span>op-&gt;inputs<span style="color: #757575;">()),</span>
                FlatBufferIntArrayToVector<span style="color: #757575;">(</span>op-&gt;outputs<span style="color: #757575;">()),</span>
                FlatBufferIntArrayToVector<span style="color: #757575;">(</span>op-&gt;intermediates<span style="color: #757575;">()),</span> <span style="color: #268bd2; font-weight: bold;">nullptr</span><span style="color: #757575;">,</span> 0<span style="color: #757575;">,</span>
                <span style="color: #268bd2; font-weight: bold;">nullptr</span><span style="color: #757575;">,</span> registration<span style="color: #757575;">)</span>;

        <span style="color: #757575;">}</span> <span style="color: #859900;">else</span> <span style="color: #757575;">{</span>
            <span style="color: #b58900;">void</span>* <span style="color: #268bd2;">builtin_data</span> = <span style="color: #268bd2; font-weight: bold;">nullptr</span>;
            <span style="color: #b58900;">MallocDataAllocator</span> <span style="color: #268bd2;">malloc_allocator</span>;
            TF_LITE_ENSURE_STATUS<span style="color: #757575;">(</span>ParseOpData<span style="color: #757575;">(</span>op<span style="color: #757575;">,</span> op_type<span style="color: #757575;">,</span> error_reporter_<span style="color: #757575;">,</span>
                                              &amp;malloc_allocator<span style="color: #757575;">,</span>
                                              &amp;builtin_data<span style="color: #757575;">))</span>;
            subgraph-&gt;AddNodeWithParameters<span style="color: #757575;">(</span>
                FlatBufferIntArrayToVector<span style="color: #757575;">(</span>op-&gt;inputs<span style="color: #757575;">()),</span>
                FlatBufferIntArrayToVector<span style="color: #757575;">(</span>op-&gt;outputs<span style="color: #757575;">()),</span>
                FlatBufferIntArrayToVector<span style="color: #757575;">(</span>op-&gt;intermediates<span style="color: #757575;">()),</span> <span style="color: #268bd2; font-weight: bold;">nullptr</span><span style="color: #757575;">,</span> 0<span style="color: #757575;">,</span>
                builtin_data<span style="color: #757575;">,</span> registration<span style="color: #757575;">)</span>;
        <span style="color: #757575;">}</span>
    <span style="color: #757575;">}</span>

    <span style="color: #859900;">return</span> status;
<span style="color: #757575;">}</span>

<span style="color: #b58900;">TfLiteStatus</span> <span style="color: #268bd2; font-weight: bold;">Subgraph</span>::<span style="color: #268bd2;">AddNodeWithParameters</span><span style="color: #757575;">(</span>
    <span style="color: #859900;">const</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">vector</span>&lt;<span style="color: #b58900;">int</span>&gt;&amp; <span style="color: #268bd2;">inputs</span><span style="color: #757575;">,</span> <span style="color: #859900;">const</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">vector</span>&lt;<span style="color: #b58900;">int</span>&gt;&amp; <span style="color: #268bd2;">outputs</span><span style="color: #757575;">,</span>
    <span style="color: #859900;">const</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">vector</span>&lt;<span style="color: #b58900;">int</span>&gt;&amp; <span style="color: #268bd2;">intermediates</span><span style="color: #757575;">,</span> <span style="color: #859900;">const</span> <span style="color: #b58900;">char</span>* <span style="color: #268bd2;">init_data</span><span style="color: #757575;">,</span>
    <span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">init_data_size</span><span style="color: #757575;">,</span> <span style="color: #b58900;">void</span>* <span style="color: #268bd2;">builtin_data</span><span style="color: #757575;">,</span>
    <span style="color: #859900;">const</span> <span style="color: #b58900;">TfLiteRegistration</span>* <span style="color: #268bd2;">registration</span><span style="color: #757575;">,</span> <span style="color: #b58900;">int</span>* <span style="color: #268bd2;">node_index</span><span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
    <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">unique_ptr</span>&lt;<span style="color: #b58900;">void</span><span style="color: #757575;">,</span> <span style="color: #859900;">decltype</span><span style="color: #757575;">(</span>free<span style="color: #757575;">)</span>*&gt; <span style="color: #268bd2;">builtin_data_deleter</span><span style="color: #757575;">(</span>builtin_data<span style="color: #757575;">,</span>
                                                                free<span style="color: #757575;">)</span>;

    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">new_node_index</span> = nodes_and_registration_.size<span style="color: #757575;">()</span>;
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>node_index<span style="color: #757575;">)</span> *node_index = new_node_index;
    nodes_and_registration_.resize<span style="color: #757575;">(</span>nodes_and_registration_.size<span style="color: #757575;">()</span> + 1<span style="color: #757575;">)</span>;
    <span style="color: #859900;">auto</span>&amp; <span style="color: #268bd2;">node_and_reg</span> = nodes_and_registration_.back<span style="color: #757575;">()</span>;
    <span style="color: #b58900;">TfLiteNode</span>&amp; <span style="color: #268bd2;">node</span> = node_and_reg.first;
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>node.inputs<span style="color: #757575;">)</span> TfLiteIntArrayFree<span style="color: #757575;">(</span>node.inputs<span style="color: #757575;">)</span>;
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>node.outputs<span style="color: #757575;">)</span> TfLiteIntArrayFree<span style="color: #757575;">(</span>node.outputs<span style="color: #757575;">)</span>;
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>node.intermediates<span style="color: #757575;">)</span> TfLiteIntArrayFree<span style="color: #757575;">(</span>node.intermediates<span style="color: #757575;">)</span>;
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>node.temporaries<span style="color: #757575;">)</span> TfLiteIntArrayFree<span style="color: #757575;">(</span>node.temporaries<span style="color: #757575;">)</span>;

    node.inputs = ConvertVectorToTfLiteIntArray<span style="color: #757575;">(</span>inputs<span style="color: #757575;">)</span>;
    node.outputs = ConvertVectorToTfLiteIntArray<span style="color: #757575;">(</span>outputs<span style="color: #757575;">)</span>;
    node.intermediates = ConvertVectorToTfLiteIntArray<span style="color: #757575;">(</span>intermediates<span style="color: #757575;">)</span>;
    node.temporaries = TfLiteIntArrayCreate<span style="color: #757575;">(</span>0<span style="color: #757575;">)</span>;
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>init_data<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        node.user_data = OpInit<span style="color: #757575;">(</span>*registration<span style="color: #757575;">,</span> init_data<span style="color: #757575;">,</span> init_data_size<span style="color: #757575;">)</span>;
    <span style="color: #757575;">}</span> <span style="color: #859900;">else</span> <span style="color: #757575;">{</span>
        node.user_data = OpInit<span style="color: #757575;">(</span>
            *registration<span style="color: #757575;">,</span> <span style="color: #859900;">static_cast</span>&lt;<span style="color: #859900;">const</span> <span style="color: #b58900;">char</span>*&gt;<span style="color: #757575;">(</span>builtin_data_deleter.get<span style="color: #757575;">()),</span> 0<span style="color: #757575;">)</span>;
    <span style="color: #757575;">}</span>

    node.builtin_data = builtin_data_deleter.release<span style="color: #757575;">()</span>;

    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>registration-&gt;builtin_code == BuiltinOperator_CUSTOM<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">When it's a CUSTOM op, the `custom_options` field in the Flatbuffer</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">`Operator` table is passed in.</span>
        node.custom_initial_data = init_data;
        node.custom_initial_data_size = init_data_size;
    <span style="color: #757575;">}</span> <span style="color: #859900;">else</span> <span style="color: #757575;">{</span>
        node.custom_initial_data = <span style="color: #268bd2; font-weight: bold;">nullptr</span>;
        node.custom_initial_data_size = 0;
    <span style="color: #757575;">}</span>

    node.delegate = <span style="color: #268bd2; font-weight: bold;">nullptr</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">Copying of registration is required to support unresolved custom ops.</span>
    node_and_reg.second = *registration;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! execution_plan_ &#34920;&#31034; subgraph invoke &#26102;&#21508;&#20010; node (operator) &#25191;&#34892;&#30340;&#39034;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#24207;, &#23454;&#38469;&#19978; tflite &#27169;&#22411;&#20013;&#30340; operator &#24050;&#32463;&#26159;&#25299;&#25169;&#25490;&#24207;&#30340;&#20102;, &#25152;&#20197;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">execution_plan_ &#22522;&#26412;&#19978;&#21644; operator &#39034;&#24207;&#30456;&#21516;, &#38500;&#38750;&#28041;&#21450;&#21040; delegate</span>
    execution_plan_.push_back<span style="color: #757575;">(</span>new_node_index<span style="color: #757575;">)</span>;
    <span style="color: #859900;">return</span> kTfLiteOk;
<span style="color: #757575;">}</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgc2315fb" class="outline-4">
<h4 id="orgc2315fb"><span class="section-number-4">1.1.3</span> AllocateTensors</h4>
<div class="outline-text-4" id="text-1-1-3">
</div>
<div id="outline-container-org5dafbb3" class="outline-5">
<h5 id="org5dafbb3"><span class="section-number-5">1.1.3.1</span> constant allocation</h5>
<div class="outline-text-5" id="text-1-1-3-1">
<p>
constant 直接把 flatbuffer mmap 进来使用
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #b58900;">TfLiteStatus</span> <span style="color: #268bd2; font-weight: bold;">InterpreterBuilder</span>::<span style="color: #268bd2;">ParseTensors</span><span style="color: #757575;">(</span>
    <span style="color: #859900;">const</span> <span style="color: #268bd2; font-weight: bold;">flatbuffers</span>::<span style="color: #b58900;">Vector</span>&lt;<span style="color: #268bd2; font-weight: bold;">flatbuffers</span>::<span style="color: #b58900;">Offset</span>&lt;Buffer&gt;&gt;* <span style="color: #268bd2;">buffers</span><span style="color: #757575;">,</span>
    <span style="color: #859900;">const</span> <span style="color: #268bd2; font-weight: bold;">flatbuffers</span>::<span style="color: #b58900;">Vector</span>&lt;<span style="color: #268bd2; font-weight: bold;">flatbuffers</span>::<span style="color: #b58900;">Offset</span>&lt;Tensor&gt;&gt;* <span style="color: #268bd2;">tensors</span><span style="color: #757575;">,</span>
    <span style="color: #b58900;">Subgraph</span>* <span style="color: #268bd2;">subgraph</span><span style="color: #757575;">)</span> <span style="color: #757575;">{</span>

    <span style="color: #859900;">auto</span> <span style="color: #268bd2;">get_readonly_data</span> = [&amp;]<span style="color: #757575;">(</span><span style="color: #859900;">const</span> <span style="color: #b58900;">char</span>** <span style="color: #268bd2;">buffer_data</span><span style="color: #757575;">,</span>
                                 <span style="color: #b58900;">size_t</span>* <span style="color: #268bd2;">buffer_size</span><span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        *buffer_data = <span style="color: #268bd2; font-weight: bold;">nullptr</span>;
        <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! &#22914;&#26524;&#26159; constant tensor, &#21017; tensor-&gt;buffer() &#25351;&#21521; floatbuffer &#20013;</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">constant tensor &#30340;&#25968;&#25454;, &#36825;&#20010;&#25968;&#25454;&#26159;&#30452;&#25509;&#36890;&#36807; mmap &#26144;&#23556;&#36827;&#26469; (flatbuffer</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">&#30456;&#27604; protocalbuffer &#30340;&#20248;&#21183;)</span>
        <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>tensor-&gt;buffer<span style="color: #757575;">()</span> == 0<span style="color: #757575;">)</span> <span style="color: #859900;">return</span> kTfLiteOk;
        <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #859900;">auto</span>* <span style="color: #268bd2;">buffer</span> = <span style="color: #757575;">(</span>*buffers<span style="color: #757575;">)</span>[tensor-&gt;buffer<span style="color: #757575;">()</span>]<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
            <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #859900;">auto</span>* <span style="color: #268bd2;">array</span> = buffer-&gt;data<span style="color: #757575;">())</span> <span style="color: #757575;">{</span>
                <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">size</span> = array-&gt;size<span style="color: #757575;">())</span> <span style="color: #757575;">{</span>
                    *buffer_size = size;
                    *buffer_data = <span style="color: #859900;">reinterpret_cast</span>&lt;<span style="color: #859900;">const</span> <span style="color: #b58900;">char</span>*&gt;<span style="color: #757575;">(</span>array-&gt;data<span style="color: #757575;">())</span>;
                    <span style="color: #859900;">return</span> kTfLiteOk;
                <span style="color: #757575;">}</span>
            <span style="color: #757575;">}</span>
        <span style="color: #757575;">}</span>
        <span style="color: #859900;">return</span> kTfLiteOk;
    <span style="color: #757575;">}</span>;

    get_readonly_data<span style="color: #757575;">(</span>&amp;buffer_ptr<span style="color: #757575;">,</span> &amp;buffer_size<span style="color: #757575;">)</span>;

    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>buffer_ptr<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        subgraph-&gt;SetTensorParametersReadOnly<span style="color: #757575;">(</span>
            i<span style="color: #757575;">,</span> type<span style="color: #757575;">,</span> get_name<span style="color: #757575;">(</span>tensor<span style="color: #757575;">),</span> dims<span style="color: #757575;">,</span> quantization<span style="color: #757575;">,</span> buffer_ptr<span style="color: #757575;">,</span>
            buffer_size<span style="color: #757575;">,</span> allocation_<span style="color: #757575;">,</span> sparsity<span style="color: #757575;">)</span>;

            tensor.data.raw = <span style="color: #859900;">const_cast</span>&lt;<span style="color: #b58900;">char</span>*&gt;<span style="color: #757575;">(</span>buffer<span style="color: #757575;">)</span>;
    <span style="color: #757575;">}</span> <span style="color: #859900;">else</span> <span style="color: #757575;">{</span>
        subgraph-&gt;SetTensorParametersReadWrite<span style="color: #757575;">(</span>
            i<span style="color: #757575;">,</span> type<span style="color: #757575;">,</span> get_name<span style="color: #757575;">(</span>tensor<span style="color: #757575;">),</span> dims<span style="color: #757575;">,</span> quantization<span style="color: #757575;">,</span> is_variable<span style="color: #757575;">,</span>
            dims_signature_rank<span style="color: #757575;">,</span> dims_signature_data<span style="color: #757575;">)</span>;
            <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! kTfLiteArenaRw &#19982; kTfLiteArenaRwPersistent</span>
            <span style="color: #586e75;">// </span><span style="color: #586e75;">&#26368;&#32456;&#20250;&#20998;&#37197;&#21040;&#19981;&#21516;&#30340; buffer</span>
            <span style="color: #b58900;">TfLiteAllocationType</span> <span style="color: #268bd2;">allocation_type</span> = kTfLiteArenaRw;
            <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>is_variable<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
                allocation_type = kTfLiteArenaRwPersistent;
            <span style="color: #757575;">}</span>
            tensor.data.raw = 0;
            tensor.allocation_type = allocation_type;
            tensor.bytes = required_bytes;
            <span style="color: #586e75;">// </span><span style="color: #586e75;">...</span>
    <span style="color: #757575;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcd2a64d" class="outline-5">
<h5 id="orgcd2a64d"><span class="section-number-5">1.1.3.2</span> tensor allocation</h5>
<div class="outline-text-5" id="text-1-1-3-2">
<p>
tensor, 包括:
</p>

<ol class="org-ol">
<li>variable (可训练的参数) tensor</li>
<li>intermediate tensor</li>
<li>temporary tensor</li>
</ol>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #b58900;">TfLiteStatus</span> <span style="color: #268bd2; font-weight: bold;">Subgraph</span>::<span style="color: #268bd2;">AllocateTensors</span><span style="color: #757575;">(){</span>PrepareOpsAndTensors<span style="color: #757575;">()}</span>

<span style="color: #268bd2;">PrepareOpsAndTensors</span><span style="color: #757575;">()</span> <span style="color: #757575;">{</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! preserve_inputs &#40664;&#35748;&#20026; true, &#25152;&#20197;&#22810;&#27425;&#36816;&#34892;&#26102;&#19981;&#38656;&#35201;&#37325;&#22797;&#32473; input tensor</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#36171;&#20540;</span>
    <span style="color: #586e75;">//</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">preserve_intermediates &#20026; false, &#25152;&#20197;&#26080;&#27861;&#26597;&#35810;&#20013;&#38388;&#32467;&#26524;</span>
    memory_planner_.reset<span style="color: #757575;">(</span><span style="color: #859900;">new</span> <span style="color: #b58900;">ArenaPlanner</span><span style="color: #757575;">(</span>
        &amp;context_<span style="color: #757575;">,</span> <span style="color: #268bd2; font-weight: bold;">std</span>::unique_ptr&lt;GraphInfo&gt;<span style="color: #757575;">(</span><span style="color: #859900;">new</span> <span style="color: #b58900;">InterpreterInfo</span><span style="color: #757575;">(</span><span style="color: #859900;">this</span><span style="color: #757575;">)),</span>
        <span style="color: #586e75;">/*</span><span style="color: #586e75;">preserve_inputs=</span><span style="color: #586e75;">*/</span><span style="color: #268bd2; font-weight: bold;">true</span><span style="color: #757575;">,</span> <span style="color: #586e75;">/*</span><span style="color: #586e75;">preserve_intermediates</span><span style="color: #586e75;">*/</span> <span style="color: #268bd2; font-weight: bold;">false</span><span style="color: #757575;">,</span>
        kDefaultTensorAlignment<span style="color: #757575;">))</span>;
    memory_planner_-&gt;PlanAllocations<span style="color: #757575;">()</span>;
    memory_planner_-&gt;ExecuteAllocations<span style="color: #757575;">(</span>
        next_execution_plan_index_to_plan_allocation_<span style="color: #757575;">,</span>
        last_exec_plan_index_prepared<span style="color: #757575;">))</span>;
<span style="color: #757575;">}</span>
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org5d33eff"></a>PlanAllocations<br />
<div class="outline-text-6" id="text-1-1-3-2-1">
<ol class="org-ol">
<li>标记只些 tensor 不能被覆盖 (通过 refcount)</li>
<li>记录 tensor 的 start_node 和 finish_node, 即 tensor 的生命期, 生命期不重叠的
tensor 可以共用内存</li>
</ol>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #b58900;">TfLiteStatus</span> <span style="color: #268bd2; font-weight: bold;">ArenaPlanner</span>::<span style="color: #268bd2;">PlanAllocations</span><span style="color: #757575;">()</span> <span style="color: #757575;">{</span>
    alloc_node_.assign<span style="color: #757575;">(</span>graph_info_-&gt;num_tensors<span style="color: #757575;">(),</span> kNodeNotAssigned<span style="color: #757575;">)</span>;
    dealloc_node_.assign<span style="color: #757575;">(</span>graph_info_-&gt;num_tensors<span style="color: #757575;">(),</span> kNodeNotAssigned<span style="color: #757575;">)</span>;

    <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">vector</span>&lt;<span style="color: #b58900;">int</span>&gt; <span style="color: #268bd2;">refcounts</span><span style="color: #757575;">(</span>graph_info_-&gt;num_tensors<span style="color: #757575;">(),</span> 0<span style="color: #757575;">)</span>;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! alloc_node_ &#21644; dealloc_node_ &#29992;&#26469;&#35760;&#24405; tensor &#30340; start_node &#21644;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">finish_node</span>
    <span style="color: #859900;">auto</span> <span style="color: #268bd2;">allocate</span> = [<span style="color: #859900;">this</span>]<span style="color: #757575;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">node</span><span style="color: #757575;">,</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">tensor</span><span style="color: #757575;">)</span> -&gt; TfLiteStatus <span style="color: #757575;">{</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! alloc_nodes_ &#38656;&#35201;&#35760;&#24405;`&#31532;&#19968;&#20010;`&#20351;&#29992;&#36825;&#20010; tensor &#30340; node, &#25152;&#20197;&#38656;&#35201;&#36825;</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20010;&#21028;&#26029;</span>
        <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>alloc_node_[tensor] != kNodeNotAssigned<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
            <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! Tensor has already been allocated.</span>
            <span style="color: #859900;">return</span> kTfLiteOk;
        <span style="color: #757575;">}</span>
        alloc_node_[tensor] = node;
    <span style="color: #757575;">}</span>;

    <span style="color: #859900;">auto</span> <span style="color: #268bd2;">deallocate</span> = [<span style="color: #859900;">this</span>]<span style="color: #757575;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">node</span><span style="color: #757575;">,</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">tensor</span><span style="color: #757575;">)</span> -&gt; TfLiteStatus <span style="color: #757575;">{</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! dealloc_node_ &#38656;&#35201;&#35760;&#24405;`&#26368;&#21518;&#19968;&#20010;`&#20351;&#29992;&#36825;&#20010; tensor &#30340; node, &#25152;&#20197;&#19981;&#38656;</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">&#35201;&#20687; alloc_node_ &#37027;&#26679;&#21028;&#26029;</span>
        dealloc_node_[tensor] = node;
    <span style="color: #757575;">}</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! -----------------------------</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! We must make sure the output tensors are never overwritten. We do</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">that by artificially adding one to their ref-counts so they are never</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">selected for deallocation.</span>
    <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">tensor_index</span> : graph_info_-&gt;outputs<span style="color: #757575;">())</span> <span style="color: #757575;">{</span>
        refcounts[tensor_index]++;
    <span style="color: #757575;">}</span>

    <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! Variable tensors also should be ensured to be never overwritten and</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">need to be alive all the time.</span>
    <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">tensor_index</span> : graph_info_-&gt;variables<span style="color: #757575;">())</span> <span style="color: #757575;">{</span>
        refcounts[tensor_index]++;
    <span style="color: #757575;">}</span>

    <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! Queue all graph inputs for allocation. If preserve_inputs_ is true,</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">make sure they never be overwritten.</span>
    <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">tensor_index</span> : graph_info_-&gt;inputs<span style="color: #757575;">())</span> <span style="color: #757575;">{</span>
        <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>preserve_inputs_<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
            refcounts[tensor_index]++;
        <span style="color: #757575;">}</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">graph inputs &#30340; start_node &#24517;&#28982;&#26159; node[0]</span>
        allocate<span style="color: #757575;">(</span>0<span style="color: #757575;">,</span> tensor_index<span style="color: #757575;">)</span>;
    <span style="color: #757575;">}</span>

    <span style="color: #586e75;">// </span><span style="color: #586e75;">Queue all graph variable tensors for allocation.</span>
    <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">tensor_index</span> : graph_info_-&gt;variables<span style="color: #757575;">())</span> <span style="color: #757575;">{</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">Increase the reference count for input tensors by one, so it will</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">never be deallocated.</span>
        allocate<span style="color: #757575;">(</span>0<span style="color: #757575;">,</span> tensor_index<span style="color: #757575;">)</span>;
    <span style="color: #757575;">}</span>

    <span style="color: #586e75;">// </span><span style="color: #586e75;">Queue all graph inputs for allocation.</span>
    <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">tensor_index</span> : graph_info_-&gt;inputs<span style="color: #757575;">())</span> <span style="color: #757575;">{</span>
        <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>tensor_index != kTfLiteOptionalTensor<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
            allocate<span style="color: #757575;">(</span>0<span style="color: #757575;">,</span> tensor_index<span style="color: #757575;">)</span>;
        <span style="color: #757575;">}</span>
    <span style="color: #757575;">}</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! -----------------------------</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">Count references to node input tensors.</span>
    <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">i</span> = 0; i &lt; graph_info_-&gt;num_nodes<span style="color: #757575;">()</span>; ++i<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        <span style="color: #859900;">const</span> <span style="color: #b58900;">TfLiteNode</span>&amp; <span style="color: #268bd2;">node</span> = graph_info_-&gt;node<span style="color: #757575;">(</span>i<span style="color: #757575;">)</span>;
        <span style="color: #b58900;">TfLiteIntArray</span>* <span style="color: #268bd2;">node_inputs</span> = node.inputs;
        <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">j</span> = 0; j &lt; node_inputs-&gt;size; ++j<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
            <span style="color: #b58900;">int</span> <span style="color: #268bd2;">tensor_index</span> = node_inputs-&gt;data[j];
            refcounts[tensor_index]++;
        <span style="color: #757575;">}</span>
    <span style="color: #757575;">}</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! -----------------------------</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">Go through the graph in execution order.</span>
    <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">i</span> = 0; i &lt; graph_info_-&gt;num_nodes<span style="color: #757575;">()</span>; ++i<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        <span style="color: #859900;">const</span> <span style="color: #b58900;">TfLiteNode</span>&amp; <span style="color: #268bd2;">node</span> = graph_info_-&gt;node<span style="color: #757575;">(</span>i<span style="color: #757575;">)</span>;

        <span style="color: #586e75;">// </span><span style="color: #586e75;">First queue output tensors for allocation.</span>
        <span style="color: #b58900;">TfLiteIntArray</span>* <span style="color: #268bd2;">node_outputs</span> = node.outputs;
        <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">j</span> = 0; j &lt; node_outputs-&gt;size; ++j<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
            <span style="color: #b58900;">int</span> <span style="color: #268bd2;">tensor_index</span> = node_outputs-&gt;data[j];
            allocate<span style="color: #757575;">(</span>i<span style="color: #757575;">,</span> tensor_index<span style="color: #757575;">)</span>;
        <span style="color: #757575;">}</span>

        <span style="color: #586e75;">// </span><span style="color: #586e75;">Then update the ref-counts of the node's inputs, and if necessary</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">queue them for deallocation.</span>
        <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>preserve_intermediates_<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
            <span style="color: #b58900;">TfLiteIntArray</span>* <span style="color: #268bd2;">node_inputs</span> = node.inputs;
            <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">j</span> = 0; j &lt; node_inputs-&gt;size; ++j<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
                <span style="color: #b58900;">int</span> <span style="color: #268bd2;">tensor_index</span> = node_inputs-&gt;data[j];
                refcounts[tensor_index]--;
                <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>refcounts[tensor_index] == 0<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
                    deallocate<span style="color: #757575;">(</span>i<span style="color: #757575;">,</span> tensor_index<span style="color: #757575;">)</span>;
                <span style="color: #757575;">}</span>
            <span style="color: #757575;">}</span>
        <span style="color: #757575;">}</span>
    <span style="color: #757575;">}</span>
<span style="color: #757575;">}</span>
</pre>
</div>
</div>
</li>

<li><a id="orgafb0c66"></a>ExecuteAllocations<br />
<div class="outline-text-6" id="text-1-1-3-2-2">
<ol class="org-ol">
<li><p>
CalculateAllocations
</p>

<p>
根据 [start_node, finish_node] 找到所有有重叠 (冲突) 的 alloc, 然后根据 bestfit
分配一个 alloc
</p></li>

<li><p>
Commit
</p>

<p>
CalculateAllocations 分配 alloc 同时会维护 high_water_mark_ 记录最大需要的内存, Commit 会 malloc 这一段 underlying_buffer
</p></li>

<li><p>
ResolveTensorAllocation
</p>

<p>
underlying_buffer 做为 base address, 根据各个 alloc 中记录的 offset 更新最终的 tensor-&gt;data 地址
</p></li>
</ol>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #b58900;">TfLiteStatus</span> <span style="color: #268bd2; font-weight: bold;">ArenaPlanner</span>::<span style="color: #268bd2;">ExecuteAllocations</span><span style="color: #757575;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">first_node</span><span style="color: #757575;">,</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">last_node</span><span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">Grow the size of `allocs_` if necessary. This allows allocating temporary</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">tensors in op's `prepare` function.</span>
    alloc_node_.resize<span style="color: #757575;">(</span>graph_info_-&gt;num_tensors<span style="color: #757575;">(),</span> kNodeNotAssigned<span style="color: #757575;">)</span>;
    dealloc_node_.resize<span style="color: #757575;">(</span>graph_info_-&gt;num_tensors<span style="color: #757575;">(),</span> kNodeNotAssigned<span style="color: #757575;">)</span>;
    allocs_.resize<span style="color: #757575;">(</span>graph_info_-&gt;num_tensors<span style="color: #757575;">())</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">Set allocation and deallocation for temporary tensors.</span>
    <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">i</span> = first_node;
         i &lt;= <span style="color: #859900;">static_cast</span>&lt;<span style="color: #b58900;">size_t</span>&gt;<span style="color: #757575;">(</span>last_node<span style="color: #757575;">)</span> &amp;&amp; i &lt; graph_info_-&gt;num_nodes<span style="color: #757575;">()</span>;
         ++i<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        <span style="color: #859900;">const</span> <span style="color: #b58900;">TfLiteNode</span>&amp; <span style="color: #268bd2;">node</span> = graph_info_-&gt;node<span style="color: #757575;">(</span>i<span style="color: #757575;">)</span>;
        <span style="color: #b58900;">TfLiteIntArray</span>* <span style="color: #268bd2;">node_temporaries</span> = node.temporaries;
        <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">j</span> = 0; j &lt; node_temporaries-&gt;size; ++j<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
            <span style="color: #b58900;">int</span> <span style="color: #268bd2;">tensor_index</span> = node_temporaries-&gt;data[j];
            alloc_node_[tensor_index] = i;
            dealloc_node_[tensor_index] = i;
        <span style="color: #757575;">}</span>
    <span style="color: #757575;">}</span>

    CalculateAllocations<span style="color: #757575;">(</span>first_node<span style="color: #757575;">,</span> last_node<span style="color: #757575;">)</span>;
    Commit<span style="color: #757575;">()</span>;

    <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">i</span> = 0; i &lt; <span style="color: #859900;">static_cast</span>&lt;<span style="color: #b58900;">int</span>&gt;<span style="color: #757575;">(</span>graph_info_-&gt;num_tensors<span style="color: #757575;">())</span>; ++i<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        ResolveTensorAllocation<span style="color: #757575;">(</span>i<span style="color: #757575;">)</span>;
    <span style="color: #757575;">}</span>
<span style="color: #757575;">}</span>
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org2492154"></a>CalculateAllocations<br />
<div class="outline-text-7" id="text-1-1-3-2-2-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #b58900;">TfLiteStatus</span> <span style="color: #268bd2; font-weight: bold;">ArenaPlanner</span>::<span style="color: #268bd2;">CalculateAllocations</span><span style="color: #757575;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">first_node</span><span style="color: #757575;">,</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">last_node</span><span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">Indices of tensors in order their allocation offsets will be calculated.</span>
    <span style="color: #859900;">const</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">vector</span>&lt;<span style="color: #b58900;">int32_t</span>&gt; <span style="color: #268bd2;">tensor_order</span> =
        CreateTensorAllocationVector<span style="color: #757575;">(</span>first_node<span style="color: #757575;">,</span> last_node<span style="color: #757575;">)</span>;

    <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #859900;">const</span> <span style="color: #859900;">auto</span>&amp; <span style="color: #268bd2;">tensor_index</span> : tensor_order<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        <span style="color: #b58900;">TfLiteTensor</span>&amp; <span style="color: #268bd2;">tensor</span> = *graph_info_-&gt;tensor<span style="color: #757575;">(</span>tensor_index<span style="color: #757575;">)</span>;
        <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>tensor.allocation_type == kTfLiteArenaRw<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
            arena_.Allocate<span style="color: #757575;">(</span>context_<span style="color: #757575;">,</span> tensor_alignment_<span style="color: #757575;">,</span> tensor.bytes<span style="color: #757575;">,</span>
                            tensor_index<span style="color: #757575;">,</span> alloc_node_[tensor_index]<span style="color: #757575;">,</span>
                            dealloc_node_[tensor_index]<span style="color: #757575;">,</span>
                            &amp;allocs_[tensor_index]<span style="color: #757575;">)</span>;
        <span style="color: #757575;">}</span>
        <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>tensor.allocation_type == kTfLiteArenaRwPersistent<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
            persistent_arena_.Allocate<span style="color: #757575;">(</span>
                context_<span style="color: #757575;">,</span> tensor_alignment_<span style="color: #757575;">,</span> tensor.bytes<span style="color: #757575;">,</span> tensor_index<span style="color: #757575;">,</span>
                <span style="color: #586e75;">/*</span><span style="color: #586e75;">first_node=</span><span style="color: #586e75;">*/</span>alloc_node_[tensor_index]<span style="color: #757575;">,</span>
                <span style="color: #586e75;">/*</span><span style="color: #586e75;">last_node=</span><span style="color: #586e75;">*/</span><span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #268bd2; font-weight: bold;">numeric_limits</span>&lt;<span style="color: #b58900;">int32_t</span>&gt;::max<span style="color: #757575;">(),</span>
                &amp;allocs_[tensor_index]<span style="color: #757575;">)</span>;
        <span style="color: #757575;">}</span>
    <span style="color: #757575;">}</span>
<span style="color: #757575;">}</span>

<span style="color: #b58900;">TfLiteStatus</span> <span style="color: #268bd2; font-weight: bold;">SimpleMemoryArena</span>::<span style="color: #268bd2;">Allocate</span><span style="color: #757575;">(</span>
    <span style="color: #b58900;">TfLiteContext</span>* <span style="color: #268bd2;">context</span><span style="color: #757575;">,</span> <span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">alignment</span><span style="color: #757575;">,</span> <span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">size</span><span style="color: #757575;">,</span> <span style="color: #b58900;">int32_t</span> <span style="color: #268bd2;">tensor</span><span style="color: #757575;">,</span>
    <span style="color: #b58900;">int32_t</span> <span style="color: #268bd2;">first_node</span><span style="color: #757575;">,</span> <span style="color: #b58900;">int32_t</span> <span style="color: #268bd2;">last_node</span><span style="color: #757575;">,</span>
    <span style="color: #b58900;">ArenaAllocWithUsageInterval</span>* <span style="color: #268bd2;">new_alloc</span><span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
    new_alloc-&gt;tensor = tensor;
    new_alloc-&gt;first_node = first_node;
    new_alloc-&gt;last_node = last_node;
    new_alloc-&gt;size = size;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">If we don't find a better gap just allocate at the end of the buffer.</span>
    <span style="color: #859900;">const</span> <span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">kOffsetNotAssigned</span> = <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #268bd2; font-weight: bold;">numeric_limits</span>&lt;<span style="color: #b58900;">size_t</span>&gt;::max<span style="color: #757575;">()</span>;
    <span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">best_offset</span> = kOffsetNotAssigned;
    <span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">best_offset_fit</span> = kOffsetNotAssigned;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">Go through the sorted allocs and look at the gaps between them.</span>
    <span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">current_offset</span> = 0;
    <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #859900;">const</span> <span style="color: #859900;">auto</span>&amp; <span style="color: #268bd2;">alloc</span> : ordered_allocs_<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>alloc.<span style="color: #b58900;">last_node</span> &lt; first_node || alloc.first_node &gt; last_node<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
            <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! &#27809;&#26377;&#37325;&#21472;&#30340; alloc &#30456;&#24403;&#20110;&#31354;&#38386;&#30340; buffer</span>
            <span style="color: #859900;">continue</span>;
        <span style="color: #757575;">}</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">If we found a gap larger than required size, and smaller than previous</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">best fit, take it.</span>
        <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>current_offset + size &lt;= alloc.offset &amp;&amp;
            alloc.offset - current_offset &lt; best_offset_fit<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
            best_offset = current_offset;
            best_offset_fit = alloc.offset - current_offset;
        <span style="color: #757575;">}</span>
        current_offset = <span style="color: #268bd2; font-weight: bold;">std</span>::max<span style="color: #757575;">(</span>current_offset<span style="color: #757575;">,</span> alloc.offset + alloc.size<span style="color: #757575;">)</span>;
    <span style="color: #757575;">}</span>
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>best_offset == kOffsetNotAssigned<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        best_offset = current_offset;
    <span style="color: #757575;">}</span>

    <span style="color: #586e75;">// </span><span style="color: #586e75;">Update the required buffer size.</span>
    high_water_mark_ = <span style="color: #268bd2; font-weight: bold;">std</span>::max<span style="color: #757575;">(</span>high_water_mark_<span style="color: #757575;">,</span> best_offset + size<span style="color: #757575;">)</span>;
    new_alloc-&gt;offset = best_offset;

    <span style="color: #859900;">auto</span> <span style="color: #268bd2;">insertion_it</span> = ordered_allocs_.begin<span style="color: #757575;">()</span>;
    <span style="color: #859900;">while</span> <span style="color: #757575;">(</span>insertion_it != ordered_allocs_.end<span style="color: #757575;">()</span> &amp;&amp; *insertion_it &lt; *new_alloc<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        ++insertion_it;
    <span style="color: #757575;">}</span>
    ordered_allocs_.insert<span style="color: #757575;">(</span>insertion_it<span style="color: #757575;">,</span> *new_alloc<span style="color: #757575;">)</span>;
<span style="color: #757575;">}</span>
</pre>
</div>
</div>
</li>

<li><a id="org857b27a"></a>Commit<br />
<div class="outline-text-7" id="text-1-1-3-2-2-2">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #b58900;">TfLiteStatus</span> <span style="color: #268bd2; font-weight: bold;">SimpleMemoryArena</span>::<span style="color: #268bd2;">Commit</span><span style="color: #757575;">(</span><span style="color: #b58900;">TfLiteContext</span>* <span style="color: #268bd2;">context</span><span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
    <span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">required_size</span> = RequiredBufferSize<span style="color: #757575;">()</span>;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! malloc</span>
    <span style="color: #b58900;">char</span>* <span style="color: #268bd2;">new_alloc</span> = <span style="color: #859900;">new</span> <span style="color: #b58900;">char</span>[required_size];
    <span style="color: #b58900;">char</span>* <span style="color: #268bd2;">new_underlying_buffer_aligned_ptr</span> = <span style="color: #859900;">reinterpret_cast</span>&lt;<span style="color: #b58900;">char</span>*&gt;<span style="color: #757575;">(</span>
        AlignTo<span style="color: #757575;">(</span>arena_alignment_<span style="color: #757575;">,</span> <span style="color: #859900;">reinterpret_cast</span>&lt;<span style="color: #b58900;">intptr_t</span>&gt;<span style="color: #757575;">(</span>new_alloc<span style="color: #757575;">)))</span>;

    underlying_buffer_.reset<span style="color: #757575;">(</span>new_alloc<span style="color: #757575;">)</span>;
    underlying_buffer_size_ = required_size;
    underlying_buffer_aligned_ptr_ = new_underlying_buffer_aligned_ptr;
<span style="color: #757575;">}</span>
</pre>
</div>
</div>
</li>

<li><a id="org7937c69"></a>ResolveTensorAllocation<br />
<div class="outline-text-7" id="text-1-1-3-2-2-3">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #b58900;">TfLiteStatus</span> <span style="color: #268bd2; font-weight: bold;">ArenaPlanner</span>::<span style="color: #268bd2;">ResolveTensorAllocation</span><span style="color: #757575;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">tensor_index</span><span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
    <span style="color: #b58900;">TfLiteTensor</span>&amp; <span style="color: #268bd2;">tensor</span> = *graph_info_-&gt;tensor<span style="color: #757575;">(</span>tensor_index<span style="color: #757575;">)</span>;
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>tensor.allocation_type == kTfLiteArenaRw<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">Skip resolution if the size of the tensor is zero, leaving it as a</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">nullptr.</span>
        arena_.ResolveAlloc<span style="color: #757575;">(</span>context_<span style="color: #757575;">,</span> allocs_[tensor_index]<span style="color: #757575;">,</span> &amp;tensor.data.raw<span style="color: #757575;">)</span>;
    <span style="color: #757575;">}</span>
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>tensor.allocation_type == kTfLiteArenaRwPersistent<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        persistent_arena_.ResolveAlloc<span style="color: #757575;">(</span>context_<span style="color: #757575;">,</span> allocs_[tensor_index]<span style="color: #757575;">,</span>
                                       &amp;tensor.data.raw<span style="color: #757575;">)</span>;
    <span style="color: #757575;">}</span>
<span style="color: #757575;">}</span>

<span style="color: #b58900;">TfLiteStatus</span> <span style="color: #268bd2; font-weight: bold;">SimpleMemoryArena</span>::<span style="color: #268bd2;">ResolveAlloc</span><span style="color: #757575;">(</span>
    <span style="color: #b58900;">TfLiteContext</span>* <span style="color: #268bd2;">context</span><span style="color: #757575;">,</span> <span style="color: #859900;">const</span> <span style="color: #b58900;">ArenaAllocWithUsageInterval</span>&amp; <span style="color: #268bd2;">alloc</span><span style="color: #757575;">,</span>
    <span style="color: #b58900;">char</span>** <span style="color: #268bd2;">output_ptr</span><span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>alloc.size == 0<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        *output_ptr = <span style="color: #268bd2; font-weight: bold;">nullptr</span>;
    <span style="color: #757575;">}</span> <span style="color: #859900;">else</span> <span style="color: #757575;">{</span>
        *output_ptr = underlying_buffer_aligned_ptr_ + alloc.offset;
    <span style="color: #757575;">}</span>
<span style="color: #757575;">}</span>
</pre>
</div>
</div>
</li>
</ol>
</li>
</ol>
</div>
</div>

<div id="outline-container-org73baa19" class="outline-4">
<h4 id="org73baa19"><span class="section-number-4">1.1.4</span> Interpreter.Invoke</h4>
<div class="outline-text-4" id="text-1-1-4">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #268bd2; font-weight: bold;">Interpreter</span>::Invoke:
    primary_subgraph<span style="color: #757575;">()</span>.Invoke<span style="color: #757575;">()</span>
        <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">execution_plan_index</span> = 0; execution_plan_index &lt; execution_plan_.size<span style="color: #757575;">()</span>; execution_plan_index++<span style="color: #757575;">)</span>:
            <span style="color: #b58900;">int</span> <span style="color: #268bd2;">node_index</span> = execution_plan_[execution_plan_index];
            <span style="color: #b58900;">TfLiteNode</span>&amp; <span style="color: #268bd2;">node</span> = nodes_and_registration_[node_index].first;
            <span style="color: #859900;">const</span> <span style="color: #b58900;">TfLiteRegistration</span>&amp; <span style="color: #268bd2;">registration</span> = nodes_and_registration_[node_index].second;
            OpInvoke<span style="color: #757575;">(</span>registration<span style="color: #757575;">,</span> &amp;node<span style="color: #757575;">)</span>
                <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! &#35843;&#29992;&#21040; resolver &#20013;&#27880;&#20876;&#30340; registration &#20013;&#30340; .invoke, &#20363;&#22914; AbsEval</span>
                registration.invoke<span style="color: #757575;">(</span>node<span style="color: #757575;">)</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org1148c58" class="outline-3">
<h3 id="org1148c58"><span class="section-number-3">1.2</span> TFLite Delegate</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-orgba15b7d" class="outline-4">
<h4 id="orgba15b7d"><span class="section-number-4">1.2.1</span> A Simple Model</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
\(f(x)=sin(x)+x+sin(x*2)\)
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #859900;">import</span> tensorflow <span style="color: #859900;">as</span> tf
<span style="color: #859900;">from</span> tensorflow.keras <span style="color: #859900;">import</span> layers<span style="color: #757575;">,</span> Model

<span style="color: #839496;">input</span>=layers.Input<span style="color: #757575;">(</span>shape=<span style="color: #757575;">(</span>1<span style="color: #757575;">,</span> <span style="color: #757575;">))</span>
<span style="color: #268bd2;">output</span>=layers.Lambda<span style="color: #757575;">(</span><span style="color: #859900;">lambda</span> x: tf.sin<span style="color: #757575;">(</span>x<span style="color: #757575;">)</span>+x+tf.sin<span style="color: #757575;">(</span>x*2<span style="color: #757575;">))(</span><span style="color: #839496;">input</span><span style="color: #757575;">)</span>
<span style="color: #268bd2;">model</span>=Model<span style="color: #757575;">(</span>inputs=<span style="color: #839496;">input</span><span style="color: #757575;">,</span>outputs=output<span style="color: #757575;">)</span>
model.summary<span style="color: #757575;">()</span>
<span style="color: #859900;">print</span><span style="color: #757575;">(</span>model.predict<span style="color: #757575;">(</span>[2.]<span style="color: #757575;">))</span>
model.save<span style="color: #757575;">(</span><span style="color: #2aa198;">"/tmp/sin"</span><span style="color: #757575;">)</span>
</pre>
</div>

<p>
Model: "model"
<span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline">_</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
Layer (type)                 Output Shape              Param #   
<code>===============================================================</code>
input_1 (InputLayer)         [(None, 1)]               0         
<span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline">_</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
lambda (Lambda)              (None, 1)                 0         
<code>===============================================================</code>
Total params: 0
Trainable params: 0
Non-trainable params: 0
<span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline">_</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
2.152495
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #859900;">import</span> tensorflow <span style="color: #859900;">as</span> tf

<span style="color: #268bd2;">converter</span> = tf.lite.TFLiteConverter.from_saved_model<span style="color: #757575;">(</span><span style="color: #2aa198;">"/tmp/sin"</span><span style="color: #757575;">)</span>
<span style="color: #268bd2;">tflite</span> = converter.convert<span style="color: #757575;">()</span>
<span style="color: #859900;">with</span> <span style="color: #839496;">open</span> <span style="color: #757575;">(</span><span style="color: #2aa198;">"/tmp/sin.tflite"</span><span style="color: #757575;">,</span><span style="color: #2aa198;">"wb"</span><span style="color: #757575;">)</span> <span style="color: #859900;">as</span> f:
    f.write<span style="color: #757575;">(</span>tflite<span style="color: #757575;">)</span>
    <span style="color: #859900;">print</span><span style="color: #757575;">(</span><span style="color: #2aa198;">"size of sin.tflite:"</span><span style="color: #757575;">,</span> <span style="color: #839496;">len</span><span style="color: #757575;">(</span>tflite<span style="color: #757575;">))</span>
</pre>
</div>

<p>
size of sin.tflite: 1240
</p>
</div>
</div>

<div id="outline-container-org4652499" class="outline-4">
<h4 id="org4652499"><span class="section-number-4">1.2.2</span> MyDelegate</h4>
<div class="outline-text-4" id="text-1-2-2">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;cstdio&gt;</span>

<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">"tensorflow/lite/builtin_ops.h"</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">"tensorflow/lite/interpreter.h"</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">"tensorflow/lite/kernels/kernel_util.h"</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">"tensorflow/lite/kernels/register.h"</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">"tensorflow/lite/model.h"</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">"tensorflow/lite/optional_debug_tools.h"</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">"tensorflow/lite/util.h"</span>

<span style="color: #859900;">using</span> <span style="color: #859900;">namespace</span> <span style="color: #268bd2; font-weight: bold;">tflite</span>;

<span style="color: #859900;">class</span> <span style="color: #b58900;">MyDelegate</span> <span style="color: #757575;">{</span>
  <span style="color: #859900;">public</span>:
    <span style="color: #859900;">static</span> <span style="color: #b58900;">bool</span> <span style="color: #268bd2;">SupportedOp</span><span style="color: #757575;">(</span><span style="color: #859900;">const</span> <span style="color: #b58900;">TfLiteRegistration</span>* <span style="color: #268bd2;">registration</span><span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        <span style="color: #859900;">return</span> registration-&gt;builtin_code == kTfLiteBuiltinSin;
    <span style="color: #757575;">}</span>

    <span style="color: #b58900;">bool</span> <span style="color: #268bd2;">Invoke</span><span style="color: #757575;">(</span><span style="color: #b58900;">TfLiteContext</span>* <span style="color: #268bd2;">context</span><span style="color: #757575;">,</span> <span style="color: #b58900;">TfLiteNode</span>* <span style="color: #268bd2;">node</span><span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! &#36825;&#37324; invoke &#30340;&#23454;&#29616;&#26159;&#26377;&#38382;&#39064;&#30340;, &#23427;&#20551;&#35774;&#20102; subset &#37324;&#21482;&#26377;&#19968;&#20010; sin, &#23454;</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">&#38469;&#19978;&#22810;&#20010;&#36830;&#32493;&#30340; sin &#20363;&#22914; tf.sin(tf.sin(x)) &#20250;&#29983;&#25104;&#22810;&#20010; sin node, &#32780;&#23545;&#19968;</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20010; subset &#21482;&#20250;&#29983;&#25104;&#19968;&#20010; delegate node...</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">&#27491;&#30830;&#30340;&#20570;&#27861;&#26159;&#20174; TfLiteDelegateParams &#20013;&#33719;&#24471;&#25152;&#26377;&#30340; node &#20449;&#24687;&#20294;&#20381;&#27425;&#25191;&#34892;,</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20363;&#22914; flex::Eval &#30340;&#20570;&#27861;:</span>
        <span style="color: #586e75;">//</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">TfLiteStatus DelegateKernel::Eval(TfLiteContext* context, TfLiteNode* node) {</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">// Execute the TensorFlow Ops sequentially.</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">for (auto&amp; node_data : op_data_-&gt;nodes) {</span>
        <span style="color: #586e75;">//   </span><span style="color: #586e75;">auto status = ExecuteFlexOp(context, buffer_map, node_data.get());</span>
        <span style="color: #586e75;">//   </span><span style="color: #586e75;">TF_LITE_ENSURE_OK(context, ConvertStatus(context, status));</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">}</span>
        <span style="color: #586e75;">//</span>

        printf<span style="color: #757575;">(</span><span style="color: #2aa198;">"sunway : invoke\n"</span><span style="color: #757575;">)</span>;
        <span style="color: #859900;">const</span> <span style="color: #b58900;">TfLiteTensor</span>* <span style="color: #268bd2;">input</span> = GetInput<span style="color: #757575;">(</span>context<span style="color: #757575;">,</span> node<span style="color: #757575;">,</span> 0<span style="color: #757575;">)</span>;
        <span style="color: #b58900;">TfLiteTensor</span>* <span style="color: #268bd2;">output</span> = GetOutput<span style="color: #757575;">(</span>context<span style="color: #757575;">,</span> node<span style="color: #757575;">,</span> 0<span style="color: #757575;">)</span>;

        <span style="color: #b58900;">float</span>* <span style="color: #268bd2;">input_data</span> = input-&gt;data.f;
        <span style="color: #b58900;">float</span>* <span style="color: #268bd2;">output_data</span> = output-&gt;data.f;

        <span style="color: #859900;">const</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">M</span> = input-&gt;dims-&gt;size;
        <span style="color: #859900;">const</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">N</span> = input-&gt;dims-&gt;data[0];
        <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">i</span> = 0; i &lt; M; i++<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
            <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">j</span> = 0; j &lt; N; ++j<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
                output_data[i * N + j] = sin<span style="color: #757575;">(</span><span style="color: #b58900;">input_data</span>[i * N + j]<span style="color: #757575;">)</span>;
            <span style="color: #757575;">}</span>
        <span style="color: #757575;">}</span>

        <span style="color: #859900;">return</span> kTfLiteOk;
    <span style="color: #757575;">}</span>
<span style="color: #757575;">}</span>;

<span style="color: #b58900;">TfLiteRegistration</span> <span style="color: #268bd2;">GetMyDelegateNodeRegistration</span><span style="color: #757575;">()</span> <span style="color: #757575;">{</span>
    <span style="color: #b58900;">TfLiteRegistration</span> <span style="color: #268bd2;">kernel_registration</span>;
    kernel_registration.builtin_code = kTfLiteBuiltinDelegate;
    kernel_registration.custom_name = <span style="color: #2aa198;">"MyDelegate"</span>;
    kernel_registration.free = <span style="color: #268bd2; font-weight: bold;">NULL</span>;
    kernel_registration.init = []<span style="color: #757575;">(</span><span style="color: #b58900;">TfLiteContext</span>* <span style="color: #268bd2;">context</span><span style="color: #757575;">,</span> <span style="color: #859900;">const</span> <span style="color: #b58900;">char</span>* <span style="color: #268bd2;">buffer</span><span style="color: #757575;">,</span>
                                  <span style="color: #b58900;">size_t</span><span style="color: #757575;">)</span> -&gt; <span style="color: #b58900;">void</span>* <span style="color: #757575;">{</span>
        <span style="color: #859900;">const</span> <span style="color: #b58900;">TfLiteDelegateParams</span>* <span style="color: #268bd2;">delegate_params</span> =
                <span style="color: #859900;">reinterpret_cast</span>&lt;<span style="color: #859900;">const</span> <span style="color: #b58900;">TfLiteDelegateParams</span>*&gt;<span style="color: #757575;">(</span>buffer<span style="color: #757575;">)</span>;
        <span style="color: #b58900;">MyDelegate</span>* <span style="color: #268bd2;">my_delegate</span> = <span style="color: #859900;">new</span> <span style="color: #b58900;">MyDelegate</span>;
        <span style="color: #859900;">return</span> my_delegate;
    <span style="color: #757575;">}</span>;
    kernel_registration.invoke = []<span style="color: #757575;">(</span><span style="color: #b58900;">TfLiteContext</span>* <span style="color: #268bd2;">context</span><span style="color: #757575;">,</span>
                                    <span style="color: #b58900;">TfLiteNode</span>* <span style="color: #268bd2;">node</span><span style="color: #757575;">)</span> -&gt; TfLiteStatus <span style="color: #757575;">{</span>
        printf<span style="color: #757575;">(</span><span style="color: #2aa198;">"kerenl_invoke\n"</span><span style="color: #757575;">)</span>;
        <span style="color: #b58900;">MyDelegate</span>* <span style="color: #268bd2;">kernel</span> = <span style="color: #859900;">reinterpret_cast</span>&lt;<span style="color: #b58900;">MyDelegate</span>*&gt;<span style="color: #757575;">(</span>node-&gt;user_data<span style="color: #757575;">)</span>;
        kernel-&gt;Invoke<span style="color: #757575;">(</span>context<span style="color: #757575;">,</span> node<span style="color: #757575;">)</span>;
        <span style="color: #859900;">return</span> kTfLiteOk;
    <span style="color: #757575;">}</span>;
    kernel_registration.prepare = <span style="color: #268bd2; font-weight: bold;">NULL</span>;

    <span style="color: #859900;">return</span> kernel_registration;
<span style="color: #757575;">}</span>

<span style="color: #b58900;">TfLiteStatus</span> <span style="color: #268bd2;">MyDelegatePrepare</span><span style="color: #757575;">(</span><span style="color: #b58900;">TfLiteContext</span>* <span style="color: #268bd2;">context</span><span style="color: #757575;">,</span>
                               <span style="color: #b58900;">TfLiteDelegate</span>* <span style="color: #268bd2;">delegate</span><span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
    <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">vector</span>&lt;<span style="color: #b58900;">int</span>&gt; <span style="color: #268bd2;">supported_nodes</span>;
    <span style="color: #b58900;">TfLiteIntArray</span>* <span style="color: #268bd2;">plan</span>;
    TF_LITE_ENSURE_STATUS<span style="color: #757575;">(</span>context-&gt;GetExecutionPlan<span style="color: #757575;">(</span>context<span style="color: #757575;">,</span> &amp;plan<span style="color: #757575;">))</span>;
    <span style="color: #b58900;">TfLiteNode</span>* <span style="color: #268bd2;">node</span>;
    <span style="color: #b58900;">TfLiteRegistration</span>* <span style="color: #268bd2;">registration</span>;
    <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">i</span> = 0; i &lt; plan-&gt;size; i++<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        <span style="color: #b58900;">int</span> <span style="color: #268bd2;">node_index</span> = plan-&gt;data[i];
        TF_LITE_ENSURE_STATUS<span style="color: #757575;">(</span>context-&gt;GetNodeAndRegistration<span style="color: #757575;">(</span>
            context<span style="color: #757575;">,</span> node_index<span style="color: #757575;">,</span> &amp;node<span style="color: #757575;">,</span> &amp;registration<span style="color: #757575;">))</span>;
        <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #268bd2; font-weight: bold;">MyDelegate</span>::SupportedOp<span style="color: #757575;">(</span>registration<span style="color: #757575;">))</span> <span style="color: #757575;">{</span>
            supported_nodes.push_back<span style="color: #757575;">(</span>node_index<span style="color: #757575;">)</span>;
        <span style="color: #757575;">}</span>
    <span style="color: #757575;">}</span>
    <span style="color: #b58900;">TfLiteRegistration</span> <span style="color: #268bd2;">my_delegate_kernel_registration</span> =
            GetMyDelegateNodeRegistration<span style="color: #757575;">()</span>;

    <span style="color: #b58900;">TfLiteIntArray</span>* <span style="color: #268bd2;">supported_nodes_int_array</span> =
            ::<span style="color: #268bd2; font-weight: bold;">tflite</span>::ConvertVectorToTfLiteIntArray<span style="color: #757575;">(</span>supported_nodes<span style="color: #757575;">)</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! replace node with new delegate registration</span>
    <span style="color: #859900;">auto</span> <span style="color: #268bd2;">status</span> = context-&gt;ReplaceNodeSubsetsWithDelegateKernels<span style="color: #757575;">(</span>
        context<span style="color: #757575;">,</span> my_delegate_kernel_registration<span style="color: #757575;">,</span> supported_nodes_int_array<span style="color: #757575;">,</span>
        delegate<span style="color: #757575;">)</span>;
    TfLiteIntArrayFree<span style="color: #757575;">(</span>supported_nodes_int_array<span style="color: #757575;">)</span>;
    <span style="color: #859900;">return</span> status;
<span style="color: #757575;">}</span>

<span style="color: #b58900;">TfLiteDelegate</span>* <span style="color: #268bd2;">CreateMyDelegate</span><span style="color: #757575;">()</span> <span style="color: #757575;">{</span>
    <span style="color: #b58900;">TfLiteDelegate</span>* <span style="color: #268bd2;">delegate</span> = <span style="color: #859900;">new</span> <span style="color: #b58900;">TfLiteDelegate</span>;

    delegate-&gt;data_ = <span style="color: #268bd2; font-weight: bold;">nullptr</span>;
    delegate-&gt;flags = kTfLiteDelegateFlagsNone;
    delegate-&gt;Prepare = &amp;MyDelegatePrepare;
    delegate-&gt;CopyFromBufferHandle = <span style="color: #268bd2; font-weight: bold;">NULL</span>;
    delegate-&gt;CopyToBufferHandle = <span style="color: #268bd2; font-weight: bold;">NULL</span>;
    delegate-&gt;FreeBufferHandle = <span style="color: #268bd2; font-weight: bold;">NULL</span>;

    <span style="color: #859900;">return</span> delegate;
<span style="color: #757575;">}</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #757575;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span><span style="color: #757575;">,</span> <span style="color: #b58900;">char</span>* <span style="color: #268bd2;">argv</span>[]<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
    <span style="color: #859900;">const</span> <span style="color: #b58900;">char</span>* <span style="color: #268bd2;">filename</span> = <span style="color: #2aa198;">"/tmp/sin.tflite"</span>;

    <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">unique_ptr</span>&lt;<span style="color: #268bd2; font-weight: bold;">tflite</span>::FlatBufferModel&gt; <span style="color: #268bd2;">model</span> =
            <span style="color: #268bd2; font-weight: bold;">tflite</span>::<span style="color: #268bd2; font-weight: bold;">FlatBufferModel</span>::BuildFromFile<span style="color: #757575;">(</span>filename<span style="color: #757575;">)</span>;

    <span style="color: #268bd2; font-weight: bold;">tflite</span>::<span style="color: #268bd2; font-weight: bold;">ops</span>::<span style="color: #268bd2; font-weight: bold;">builtin</span>::<span style="color: #b58900;">BuiltinOpResolver</span> <span style="color: #268bd2;">resolver</span>;
    <span style="color: #b58900;">InterpreterBuilder</span> <span style="color: #268bd2;">builder</span><span style="color: #757575;">(</span>*model<span style="color: #757575;">,</span> resolver<span style="color: #757575;">)</span>;
    <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">unique_ptr</span>&lt;Interpreter&gt; <span style="color: #268bd2;">interpreter</span>;
    builder<span style="color: #757575;">(</span>&amp;interpreter<span style="color: #757575;">)</span>;

    <span style="color: #859900;">auto</span>* <span style="color: #268bd2;">my_delegate</span> = CreateMyDelegate<span style="color: #757575;">()</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! ModifyGraphWithDelegate</span>
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>interpreter-&gt;ModifyGraphWithDelegate<span style="color: #757575;">(</span>my_delegate<span style="color: #757575;">)</span> != kTfLiteOk<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        printf<span style="color: #757575;">(</span><span style="color: #2aa198;">"sunway:ModifyGraphWithDelegate failed\n"</span><span style="color: #757575;">)</span>;
    <span style="color: #757575;">}</span>

    interpreter-&gt;AllocateTensors<span style="color: #757575;">()</span>;
    <span style="color: #b58900;">float</span>* <span style="color: #268bd2;">input</span> = interpreter-&gt;typed_input_tensor&lt;<span style="color: #b58900;">float</span>&gt;<span style="color: #757575;">(</span>0<span style="color: #757575;">)</span>;
    input[0] = 2.0;
    interpreter-&gt;Invoke<span style="color: #757575;">()</span>;
    <span style="color: #b58900;">float</span>* <span style="color: #268bd2;">output</span> = interpreter-&gt;typed_output_tensor&lt;<span style="color: #b58900;">float</span>&gt;<span style="color: #757575;">(</span>0<span style="color: #757575;">)</span>;
    printf<span style="color: #757575;">(</span><span style="color: #2aa198;">"%f\n"</span><span style="color: #757575;">,</span> output[0]<span style="color: #757575;">)</span>;

    <span style="color: #859900;">return</span> 0;
<span style="color: #757575;">}</span>

</pre>
</div>
</div>
</div>

<div id="outline-container-org9f69a0c" class="outline-4">
<h4 id="org9f69a0c"><span class="section-number-4">1.2.3</span> ModifyGraphWithDelegate</h4>
<div class="outline-text-4" id="text-1-2-3">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #b58900;">TfLiteStatus</span> <span style="color: #268bd2; font-weight: bold;">Subgraph</span>::<span style="color: #268bd2;">ModifyGraphWithDelegate</span><span style="color: #757575;">(</span><span style="color: #b58900;">TfLiteDelegate</span>* <span style="color: #268bd2;">delegate</span><span style="color: #757575;">)</span>:
    <span style="color: #b58900;">TfLiteStatus</span> <span style="color: #268bd2;">status</span> = delegate-&gt;Prepare<span style="color: #757575;">(</span>&amp;context_<span style="color: #757575;">,</span> delegate<span style="color: #757575;">)</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! Prepare &#22914;&#21069;&#38754;&#30340; MyDelegatePrepare, &#36127;&#36131;&#25195;&#25551;&#25152;&#26377; node, &#25214;&#21040;&#33021;&#22788;&#29702;&#30340;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">node, &#28982;&#21518;&#35843;&#29992; ReplaceNodeSubsetsWithDelegateKernels &#26469;&#26367;&#25442; node &#21644;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">execution plan</span>

</pre>
</div>
</div>
</div>

<div id="outline-container-org97aa361" class="outline-4">
<h4 id="org97aa361"><span class="section-number-4">1.2.4</span> ReplaceNodeSubsetsWithDelegateKernels</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
ReplaceNodeSubsetsWithDelegateKernels 的作用是把所有 node 拆成不同的
node_subset, 例如前面的 \(f(x)=sin(x)+x+sin(x*2)\), 其结构为:
</p>

<div class="org-src-container">
<pre class="src src-dot"><span style="color: #859900;">digraph</span> <span style="color: #268bd2;">G</span> <span style="color: #757575;">{</span>
    SIN1 [<span style="color: #268bd2;">color=</span><span style="color: #2aa198;">red</span>]
    SIN2 [<span style="color: #268bd2;">color=</span><span style="color: #2aa198;">red</span>]
    MULTIPLY [<span style="color: #268bd2;">color=</span><span style="color: #2aa198;">green</span>]
    ADD1 [<span style="color: #268bd2;">color=</span><span style="color: #2aa198;">green</span>]
    ADD2 [<span style="color: #268bd2;">color=</span><span style="color: #2aa198;">green</span>]
    X-&gt;SIN1-&gt;ADD1-&gt;ADD2
    X-&gt;ADD1
    X-&gt;MULTIPLY
    2-&gt;MULTIPLY-&gt;SIN2-&gt;ADD2-&gt;Y
<span style="color: #757575;">}</span>
</pre>
</div>


<div id="org940f383" class="figure">
<p><img src="../extra/tflite_delegate.png" alt="tflite_delegate.png" />
</p>
</div>

<p>
一个五个 node 划分为四个按顺排列的 subset:
</p>

<ol class="org-ol">
<li>SIN1</li>
<li>ADD1, MULTIPLY</li>
<li>SIN2</li>
<li>ADD2</li>
</ol>

<p>
划分的原则是:
</p>

<ol class="org-ol">
<li>属于不同 delegate 的 node 需要分开</li>
<li>在满足 input, output 依赖的前提下, 属于同一个 delegate 的 node 划分在一起, 如上面的 (ADD1, MULTIPLY)</li>
<li>各个 subset 要按 topo 排序, 因为 ReplaceNodeSubsetsWithDelegateKernels 时会线性的遍历 subset 构造了一个线性的 execution_plan</li>
</ol>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #b58900;">TfLiteStatus</span> <span style="color: #268bd2; font-weight: bold;">Subgraph</span>::<span style="color: #268bd2;">ReplaceNodeSubsetsWithDelegateKernels</span><span style="color: #757575;">(</span>
    <span style="color: #b58900;">TfLiteRegistration</span> <span style="color: #268bd2;">registration</span><span style="color: #757575;">,</span> <span style="color: #859900;">const</span> <span style="color: #b58900;">TfLiteIntArray</span>* <span style="color: #268bd2;">nodes_to_replace</span><span style="color: #757575;">,</span>
    <span style="color: #b58900;">TfLiteDelegate</span>* <span style="color: #268bd2;">delegate</span><span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
    registration.builtin_code = BuiltinOperator_DELEGATE;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">Analyze the graph to find all independent node_subsets that are either</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">fully not\-this\-delegate or this\-delegate computation.</span>
    <span style="color: #b58900;">InterpreterInfo</span> <span style="color: #268bd2;">info</span><span style="color: #757575;">(</span><span style="color: #859900;">this</span><span style="color: #757575;">)</span>;
    <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">vector</span>&lt;NodeSubset&gt; <span style="color: #268bd2;">node_subsets</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! &#20998;&#20026;&#22810;&#20010; subset</span>
    PartitionGraphIntoIndependentNodeSubsets<span style="color: #757575;">(</span>&amp;info<span style="color: #757575;">,</span> nodes_to_replace<span style="color: #757575;">,</span>
                                             &amp;node_subsets<span style="color: #757575;">)</span>;

    execution_plan_.clear<span style="color: #757575;">()</span>;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! &#25353;&#39034;&#24207;&#36941;&#21382; subset, &#22240;&#20026;&#21508;&#20010; subset &#20043;&#38388;&#24050;&#32463;&#26159; topo &#26377;&#24207;&#30340;</span>
    <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #859900;">auto</span>&amp; <span style="color: #268bd2;">node_subset</span> : node_subsets<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        <span style="color: #859900;">switch</span> <span style="color: #757575;">(</span>node_subset.type<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
            <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! node &#19981;&#23646;&#20110; delegate, &#19981;&#38656;&#35201;&#26367;&#25442;, &#30452;&#25509;&#36861;&#21152;&#21040; execution_plan_</span>
            <span style="color: #859900;">case</span> <span style="color: #268bd2; font-weight: bold;">NodeSubset</span>::kTfNonPartition:
                <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #859900;">auto</span> <span style="color: #268bd2;">it</span> = node_subset.nodes.begin<span style="color: #757575;">()</span>; it != node_subset.nodes.end<span style="color: #757575;">()</span>;
                     ++it<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
                    execution_plan_.push_back<span style="color: #757575;">(</span>*it<span style="color: #757575;">)</span>;
                <span style="color: #757575;">}</span>
                <span style="color: #859900;">break</span>;
            <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! &#23545;&#20110; delegate, &#38656;&#35201;&#29983;&#25104;&#19968;&#20010;&#26032;&#30340; node &#20195;&#26367;subset &#20013;&#30340; node(&#21487;</span>
            <span style="color: #586e75;">// </span><span style="color: #586e75;">&#33021;&#20026;&#22810;&#20010; node, delegate &#30340; TfLiteDelegateParams &#33021;&#25343;&#21040;&#21738;&#20123; node</span>
            <span style="color: #586e75;">// </span><span style="color: #586e75;">&#34987;&#26367;&#25442;), &#28982;&#21518;&#36861;&#21152;&#21040; execution\_plan\_, &#26032;&#30340; node &#20250;&#20351;&#29992;delegate &#30340;</span>
            <span style="color: #586e75;">// </span><span style="color: #586e75;">registration</span>
            <span style="color: #859900;">case</span> <span style="color: #268bd2; font-weight: bold;">NodeSubset</span>::kTfPartition: <span style="color: #757575;">{</span>
                <span style="color: #b58900;">int</span> <span style="color: #268bd2;">node_index</span>;

                <span style="color: #b58900;">TfLiteDelegateParams</span>* <span style="color: #268bd2;">params</span> =
                        CreateDelegateParams<span style="color: #757575;">(</span>delegate<span style="color: #757575;">,</span> node_subset<span style="color: #757575;">)</span>;
                AddNodeWithParameters<span style="color: #757575;">(</span>
                    node_subset.input_tensors<span style="color: #757575;">,</span> node_subset.output_tensors<span style="color: #757575;">,</span> <span style="color: #757575;">{},</span> <span style="color: #268bd2; font-weight: bold;">nullptr</span><span style="color: #757575;">,</span>
                    0<span style="color: #757575;">,</span> params<span style="color: #757575;">,</span> &amp;registration<span style="color: #757575;">,</span> &amp;node_index<span style="color: #757575;">)</span>

                <span style="color: #586e75;">// </span><span style="color: #586e75;">Initialize the output tensors's delegate-related fields.</span>
                <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">tensor_index</span> : node_subset.output_tensors<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
                    <span style="color: #b58900;">TfLiteTensor</span>* <span style="color: #268bd2;">tensor</span> = &amp;tensors_[tensor_index];
                    TF_LITE_ENSURE<span style="color: #757575;">(</span>&amp;context_<span style="color: #757575;">,</span> tensor-&gt;delegate == <span style="color: #268bd2; font-weight: bold;">nullptr</span> ||
                                   tensor-&gt;delegate == delegate<span style="color: #757575;">)</span>;
                    tensor-&gt;delegate = delegate;
                <span style="color: #757575;">}</span>

                <span style="color: #586e75;">// </span><span style="color: #586e75;">Associate the node with the delegate.</span>
                <span style="color: #b58900;">TfLiteNode</span>* <span style="color: #268bd2;">node</span> = &amp;nodes_and_registration_[node_index].first;
                node-&gt;delegate = delegate;
            <span style="color: #757575;">}</span> <span style="color: #859900;">break</span>;
        <span style="color: #757575;">}</span>
    <span style="color: #757575;">}</span>
<span style="color: #757575;">}</span>

</pre>
</div>
</div>
</div>

<div id="outline-container-orgd59f5a5" class="outline-4">
<h4 id="orgd59f5a5"><span class="section-number-4">1.2.5</span> PartitionGraphIntoIndependentNodeSubsets</h4>
<div class="outline-text-4" id="text-1-2-5">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #859900;">while</span> <span style="color: #757575;">(</span>changed<span style="color: #757575;">)</span>:
    subset = <span style="color: #859900;">new</span> <span style="color: #b58900;">array</span><span style="color: #757575;">()</span>
    changed = <span style="color: #268bd2; font-weight: bold;">false</span>
    is_delegate = nil

    <span style="color: #859900;">for</span> node in nodes:
        skip <span style="color: #859900;">if</span> node.input is <span style="color: #859900;">not</span> ready
        skip <span style="color: #859900;">if</span> node.visited
        <span style="color: #859900;">if</span> is_delegate is nil:
            is_delegate = node.is_delegate
        skip <span style="color: #859900;">if</span> node.is_delegate != is_delegate
        subset.push<span style="color: #757575;">(</span>node<span style="color: #757575;">)</span>
        node.visited = <span style="color: #268bd2; font-weight: bold;">true</span>
        node.output.ready = <span style="color: #268bd2; font-weight: bold;">true</span>
    <span style="color: #859900;">if</span> subset is <span style="color: #859900;">not</span> empty:
        subsets.push<span style="color: #757575;">(</span>subset<span style="color: #757575;">)</span>
        changed = <span style="color: #268bd2; font-weight: bold;">true</span>

</pre>
</div>
</div>
</div>

<div id="outline-container-orgb3dfeda" class="outline-4">
<h4 id="orgb3dfeda"><span class="section-number-4">1.2.6</span> Delegate 与 Custom Op 的区别</h4>
<div class="outline-text-4" id="text-1-2-6">
<p>
Delegate 实际上利用了 Custom Op 的机制, 例如 Delegate Op 也是一种特殊的 Custom
Op, 它们都会给 node 注册了一个 registration, 使得执行该 node 时会执行到自定义的
Invoke
</p>

<p>
但 delegate 比 Custom Op 多了一个 partition 的操作, 即它会尽量的把 delegate op
放在同一个 node 里, 例如:
</p>

<pre class="example" id="org77dd62b">
X-&gt;A1-&gt;A2-&gt;D1-&gt;D2-&gt;D3-Y
</pre>

<p>
假设用 Custom Op 实现 D1, D2, D3 (用 CD1 表示 D1 使用 AddCustom 指定的
registration), 则变为:
</p>

<pre class="example" id="org7fa8be1">
X-&gt;A1-&gt;A2-&gt;CD1-&gt;CD2-&gt;CD3-Y
</pre>

<p>
用 delegate 实现 D1, D2, D3 则变为:
</p>

<pre class="example" id="org57082d6">
X-&gt;A1-&gt;A2-&gt;CD-&gt;Y
</pre>

<p>
其中 CD 对应 delegate 对 D1, D2, D3 的实现, 这样做的好处是:
</p>

<blockquote>
<p>
D1, D2 的输出变成了 delegate 设备内部的中间结果, 不必传递给主设备 (CPU)
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orgccda650" class="outline-4">
<h4 id="orgccda650"><span class="section-number-4">1.2.7</span> Flex Delegate</h4>
<div class="outline-text-4" id="text-1-2-7">
<p>
<a href="https://www.tensorflow.org/lite/guide/ops_select">https://www.tensorflow.org/lite/guide/ops_select</a>
</p>
</div>

<div id="outline-container-org903acf4" class="outline-5">
<h5 id="org903acf4"><span class="section-number-5">1.2.7.1</span> Tflite Converter</h5>
<div class="outline-text-5" id="text-1-2-7-1">
</div>
<ol class="org-ol">
<li><a id="orgd70fd86"></a>target ops<br />
<div class="outline-text-6" id="text-1-2-7-1-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #268bd2;">converter.target_spec.supported_ops</span> = [tf.lite.OpsSet.TFLITE_BUILTINS<span style="color: #757575;">,</span>
                                       tf.lite.OpsSet.SELECT_TF_OPS]

</pre>
</div>

<p>
通过设置 converter 的 supported_ops, 可以影响生成 tflite 的过程
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900;">if</span> target_ops:
    <span style="color: #859900;">if</span> <span style="color: #839496;">set</span><span style="color: #757575;">(</span>target_ops<span style="color: #757575;">)</span> == <span style="color: #839496;">set</span><span style="color: #757575;">(</span>[OpsSet.TFLITE_BUILTINS<span style="color: #757575;">,</span> OpsSet.SELECT_TF_OPS]<span style="color: #757575;">)</span>:
      <span style="color: #268bd2;">toco.enable_select_tf_ops</span> = <span style="color: #268bd2; font-weight: bold;">True</span>
    <span style="color: #859900;">elif</span> <span style="color: #839496;">set</span><span style="color: #757575;">(</span>target_ops<span style="color: #757575;">)</span> == <span style="color: #839496;">set</span><span style="color: #757575;">(</span>[OpsSet.SELECT_TF_OPS]<span style="color: #757575;">)</span>:
      <span style="color: #268bd2;">toco.enable_select_tf_ops</span> = <span style="color: #268bd2; font-weight: bold;">True</span>
      <span style="color: #268bd2;">toco.force_select_tf_ops</span> = <span style="color: #268bd2; font-weight: bold;">True</span>
</pre>
</div>

<p>
通过 supported_ops, 可以控制是否 enable_select_tf_ops 或 force_select_tf_ops:
</p>

<ol class="org-ol">
<li>若 force_select_tf_ops, 即 toco (Tensorflow Optimized COnverter) 会把所有 op
都转换为 tf_op (即 flex delegate op)</li>
<li>若 enable_select_tf_ops (而非 force_select_tf_ops), 则 builtin_op 之外的
op 会转换为 tf_op</li>
</ol>
</div>
</li>

<li><a id="orgb35e2df"></a>export<br />
<div class="outline-text-6" id="text-1-2-7-1-2">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #586e75;">// </span><span style="color: #586e75;">!!! &#24403;&#21069; flex op &#26377;&#19968;&#20010; allowlist, &#34920;&#31034;&#21738;&#20123; tf op &#21487;&#20197;&#25903;&#25345;</span>
<span style="color: #859900;">if</span> <span style="color: #757575;">(</span>enabled_op_types_.contains<span style="color: #757575;">(</span><span style="color: #268bd2; font-weight: bold;">OpType</span>::kSelectTf<span style="color: #757575;">)</span> &amp;&amp;
    IsAllowlistedFlexOp<span style="color: #757575;">(</span>node_def-&gt;op<span style="color: #757575;">()))</span> <span style="color: #757575;">{</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! kFlexOpNamePrefix = "Flex"</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">flex op &#20363;&#22914; Abs &#20250;&#34987;&#20462;&#25913;&#20026;&#21517;&#20026; FlexAbs &#30340; custom_op</span>
    op_name = <span style="color: #268bd2; font-weight: bold;">std</span>::string<span style="color: #757575;">(</span>kFlexOpNamePrefix<span style="color: #757575;">)</span> + node_def-&gt;op<span style="color: #757575;">()</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! node_def-&gt;op() (&#21363; op name, &#20363;&#22914; Abs) &#22312; CreateFlexOpCustomOptions &#26102;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20250;&#20889;&#22312; custom options, flex delegate &#20250;&#20174; custom options &#20013;&#35835;&#21040; op name,</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20877;&#21435;&#25191;&#34892;, &#32780;&#19981;&#26159;&#30452;&#25509;&#29992; custom name &#21435;&#25481; "Flex" &#21069;&#32512;</span>
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #859900;">auto</span> <span style="color: #268bd2;">options</span> = CreateFlexOpCustomOptions<span style="color: #757575;">(</span>*node_def<span style="color: #757575;">,</span> inst-&gt;getLoc<span style="color: #757575;">()))</span> <span style="color: #757575;">{</span>

        custom_options = *options;
    <span style="color: #757575;">}</span> <span style="color: #859900;">else</span> <span style="color: #757575;">{</span>
        <span style="color: #859900;">return</span> <span style="color: #268bd2; font-weight: bold;">llvm</span>::None;
    <span style="color: #757575;">}</span>
</pre>
</div>
</div>
</li>
</ol>
</div>


<div id="outline-container-org7aa9255" class="outline-5">
<h5 id="org7aa9255"><span class="section-number-5">1.2.7.2</span> Flex Delegate Impl</h5>
<div class="outline-text-5" id="text-1-2-7-2">
</div>
<ol class="org-ol">
<li><a id="org0e57505"></a>ApplyDelegates<br />
<div class="outline-text-6" id="text-1-2-7-2-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #b58900;">TfLiteStatus</span> <span style="color: #268bd2; font-weight: bold;">InterpreterBuilder</span>::<span style="color: #268bd2;">ApplyDelegates</span><span style="color: #757575;">(</span><span style="color: #b58900;">Interpreter</span>* <span style="color: #268bd2;">interpreter</span><span style="color: #757575;">,</span>
                                                <span style="color: #b58900;">int</span> <span style="color: #268bd2;">num_threads</span><span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>has_flex_op_<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #859900;">auto</span> <span style="color: #268bd2;">flex_delegate</span> = AcquireFlexDelegate<span style="color: #757575;">())</span> <span style="color: #757575;">{</span>
            <span style="color: #859900;">return</span> interpreter-&gt;ModifyGraphWithDelegate<span style="color: #757575;">(</span><span style="color: #268bd2; font-weight: bold;">std</span>::move<span style="color: #757575;">(</span>flex_delegate<span style="color: #757575;">))</span>;
        <span style="color: #757575;">}</span>
    <span style="color: #757575;">}</span>

    <span style="color: #859900;">return</span> kTfLiteOk;
<span style="color: #757575;">}</span>

<span style="color: #b58900;">TfLiteStatus</span> <span style="color: #268bd2; font-weight: bold;">InterpreterBuilder</span>::<span style="color: #268bd2;">BuildLocalIndexToRegistrationMapping</span><span style="color: #757575;">()</span> <span style="color: #757575;">{</span>
    <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #859900;">const</span> <span style="color: #b58900;">OperatorCode</span>* <span style="color: #268bd2;">opcode</span> : *opcodes<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        <span style="color: #859900;">const</span> <span style="color: #b58900;">TfLiteRegistration</span>* <span style="color: #268bd2;">registration</span> = <span style="color: #268bd2; font-weight: bold;">nullptr</span>;
        status = GetRegistrationFromOpCode<span style="color: #757575;">(</span>opcode<span style="color: #757575;">,</span> op_resolver_<span style="color: #757575;">,</span> error_reporter_<span style="color: #757575;">,</span>
                                           &amp;registration<span style="color: #757575;">)</span>;
        <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>status != kTfLiteOk<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
            <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! flex op &#39318;&#20808;&#26159; custom_op</span>
            <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>opcode-&gt;builtin_code<span style="color: #757575;">()</span> != BuiltinOperator_CUSTOM<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
                <span style="color: #859900;">return</span> status;
            <span style="color: #757575;">}</span>
            <span style="color: #859900;">const</span> <span style="color: #859900;">auto</span>* <span style="color: #268bd2;">op_name</span> = opcode-&gt;custom_code<span style="color: #757575;">()</span>-&gt;c_str<span style="color: #757575;">()</span>;
            <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! op_name &#26159;&#21542;&#26377; "Flex" &#21069;&#32512;</span>
            has_flex_op_ |= IsFlexOp<span style="color: #757575;">(</span>op_name<span style="color: #757575;">)</span>;
        <span style="color: #757575;">}</span>
    <span style="color: #757575;">}</span>
    <span style="color: #859900;">return</span> status;
<span style="color: #757575;">}</span>

<span style="color: #b58900;">bool</span> <span style="color: #268bd2;">IsFlexOp</span><span style="color: #757575;">(</span><span style="color: #859900;">const</span> <span style="color: #b58900;">char</span>* <span style="color: #268bd2;">custom_name</span><span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
    <span style="color: #859900;">return</span> custom_name &amp;&amp; strncmp<span style="color: #757575;">(</span>custom_name<span style="color: #757575;">,</span> kFlexCustomCodePrefix<span style="color: #757575;">,</span>
                                 strlen<span style="color: #757575;">(</span>kFlexCustomCodePrefix<span style="color: #757575;">))</span> == 0;
<span style="color: #757575;">}</span>
</pre>
</div>
</div>
</li>

<li><a id="org8afed5a"></a>Flex Delegate<br />
<ol class="org-ol">
<li><a id="org93cf084"></a>IsNodeSupportedByDelegate<br />
<div class="outline-text-7" id="text-1-2-7-2-2-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #b58900;">bool</span> <span style="color: #268bd2; font-weight: bold;">FlexDelegate</span>::<span style="color: #268bd2;">IsNodeSupportedByDelegate</span><span style="color: #757575;">(</span>
    <span style="color: #859900;">const</span> <span style="color: #b58900;">TfLiteRegistration</span>* <span style="color: #268bd2;">registration</span><span style="color: #757575;">,</span> <span style="color: #859900;">const</span> <span style="color: #b58900;">TfLiteNode</span>* <span style="color: #268bd2;">node</span><span style="color: #757575;">,</span>
    <span style="color: #b58900;">TfLiteContext</span>* <span style="color: #268bd2;">context</span><span style="color: #757575;">)</span> <span style="color: #859900;">const</span> <span style="color: #757575;">{</span>
    <span style="color: #859900;">return</span> IsFlexOp<span style="color: #757575;">(</span>registration-&gt;custom_name<span style="color: #757575;">)</span>;
<span style="color: #757575;">}</span>
</pre>
</div>
</div>
</li>


<li><a id="org8cbb5fd"></a>Eval<br />
<div class="outline-text-7" id="text-1-2-7-2-2-2">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #b58900;">TfLiteStatus</span> <span style="color: #268bd2; font-weight: bold;">DelegateKernel</span>::<span style="color: #268bd2;">Eval</span><span style="color: #757575;">(</span><span style="color: #b58900;">TfLiteContext</span>* <span style="color: #268bd2;">context</span><span style="color: #757575;">,</span> <span style="color: #b58900;">TfLiteNode</span>* <span style="color: #268bd2;">node</span><span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">Execute the TensorFlow Ops sequentially.</span>
    <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #859900;">auto</span>&amp; <span style="color: #268bd2;">node_data</span> : op_data_-&gt;nodes<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        TFLITE_SCOPED_DELEGATE_OPERATOR_PROFILE<span style="color: #757575;">(</span>
            <span style="color: #859900;">reinterpret_cast</span>&lt;<span style="color: #b58900;">Profiler</span>*&gt;<span style="color: #757575;">(</span>context-&gt;profiler<span style="color: #757575;">),</span>
            node_data-&gt;name<span style="color: #757575;">()</span>.c_str<span style="color: #757575;">(),</span> node_data-&gt;index<span style="color: #757575;">())</span>;

        <span style="color: #586e75;">// </span><span style="color: #586e75;">node_data-&gt;name() &#26159;&#31867;&#20284;&#20110; Abs &#36825;&#26679;&#30340; string</span>
        <span style="color: #859900;">auto</span> <span style="color: #268bd2;">status</span> = ExecuteFlexOp<span style="color: #757575;">(</span>context<span style="color: #757575;">,</span> buffer_map<span style="color: #757575;">,</span> node_data.get<span style="color: #757575;">())</span>;
        TF_LITE_ENSURE_OK<span style="color: #757575;">(</span>context<span style="color: #757575;">,</span> ConvertStatus<span style="color: #757575;">(</span>context<span style="color: #757575;">,</span> status<span style="color: #757575;">))</span>;
    <span style="color: #757575;">}</span>
<span style="color: #757575;">}</span>

<span style="color: #268bd2; font-weight: bold;">tensorflow</span>::<span style="color: #b58900;">Status</span> <span style="color: #268bd2;">InitializeNodeDef</span><span style="color: #757575;">(</span><span style="color: #859900;">const</span> <span style="color: #b58900;">void</span>* <span style="color: #268bd2;">custom_initial_data</span><span style="color: #757575;">,</span>
                                     <span style="color: #b58900;">int</span> <span style="color: #268bd2;">custom_initial_data_size</span><span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
    <span style="color: #859900;">const</span> <span style="color: #268bd2; font-weight: bold;">flexbuffers</span>::<span style="color: #b58900;">Vector</span>&amp; <span style="color: #268bd2;">v</span> =
            <span style="color: #268bd2; font-weight: bold;">flexbuffers</span>::GetRoot<span style="color: #757575;">(</span>
                <span style="color: #859900;">reinterpret_cast</span>&lt;<span style="color: #859900;">const</span> <span style="color: #b58900;">uint8_t</span>*&gt;<span style="color: #757575;">(</span>custom_initial_data<span style="color: #757575;">),</span>
                custom_initial_data_size<span style="color: #757575;">)</span>
            .AsVector<span style="color: #757575;">()</span>;

    name_ = v[0].AsString<span style="color: #757575;">()</span>.str<span style="color: #757575;">()</span>;
<span style="color: #757575;">}</span>

<span style="color: #b58900;">TfLiteStatus</span> <span style="color: #268bd2; font-weight: bold;">DelegateKernel</span>::<span style="color: #268bd2;">Init</span><span style="color: #757575;">(</span><span style="color: #b58900;">TfLiteContext</span>* <span style="color: #268bd2;">context</span><span style="color: #757575;">,</span>
                                  <span style="color: #859900;">const</span> <span style="color: #b58900;">TfLiteDelegateParams</span>* <span style="color: #268bd2;">params</span><span style="color: #757575;">)</span> <span style="color: #757575;">{</span>

    <span style="color: #859900;">for</span> <span style="color: #757575;">(</span><span style="color: #859900;">auto</span> <span style="color: #268bd2;">node_index</span> : TfLiteIntArrayView<span style="color: #757575;">(</span>params-&gt;nodes_to_replace<span style="color: #757575;">))</span> <span style="color: #757575;">{</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! custom_initial_data</span>
        status = node_data.InitializeNodeDef<span style="color: #757575;">(</span>node-&gt;custom_initial_data<span style="color: #757575;">,</span>
                                             node-&gt;custom_initial_data_size<span style="color: #757575;">)</span>;
    <span style="color: #757575;">}</span>
<span style="color: #757575;">}</span>

<span style="color: #b58900;">TfLiteStatus</span> <span style="color: #268bd2; font-weight: bold;">Subgraph</span>::<span style="color: #268bd2;">AddNodeWithParameters</span><span style="color: #757575;">(</span>
    <span style="color: #859900;">const</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">vector</span>&lt;<span style="color: #b58900;">int</span>&gt;&amp; <span style="color: #268bd2;">inputs</span><span style="color: #757575;">,</span> <span style="color: #859900;">const</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">vector</span>&lt;<span style="color: #b58900;">int</span>&gt;&amp; <span style="color: #268bd2;">outputs</span><span style="color: #757575;">,</span>
    <span style="color: #859900;">const</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">vector</span>&lt;<span style="color: #b58900;">int</span>&gt;&amp; <span style="color: #268bd2;">intermediates</span><span style="color: #757575;">,</span> <span style="color: #859900;">const</span> <span style="color: #b58900;">char</span>* <span style="color: #268bd2;">init_data</span><span style="color: #757575;">,</span>
    <span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">init_data_size</span><span style="color: #757575;">,</span> <span style="color: #b58900;">void</span>* <span style="color: #268bd2;">builtin_data</span><span style="color: #757575;">,</span>
    <span style="color: #859900;">const</span> <span style="color: #b58900;">TfLiteRegistration</span>* <span style="color: #268bd2;">registration</span><span style="color: #757575;">,</span> <span style="color: #b58900;">int</span>* <span style="color: #268bd2;">node_index</span><span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>registration-&gt;builtin_code == BuiltinOperator_CUSTOM<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">When it's a CUSTOM op, the `custom_options` field in the Flatbuffer</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">`Operator` table is passed in.</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! init_data</span>
        node.custom_initial_data = init_data;
        node.custom_initial_data_size = init_data_size;
    <span style="color: #757575;">}</span> <span style="color: #859900;">else</span> <span style="color: #757575;">{</span>
        node.custom_initial_data = <span style="color: #268bd2; font-weight: bold;">nullptr</span>;
        node.custom_initial_data_size = 0;
    <span style="color: #757575;">}</span>
<span style="color: #757575;">}</span>

<span style="color: #b58900;">TfLiteStatus</span> <span style="color: #268bd2; font-weight: bold;">InterpreterBuilder</span>::<span style="color: #268bd2;">ParseNodes</span><span style="color: #757575;">(</span>
    <span style="color: #859900;">const</span> <span style="color: #268bd2; font-weight: bold;">flatbuffers</span>::<span style="color: #b58900;">Vector</span>&lt;<span style="color: #268bd2; font-weight: bold;">flatbuffers</span>::<span style="color: #b58900;">Offset</span>&lt;Operator&gt;&gt;* <span style="color: #268bd2;">operators</span><span style="color: #757575;">,</span>
    <span style="color: #b58900;">Subgraph</span>* <span style="color: #268bd2;">subgraph</span><span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>op_type == BuiltinOperator_CUSTOM<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
        <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>op-&gt;custom_options<span style="color: #757575;">())</span> <span style="color: #757575;">{</span>
            subgraph-&gt;AddNodeWithParameters<span style="color: #757575;">(</span>
                FlatBufferIntArrayToVector<span style="color: #757575;">(</span>op-&gt;inputs<span style="color: #757575;">()),</span>
                FlatBufferIntArrayToVector<span style="color: #757575;">(</span>op-&gt;outputs<span style="color: #757575;">()),</span>
                FlatBufferIntArrayToVector<span style="color: #757575;">(</span>op-&gt;intermediates<span style="color: #757575;">()),</span>
                <span style="color: #586e75;">// </span><span style="color: #586e75;">!!! custom_options()-&gt;data</span>
                <span style="color: #859900;">reinterpret_cast</span>&lt;<span style="color: #859900;">const</span> <span style="color: #b58900;">char</span>*&gt;<span style="color: #757575;">(</span>op-&gt;custom_options<span style="color: #757575;">()</span>-&gt;data<span style="color: #757575;">()),</span>
                op-&gt;custom_options<span style="color: #757575;">()</span>-&gt;size<span style="color: #757575;">(),</span> <span style="color: #268bd2; font-weight: bold;">nullptr</span><span style="color: #757575;">,</span> registration<span style="color: #757575;">)</span>;
        <span style="color: #757575;">}</span>
<span style="color: #757575;">}</span>
</pre>
</div>
</div>
</li>
</ol>
</li>
</ol>
</div>

<div id="outline-container-orgdd385ff" class="outline-5">
<h5 id="orgdd385ff"><span class="section-number-5">1.2.7.3</span> edge tpu</h5>
<div class="outline-text-5" id="text-1-2-7-3">
<p>
edge tpu 的支持并不是通过 delegate, 而是需要用 edgetpu_compiler 把最初的 tflite
文件转换一下, 把其中 edge tpu 支持的操作封装到一个 custom op (edgetpu-custom-op)
中, 并输出另一个 tflite 文件
</p>

<p>
运行时反 libedgetpu 链接进来, 同时通过 AddCustom 注册 edgetpu 使用的 custom op:
</p>

<div class="org-src-container">
<pre class="src src-c++">resolver.AddCustom<span style="color: #757575;">(</span><span style="color: #268bd2; font-weight: bold;">edgetpu</span>::kCustomOp<span style="color: #757575;">,</span> <span style="color: #268bd2; font-weight: bold;">edgetpu</span>::RegisterCustomOp<span style="color: #757575;">())</span>;                                                                          
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org0f18681" class="outline-3">
<h3 id="org0f18681"><span class="section-number-3">1.3</span> <a href="tflite_format.html#org58a8697">TFLite Format</a></h3>
</div>

<div id="outline-container-org1f37f79" class="outline-3">
<h3 id="org1f37f79"><span class="section-number-3">1.4</span> <a href="tflite_quantization_detail.html#orgd9b34bb">TFLite Quantization Details</a></h3>
</div>
</div>
</div>
<div id="postamble" class="status">

<p class="author">Author: sunway (sunwayforever@gmail.com)<br />
Date: 2020-07-28 二 00:00<br />
Last updated: 2022-01-24 一 19:29</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。
<br />

<div id="disqus_thread"></div>
<script>

(function() { // DON'T EDIT BELOW THIS LINE
         var d = document, s = d.createElement('script');
         s.src = '//sunwayforever-github-io.disqus.com/embed.js';
         s.setAttribute('data-timestamp', +new Date());
         (d.head || d.body).appendChild(s);
         })();
</script>
</div>
</body>
</html>
