<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-01-25 Tue 18:53 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Tensorflow Lite Internal</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wei Sun (孙伟)" />
<link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
<link rel = "icon" href = "/icon.png"  type = "image/x-icon">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Tensorflow Lite Internal</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org05c7265">1. TFLite Internal</a>
<ul>
<li><a href="#org7514743">1.1. Overview</a>
<ul>
<li><a href="#org25b4ba3">1.1.1. BuiltinOpResolver</a></li>
<li><a href="#orgd36626b">1.1.2. InterpreterBuilder</a></li>
<li><a href="#orge5fda87">1.1.3. AllocateTensors</a></li>
<li><a href="#org81e642c">1.1.4. Interpreter.Invoke</a></li>
</ul>
</li>
<li><a href="#org46cecd5">1.2. TFLite Delegate</a>
<ul>
<li><a href="#orgbd79bdc">1.2.1. A Simple Model</a></li>
<li><a href="#org4252725">1.2.2. MyDelegate</a></li>
<li><a href="#org3f0c6f9">1.2.3. ModifyGraphWithDelegate</a></li>
<li><a href="#org12938b0">1.2.4. ReplaceNodeSubsetsWithDelegateKernels</a></li>
<li><a href="#orgee156ac">1.2.5. WAIT PartitionGraphIntoIndependentNodeSubsets</a></li>
<li><a href="#orgd59b8cb">1.2.6. Delegate 与 Custom Op 的区别</a></li>
<li><a href="#orgb6a4b5d">1.2.7. Flex Delegate</a></li>
</ul>
</li>
<li><a href="#org8384c5f">1.3. TFLite Format</a></li>
<li><a href="#org0384a4e">1.4. TFLite Quantization Details</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org05c7265" class="outline-2">
<h2 id="org05c7265"><span class="section-number-2">1</span> TFLite Internal</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org7514743" class="outline-3">
<h3 id="org7514743"><span class="section-number-3">1.1</span> Overview</h3>
<div class="outline-text-3" id="text-1-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">main</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">argc</span>, <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">argv</span>[]) {
    <span style="font-weight: bold;">if</span> (argc != 2) {
        fprintf(stderr, <span style="font-style: italic;">"square &lt;tflite model&gt;\n"</span>);
        <span style="font-weight: bold;">return</span> 1;
    }
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">filename</span> = argv[1];

    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">unique_ptr</span>&lt;<span style="font-weight: bold; text-decoration: underline;">tflite</span>::FlatBufferModel&gt; <span style="font-weight: bold; font-style: italic;">model</span> =
            <span style="font-weight: bold; text-decoration: underline;">tflite</span>::<span style="font-weight: bold; text-decoration: underline;">FlatBufferModel</span>::BuildFromFile(filename);

    <span style="font-weight: bold; text-decoration: underline;">tflite</span>::<span style="font-weight: bold; text-decoration: underline;">ops</span>::<span style="font-weight: bold; text-decoration: underline;">builtin</span>::<span style="font-weight: bold; text-decoration: underline;">BuiltinOpResolver</span> <span style="font-weight: bold; font-style: italic;">resolver</span>;
    <span style="font-weight: bold; text-decoration: underline;">InterpreterBuilder</span> <span style="font-weight: bold; font-style: italic;">builder</span>(*model, resolver);
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">unique_ptr</span>&lt;Interpreter&gt; <span style="font-weight: bold; font-style: italic;">interpreter</span>;
    builder(&amp;interpreter);

    interpreter-&gt;AllocateTensors();
    <span style="font-weight: bold; text-decoration: underline;">float</span>* <span style="font-weight: bold; font-style: italic;">input</span> = interpreter-&gt;typed_input_tensor&lt;<span style="font-weight: bold; text-decoration: underline;">float</span>&gt;(0);
    input[0] = 10;
    interpreter-&gt;Invoke();
    <span style="font-weight: bold; text-decoration: underline;">float</span>* <span style="font-weight: bold; font-style: italic;">output</span> = interpreter-&gt;typed_output_tensor&lt;<span style="font-weight: bold; text-decoration: underline;">float</span>&gt;(0);
    printf(<span style="font-style: italic;">"%f\n"</span>, output[0]);

    <span style="font-weight: bold;">return</span> 0;
}
</pre>
</div>
</div>

<div id="outline-container-org25b4ba3" class="outline-4">
<h4 id="org25b4ba3"><span class="section-number-4">1.1.1</span> BuiltinOpResolver</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
注册各个 op 对应的 Invoke 函数, 例如 abs 最终会对应 AbsEval, 后者最终会调用 std::abs
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold; text-decoration: underline;">BuiltinOpResolver</span>::<span style="font-weight: bold;">BuiltinOpResolver</span>() {
    AddBuiltin(BuiltinOperator_ABS, Register_ABS());
    AddBuiltin(BuiltinOperator_RELU, Register_RELU(), 1, 2);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">...</span>
    AddBuiltin(BuiltinOperator_MAX_POOL_2D, Register_MAX_POOL_2D(), 1, 3);
    AddBuiltin(BuiltinOperator_L2_POOL_2D, Register_L2_POOL_2D());
    AddBuiltin(BuiltinOperator_CONV_2D, Register_CONV_2D(), 1, 5);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">....</span>
    AddBuiltin(BuiltinOperator_FULLY_CONNECTED, Register_FULLY_CONNECTED(), 1,
               9);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">...</span>
}

<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">MutableOpResolver</span>::<span style="font-weight: bold;">AddBuiltin</span>(<span style="font-weight: bold; text-decoration: underline;">tflite</span>::<span style="font-weight: bold; text-decoration: underline;">BuiltinOperator</span> <span style="font-weight: bold; font-style: italic;">op</span>,
                                   <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">TfLiteRegistration</span>* <span style="font-weight: bold; font-style: italic;">registration</span>,
                                   <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">version</span>) {
    <span style="font-weight: bold; text-decoration: underline;">TfLiteRegistration</span> <span style="font-weight: bold; font-style: italic;">new_registration</span> = *registration;
    new_registration.custom_name = <span style="font-weight: bold; text-decoration: underline;">nullptr</span>;
    new_registration.builtin_code = op;
    new_registration.version = version;
    <span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">op_key</span> = <span style="font-weight: bold; text-decoration: underline;">std</span>::make_pair(op, version);
    builtins_[op_key] = new_registration;
}

<span style="font-weight: bold; text-decoration: underline;">TfLiteRegistration</span>* <span style="font-weight: bold;">Register_ABS</span>() {
    <span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">TfLiteRegistration</span> <span style="font-weight: bold; font-style: italic;">r</span> = {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">init</span>
        <span style="font-weight: bold; text-decoration: underline;">nullptr</span>,
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">free</span>
        <span style="font-weight: bold; text-decoration: underline;">nullptr</span>,
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">prepare</span>
        <span style="font-weight: bold; text-decoration: underline;">elementwise</span>::<span style="font-weight: bold; text-decoration: underline;">GenericPrepare</span>&lt;<span style="font-weight: bold; text-decoration: underline;">elementwise</span>::IsNumericSupportedType,
                                    <span style="font-weight: bold; text-decoration: underline;">elementwise</span>::kAbsName&gt;,
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">invoke</span>
        <span style="font-weight: bold; text-decoration: underline;">elementwise</span>::AbsEval};
    <span style="font-weight: bold;">return</span> &amp;r;
}

<span style="font-weight: bold; text-decoration: underline;">TfLiteStatus</span> <span style="font-weight: bold;">AbsEval</span>(<span style="font-weight: bold; text-decoration: underline;">TfLiteContext</span>* <span style="font-weight: bold; font-style: italic;">context</span>, <span style="font-weight: bold; text-decoration: underline;">TfLiteNode</span>* <span style="font-weight: bold; font-style: italic;">node</span>) {
    <span style="font-weight: bold;">return</span> EvalNumeric(context, node, <span style="font-weight: bold; text-decoration: underline;">std</span>::abs);
}

<span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">TfLiteStatus</span> <span style="font-weight: bold;">EvalNumeric</span>(<span style="font-weight: bold; text-decoration: underline;">TfLiteContext</span>* <span style="font-weight: bold; font-style: italic;">context</span>, <span style="font-weight: bold; text-decoration: underline;">TfLiteNode</span>* <span style="font-weight: bold; font-style: italic;">node</span>,
                                <span style="font-weight: bold; text-decoration: underline;">float</span> <span style="font-weight: bold;">float_func</span>(<span style="font-weight: bold; text-decoration: underline;">float</span>)) {
    <span style="font-weight: bold;">return</span> EvalImpl&lt;<span style="font-weight: bold; text-decoration: underline;">float</span>&gt;(context, node, float_func, kTfLiteFloat32);
}

<span style="font-weight: bold;">template</span> &lt;<span style="font-weight: bold;">typename</span> <span style="font-weight: bold; text-decoration: underline;">T</span>&gt;
<span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">TfLiteStatus</span> <span style="font-weight: bold;">EvalImpl</span>(<span style="font-weight: bold; text-decoration: underline;">TfLiteContext</span>* <span style="font-weight: bold; font-style: italic;">context</span>, <span style="font-weight: bold; text-decoration: underline;">TfLiteNode</span>* <span style="font-weight: bold; font-style: italic;">node</span>,
                             <span style="font-weight: bold; text-decoration: underline;">T</span> <span style="font-weight: bold;">func</span>(<span style="font-weight: bold; text-decoration: underline;">T</span>), <span style="font-weight: bold; text-decoration: underline;">TfLiteType</span> <span style="font-weight: bold; font-style: italic;">expected_type</span>) {
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">TfLiteTensor</span>* <span style="font-weight: bold; font-style: italic;">input</span> = GetInput(context, node, 0);
    <span style="font-weight: bold; text-decoration: underline;">TfLiteTensor</span>* <span style="font-weight: bold; font-style: italic;">output</span> = GetOutput(context, node, 0);
    TF_LITE_ENSURE_TYPES_EQ(context, input-&gt;type, expected_type);
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int64_t</span> <span style="font-weight: bold; font-style: italic;">num_elements</span> = NumElements(input);
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">T</span>* <span style="font-weight: bold; font-style: italic;">in_data</span> = GetTensorData&lt;<span style="font-weight: bold; text-decoration: underline;">T</span>&gt;(input);
    <span style="font-weight: bold; text-decoration: underline;">T</span>* <span style="font-weight: bold; font-style: italic;">out_data</span> = GetTensorData&lt;<span style="font-weight: bold; text-decoration: underline;">T</span>&gt;(output);
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int64_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; num_elements; ++i) {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! out_data[i] = std::abs(in_data[i])</span>
        out_data[i] = func(in_data[i]);
    }
    <span style="font-weight: bold;">return</span> kTfLiteOk;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd36626b" class="outline-4">
<h4 id="orgd36626b"><span class="section-number-4">1.1.2</span> InterpreterBuilder</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
生成 interpreter, 主要是根据 model 中的 operator 及 resolver 中的 registration
生成 graph 及其中的 node 以便执行. 另外会用 delegate 把 graph 分割为不同的
subgraph 以分别执行.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold; text-decoration: underline;">TfLiteStatus</span> <span style="font-weight: bold; text-decoration: underline;">InterpreterBuilder</span>::<span style="font-weight: bold;">operator</span><span style="font-weight: bold;">()</span>(
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">unique_ptr</span>&lt;Interpreter&gt;* <span style="font-weight: bold; font-style: italic;">interpreter</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">num_threads</span>) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! &#26597;&#25214; resolver &#20013;&#35760;&#24405;&#30340; registration</span>
    BuildLocalIndexToRegistrationMapping();

    <span style="font-weight: bold;">auto</span>* <span style="font-weight: bold; font-style: italic;">subgraphs</span> = model_-&gt;subgraphs();
    <span style="font-weight: bold;">auto</span>* <span style="font-weight: bold; font-style: italic;">buffers</span> = model_-&gt;buffers();

    <span style="font-weight: bold;">if</span> (subgraphs-&gt;size() &gt; 1) {
        (*interpreter)-&gt;AddSubgraphs(subgraphs-&gt;size() - 1);
    }

    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">subgraph_index</span> = 0; subgraph_index &lt; subgraphs-&gt;size();
         ++subgraph_index) {
        <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">tflite</span>::<span style="font-weight: bold; text-decoration: underline;">SubGraph</span>* <span style="font-weight: bold; font-style: italic;">subgraph</span> = (*subgraphs)[subgraph_index];
        <span style="font-weight: bold; text-decoration: underline;">tflite</span>::<span style="font-weight: bold; text-decoration: underline;">Subgraph</span>* <span style="font-weight: bold; font-style: italic;">modified_subgraph</span> =
            (*interpreter)-&gt;subgraph(subgraph_index);
        <span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">operators</span> = subgraph-&gt;operators();
        <span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">tensors</span> = subgraph-&gt;tensors();

        modified_subgraph-&gt;AddTensors(tensors-&gt;size());

        modified_subgraph-&gt;SetInputs(
            FlatBufferIntArrayToVector(subgraph-&gt;inputs()));
        modified_subgraph-&gt;SetOutputs(
            FlatBufferIntArrayToVector(subgraph-&gt;outputs()));

        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! &#26681;&#25454; operator &#29983;&#25104; node &#21450; execution_plan</span>
        ParseNodes(operators, modified_subgraph);
        ParseTensors(buffers, tensors, modified_subgraph);

        <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt; <span style="font-weight: bold; font-style: italic;">variables</span>;
        <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; modified_subgraph-&gt;tensors_size(); ++i) {
            <span style="font-weight: bold;">auto</span>* <span style="font-weight: bold; font-style: italic;">tensor</span> = modified_subgraph-&gt;tensor(i);
            <span style="font-weight: bold;">if</span> (tensor-&gt;is_variable) {
                variables.push_back(i);
            }
        }
        modified_subgraph-&gt;SetVariables(<span style="font-weight: bold; text-decoration: underline;">std</span>::move(variables));
    }

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! &#26159;&#21542;&#20351;&#29992; flex delegate &#25903;&#25345; tensorflow op (&#32780;&#19981;&#26159; tflite builtin op)</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">https://www.tensorflow.org/lite/guide/ops_select?hl=zh-cn</span>
    ApplyDelegates(interpreter-&gt;get(), num_threads)
}
</pre>
</div>
</div>

<div id="outline-container-org4eb11ba" class="outline-5">
<h5 id="org4eb11ba"><span class="section-number-5">1.1.2.1</span> BuildLocalIndexToRegistrationMapping</h5>
<div class="outline-text-5" id="text-1-1-2-1">
<p>
查找之前 BuiltinOpResolver 注册的 registration
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold; text-decoration: underline;">TfLiteStatus</span> <span style="font-weight: bold; text-decoration: underline;">InterpreterBuilder</span>::<span style="font-weight: bold;">BuildLocalIndexToRegistrationMapping</span>() {
    unresolved_custom_ops_.clear();

    <span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">opcodes</span> = model_-&gt;operator_codes();

    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">num_custom_ops</span> = 0;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">builtin_code &#38500;&#20102;&#27491;&#24120;&#30340;&#22914; BuiltinOperator_ABS &#20043;&#31867;&#30340;, &#36824;&#21253;&#21547;&#20004;&#31181;&#29305;&#27530;&#30340;&#20540;:</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">BuiltinOperator\_CUSTOM</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">BuiltinOperator\_DELEGATE</span>
    <span style="font-weight: bold; font-style: italic;">//</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20854;&#20013;&#23545;&#20110; BuiltinOperator_CUSTOM, OperatorCode.custom_code (&#19968;&#20010; string)</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#29992;&#26469;&#21306;&#21035;&#36825;&#20010; custom op &#20855;&#20307;&#26159;&#20160;&#20040;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110; custom op, BuiltinOpResolver &#21487;&#20197;&#36890;&#36807; AddCustom &#28155;&#21152;&#23545;&#23427;&#30340;&#25903;&#25345;,</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25110;&#32773; delegate &#20063;&#21487;&#20197;&#25903;&#25345;&#23427;, &#20294; delegate &#30340;&#25903;&#25345;&#24182;&#19981;&#20250;&#22312; resolver &#20013;&#20307;&#29616;,</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25152;&#20197;&#19979;&#38754;&#30340;&#20195;&#30721;&#20250;&#26377; unresolved_custom_ops_</span>

    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">OperatorCode</span>* <span style="font-weight: bold; font-style: italic;">opcode</span> : *opcodes) {
        <span style="font-weight: bold;">if</span> (opcode-&gt;builtin_code() == BuiltinOperator_CUSTOM) {
            num_custom_ops++;
        }
    }
    unresolved_custom_ops_.reserve(num_custom_ops);
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">OperatorCode</span>* <span style="font-weight: bold; font-style: italic;">opcode</span> : *opcodes) {
        <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">TfLiteRegistration</span>* <span style="font-weight: bold; font-style: italic;">registration</span> = <span style="font-weight: bold; text-decoration: underline;">nullptr</span>;
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! &#26597;&#25214; builtin_code &#21644; custom_code</span>
        status = GetRegistrationFromOpCode(opcode, op_resolver_, error_reporter_,
                                           &amp;registration);
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! op &#22312; resolver &#20013;&#25214;&#19981;&#21040; registration, &#20132;&#32473; delegate</span>
        <span style="font-weight: bold;">if</span> (status != kTfLiteOk) {
            <span style="font-weight: bold;">const</span> <span style="font-weight: bold;">auto</span>* <span style="font-weight: bold; font-style: italic;">op_name</span> = opcode-&gt;custom_code()-&gt;c_str();
            unresolved_custom_ops_.push_back(CreateUnresolvedCustomOp(op_name));
            registration = &amp;unresolved_custom_ops_.back();
            has_flex_op_ |= IsFlexOp(op_name);
            status = kTfLiteOk;
        }
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! registration &#25353;&#39034;&#24207;&#35760;&#24405;&#19979;&#26469;</span>
        flatbuffer_op_index_to_registration_.push_back(registration);
    }
    <span style="font-weight: bold;">return</span> status;
}

<span style="font-weight: bold; text-decoration: underline;">GetRegistrationFromOpCode</span>:
    *registration = op_resolver.FindOp(builtin_code, version);
        <span style="font-weight: bold;">return</span> builtins_.find(<span style="font-weight: bold; text-decoration: underline;">std</span>::make_pair(op, version));
    <span style="font-weight: bold;">if</span> (not_found_in_builtins):
        <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">name</span> = opcode-&gt;custom_code()-&gt;c_str();
        *registration = op_resolver.FindOp(name, version);
        <span style="font-weight: bold;">return</span> custom_ops_.find(<span style="font-weight: bold; text-decoration: underline;">std</span>::make_pair(op, version));
</pre>
</div>
</div>
</div>

<div id="outline-container-org2f743b6" class="outline-5">
<h5 id="org2f743b6"><span class="section-number-5">1.1.2.2</span> ParseNode</h5>
<div class="outline-text-5" id="text-1-1-2-2">
<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold; text-decoration: underline;">TfLiteStatus</span> <span style="font-weight: bold; text-decoration: underline;">InterpreterBuilder</span>::<span style="font-weight: bold;">ParseNodes</span>(
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">flatbuffers</span>::<span style="font-weight: bold; text-decoration: underline;">Vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">flatbuffers</span>::<span style="font-weight: bold; text-decoration: underline;">Offset</span>&lt;Operator&gt;&gt;* <span style="font-weight: bold; font-style: italic;">operators</span>,
    <span style="font-weight: bold; text-decoration: underline;">Subgraph</span>* <span style="font-weight: bold; font-style: italic;">subgraph</span>) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Reduce the number of redundant allocations</span>
    subgraph-&gt;ReserveNodes(operators-&gt;size());

    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; operators-&gt;size(); ++i) {
        <span style="font-weight: bold;">const</span> <span style="font-weight: bold;">auto</span>* <span style="font-weight: bold; font-style: italic;">op</span> = operators-&gt;Get(i);
        <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">index</span> = op-&gt;opcode_index();

        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! &#25214;&#21040; registration</span>
        <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">TfLiteRegistration</span>* <span style="font-weight: bold; font-style: italic;">registration</span> =
            flatbuffer_op_index_to_registration_[index];

        <span style="font-weight: bold; text-decoration: underline;">BuiltinOperator</span> <span style="font-weight: bold; font-style: italic;">op_type</span> =
            <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">BuiltinOperator</span>&gt;(registration-&gt;builtin_code);

        <span style="font-weight: bold;">if</span> (op_type == BuiltinOperator_CUSTOM) {
            subgraph-&gt;AddNodeWithParameters(
                FlatBufferIntArrayToVector(op-&gt;inputs()),
                FlatBufferIntArrayToVector(op-&gt;outputs()),
                FlatBufferIntArrayToVector(op-&gt;intermediates()), <span style="font-weight: bold; text-decoration: underline;">nullptr</span>, 0,
                <span style="font-weight: bold; text-decoration: underline;">nullptr</span>, registration);

        } <span style="font-weight: bold;">else</span> {
            <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">builtin_data</span> = <span style="font-weight: bold; text-decoration: underline;">nullptr</span>;
            <span style="font-weight: bold; text-decoration: underline;">MallocDataAllocator</span> <span style="font-weight: bold; font-style: italic;">malloc_allocator</span>;
            TF_LITE_ENSURE_STATUS(ParseOpData(op, op_type, error_reporter_,
                                              &amp;malloc_allocator,
                                              &amp;builtin_data));
            subgraph-&gt;AddNodeWithParameters(
                FlatBufferIntArrayToVector(op-&gt;inputs()),
                FlatBufferIntArrayToVector(op-&gt;outputs()),
                FlatBufferIntArrayToVector(op-&gt;intermediates()), <span style="font-weight: bold; text-decoration: underline;">nullptr</span>, 0,
                builtin_data, registration);
        }
    }

    <span style="font-weight: bold;">return</span> status;
}

<span style="font-weight: bold; text-decoration: underline;">TfLiteStatus</span> <span style="font-weight: bold; text-decoration: underline;">Subgraph</span>::<span style="font-weight: bold;">AddNodeWithParameters</span>(
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt;&amp; <span style="font-weight: bold; font-style: italic;">inputs</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt;&amp; <span style="font-weight: bold; font-style: italic;">outputs</span>,
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt;&amp; <span style="font-weight: bold; font-style: italic;">intermediates</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">init_data</span>,
    <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">init_data_size</span>, <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">builtin_data</span>,
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">TfLiteRegistration</span>* <span style="font-weight: bold; font-style: italic;">registration</span>, <span style="font-weight: bold; text-decoration: underline;">int</span>* <span style="font-weight: bold; font-style: italic;">node_index</span>) {
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">unique_ptr</span>&lt;<span style="font-weight: bold; text-decoration: underline;">void</span>, <span style="font-weight: bold;">decltype</span>(free)*&gt; <span style="font-weight: bold; font-style: italic;">builtin_data_deleter</span>(builtin_data,
                                                                free);

    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">new_node_index</span> = nodes_and_registration_.size();
    <span style="font-weight: bold;">if</span> (node_index) *node_index = new_node_index;
    nodes_and_registration_.resize(nodes_and_registration_.size() + 1);
    <span style="font-weight: bold;">auto</span>&amp; <span style="font-weight: bold; font-style: italic;">node_and_reg</span> = nodes_and_registration_.back();
    <span style="font-weight: bold; text-decoration: underline;">TfLiteNode</span>&amp; <span style="font-weight: bold; font-style: italic;">node</span> = node_and_reg.first;
    <span style="font-weight: bold;">if</span> (node.inputs) TfLiteIntArrayFree(node.inputs);
    <span style="font-weight: bold;">if</span> (node.outputs) TfLiteIntArrayFree(node.outputs);
    <span style="font-weight: bold;">if</span> (node.intermediates) TfLiteIntArrayFree(node.intermediates);
    <span style="font-weight: bold;">if</span> (node.temporaries) TfLiteIntArrayFree(node.temporaries);

    node.inputs = ConvertVectorToTfLiteIntArray(inputs);
    node.outputs = ConvertVectorToTfLiteIntArray(outputs);
    node.intermediates = ConvertVectorToTfLiteIntArray(intermediates);
    node.temporaries = TfLiteIntArrayCreate(0);
    <span style="font-weight: bold;">if</span> (init_data) {
        node.user_data = OpInit(*registration, init_data, init_data_size);
    } <span style="font-weight: bold;">else</span> {
        node.user_data = OpInit(
            *registration, <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>*&gt;(builtin_data_deleter.get()), 0);
    }

    node.builtin_data = builtin_data_deleter.release();

    <span style="font-weight: bold;">if</span> (registration-&gt;builtin_code == BuiltinOperator_CUSTOM) {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">When it's a CUSTOM op, the `custom_options` field in the Flatbuffer</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">`Operator` table is passed in.</span>
        node.custom_initial_data = init_data;
        node.custom_initial_data_size = init_data_size;
    } <span style="font-weight: bold;">else</span> {
        node.custom_initial_data = <span style="font-weight: bold; text-decoration: underline;">nullptr</span>;
        node.custom_initial_data_size = 0;
    }

    node.delegate = <span style="font-weight: bold; text-decoration: underline;">nullptr</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Copying of registration is required to support unresolved custom ops.</span>
    node_and_reg.second = *registration;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! execution_plan_ &#34920;&#31034; subgraph invoke &#26102;&#21508;&#20010; node (operator) &#25191;&#34892;&#30340;&#39034;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24207;, &#23454;&#38469;&#19978; tflite &#27169;&#22411;&#20013;&#30340; operator &#24050;&#32463;&#26159;&#25299;&#25169;&#25490;&#24207;&#30340;&#20102;, &#25152;&#20197;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">execution_plan_ &#22522;&#26412;&#19978;&#21644; operator &#39034;&#24207;&#30456;&#21516;, &#38500;&#38750;&#28041;&#21450;&#21040; delegate</span>
    execution_plan_.push_back(new_node_index);
    <span style="font-weight: bold;">return</span> kTfLiteOk;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orge5fda87" class="outline-4">
<h4 id="orge5fda87"><span class="section-number-4">1.1.3</span> AllocateTensors</h4>
<div class="outline-text-4" id="text-1-1-3">
</div>
<div id="outline-container-org8c2ac4c" class="outline-5">
<h5 id="org8c2ac4c"><span class="section-number-5">1.1.3.1</span> constant allocation</h5>
<div class="outline-text-5" id="text-1-1-3-1">
<p>
constant 直接把 flatbuffer mmap 进来使用
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold; text-decoration: underline;">TfLiteStatus</span> <span style="font-weight: bold; text-decoration: underline;">InterpreterBuilder</span>::<span style="font-weight: bold;">ParseTensors</span>(
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">flatbuffers</span>::<span style="font-weight: bold; text-decoration: underline;">Vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">flatbuffers</span>::<span style="font-weight: bold; text-decoration: underline;">Offset</span>&lt;Buffer&gt;&gt;* <span style="font-weight: bold; font-style: italic;">buffers</span>,
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">flatbuffers</span>::<span style="font-weight: bold; text-decoration: underline;">Vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">flatbuffers</span>::<span style="font-weight: bold; text-decoration: underline;">Offset</span>&lt;Tensor&gt;&gt;* <span style="font-weight: bold; font-style: italic;">tensors</span>,
    <span style="font-weight: bold; text-decoration: underline;">Subgraph</span>* <span style="font-weight: bold; font-style: italic;">subgraph</span>) {

    <span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">get_readonly_data</span> = [&amp;](<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>** <span style="font-weight: bold; font-style: italic;">buffer_data</span>,
                                 <span style="font-weight: bold; text-decoration: underline;">size_t</span>* <span style="font-weight: bold; font-style: italic;">buffer_size</span>) {
        *buffer_data = <span style="font-weight: bold; text-decoration: underline;">nullptr</span>;
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! &#22914;&#26524;&#26159; constant tensor, &#21017; tensor-&gt;buffer() &#25351;&#21521; floatbuffer &#20013;</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">constant tensor &#30340;&#25968;&#25454;, &#36825;&#20010;&#25968;&#25454;&#26159;&#30452;&#25509;&#36890;&#36807; mmap &#26144;&#23556;&#36827;&#26469; (flatbuffer</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#30456;&#27604; protocalbuffer &#30340;&#20248;&#21183;)</span>
        <span style="font-weight: bold;">if</span> (tensor-&gt;buffer() == 0) <span style="font-weight: bold;">return</span> kTfLiteOk;
        <span style="font-weight: bold;">if</span> (<span style="font-weight: bold;">auto</span>* <span style="font-weight: bold; font-style: italic;">buffer</span> = (*buffers)[tensor-&gt;buffer()]) {
            <span style="font-weight: bold;">if</span> (<span style="font-weight: bold;">auto</span>* <span style="font-weight: bold; font-style: italic;">array</span> = buffer-&gt;data()) {
                <span style="font-weight: bold;">if</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">size</span> = array-&gt;size()) {
                    *buffer_size = size;
                    *buffer_data = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>*&gt;(array-&gt;data());
                    <span style="font-weight: bold;">return</span> kTfLiteOk;
                }
            }
        }
        <span style="font-weight: bold;">return</span> kTfLiteOk;
    };

    get_readonly_data(&amp;buffer_ptr, &amp;buffer_size);

    <span style="font-weight: bold;">if</span> (buffer_ptr) {
        subgraph-&gt;SetTensorParametersReadOnly(
            i, type, get_name(tensor), dims, quantization, buffer_ptr,
            buffer_size, allocation_, sparsity);

            tensor.data.raw = <span style="font-weight: bold;">const_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">char</span>*&gt;(buffer);
    } <span style="font-weight: bold;">else</span> {
        subgraph-&gt;SetTensorParametersReadWrite(
            i, type, get_name(tensor), dims, quantization, is_variable,
            dims_signature_rank, dims_signature_data);
            <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! kTfLiteArenaRw &#19982; kTfLiteArenaRwPersistent</span>
            <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26368;&#32456;&#20250;&#20998;&#37197;&#21040;&#19981;&#21516;&#30340; buffer</span>
            <span style="font-weight: bold; text-decoration: underline;">TfLiteAllocationType</span> <span style="font-weight: bold; font-style: italic;">allocation_type</span> = kTfLiteArenaRw;
            <span style="font-weight: bold;">if</span> (is_variable) {
                allocation_type = kTfLiteArenaRwPersistent;
            }
            tensor.data.raw = 0;
            tensor.allocation_type = allocation_type;
            tensor.bytes = required_bytes;
            <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">...</span>
    }
</pre>
</div>
</div>
</div>

<div id="outline-container-org63b4e07" class="outline-5">
<h5 id="org63b4e07"><span class="section-number-5">1.1.3.2</span> tensor allocation</h5>
<div class="outline-text-5" id="text-1-1-3-2">
<p>
tensor, 包括:
</p>

<ol class="org-ol">
<li>variable (可训练的参数) tensor</li>
<li>intermediate tensor</li>
<li>temporary tensor</li>
</ol>

<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold; text-decoration: underline;">TfLiteStatus</span> <span style="font-weight: bold; text-decoration: underline;">Subgraph</span>::<span style="font-weight: bold;">AllocateTensors</span>(){PrepareOpsAndTensors()}

<span style="font-weight: bold;">PrepareOpsAndTensors</span>() {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! preserve_inputs &#40664;&#35748;&#20026; true, &#25152;&#20197;&#22810;&#27425;&#36816;&#34892;&#26102;&#19981;&#38656;&#35201;&#37325;&#22797;&#32473; input tensor</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36171;&#20540;</span>
    <span style="font-weight: bold; font-style: italic;">//</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">preserve_intermediates &#20026; false, &#25152;&#20197;&#26080;&#27861;&#26597;&#35810;&#20013;&#38388;&#32467;&#26524;</span>
    memory_planner_.reset(<span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">ArenaPlanner</span>(
        &amp;context_, <span style="font-weight: bold; text-decoration: underline;">std</span>::unique_ptr&lt;GraphInfo&gt;(<span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">InterpreterInfo</span>(<span style="font-weight: bold;">this</span>)),
        <span style="font-weight: bold; font-style: italic;">/*</span><span style="font-weight: bold; font-style: italic;">preserve_inputs=</span><span style="font-weight: bold; font-style: italic;">*/</span><span style="font-weight: bold; text-decoration: underline;">true</span>, <span style="font-weight: bold; font-style: italic;">/*</span><span style="font-weight: bold; font-style: italic;">preserve_intermediates</span><span style="font-weight: bold; font-style: italic;">*/</span> <span style="font-weight: bold; text-decoration: underline;">false</span>,
        kDefaultTensorAlignment));
    memory_planner_-&gt;PlanAllocations();
    memory_planner_-&gt;ExecuteAllocations(
        next_execution_plan_index_to_plan_allocation_,
        last_exec_plan_index_prepared));
}
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org0b2a1f1"></a>PlanAllocations<br />
<div class="outline-text-6" id="text-1-1-3-2-1">
<ol class="org-ol">
<li>标记只些 tensor 不能被覆盖 (通过 refcount)</li>
<li>记录 tensor 的 start_node 和 finish_node, 即 tensor 的生命期, 生命期不重叠的
tensor 可以共用内存</li>
</ol>

<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold; text-decoration: underline;">TfLiteStatus</span> <span style="font-weight: bold; text-decoration: underline;">ArenaPlanner</span>::<span style="font-weight: bold;">PlanAllocations</span>() {
    alloc_node_.assign(graph_info_-&gt;num_tensors(), kNodeNotAssigned);
    dealloc_node_.assign(graph_info_-&gt;num_tensors(), kNodeNotAssigned);

    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt; <span style="font-weight: bold; font-style: italic;">refcounts</span>(graph_info_-&gt;num_tensors(), 0);

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! alloc_node_ &#21644; dealloc_node_ &#29992;&#26469;&#35760;&#24405; tensor &#30340; start_node &#21644;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">finish_node</span>
    <span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">allocate</span> = [<span style="font-weight: bold;">this</span>](<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">node</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">tensor</span>) -&gt; TfLiteStatus {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! alloc_nodes_ &#38656;&#35201;&#35760;&#24405;`&#31532;&#19968;&#20010;`&#20351;&#29992;&#36825;&#20010; tensor &#30340; node, &#25152;&#20197;&#38656;&#35201;&#36825;</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20010;&#21028;&#26029;</span>
        <span style="font-weight: bold;">if</span> (alloc_node_[tensor] != kNodeNotAssigned) {
            <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! Tensor has already been allocated.</span>
            <span style="font-weight: bold;">return</span> kTfLiteOk;
        }
        alloc_node_[tensor] = node;
    };

    <span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">deallocate</span> = [<span style="font-weight: bold;">this</span>](<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">node</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">tensor</span>) -&gt; TfLiteStatus {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! dealloc_node_ &#38656;&#35201;&#35760;&#24405;`&#26368;&#21518;&#19968;&#20010;`&#20351;&#29992;&#36825;&#20010; tensor &#30340; node, &#25152;&#20197;&#19981;&#38656;</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35201;&#20687; alloc_node_ &#37027;&#26679;&#21028;&#26029;</span>
        dealloc_node_[tensor] = node;
    };
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! -----------------------------</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! We must make sure the output tensors are never overwritten. We do</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">that by artificially adding one to their ref-counts so they are never</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">selected for deallocation.</span>
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">tensor_index</span> : graph_info_-&gt;outputs()) {
        refcounts[tensor_index]++;
    }

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! Variable tensors also should be ensured to be never overwritten and</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">need to be alive all the time.</span>
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">tensor_index</span> : graph_info_-&gt;variables()) {
        refcounts[tensor_index]++;
    }

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! Queue all graph inputs for allocation. If preserve_inputs_ is true,</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">make sure they never be overwritten.</span>
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">tensor_index</span> : graph_info_-&gt;inputs()) {
        <span style="font-weight: bold;">if</span> (preserve_inputs_) {
            refcounts[tensor_index]++;
        }
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">graph inputs &#30340; start_node &#24517;&#28982;&#26159; node[0]</span>
        allocate(0, tensor_index);
    }

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Queue all graph variable tensors for allocation.</span>
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">tensor_index</span> : graph_info_-&gt;variables()) {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Increase the reference count for input tensors by one, so it will</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">never be deallocated.</span>
        allocate(0, tensor_index);
    }

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Queue all graph inputs for allocation.</span>
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">tensor_index</span> : graph_info_-&gt;inputs()) {
        <span style="font-weight: bold;">if</span> (tensor_index != kTfLiteOptionalTensor) {
            allocate(0, tensor_index);
        }
    }
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! -----------------------------</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Count references to node input tensors.</span>
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; graph_info_-&gt;num_nodes(); ++i) {
        <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">TfLiteNode</span>&amp; <span style="font-weight: bold; font-style: italic;">node</span> = graph_info_-&gt;node(i);
        <span style="font-weight: bold; text-decoration: underline;">TfLiteIntArray</span>* <span style="font-weight: bold; font-style: italic;">node_inputs</span> = node.inputs;
        <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">j</span> = 0; j &lt; node_inputs-&gt;size; ++j) {
            <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">tensor_index</span> = node_inputs-&gt;data[j];
            refcounts[tensor_index]++;
        }
    }
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! -----------------------------</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Go through the graph in execution order.</span>
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; graph_info_-&gt;num_nodes(); ++i) {
        <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">TfLiteNode</span>&amp; <span style="font-weight: bold; font-style: italic;">node</span> = graph_info_-&gt;node(i);

        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">First queue output tensors for allocation.</span>
        <span style="font-weight: bold; text-decoration: underline;">TfLiteIntArray</span>* <span style="font-weight: bold; font-style: italic;">node_outputs</span> = node.outputs;
        <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">j</span> = 0; j &lt; node_outputs-&gt;size; ++j) {
            <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">tensor_index</span> = node_outputs-&gt;data[j];
            allocate(i, tensor_index);
        }

        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Then update the ref-counts of the node's inputs, and if necessary</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">queue them for deallocation.</span>
        <span style="font-weight: bold;">if</span> (!preserve_intermediates_) {
            <span style="font-weight: bold; text-decoration: underline;">TfLiteIntArray</span>* <span style="font-weight: bold; font-style: italic;">node_inputs</span> = node.inputs;
            <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">j</span> = 0; j &lt; node_inputs-&gt;size; ++j) {
                <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">tensor_index</span> = node_inputs-&gt;data[j];
                refcounts[tensor_index]--;
                <span style="font-weight: bold;">if</span> (refcounts[tensor_index] == 0) {
                    deallocate(i, tensor_index);
                }
            }
        }
    }
}
</pre>
</div>
</div>
</li>

<li><a id="orgb08d6c4"></a>ExecuteAllocations<br />
<div class="outline-text-6" id="text-1-1-3-2-2">
<ol class="org-ol">
<li><p>
CalculateAllocations
</p>

<p>
根据 [start_node, finish_node] 找到所有有重叠 (冲突) 的 alloc, 然后根据 bestfit
分配一个 alloc
</p></li>

<li><p>
Commit
</p>

<p>
CalculateAllocations 分配 alloc 同时会维护 high_water_mark_ 记录最大需要的内
存, Commit 会 malloc 这一段 underlying_buffer
</p></li>

<li><p>
ResolveTensorAllocation
</p>

<p>
underlying_buffer 做为 base address, 根据各个 alloc 中记录的 offset 更新最终
的 tensor-&gt;data 地址
</p></li>
</ol>

<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold; text-decoration: underline;">TfLiteStatus</span> <span style="font-weight: bold; text-decoration: underline;">ArenaPlanner</span>::<span style="font-weight: bold;">ExecuteAllocations</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">first_node</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">last_node</span>) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Grow the size of `allocs_` if necessary. This allows allocating temporary</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">tensors in op's `prepare` function.</span>
    alloc_node_.resize(graph_info_-&gt;num_tensors(), kNodeNotAssigned);
    dealloc_node_.resize(graph_info_-&gt;num_tensors(), kNodeNotAssigned);
    allocs_.resize(graph_info_-&gt;num_tensors());
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Set allocation and deallocation for temporary tensors.</span>
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = first_node;
         i &lt;= <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">size_t</span>&gt;(last_node) &amp;&amp; i &lt; graph_info_-&gt;num_nodes();
         ++i) {
        <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">TfLiteNode</span>&amp; <span style="font-weight: bold; font-style: italic;">node</span> = graph_info_-&gt;node(i);
        <span style="font-weight: bold; text-decoration: underline;">TfLiteIntArray</span>* <span style="font-weight: bold; font-style: italic;">node_temporaries</span> = node.temporaries;
        <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">j</span> = 0; j &lt; node_temporaries-&gt;size; ++j) {
            <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">tensor_index</span> = node_temporaries-&gt;data[j];
            alloc_node_[tensor_index] = i;
            dealloc_node_[tensor_index] = i;
        }
    }

    CalculateAllocations(first_node, last_node);
    Commit();

    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt;(graph_info_-&gt;num_tensors()); ++i) {
        ResolveTensorAllocation(i);
    }
}
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org6cdf46f"></a>CalculateAllocations<br />
<div class="outline-text-7" id="text-1-1-3-2-2-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold; text-decoration: underline;">TfLiteStatus</span> <span style="font-weight: bold; text-decoration: underline;">ArenaPlanner</span>::<span style="font-weight: bold;">CalculateAllocations</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">first_node</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">last_node</span>) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Indices of tensors in order their allocation offsets will be calculated.</span>
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int32_t</span>&gt; <span style="font-weight: bold; font-style: italic;">tensor_order</span> =
        CreateTensorAllocationVector(first_node, last_node);

    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold;">const</span> <span style="font-weight: bold;">auto</span>&amp; <span style="font-weight: bold; font-style: italic;">tensor_index</span> : tensor_order) {
        <span style="font-weight: bold; text-decoration: underline;">TfLiteTensor</span>&amp; <span style="font-weight: bold; font-style: italic;">tensor</span> = *graph_info_-&gt;tensor(tensor_index);
        <span style="font-weight: bold;">if</span> (tensor.allocation_type == kTfLiteArenaRw) {
            arena_.Allocate(context_, tensor_alignment_, tensor.bytes,
                            tensor_index, alloc_node_[tensor_index],
                            dealloc_node_[tensor_index],
                            &amp;allocs_[tensor_index]);
        }
        <span style="font-weight: bold;">if</span> (tensor.allocation_type == kTfLiteArenaRwPersistent) {
            persistent_arena_.Allocate(
                context_, tensor_alignment_, tensor.bytes, tensor_index,
                <span style="font-weight: bold; font-style: italic;">/*</span><span style="font-weight: bold; font-style: italic;">first_node=</span><span style="font-weight: bold; font-style: italic;">*/</span>alloc_node_[tensor_index],
                <span style="font-weight: bold; font-style: italic;">/*</span><span style="font-weight: bold; font-style: italic;">last_node=</span><span style="font-weight: bold; font-style: italic;">*/</span><span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">numeric_limits</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int32_t</span>&gt;::max(),
                &amp;allocs_[tensor_index]);
        }
    }
}

<span style="font-weight: bold; text-decoration: underline;">TfLiteStatus</span> <span style="font-weight: bold; text-decoration: underline;">SimpleMemoryArena</span>::<span style="font-weight: bold;">Allocate</span>(
    <span style="font-weight: bold; text-decoration: underline;">TfLiteContext</span>* <span style="font-weight: bold; font-style: italic;">context</span>, <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">alignment</span>, <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">size</span>, <span style="font-weight: bold; text-decoration: underline;">int32_t</span> <span style="font-weight: bold; font-style: italic;">tensor</span>,
    <span style="font-weight: bold; text-decoration: underline;">int32_t</span> <span style="font-weight: bold; font-style: italic;">first_node</span>, <span style="font-weight: bold; text-decoration: underline;">int32_t</span> <span style="font-weight: bold; font-style: italic;">last_node</span>,
    <span style="font-weight: bold; text-decoration: underline;">ArenaAllocWithUsageInterval</span>* <span style="font-weight: bold; font-style: italic;">new_alloc</span>) {
    new_alloc-&gt;tensor = tensor;
    new_alloc-&gt;first_node = first_node;
    new_alloc-&gt;last_node = last_node;
    new_alloc-&gt;size = size;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If we don't find a better gap just allocate at the end of the buffer.</span>
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">kOffsetNotAssigned</span> = <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">numeric_limits</span>&lt;<span style="font-weight: bold; text-decoration: underline;">size_t</span>&gt;::max();
    <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">best_offset</span> = kOffsetNotAssigned;
    <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">best_offset_fit</span> = kOffsetNotAssigned;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Go through the sorted allocs and look at the gaps between them.</span>
    <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">current_offset</span> = 0;
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold;">const</span> <span style="font-weight: bold;">auto</span>&amp; <span style="font-weight: bold; font-style: italic;">alloc</span> : ordered_allocs_) {
        <span style="font-weight: bold;">if</span> (alloc.<span style="font-weight: bold; text-decoration: underline;">last_node</span> &lt; first_node || alloc.first_node &gt; last_node) {
            <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! &#27809;&#26377;&#37325;&#21472;&#30340; alloc &#30456;&#24403;&#20110;&#31354;&#38386;&#30340; buffer</span>
            <span style="font-weight: bold;">continue</span>;
        }
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If we found a gap larger than required size, and smaller than previous</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">best fit, take it.</span>
        <span style="font-weight: bold;">if</span> (current_offset + size &lt;= alloc.offset &amp;&amp;
            alloc.offset - current_offset &lt; best_offset_fit) {
            best_offset = current_offset;
            best_offset_fit = alloc.offset - current_offset;
        }
        current_offset = <span style="font-weight: bold; text-decoration: underline;">std</span>::max(current_offset, alloc.offset + alloc.size);
    }
    <span style="font-weight: bold;">if</span> (best_offset == kOffsetNotAssigned) {
        best_offset = current_offset;
    }

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Update the required buffer size.</span>
    high_water_mark_ = <span style="font-weight: bold; text-decoration: underline;">std</span>::max(high_water_mark_, best_offset + size);
    new_alloc-&gt;offset = best_offset;

    <span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">insertion_it</span> = ordered_allocs_.begin();
    <span style="font-weight: bold;">while</span> (insertion_it != ordered_allocs_.end() &amp;&amp; *insertion_it &lt; *new_alloc) {
        ++insertion_it;
    }
    ordered_allocs_.insert(insertion_it, *new_alloc);
}
</pre>
</div>
</div>
</li>

<li><a id="org50dc0aa"></a>Commit<br />
<div class="outline-text-7" id="text-1-1-3-2-2-2">
<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold; text-decoration: underline;">TfLiteStatus</span> <span style="font-weight: bold; text-decoration: underline;">SimpleMemoryArena</span>::<span style="font-weight: bold;">Commit</span>(<span style="font-weight: bold; text-decoration: underline;">TfLiteContext</span>* <span style="font-weight: bold; font-style: italic;">context</span>) {
    <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">required_size</span> = RequiredBufferSize();

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! malloc</span>
    <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">new_alloc</span> = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">char</span>[required_size];
    <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">new_underlying_buffer_aligned_ptr</span> = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">char</span>*&gt;(
        AlignTo(arena_alignment_, <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">intptr_t</span>&gt;(new_alloc)));

    underlying_buffer_.reset(new_alloc);
    underlying_buffer_size_ = required_size;
    underlying_buffer_aligned_ptr_ = new_underlying_buffer_aligned_ptr;
}
</pre>
</div>
</div>
</li>

<li><a id="org3ff72e5"></a>ResolveTensorAllocation<br />
<div class="outline-text-7" id="text-1-1-3-2-2-3">
<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold; text-decoration: underline;">TfLiteStatus</span> <span style="font-weight: bold; text-decoration: underline;">ArenaPlanner</span>::<span style="font-weight: bold;">ResolveTensorAllocation</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">tensor_index</span>) {
    <span style="font-weight: bold; text-decoration: underline;">TfLiteTensor</span>&amp; <span style="font-weight: bold; font-style: italic;">tensor</span> = *graph_info_-&gt;tensor(tensor_index);
    <span style="font-weight: bold;">if</span> (tensor.allocation_type == kTfLiteArenaRw) {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Skip resolution if the size of the tensor is zero, leaving it as a</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">nullptr.</span>
        arena_.ResolveAlloc(context_, allocs_[tensor_index], &amp;tensor.data.raw);
    }
    <span style="font-weight: bold;">if</span> (tensor.allocation_type == kTfLiteArenaRwPersistent) {
        persistent_arena_.ResolveAlloc(context_, allocs_[tensor_index],
                                       &amp;tensor.data.raw);
    }
}

<span style="font-weight: bold; text-decoration: underline;">TfLiteStatus</span> <span style="font-weight: bold; text-decoration: underline;">SimpleMemoryArena</span>::<span style="font-weight: bold;">ResolveAlloc</span>(
    <span style="font-weight: bold; text-decoration: underline;">TfLiteContext</span>* <span style="font-weight: bold; font-style: italic;">context</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">ArenaAllocWithUsageInterval</span>&amp; <span style="font-weight: bold; font-style: italic;">alloc</span>,
    <span style="font-weight: bold; text-decoration: underline;">char</span>** <span style="font-weight: bold; font-style: italic;">output_ptr</span>) {
    <span style="font-weight: bold;">if</span> (alloc.size == 0) {
        *output_ptr = <span style="font-weight: bold; text-decoration: underline;">nullptr</span>;
    } <span style="font-weight: bold;">else</span> {
        *output_ptr = underlying_buffer_aligned_ptr_ + alloc.offset;
    }
}
</pre>
</div>
</div>
</li>
</ol>
</li>
</ol>
</div>
</div>

<div id="outline-container-org81e642c" class="outline-4">
<h4 id="org81e642c"><span class="section-number-4">1.1.4</span> Interpreter.Invoke</h4>
<div class="outline-text-4" id="text-1-1-4">
<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold; text-decoration: underline;">Interpreter</span>::Invoke:
    primary_subgraph().Invoke()
        <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">execution_plan_index</span> = 0; execution_plan_index &lt; execution_plan_.size(); execution_plan_index++):
            <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">node_index</span> = execution_plan_[execution_plan_index];
            <span style="font-weight: bold; text-decoration: underline;">TfLiteNode</span>&amp; <span style="font-weight: bold; font-style: italic;">node</span> = nodes_and_registration_[node_index].first;
            <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">TfLiteRegistration</span>&amp; <span style="font-weight: bold; font-style: italic;">registration</span> = nodes_and_registration_[node_index].second;
            OpInvoke(registration, &amp;node)
                <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! &#35843;&#29992;&#21040; resolver &#20013;&#27880;&#20876;&#30340; registration &#20013;&#30340; .invoke, &#20363;&#22914; AbsEval</span>
                registration.invoke(node)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org46cecd5" class="outline-3">
<h3 id="org46cecd5"><span class="section-number-3">1.2</span> TFLite Delegate</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-orgbd79bdc" class="outline-4">
<h4 id="orgbd79bdc"><span class="section-number-4">1.2.1</span> A Simple Model</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
\(f(x)=sin(x)+x+sin(x*2)\)
</p>

<div class="org-src-container">
<pre class="src src-ipython">import tensorflow as tf
from tensorflow.keras import layers, Model

input=layers.Input(shape=(1, ))
output=layers.Lambda(lambda x: tf.sin(x)+x+tf.sin(x*2))(input)
model=Model(inputs=input,outputs=output)
model.summary()
print(model.predict([2.]))
model.save("/tmp/sin")
</pre>
</div>

<p>
Model: "model"
<span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline">_</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
Layer (type)                 Output Shape              Param #   
<code>===============================================================</code>
input_1 (InputLayer)         [(None, 1)]               0         
<span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline">_</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
lambda (Lambda)              (None, 1)                 0         
<code>===============================================================</code>
Total params: 0
Trainable params: 0
Non-trainable params: 0
<span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline"><span class="underline">_</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
2.152495
</p>

<div class="org-src-container">
<pre class="src src-ipython">import tensorflow as tf

converter = tf.lite.TFLiteConverter.from_saved_model("/tmp/sin")
tflite = converter.convert()
with open ("/tmp/sin.tflite","wb") as f:
    f.write(tflite)
    print("size of sin.tflite:", len(tflite))
</pre>
</div>

<p>
size of sin.tflite: 1240
</p>
</div>
</div>

<div id="outline-container-org4252725" class="outline-4">
<h4 id="org4252725"><span class="section-number-4">1.2.2</span> MyDelegate</h4>
<div class="outline-text-4" id="text-1-2-2">
<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;cstdio&gt;</span>

<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">"tensorflow/lite/builtin_ops.h"</span>
<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">"tensorflow/lite/interpreter.h"</span>
<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">"tensorflow/lite/kernels/kernel_util.h"</span>
<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">"tensorflow/lite/kernels/register.h"</span>
<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">"tensorflow/lite/model.h"</span>
<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">"tensorflow/lite/optional_debug_tools.h"</span>
<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">"tensorflow/lite/util.h"</span>

<span style="font-weight: bold;">using</span> <span style="font-weight: bold;">namespace</span> <span style="font-weight: bold; text-decoration: underline;">tflite</span>;

<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">MyDelegate</span> {
  <span style="font-weight: bold;">public</span>:
    <span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">SupportedOp</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">TfLiteRegistration</span>* <span style="font-weight: bold; font-style: italic;">registration</span>) {
        <span style="font-weight: bold;">return</span> registration-&gt;builtin_code == kTfLiteBuiltinSin;
    }

    <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">Invoke</span>(<span style="font-weight: bold; text-decoration: underline;">TfLiteContext</span>* <span style="font-weight: bold; font-style: italic;">context</span>, <span style="font-weight: bold; text-decoration: underline;">TfLiteNode</span>* <span style="font-weight: bold; font-style: italic;">node</span>) {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! &#36825;&#37324; invoke &#30340;&#23454;&#29616;&#26159;&#26377;&#38382;&#39064;&#30340;, &#23427;&#20551;&#35774;&#20102; subset &#37324;&#21482;&#26377;&#19968;&#20010; sin, &#23454;</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#38469;&#19978;&#22810;&#20010;&#36830;&#32493;&#30340; sin &#20363;&#22914; tf.sin(tf.sin(x)) &#20250;&#29983;&#25104;&#22810;&#20010; sin node, &#32780;&#23545;&#19968;</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20010; subset &#21482;&#20250;&#29983;&#25104;&#19968;&#20010; delegate node...</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27491;&#30830;&#30340;&#20570;&#27861;&#26159;&#20174; TfLiteDelegateParams &#20013;&#33719;&#24471;&#25152;&#26377;&#30340; node &#20449;&#24687;&#20294;&#20381;&#27425;&#25191;&#34892;,</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20363;&#22914; flex::Eval &#30340;&#20570;&#27861;:</span>
        <span style="font-weight: bold; font-style: italic;">//</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">TfLiteStatus DelegateKernel::Eval(TfLiteContext* context, TfLiteNode* node) {</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">// Execute the TensorFlow Ops sequentially.</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">for (auto&amp; node_data : op_data_-&gt;nodes) {</span>
        <span style="font-weight: bold; font-style: italic;">//   </span><span style="font-weight: bold; font-style: italic;">auto status = ExecuteFlexOp(context, buffer_map, node_data.get());</span>
        <span style="font-weight: bold; font-style: italic;">//   </span><span style="font-weight: bold; font-style: italic;">TF_LITE_ENSURE_OK(context, ConvertStatus(context, status));</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">}</span>
        <span style="font-weight: bold; font-style: italic;">//</span>

        printf(<span style="font-style: italic;">"sunway : invoke\n"</span>);
        <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">TfLiteTensor</span>* <span style="font-weight: bold; font-style: italic;">input</span> = GetInput(context, node, 0);
        <span style="font-weight: bold; text-decoration: underline;">TfLiteTensor</span>* <span style="font-weight: bold; font-style: italic;">output</span> = GetOutput(context, node, 0);

        <span style="font-weight: bold; text-decoration: underline;">float</span>* <span style="font-weight: bold; font-style: italic;">input_data</span> = input-&gt;data.f;
        <span style="font-weight: bold; text-decoration: underline;">float</span>* <span style="font-weight: bold; font-style: italic;">output_data</span> = output-&gt;data.f;

        <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">M</span> = input-&gt;dims-&gt;size;
        <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">N</span> = input-&gt;dims-&gt;data[0];
        <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; M; i++) {
            <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">j</span> = 0; j &lt; N; ++j) {
                output_data[i * N + j] = sin(<span style="font-weight: bold; text-decoration: underline;">input_data</span>[i * N + j]);
            }
        }

        <span style="font-weight: bold;">return</span> kTfLiteOk;
    }
};

<span style="font-weight: bold; text-decoration: underline;">TfLiteRegistration</span> <span style="font-weight: bold;">GetMyDelegateNodeRegistration</span>() {
    <span style="font-weight: bold; text-decoration: underline;">TfLiteRegistration</span> <span style="font-weight: bold; font-style: italic;">kernel_registration</span>;
    kernel_registration.builtin_code = kTfLiteBuiltinDelegate;
    kernel_registration.custom_name = <span style="font-style: italic;">"MyDelegate"</span>;
    kernel_registration.free = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
    kernel_registration.init = [](<span style="font-weight: bold; text-decoration: underline;">TfLiteContext</span>* <span style="font-weight: bold; font-style: italic;">context</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">buffer</span>,
                                  <span style="font-weight: bold; text-decoration: underline;">size_t</span>) -&gt; <span style="font-weight: bold; text-decoration: underline;">void</span>* {
        <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">TfLiteDelegateParams</span>* <span style="font-weight: bold; font-style: italic;">delegate_params</span> =
                <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">TfLiteDelegateParams</span>*&gt;(buffer);
        <span style="font-weight: bold; text-decoration: underline;">MyDelegate</span>* <span style="font-weight: bold; font-style: italic;">my_delegate</span> = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">MyDelegate</span>;
        <span style="font-weight: bold;">return</span> my_delegate;
    };
    kernel_registration.invoke = [](<span style="font-weight: bold; text-decoration: underline;">TfLiteContext</span>* <span style="font-weight: bold; font-style: italic;">context</span>,
                                    <span style="font-weight: bold; text-decoration: underline;">TfLiteNode</span>* <span style="font-weight: bold; font-style: italic;">node</span>) -&gt; TfLiteStatus {
        printf(<span style="font-style: italic;">"kerenl_invoke\n"</span>);
        <span style="font-weight: bold; text-decoration: underline;">MyDelegate</span>* <span style="font-weight: bold; font-style: italic;">kernel</span> = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">MyDelegate</span>*&gt;(node-&gt;user_data);
        kernel-&gt;Invoke(context, node);
        <span style="font-weight: bold;">return</span> kTfLiteOk;
    };
    kernel_registration.prepare = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;

    <span style="font-weight: bold;">return</span> kernel_registration;
}

<span style="font-weight: bold; text-decoration: underline;">TfLiteStatus</span> <span style="font-weight: bold;">MyDelegatePrepare</span>(<span style="font-weight: bold; text-decoration: underline;">TfLiteContext</span>* <span style="font-weight: bold; font-style: italic;">context</span>,
                               <span style="font-weight: bold; text-decoration: underline;">TfLiteDelegate</span>* <span style="font-weight: bold; font-style: italic;">delegate</span>) {
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt; <span style="font-weight: bold; font-style: italic;">supported_nodes</span>;
    <span style="font-weight: bold; text-decoration: underline;">TfLiteIntArray</span>* <span style="font-weight: bold; font-style: italic;">plan</span>;
    TF_LITE_ENSURE_STATUS(context-&gt;GetExecutionPlan(context, &amp;plan));
    <span style="font-weight: bold; text-decoration: underline;">TfLiteNode</span>* <span style="font-weight: bold; font-style: italic;">node</span>;
    <span style="font-weight: bold; text-decoration: underline;">TfLiteRegistration</span>* <span style="font-weight: bold; font-style: italic;">registration</span>;
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; plan-&gt;size; i++) {
        <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">node_index</span> = plan-&gt;data[i];
        TF_LITE_ENSURE_STATUS(context-&gt;GetNodeAndRegistration(
            context, node_index, &amp;node, &amp;registration));
        <span style="font-weight: bold;">if</span> (<span style="font-weight: bold; text-decoration: underline;">MyDelegate</span>::SupportedOp(registration)) {
            supported_nodes.push_back(node_index);
        }
    }
    <span style="font-weight: bold; text-decoration: underline;">TfLiteRegistration</span> <span style="font-weight: bold; font-style: italic;">my_delegate_kernel_registration</span> =
            GetMyDelegateNodeRegistration();

    <span style="font-weight: bold; text-decoration: underline;">TfLiteIntArray</span>* <span style="font-weight: bold; font-style: italic;">supported_nodes_int_array</span> =
            ::<span style="font-weight: bold; text-decoration: underline;">tflite</span>::ConvertVectorToTfLiteIntArray(supported_nodes);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! replace node with new delegate registration</span>
    <span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">status</span> = context-&gt;ReplaceNodeSubsetsWithDelegateKernels(
        context, my_delegate_kernel_registration, supported_nodes_int_array,
        delegate);
    TfLiteIntArrayFree(supported_nodes_int_array);
    <span style="font-weight: bold;">return</span> status;
}

<span style="font-weight: bold; text-decoration: underline;">TfLiteDelegate</span>* <span style="font-weight: bold;">CreateMyDelegate</span>() {
    <span style="font-weight: bold; text-decoration: underline;">TfLiteDelegate</span>* <span style="font-weight: bold; font-style: italic;">delegate</span> = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">TfLiteDelegate</span>;

    delegate-&gt;data_ = <span style="font-weight: bold; text-decoration: underline;">nullptr</span>;
    delegate-&gt;flags = kTfLiteDelegateFlagsNone;
    delegate-&gt;Prepare = &amp;MyDelegatePrepare;
    delegate-&gt;CopyFromBufferHandle = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
    delegate-&gt;CopyToBufferHandle = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
    delegate-&gt;FreeBufferHandle = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;

    <span style="font-weight: bold;">return</span> delegate;
}

<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">main</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">argc</span>, <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">argv</span>[]) {
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">filename</span> = <span style="font-style: italic;">"/tmp/sin.tflite"</span>;

    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">unique_ptr</span>&lt;<span style="font-weight: bold; text-decoration: underline;">tflite</span>::FlatBufferModel&gt; <span style="font-weight: bold; font-style: italic;">model</span> =
            <span style="font-weight: bold; text-decoration: underline;">tflite</span>::<span style="font-weight: bold; text-decoration: underline;">FlatBufferModel</span>::BuildFromFile(filename);

    <span style="font-weight: bold; text-decoration: underline;">tflite</span>::<span style="font-weight: bold; text-decoration: underline;">ops</span>::<span style="font-weight: bold; text-decoration: underline;">builtin</span>::<span style="font-weight: bold; text-decoration: underline;">BuiltinOpResolver</span> <span style="font-weight: bold; font-style: italic;">resolver</span>;
    <span style="font-weight: bold; text-decoration: underline;">InterpreterBuilder</span> <span style="font-weight: bold; font-style: italic;">builder</span>(*model, resolver);
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">unique_ptr</span>&lt;Interpreter&gt; <span style="font-weight: bold; font-style: italic;">interpreter</span>;
    builder(&amp;interpreter);

    <span style="font-weight: bold;">auto</span>* <span style="font-weight: bold; font-style: italic;">my_delegate</span> = CreateMyDelegate();
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! ModifyGraphWithDelegate</span>
    <span style="font-weight: bold;">if</span> (interpreter-&gt;ModifyGraphWithDelegate(my_delegate) != kTfLiteOk) {
        printf(<span style="font-style: italic;">"sunway:ModifyGraphWithDelegate failed\n"</span>);
    }

    interpreter-&gt;AllocateTensors();
    <span style="font-weight: bold; text-decoration: underline;">float</span>* <span style="font-weight: bold; font-style: italic;">input</span> = interpreter-&gt;typed_input_tensor&lt;<span style="font-weight: bold; text-decoration: underline;">float</span>&gt;(0);
    input[0] = 2.0;
    interpreter-&gt;Invoke();
    <span style="font-weight: bold; text-decoration: underline;">float</span>* <span style="font-weight: bold; font-style: italic;">output</span> = interpreter-&gt;typed_output_tensor&lt;<span style="font-weight: bold; text-decoration: underline;">float</span>&gt;(0);
    printf(<span style="font-style: italic;">"%f\n"</span>, output[0]);

    <span style="font-weight: bold;">return</span> 0;
}

</pre>
</div>
</div>
</div>

<div id="outline-container-org3f0c6f9" class="outline-4">
<h4 id="org3f0c6f9"><span class="section-number-4">1.2.3</span> ModifyGraphWithDelegate</h4>
<div class="outline-text-4" id="text-1-2-3">
<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold; text-decoration: underline;">TfLiteStatus</span> <span style="font-weight: bold; text-decoration: underline;">Subgraph</span>::<span style="font-weight: bold;">ModifyGraphWithDelegate</span>(<span style="font-weight: bold; text-decoration: underline;">TfLiteDelegate</span>* <span style="font-weight: bold; font-style: italic;">delegate</span>):
    <span style="font-weight: bold; text-decoration: underline;">TfLiteStatus</span> <span style="font-weight: bold; font-style: italic;">status</span> = delegate-&gt;Prepare(&amp;context_, delegate);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! Prepare &#22914;&#21069;&#38754;&#30340; MyDelegatePrepare, &#36127;&#36131;&#25195;&#25551;&#25152;&#26377; node, &#25214;&#21040;&#33021;&#22788;&#29702;&#30340;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">node, &#28982;&#21518;&#35843;&#29992; ReplaceNodeSubsetsWithDelegateKernels &#26469;&#26367;&#25442; node &#21644;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">execution plan</span>

</pre>
</div>
</div>
</div>

<div id="outline-container-org12938b0" class="outline-4">
<h4 id="org12938b0"><span class="section-number-4">1.2.4</span> ReplaceNodeSubsetsWithDelegateKernels</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
ReplaceNodeSubsetsWithDelegateKernels 的作用是把所有 node 拆成不同的
node_subset, 例如前面的 \(f(x)=sin(x)+x+sin(x*2)\), 其结构为:
</p>

<div class="org-src-container">
<pre class="src src-dot">digraph G {
    SIN1 [color=red]
    SIN2 [color=red]
    MULTIPLY [color=green]
    ADD1 [color=green]
    ADD2 [color=green]
    X-&gt;SIN1-&gt;ADD1-&gt;ADD2
    X-&gt;ADD1
    X-&gt;MULTIPLY
    2-&gt;MULTIPLY-&gt;SIN2-&gt;ADD2-&gt;Y
}
</pre>
</div>


<div id="org8d1de91" class="figure">
<p><img src="../extra/tflite_delegate.png" alt="tflite_delegate.png" />
</p>
</div>

<p>
一个五个 node 划分为四个按顺排列的 subset:
</p>

<ol class="org-ol">
<li>SIN1</li>
<li>ADD1, MULTIPLY</li>
<li>SIN2</li>
<li>ADD2</li>
</ol>

<p>
划分的原则是:
</p>

<ol class="org-ol">
<li>属于不同 delegate 的 node 需要分开</li>
<li>在满足 input, output 依赖的前提下, 属于同一个 delegate 的 node 划分在一起, 如
上面的 (ADD1, MULTIPLY)</li>
<li>各个 subset 要按 topo 排序, 因为 ReplaceNodeSubsetsWithDelegateKernels 时会线
性的遍历 subset 构造了一个线性的 execution_plan</li>
</ol>

<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold; text-decoration: underline;">TfLiteStatus</span> <span style="font-weight: bold; text-decoration: underline;">Subgraph</span>::<span style="font-weight: bold;">ReplaceNodeSubsetsWithDelegateKernels</span>(
    <span style="font-weight: bold; text-decoration: underline;">TfLiteRegistration</span> <span style="font-weight: bold; font-style: italic;">registration</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">TfLiteIntArray</span>* <span style="font-weight: bold; font-style: italic;">nodes_to_replace</span>,
    <span style="font-weight: bold; text-decoration: underline;">TfLiteDelegate</span>* <span style="font-weight: bold; font-style: italic;">delegate</span>) {
    registration.builtin_code = BuiltinOperator_DELEGATE;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Analyze the graph to find all independent node_subsets that are either</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">fully not\-this\-delegate or this\-delegate computation.</span>
    <span style="font-weight: bold; text-decoration: underline;">InterpreterInfo</span> <span style="font-weight: bold; font-style: italic;">info</span>(<span style="font-weight: bold;">this</span>);
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;NodeSubset&gt; <span style="font-weight: bold; font-style: italic;">node_subsets</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! &#20998;&#20026;&#22810;&#20010; subset</span>
    PartitionGraphIntoIndependentNodeSubsets(&amp;info, nodes_to_replace,
                                             &amp;node_subsets);

    execution_plan_.clear();

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! &#25353;&#39034;&#24207;&#36941;&#21382; subset, &#22240;&#20026;&#21508;&#20010; subset &#20043;&#38388;&#24050;&#32463;&#26159; topo &#26377;&#24207;&#30340;</span>
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold;">auto</span>&amp; <span style="font-weight: bold; font-style: italic;">node_subset</span> : node_subsets) {
        <span style="font-weight: bold;">switch</span> (node_subset.type) {
            <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! node &#19981;&#23646;&#20110; delegate, &#19981;&#38656;&#35201;&#26367;&#25442;, &#30452;&#25509;&#36861;&#21152;&#21040; execution_plan_</span>
            <span style="font-weight: bold;">case</span> <span style="font-weight: bold; text-decoration: underline;">NodeSubset</span>::kTfNonPartition:
                <span style="font-weight: bold;">for</span> (<span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">it</span> = node_subset.nodes.begin(); it != node_subset.nodes.end();
                     ++it) {
                    execution_plan_.push_back(*it);
                }
                <span style="font-weight: bold;">break</span>;
            <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! &#23545;&#20110; delegate, &#38656;&#35201;&#29983;&#25104;&#19968;&#20010;&#26032;&#30340; node &#20195;&#26367;subset &#20013;&#30340; node(&#21487;</span>
            <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#33021;&#20026;&#22810;&#20010; node, delegate &#30340; TfLiteDelegateParams &#33021;&#25343;&#21040;&#21738;&#20123; node</span>
            <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#34987;&#26367;&#25442;), &#28982;&#21518;&#36861;&#21152;&#21040; execution\_plan\_, &#26032;&#30340; node &#20250;&#20351;&#29992;delegate &#30340;</span>
            <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">registration</span>
            <span style="font-weight: bold;">case</span> <span style="font-weight: bold; text-decoration: underline;">NodeSubset</span>::kTfPartition: {
                <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">node_index</span>;

                <span style="font-weight: bold; text-decoration: underline;">TfLiteDelegateParams</span>* <span style="font-weight: bold; font-style: italic;">params</span> =
                        CreateDelegateParams(delegate, node_subset);
                AddNodeWithParameters(
                    node_subset.input_tensors, node_subset.output_tensors, {}, <span style="font-weight: bold; text-decoration: underline;">nullptr</span>,
                    0, params, &amp;registration, &amp;node_index)

                <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Initialize the output tensors's delegate-related fields.</span>
                <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">tensor_index</span> : node_subset.output_tensors) {
                    <span style="font-weight: bold; text-decoration: underline;">TfLiteTensor</span>* <span style="font-weight: bold; font-style: italic;">tensor</span> = &amp;tensors_[tensor_index];
                    TF_LITE_ENSURE(&amp;context_, tensor-&gt;delegate == <span style="font-weight: bold; text-decoration: underline;">nullptr</span> ||
                                   tensor-&gt;delegate == delegate);
                    tensor-&gt;delegate = delegate;
                }

                <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Associate the node with the delegate.</span>
                <span style="font-weight: bold; text-decoration: underline;">TfLiteNode</span>* <span style="font-weight: bold; font-style: italic;">node</span> = &amp;nodes_and_registration_[node_index].first;
                node-&gt;delegate = delegate;
            } <span style="font-weight: bold;">break</span>;
        }
    }
}

</pre>
</div>
</div>
</div>

<div id="outline-container-orgee156ac" class="outline-4">
<h4 id="orgee156ac"><span class="section-number-4">1.2.5</span> WAIT PartitionGraphIntoIndependentNodeSubsets</h4>
<div class="outline-text-4" id="text-1-2-5">
<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold;">while</span> (changed):
    subset = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">array</span>()
    changed = <span style="font-weight: bold; text-decoration: underline;">false</span>
    is_delegate = nil

    <span style="font-weight: bold;">for</span> node in nodes:
        skip <span style="font-weight: bold;">if</span> node.input is <span style="font-weight: bold;">not</span> ready
        skip <span style="font-weight: bold;">if</span> node.visited
        <span style="font-weight: bold;">if</span> is_delegate is nil:
            is_delegate = node.is_delegate
        skip <span style="font-weight: bold;">if</span> node.is_delegate != is_delegate
        subset.push(node)
        node.visited = <span style="font-weight: bold; text-decoration: underline;">true</span>
        node.output.ready = <span style="font-weight: bold; text-decoration: underline;">true</span>
    <span style="font-weight: bold;">if</span> subset is <span style="font-weight: bold;">not</span> empty:
        subsets.push(subset)
        changed = <span style="font-weight: bold; text-decoration: underline;">true</span>

</pre>
</div>
</div>
</div>

<div id="outline-container-orgd59b8cb" class="outline-4">
<h4 id="orgd59b8cb"><span class="section-number-4">1.2.6</span> Delegate 与 Custom Op 的区别</h4>
<div class="outline-text-4" id="text-1-2-6">
<p>
Delegate 实际上利用了 Custom Op 的机制, 例如 Delegate Op 也是一种特殊的 Custom
Op, 它们都会给 node 注册了一个 registration, 使得执行该 node 时会执行到自定义的
Invoke
</p>

<p>
但 delegate 比 Custom Op 多了一个 partition 的操作, 即它会尽量的把 delegate op
放在同一个 node 里, 例如:
</p>

<pre class="example" id="orgdb31d7c">
X-&gt;A1-&gt;A2-&gt;D1-&gt;D2-&gt;D3-Y
</pre>

<p>
假设用 Custom Op 实现 D1, D2, D3 (用 CD1 表示 D1 使用 AddCustom 指定的
registration), 则变为:
</p>

<pre class="example" id="orgee45f5c">
X-&gt;A1-&gt;A2-&gt;CD1-&gt;CD2-&gt;CD3-Y
</pre>

<p>
用 delegate 实现 D1, D2, D3 则变为:
</p>

<pre class="example" id="orgd3e850e">
X-&gt;A1-&gt;A2-&gt;CD-&gt;Y
</pre>

<p>
其中 CD 对应 delegate 对 D1, D2, D3 的实现, 这样做的好处是:
</p>

<blockquote>
<p>
D1, D2 的输出变成了 delegate 设备内部的中间结果, 不必传递给主设备 (CPU)
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orgb6a4b5d" class="outline-4">
<h4 id="orgb6a4b5d"><span class="section-number-4">1.2.7</span> Flex Delegate</h4>
<div class="outline-text-4" id="text-1-2-7">
<p>
<a href="https://www.tensorflow.org/lite/guide/ops_select">https://www.tensorflow.org/lite/guide/ops_select</a>
</p>
</div>

<div id="outline-container-org6e3fbc8" class="outline-5">
<h5 id="org6e3fbc8"><span class="section-number-5">1.2.7.1</span> Tflite Converter</h5>
<div class="outline-text-5" id="text-1-2-7-1">
</div>
<ol class="org-ol">
<li><a id="org383a024"></a>target ops<br />
<div class="outline-text-6" id="text-1-2-7-1-1">
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">converter.target_spec.supported_ops</span> = [tf.lite.OpsSet.TFLITE_BUILTINS,
                                       tf.lite.OpsSet.SELECT_TF_OPS]

</pre>
</div>

<p>
通过设置 converter 的 supported_ops, 可以影响生成 tflite 的过程
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">if</span> target_ops:
    <span style="font-weight: bold;">if</span> <span style="font-weight: bold;">set</span>(target_ops) == <span style="font-weight: bold;">set</span>([OpsSet.TFLITE_BUILTINS, OpsSet.SELECT_TF_OPS]):
      <span style="font-weight: bold; font-style: italic;">toco.enable_select_tf_ops</span> = <span style="font-weight: bold; text-decoration: underline;">True</span>
    <span style="font-weight: bold;">elif</span> <span style="font-weight: bold;">set</span>(target_ops) == <span style="font-weight: bold;">set</span>([OpsSet.SELECT_TF_OPS]):
      <span style="font-weight: bold; font-style: italic;">toco.enable_select_tf_ops</span> = <span style="font-weight: bold; text-decoration: underline;">True</span>
      <span style="font-weight: bold; font-style: italic;">toco.force_select_tf_ops</span> = <span style="font-weight: bold; text-decoration: underline;">True</span>
</pre>
</div>

<p>
通过 supported_ops, 可以控制是否 enable_select_tf_ops 或 force_select_tf_ops:
</p>

<ol class="org-ol">
<li>若 force_select_tf_ops, 即 toco (Tensorflow Optimized COnverter) 会把所有 op
都转换为 tf_op (即 flex delegate op)</li>
<li>若 enable_select_tf_ops (而非 force_select_tf_ops), 则 builtin_op 之外的
op 会转换为 tf_op</li>
</ol>
</div>
</li>

<li><a id="org76766e6"></a>export<br />
<div class="outline-text-6" id="text-1-2-7-1-2">
<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! &#24403;&#21069; flex op &#26377;&#19968;&#20010; allowlist, &#34920;&#31034;&#21738;&#20123; tf op &#21487;&#20197;&#25903;&#25345;</span>
<span style="font-weight: bold;">if</span> (enabled_op_types_.contains(<span style="font-weight: bold; text-decoration: underline;">OpType</span>::kSelectTf) &amp;&amp;
    IsAllowlistedFlexOp(node_def-&gt;op())) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! kFlexOpNamePrefix = "Flex"</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">flex op &#20363;&#22914; Abs &#20250;&#34987;&#20462;&#25913;&#20026;&#21517;&#20026; FlexAbs &#30340; custom_op</span>
    op_name = <span style="font-weight: bold; text-decoration: underline;">std</span>::string(kFlexOpNamePrefix) + node_def-&gt;op();
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! node_def-&gt;op() (&#21363; op name, &#20363;&#22914; Abs) &#22312; CreateFlexOpCustomOptions &#26102;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20250;&#20889;&#22312; custom options, flex delegate &#20250;&#20174; custom options &#20013;&#35835;&#21040; op name,</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20877;&#21435;&#25191;&#34892;, &#32780;&#19981;&#26159;&#30452;&#25509;&#29992; custom name &#21435;&#25481; "Flex" &#21069;&#32512;</span>
    <span style="font-weight: bold;">if</span> (<span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">options</span> = CreateFlexOpCustomOptions(*node_def, inst-&gt;getLoc())) {

        custom_options = *options;
    } <span style="font-weight: bold;">else</span> {
        <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">llvm</span>::None;
    }
</pre>
</div>
</div>
</li>
</ol>
</div>


<div id="outline-container-org0062572" class="outline-5">
<h5 id="org0062572"><span class="section-number-5">1.2.7.2</span> Flex Delegate Impl</h5>
<div class="outline-text-5" id="text-1-2-7-2">
</div>
<ol class="org-ol">
<li><a id="orge7dc3cd"></a>ApplyDelegates<br />
<div class="outline-text-6" id="text-1-2-7-2-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold; text-decoration: underline;">TfLiteStatus</span> <span style="font-weight: bold; text-decoration: underline;">InterpreterBuilder</span>::<span style="font-weight: bold;">ApplyDelegates</span>(<span style="font-weight: bold; text-decoration: underline;">Interpreter</span>* <span style="font-weight: bold; font-style: italic;">interpreter</span>,
                                                <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">num_threads</span>) {
    <span style="font-weight: bold;">if</span> (has_flex_op_) {
        <span style="font-weight: bold;">if</span> (<span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">flex_delegate</span> = AcquireFlexDelegate()) {
            <span style="font-weight: bold;">return</span> interpreter-&gt;ModifyGraphWithDelegate(<span style="font-weight: bold; text-decoration: underline;">std</span>::move(flex_delegate));
        }
    }

    <span style="font-weight: bold;">return</span> kTfLiteOk;
}

<span style="font-weight: bold; text-decoration: underline;">TfLiteStatus</span> <span style="font-weight: bold; text-decoration: underline;">InterpreterBuilder</span>::<span style="font-weight: bold;">BuildLocalIndexToRegistrationMapping</span>() {
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">OperatorCode</span>* <span style="font-weight: bold; font-style: italic;">opcode</span> : *opcodes) {
        <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">TfLiteRegistration</span>* <span style="font-weight: bold; font-style: italic;">registration</span> = <span style="font-weight: bold; text-decoration: underline;">nullptr</span>;
        status = GetRegistrationFromOpCode(opcode, op_resolver_, error_reporter_,
                                           &amp;registration);
        <span style="font-weight: bold;">if</span> (status != kTfLiteOk) {
            <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! flex op &#39318;&#20808;&#26159; custom_op</span>
            <span style="font-weight: bold;">if</span> (opcode-&gt;builtin_code() != BuiltinOperator_CUSTOM) {
                <span style="font-weight: bold;">return</span> status;
            }
            <span style="font-weight: bold;">const</span> <span style="font-weight: bold;">auto</span>* <span style="font-weight: bold; font-style: italic;">op_name</span> = opcode-&gt;custom_code()-&gt;c_str();
            <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! op_name &#26159;&#21542;&#26377; "Flex" &#21069;&#32512;</span>
            has_flex_op_ |= IsFlexOp(op_name);
        }
    }
    <span style="font-weight: bold;">return</span> status;
}

<span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">IsFlexOp</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">custom_name</span>) {
    <span style="font-weight: bold;">return</span> custom_name &amp;&amp; strncmp(custom_name, kFlexCustomCodePrefix,
                                 strlen(kFlexCustomCodePrefix)) == 0;
}
</pre>
</div>
</div>
</li>

<li><a id="org9113e35"></a>Flex Delegate<br />
<ol class="org-ol">
<li><a id="org1fe2efd"></a>IsNodeSupportedByDelegate<br />
<div class="outline-text-7" id="text-1-2-7-2-2-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; text-decoration: underline;">FlexDelegate</span>::<span style="font-weight: bold;">IsNodeSupportedByDelegate</span>(
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">TfLiteRegistration</span>* <span style="font-weight: bold; font-style: italic;">registration</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">TfLiteNode</span>* <span style="font-weight: bold; font-style: italic;">node</span>,
    <span style="font-weight: bold; text-decoration: underline;">TfLiteContext</span>* <span style="font-weight: bold; font-style: italic;">context</span>) <span style="font-weight: bold;">const</span> {
    <span style="font-weight: bold;">return</span> IsFlexOp(registration-&gt;custom_name);
}
</pre>
</div>
</div>
</li>


<li><a id="org693a884"></a>Eval<br />
<div class="outline-text-7" id="text-1-2-7-2-2-2">
<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold; text-decoration: underline;">TfLiteStatus</span> <span style="font-weight: bold; text-decoration: underline;">DelegateKernel</span>::<span style="font-weight: bold;">Eval</span>(<span style="font-weight: bold; text-decoration: underline;">TfLiteContext</span>* <span style="font-weight: bold; font-style: italic;">context</span>, <span style="font-weight: bold; text-decoration: underline;">TfLiteNode</span>* <span style="font-weight: bold; font-style: italic;">node</span>) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Execute the TensorFlow Ops sequentially.</span>
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold;">auto</span>&amp; <span style="font-weight: bold; font-style: italic;">node_data</span> : op_data_-&gt;nodes) {
        TFLITE_SCOPED_DELEGATE_OPERATOR_PROFILE(
            <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Profiler</span>*&gt;(context-&gt;profiler),
            node_data-&gt;name().c_str(), node_data-&gt;index());

        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">node_data-&gt;name() &#26159;&#31867;&#20284;&#20110; Abs &#36825;&#26679;&#30340; string</span>
        <span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">status</span> = ExecuteFlexOp(context, buffer_map, node_data.get());
        TF_LITE_ENSURE_OK(context, ConvertStatus(context, status));
    }
}

<span style="font-weight: bold; text-decoration: underline;">tensorflow</span>::<span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">InitializeNodeDef</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">custom_initial_data</span>,
                                     <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">custom_initial_data_size</span>) {
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">flexbuffers</span>::<span style="font-weight: bold; text-decoration: underline;">Vector</span>&amp; <span style="font-weight: bold; font-style: italic;">v</span> =
            <span style="font-weight: bold; text-decoration: underline;">flexbuffers</span>::GetRoot(
                <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint8_t</span>*&gt;(custom_initial_data),
                custom_initial_data_size)
            .AsVector();

    name_ = v[0].AsString().str();
}

<span style="font-weight: bold; text-decoration: underline;">TfLiteStatus</span> <span style="font-weight: bold; text-decoration: underline;">DelegateKernel</span>::<span style="font-weight: bold;">Init</span>(<span style="font-weight: bold; text-decoration: underline;">TfLiteContext</span>* <span style="font-weight: bold; font-style: italic;">context</span>,
                                  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">TfLiteDelegateParams</span>* <span style="font-weight: bold; font-style: italic;">params</span>) {

    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">node_index</span> : TfLiteIntArrayView(params-&gt;nodes_to_replace)) {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! custom_initial_data</span>
        status = node_data.InitializeNodeDef(node-&gt;custom_initial_data,
                                             node-&gt;custom_initial_data_size);
    }
}

<span style="font-weight: bold; text-decoration: underline;">TfLiteStatus</span> <span style="font-weight: bold; text-decoration: underline;">Subgraph</span>::<span style="font-weight: bold;">AddNodeWithParameters</span>(
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt;&amp; <span style="font-weight: bold; font-style: italic;">inputs</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt;&amp; <span style="font-weight: bold; font-style: italic;">outputs</span>,
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt;&amp; <span style="font-weight: bold; font-style: italic;">intermediates</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">init_data</span>,
    <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">init_data_size</span>, <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">builtin_data</span>,
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">TfLiteRegistration</span>* <span style="font-weight: bold; font-style: italic;">registration</span>, <span style="font-weight: bold; text-decoration: underline;">int</span>* <span style="font-weight: bold; font-style: italic;">node_index</span>) {
    <span style="font-weight: bold;">if</span> (registration-&gt;builtin_code == BuiltinOperator_CUSTOM) {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">When it's a CUSTOM op, the `custom_options` field in the Flatbuffer</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">`Operator` table is passed in.</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! init_data</span>
        node.custom_initial_data = init_data;
        node.custom_initial_data_size = init_data_size;
    } <span style="font-weight: bold;">else</span> {
        node.custom_initial_data = <span style="font-weight: bold; text-decoration: underline;">nullptr</span>;
        node.custom_initial_data_size = 0;
    }
}

<span style="font-weight: bold; text-decoration: underline;">TfLiteStatus</span> <span style="font-weight: bold; text-decoration: underline;">InterpreterBuilder</span>::<span style="font-weight: bold;">ParseNodes</span>(
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">flatbuffers</span>::<span style="font-weight: bold; text-decoration: underline;">Vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">flatbuffers</span>::<span style="font-weight: bold; text-decoration: underline;">Offset</span>&lt;Operator&gt;&gt;* <span style="font-weight: bold; font-style: italic;">operators</span>,
    <span style="font-weight: bold; text-decoration: underline;">Subgraph</span>* <span style="font-weight: bold; font-style: italic;">subgraph</span>) {
    <span style="font-weight: bold;">if</span> (op_type == BuiltinOperator_CUSTOM) {
        <span style="font-weight: bold;">if</span> (op-&gt;custom_options()) {
            subgraph-&gt;AddNodeWithParameters(
                FlatBufferIntArrayToVector(op-&gt;inputs()),
                FlatBufferIntArrayToVector(op-&gt;outputs()),
                FlatBufferIntArrayToVector(op-&gt;intermediates()),
                <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!!! custom_options()-&gt;data</span>
                <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>*&gt;(op-&gt;custom_options()-&gt;data()),
                op-&gt;custom_options()-&gt;size(), <span style="font-weight: bold; text-decoration: underline;">nullptr</span>, registration);
        }
}
</pre>
</div>
</div>
</li>
</ol>
</li>
</ol>
</div>

<div id="outline-container-org108cac1" class="outline-5">
<h5 id="org108cac1"><span class="section-number-5">1.2.7.3</span> edge tpu</h5>
<div class="outline-text-5" id="text-1-2-7-3">
<p>
edge tpu 的支持并不是通过 delegate, 而是需要用 edgetpu_compiler 把最初的 tflite
文件转换一下, 把其中 edge tpu 支持的操作封装到一个 custom op (edgetpu-custom-op)
中, 并输出另一个 tflite 文件
</p>

<p>
运行时反 libedgetpu 链接进来, 同时通过 AddCustom 注册 edgetpu 使用的 custom op:
</p>

<div class="org-src-container">
<pre class="src src-c++">resolver.AddCustom(<span style="font-weight: bold; text-decoration: underline;">edgetpu</span>::kCustomOp, <span style="font-weight: bold; text-decoration: underline;">edgetpu</span>::RegisterCustomOp());                                                                          
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org8384c5f" class="outline-3">
<h3 id="org8384c5f"><span class="section-number-3">1.3</span> </h3>
</div>

<div id="outline-container-org0384a4e" class="outline-3">
<h3 id="org0384a4e"><span class="section-number-3">1.4</span> <a href="tflite_quantization_detail.html#org35a53f2">TFLite Quantization Details</a></h3>
</div>
</div>
</div>
<div id="postamble" class="status">

<p class="author">Author: sunway (sunwayforever@gmail.com)<br />
Date: 2020-07-28 Tue 00:00<br />
Last updated: 2022-01-24 Mon 19:29</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。
<br />

<div id="disqus_thread"></div>
<script>

(function() { // DON'T EDIT BELOW THIS LINE
         var d = document, s = d.createElement('script');
         s.src = '//sunwayforever-github-io.disqus.com/embed.js';
         s.setAttribute('data-timestamp', +new Date());
         (d.head || d.body).appendChild(s);
         })();
</script>
</div>
</body>
</html>
