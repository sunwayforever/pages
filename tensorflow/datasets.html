<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-01-27 Thu 20:15 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Datasets</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wei Sun (孙伟)" />
<link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
<link rel = "icon" href = "/icon.png"  type = "image/x-icon">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">Datasets</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org0000000">1. Datasets</a></li>
</ul>
</div>
</div>

<div id="outline-container-org0000000" class="outline-2">
<h2 id="org0000000"><span class="section-number-2">1</span> Datasets</h2>
<div class="outline-text-2" id="text-1">
<ol class="org-ol">
<li>tensorflow dataset 不支持 eager execution, 所以 map,filter 等方法无法直接使用
python 代码, 需要用 numpy_function 封装一下</li>

<li>map 支持 num_parallel_calls, 可以自动多线程处理数据</li>

<li>prefetch 可以在 GPU 训练时通过 CPU 提前加载数据</li>

<li>from_generator 返回的数据不应包括 batch 维度, dataset 的 batch 方法会产生最终
的 batch 维度</li>

<li>使用 dataset 时, 由于 dataset 已经指定了 batch 大小, 所以 model.fit 不需要再
指定 batch_size</li>

<li>对于 from_generator 的 dataset, 由于总大小未知, model.fit 时需要通过
steps_per_epoch 指定一个 epoch 需要多少个 batch 的数据. 或者使用 dataset 的
take(N) 让它只返回 N 个 batch</li>
</ol>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">get_dataset</span>(mode):
    <span class="org-keyword">return</span> (
        tf.data.Dataset.from_generator(
            <span class="org-keyword">lambda</span>: data_generator(mode),
            output_types=(tf.string, tf.string),
        )
        .<span class="org-builtin">map</span>(decode_op, num_parallel_calls=40)
        .<span class="org-builtin">filter</span>(filter_op)
        .batch(BATCH_SIZE)
        .prefetch(tf.data.experimental.AUTOTUNE)
    )


<span class="org-keyword">def</span> <span class="org-function-name">norm</span>(x):
    <span class="org-keyword">return</span> (x ** 2).<span class="org-builtin">sum</span>()


<span class="org-keyword">def</span> <span class="org-function-name">filter_op</span>(a, b):
    <span class="org-keyword">return</span> tf.numpy_function(filter_audio, [a, b], tf.<span class="org-builtin">bool</span>)


<span class="org-keyword">def</span> <span class="org-function-name">filter_audio</span>(a, b):
    <span class="org-keyword">return</span> norm(a) &gt; MIN_ENERGY


<span class="org-keyword">def</span> <span class="org-function-name">decode_op</span>(a, b):
    <span class="org-keyword">return</span> tf.numpy_function(decode_audio, [a, b], (tf.float32, tf.float32))


<span class="org-variable-name">zeros</span> = np.zeros(SAMPLE_FRAMES).astype(np.float32)
<span class="org-variable-name">ignored</span> = (
    zeros,
    np.stack((zeros, zeros)),
)


<span class="org-keyword">def</span> <span class="org-function-name">decode_audio</span>(clean_file, noise_file):
    <span class="org-variable-name">signal</span>, <span class="org-variable-name">_</span> = librosa.load(clean_file, sr=SAMPLE_RATE, dtype=<span class="org-string">"float32"</span>)
    <span class="org-comment-delimiter"># </span><span class="org-comment">signal, _ = sf.read(clean_file, dtype="float32")</span>
    <span class="org-keyword">if</span> signal.shape[0] &lt;= SAMPLE_FRAMES:
        <span class="org-keyword">return</span> ignored

    <span class="org-variable-name">beg</span> = np.random.randint(signal.shape[0] - SAMPLE_FRAMES)
    <span class="org-variable-name">end</span> = beg + SAMPLE_FRAMES
    <span class="org-variable-name">clean_signal</span> = signal[beg:end]

    <span class="org-variable-name">signal</span>, <span class="org-variable-name">_</span> = librosa.load(noise_file, sr=SAMPLE_RATE, dtype=<span class="org-string">"float32"</span>)
    <span class="org-comment-delimiter"># </span><span class="org-comment">signal, _ = sf.read(noise_file, dtype="float32")</span>
    <span class="org-keyword">if</span> signal.shape[0] &lt;= SAMPLE_FRAMES:
        <span class="org-keyword">return</span> ignored

    <span class="org-variable-name">beg</span> = np.random.randint(signal.shape[0] - SAMPLE_FRAMES)
    <span class="org-variable-name">end</span> = beg + SAMPLE_FRAMES
    <span class="org-variable-name">noise_signal</span> = signal[beg:end]

    <span class="org-variable-name">noisy</span> = (
        clean_signal + np.sqrt(norm(clean_signal) / norm(noise_signal)) * noise_signal
    )
    <span class="org-keyword">return</span> noisy, np.stack((clean_signal, noise_signal))


<span class="org-keyword">def</span> <span class="org-function-name">data_generator</span>(mode):
    <span class="org-variable-name">clean_files</span>, <span class="org-variable-name">noise_files</span> = data[mode][<span class="org-string">"clean"</span>], data[mode][<span class="org-string">"noise"</span>]
    <span class="org-keyword">while</span> <span class="org-constant">True</span>:
        <span class="org-keyword">yield</span> np.random.choice(clean_files), np.random.choice(noise_files)


<span class="org-keyword">if</span> <span class="org-builtin">__name__</span> == <span class="org-string">"__main__"</span>:
    <span class="org-variable-name">dataset</span> = <span class="org-builtin">iter</span>(get_dataset(<span class="org-string">"train"</span>))
    <span class="org-keyword">print</span>(<span class="org-builtin">next</span>(dataset))


<span class="org-comment-delimiter"># </span><span class="org-comment">&#20351;&#29992; dataset </span>
model.fit(
    get_dataset(<span class="org-string">"train"</span>),
    steps_per_epoch=N_BATCH,
    epochs=FLAGS.epoch,
    callbacks=[save_model_callback, tensorboard_callback],
    <span class="org-comment-delimiter"># </span><span class="org-comment">validation_data=data_generator("test"),</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">validation_freq=5,</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">validation_steps=2,</span>
    shuffle=<span class="org-constant">False</span>,
    verbose=1,
)
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

<p class="author">Author: sunway (sunwayforever@gmail.com)<br />
Date: 2020-12-08 Tue 00:00<br />
Last updated: 2022-01-24 Mon 19:29</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。
<br />

<div id="disqus_thread"></div>
<script>

(function() { // DON'T EDIT BELOW THIS LINE
         var d = document, s = d.createElement('script');
         s.src = '//sunwayforever-github-io.disqus.com/embed.js';
         s.setAttribute('data-timestamp', +new Date());
         (d.head || d.body).appendChild(s);
         })();
</script>
</div>
</body>
</html>
