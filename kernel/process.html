<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-01-26 Wed 20:09 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Linux Kernel: Process</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wei Sun (孙伟)" />
<link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
<link rel = "icon" href = "/icon.png"  type = "image/x-icon">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">Linux Kernel: Process</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org9324fd6">1. Linux Kernel: Process</a>
<ul>
<li><a href="#orgf01ab2d">1.1. 进程描述符</a>
<ul>
<li><a href="#org03fa822">1.1.1. task_struct</a></li>
<li><a href="#org78f7e18">1.1.2. 进程状态</a></li>
<li><a href="#org48697ae">1.1.3. 识别一个进程</a></li>
<li><a href="#org2325cb5">1.1.4. 进程之间的关系</a></li>
<li><a href="#org5d6e37e">1.1.5. Pid Hashtable</a></li>
</ul>
</li>
<li><a href="#org98a0d81">1.2. 上下文切换</a>
<ul>
<li><a href="#orgd3484cd">1.2.1. switch_mm 与 Kernel Thread</a></li>
<li><a href="#org71d1acc">1.2.2. switch_to</a></li>
</ul>
</li>
<li><a href="#org9fce248">1.3. 创建进程</a>
<ul>
<li><a href="#orgb3658de">1.3.1. fork 系统调用</a></li>
<li><a href="#org2b36a4e">1.3.2. 关于系统调用 (syscall)</a></li>
<li><a href="#orgb49adc0">1.3.3. Kernel Thread</a></li>
</ul>
</li>
<li><a href="#org8979291">1.4. 销毁进程</a>
<ul>
<li><a href="#org73edf8f">1.4.1. main 返回</a></li>
</ul>
</li>
<li><a href="#orgbfb280e">1.5. Appendix</a>
<ul>
<li><a href="#orgca2919f">1.5.1. 0 号进程与 1 号进程</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org9324fd6" class="outline-2">
<h2 id="org9324fd6"><span class="section-number-2">1</span> Linux Kernel: Process</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgf01ab2d" class="outline-3">
<h3 id="orgf01ab2d"><span class="section-number-3">1.1</span> 进程描述符</h3>
<div class="outline-text-3" id="text-1-1">
<p>
进程描述符, 即 process descriptor, 是 kernel 用来表示进程的数据结构
</p>
</div>

<div id="outline-container-org03fa822" class="outline-4">
<h4 id="org03fa822"><span class="section-number-4">1.1.1</span> task_struct</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
Process Descriptor 即 task_struct 结构体, 它的主要成员有:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">task_struct</span> {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36827;&#31243;&#29366;&#24577;</span>
    <span style="font-weight: bold;">volatile</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">state</span>;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">thread_info &#21450; kernel_stack</span>
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">thread_info</span> *<span style="font-weight: bold; font-style: italic;">thread_info</span>;

    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">prio</span>, <span style="font-weight: bold; font-style: italic;">static_prio</span>;

    <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">process &#30340;&#31532;&#19968;&#31181;&#32452;&#32455;&#26041;&#24335;: prio_array_t &#26159;&#19968;&#20010;&#21253;&#21547; 140 &#20010;</span>
<span style="font-weight: bold; font-style: italic;">     * list_head &#30340;&#25968;&#32452;, &#23545;&#24212; 140 &#20010;&#36827;&#31243;&#20248;&#20808;&#32423;. p-&gt;run_list &#26159;&#36827;&#31243; p</span>
<span style="font-weight: bold; font-style: italic;">     * &#22312; array[p-&gt;prio] &#36825;&#20010; list_head &#38142;&#34920;&#20013;&#30340; list entry.</span>
<span style="font-weight: bold; font-style: italic;">     *</span>
<span style="font-weight: bold; font-style: italic;">     * &#26681;&#25454; task &#30340;&#29366;&#24577;, task-&gt;array &#24517;&#23450;&#25351;&#21521; runqueue &#20013; active &#25110;</span>
<span style="font-weight: bold; font-style: italic;">     * expire &#20013;&#30340;&#26576;&#19968;&#20010; prio_array_t. &#25152;&#26377; state &#20026; running (active)</span>
<span style="font-weight: bold; font-style: italic;">     * &#30340;&#36827;&#31243; p &#32452;&#32455;&#22312; runqueue-&gt;active &#20013;, &#19988; p-&gt;array =</span>
<span style="font-weight: bold; font-style: italic;">     * runqueue-&gt;active. &#25152;&#26377; state &#20026; running (expired) &#30340;&#36827;&#31243; p &#32452;&#32455;</span>
<span style="font-weight: bold; font-style: italic;">     * &#22312; running-&gt;expired &#20013;, &#19988; p-&gt;array = runqueue-&gt;expired, &#20855;&#20307;&#30340;</span>
<span style="font-weight: bold; font-style: italic;">     * &#21442;&#32771; process scheduling</span><span style="font-weight: bold; font-style: italic;"> */</span>

    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">list_head</span> <span style="font-weight: bold; font-style: italic;">run_list</span>;
    <span style="font-weight: bold; text-decoration: underline;">prio_array_t</span> *<span style="font-weight: bold; font-style: italic;">array</span>;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">process &#30340;&#31532;&#20108;&#31181;&#32452;&#32455;&#26041;&#24335;: tasks &#23558;&#25152;&#26377;&#36827;&#31243;&#32452;&#32455;&#20026;&#19968;&#20010; list, &#23545;&#24212;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#30340; list_head &#20026; init_task.tasks</span>
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">list_head</span> <span style="font-weight: bold; font-style: italic;">tasks</span>;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21644;&#20869;&#23384;&#30456;&#20851;&#30340;&#23383;&#27573;, &#21253;&#25324; vma, pgd &#31561;</span>
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">mm_struct</span> *<span style="font-weight: bold; font-style: italic;">mm</span>, *<span style="font-weight: bold; font-style: italic;">active_mm</span>;

    <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">exit_state</span>;
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">exit_code</span>, <span style="font-weight: bold; font-style: italic;">exit_signal</span>;

    <span style="font-weight: bold; text-decoration: underline;">pid_t</span> <span style="font-weight: bold; font-style: italic;">pid</span>;
    <span style="font-weight: bold; text-decoration: underline;">pid_t</span> <span style="font-weight: bold; font-style: italic;">tgid</span>;

    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">task_struct</span> *<span style="font-weight: bold; font-style: italic;">parent</span>;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">process &#30340;&#31532;&#19977;&#31181;&#32452;&#32455;&#26041;&#24335;: &#36890;&#36807; children &#21644; sibling, &#21487;&#20197;&#25214;&#21040;&#36827;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#31243;&#30340;&#25152;&#26377;&#23376;&#36827;&#31243;</span>
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">list_head</span> <span style="font-weight: bold; font-style: italic;">children</span>;
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">list_head</span> <span style="font-weight: bold; font-style: italic;">sibling</span>;

    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">task_struct</span> *<span style="font-weight: bold; font-style: italic;">group_leader</span>;   <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">threadgroup leader</span><span style="font-weight: bold; font-style: italic;"> */</span>

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">process &#30340;&#31532;&#22235;&#31181;&#32452;&#32455;&#26041;&#24335;: &#25152;&#26377;&#36827;&#31243;&#26681;&#25454;&#20854; pid, tgid, pgid, sid &#32452;&#32455;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22312;&#22235;&#26465;&#19981;&#21516;&#30340; hash table &#20445;&#23384;&#22312; pids &#25968;&#32452;&#20013;</span>
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">pid</span> <span style="font-weight: bold; font-style: italic;">pids</span>[PIDTYPE_MAX];

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">user time &#19982; system time, timer interrupt &#26102;&#36890;&#36807;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">update_process_times &#26356;&#26032;</span>
    <span style="font-weight: bold; text-decoration: underline;">cputime_t</span> <span style="font-weight: bold; font-style: italic;">utime</span>, <span style="font-weight: bold; font-style: italic;">stime</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">minor fault &#19982; major fault &#30340;&#32479;&#35745;</span>
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">min_flt</span>, <span style="font-weight: bold; font-style: italic;">maj_flt</span>;

    <span style="font-weight: bold; text-decoration: underline;">uid_t</span> <span style="font-weight: bold; font-style: italic;">uid</span>,<span style="font-weight: bold; font-style: italic;">euid</span>,<span style="font-weight: bold; font-style: italic;">suid</span>,<span style="font-weight: bold; font-style: italic;">fsuid</span>;
    <span style="font-weight: bold; text-decoration: underline;">gid_t</span> <span style="font-weight: bold; font-style: italic;">gid</span>,<span style="font-weight: bold; font-style: italic;">egid</span>,<span style="font-weight: bold; font-style: italic;">sgid</span>,<span style="font-weight: bold; font-style: italic;">fsgid</span>;

    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">oomkilladj</span>; */
    <span style="font-weight: bold; text-decoration: underline;">char</span> comm[TASK_COMM_LEN];

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36827;&#31243;&#20999;&#25442;&#26102;&#38656;&#35201;&#20174; thread &#20013;&#33719;&#21462;&#20445;&#23384;&#30340; kernel mode &#19979; esp, eip &#31561;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20449;&#24687;</span>
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">thread_struct</span> <span style="font-weight: bold; font-style: italic;">thread</span>;

    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">fs_struct</span> *<span style="font-weight: bold; font-style: italic;">fs</span>;

    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">files_struct</span> *<span style="font-weight: bold; font-style: italic;">files</span>;

    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">signal_struct</span> *<span style="font-weight: bold; font-style: italic;">signal</span>;
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">sighand_struct</span> *<span style="font-weight: bold; font-style: italic;">sighand</span>;
};

</pre>
</div>
</div>
</div>

<div id="outline-container-org78f7e18" class="outline-4">
<h4 id="org78f7e18"><span class="section-number-4">1.1.2</span> 进程状态</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
task_struct.state 表示进程的状态:
</p>

<ol class="org-ol">
<li><p>
TASK_RUNNING
</p>

<p>
进程处于 running 状态, 只是表示 schedule 时该进程可以被选择, 而并不
是表示该进程一直在 "执行" 的状态.
</p>

<p>
TASK_RUNNING 状态的进程一定处于 p-&gt;array[p-&gt;prio] 链表中
</p></li>

<li><p>
TASK_INTERRUPTIBLE
</p>

<p>
TASK_INTERRUPTIBLE 的进程处于 sleeping 状态, 但可以被信号唤醒 (信号
唤醒进程的过程参考 signal 相关的部分 <a href="signal.html#org1d1ed22">specific_send_sig_info</a>) 而变成
TASK_RUNNING 状态.
</p>

<p>
典型的例子比如 nanosleep 和 read(pipe) 这种阻塞
</p></li>

<li><p>
TASK_UNINTERRUPTIBLE
</p>

<p>
TASK_UNINTERRUPTIBLE 的进程处于 sleeping 状态, 但无法被信号唤醒, 典
型的例子比如做 IO 时的 lock_page
</p></li>

<li>TASK_STOPPED</li>

<li>TASK_TRACED</li>

<li><p>
EXIT_ZOMBIE
</p>

<p>
由于 wait4, waitpid 这类系统调用在存在, 进程终止时无法直接变为
EXIT_DEAD 状态, 因为它还需要维护一些信息等待父进程调用 wait4 时返回
给父进程
</p></li>

<li>EXIT_DEAD</li>
</ol>
</div>
</div>

<div id="outline-container-org48697ae" class="outline-4">
<h4 id="org48697ae"><span class="section-number-4">1.1.3</span> 识别一个进程</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
识别一个进程 (identifing a process), 主要是指下面这些需求:
</p>

<ol class="org-ol">
<li>如何知道当前正在执行的是哪个进程</li>

<li>如何遍历进程:

<ol class="org-ol">
<li>遍历所有进程</li>

<li>根据 pid, tgid</li>

<li>根据进程的关系</li>

<li>根据进程的状态</li>
</ol></li>
</ol>
</div>

<div id="outline-container-org91dfee4" class="outline-5">
<h5 id="org91dfee4"><span class="section-number-5">1.1.3.1</span> 当前进程</h5>
<div class="outline-text-5" id="text-1-1-3-1">
<p>
首先, task_struct, thread_info 及 kernel stack 有密切的关系:
</p>


<div id="org16cb942" class="figure">
<p><img src="../extra/kernel_process_thread_info.png" alt="kernel_process_thread_info.png" />
</p>
</div>

<p>
相关的数据结构的定义如下:
</p>

<ol class="org-ol">
<li><p>
task_struct
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">task_struct</span> {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">...</span>
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">thread_info</span> *<span style="font-weight: bold; font-style: italic;">thread_info</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">...</span>
}
</pre>
</div></li>

<li><p>
thread_info
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">thread_info</span> {
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">task_struct</span>  *<span style="font-weight: bold; font-style: italic;">task</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">...</span>
    <span style="font-weight: bold; text-decoration: underline;">__u8</span>                        <span style="font-weight: bold; font-style: italic;">supervisor_stack</span>[0];
};

</pre>
</div></li>
</ol>

<p>
thread_info 是通过 kmalloc(THREAD_SIZE) 分配的, THREAD_SIZE 根据配置不
同可能是 4K 或 8K, thread_info 是通过 kmalloc 分配的, kmalloc 会保证
thread_info 一定是 4K 或 8K 对齐的 (参考 OFF_SLAB 的布局)
</p>

<p>
由于 thread_info 的对齐以及它与 kernel stack 的关系, 可以很容易的从
esp (kernel_stack) 的值得于 thread_info 的地址, 进而得到 task_struct,
这就是 current 宏的原理.
</p>
</div>

<div id="outline-container-orgdbb6ec2" class="outline-6">
<h6 id="orgdbb6ec2"><span class="section-number-6">1.1.3.1.1</span> current 宏</h6>
<div class="outline-text-6" id="text-1-1-3-1-1">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">current</span>:
  <span style="font-weight: bold;">current_thread_info</span>()-&gt;task;
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">thread_info</span> *<span style="font-weight: bold; font-style: italic;">ti</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20551;&#35774; THREAD_SIZE &#20026; 4k (0100 0000000000), &#21017; ~(THREAD_SIZE-1)</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20540;&#20026; 11 1111111111</span>
    <span style="font-weight: bold;">__asm__</span>(<span style="font-style: italic;">"andl %%esp,%0; "</span>:<span style="font-style: italic;">"=r"</span> (ti) : <span style="font-style: italic;">"0"</span> (~(THREAD_SIZE - 1)));
    <span style="font-weight: bold;">return</span> ti;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org7f10776" class="outline-5">
<h5 id="org7f10776"><span class="section-number-5">1.1.3.2</span> 双向链表</h5>
<div class="outline-text-5" id="text-1-1-3-2">
<p>
task_struct 是用许多双向链表组织起来的, 比如:
</p>

<ol class="org-ol">
<li>所有进程</li>

<li>同 tgid 的所有进程</li>

<li>同优先级的处于 TASK_RUNNING 状态的进程</li>

<li>一个进程的所有子进程</li>
</ol>

<p>
linux 使用 list_head 数据结构来实现一个通用的链表, 并提供了一些通用的
函数, 比如 list_add, list_for_each_entry 等
</p>


<div id="org316b950" class="figure">
<p><img src="../extra/kernel_list.png" alt="kernel_list.png" />
</p>
</div>
</div>

<div id="outline-container-org997662a" class="outline-6">
<h6 id="org997662a"><span class="section-number-6">1.1.3.2.1</span> list_head</h6>
<div class="outline-text-6" id="text-1-1-3-2-1">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">list_head</span> {
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">list_head</span> *<span style="font-weight: bold; font-style: italic;">next</span>, *<span style="font-weight: bold; font-style: italic;">prev</span>;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf493769" class="outline-6">
<h6 id="orgf493769"><span class="section-number-6">1.1.3.2.2</span> list_entry (container_of)</h6>
<div class="outline-text-6" id="text-1-1-3-2-2">
<p>
list_entry 的作用是给定一个 list_head, 得到外层的数据结构的地址(对应于
上图中的 data structure {1,2,3})
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">ptr &#26159; list_head, type &#20026; data struct &#30340;&#31867;&#22411;, member &#20026; data</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">structure &#20013; list_head &#23545;&#24212;&#30340;&#23383;&#27573;&#21517;</span>
<span style="font-weight: bold;">#define</span> <span style="font-weight: bold;">container_of</span>(<span style="font-weight: bold; font-style: italic;">ptr</span>, <span style="font-weight: bold; font-style: italic;">type</span>, <span style="font-weight: bold; font-style: italic;">member</span>) ({                              \
            <span style="font-weight: bold;">const</span> <span style="font-weight: bold;">typeof</span>( ((<span style="font-weight: bold; text-decoration: underline;">type</span> *)0)-&gt;member ) *<span style="font-weight: bold; font-style: italic;">__mptr</span> = (ptr);         \
            (<span style="font-weight: bold; text-decoration: underline;">type</span> *)( (<span style="font-weight: bold; text-decoration: underline;">char</span> *)__mptr - offsetof(type,member) );})

</pre>
</div>

<p>
以遍历 all tasks 为例, 假设通过 list_for_each 已经拿到一个对应于
task_struct-&gt;tasks 这个 list_head 的指针为 p, 则 list_entry(p,
struct task_struct, tasks) 宏可以得到对应的外层的 task_struct
</p>
</div>
</div>

<div id="outline-container-org150f1f4" class="outline-6">
<h6 id="org150f1f4"><span class="section-number-6">1.1.3.2.3</span> list_for_each</h6>
<div class="outline-text-6" id="text-1-1-3-2-3">
<p>
list_for_each 是通用的遍历链表的代码
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">pos &#26159;&#19968;&#20010;&#20020;&#26102;&#21464;&#37327;, &#34920;&#31034;&#36941;&#21382;&#36807;&#31243;&#20013;&#30340;"&#24403;&#21069;" list_head,</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">head &#26159;&#20195;&#34920;&#38142;&#34920;&#22836;&#30340; list_head</span>
<span style="font-weight: bold;">#define</span> <span style="font-weight: bold;">list_for_each</span>(<span style="font-weight: bold; font-style: italic;">pos</span>, <span style="font-weight: bold; font-style: italic;">head</span>)                                \
    <span style="font-weight: bold;">for</span> (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)
</pre>
</div>

<p>
可见遍历结束的条件是 pos != (head), 因为 linux 的链表是双向的循环链表.
</p>

<p>
list_for_each 每次迭代拿到一个 list_head 后, 通过 list_entry 宏可以拿
到对应的数据结构
</p>
</div>
</div>

<div id="outline-container-orge9f6da5" class="outline-6">
<h6 id="orge9f6da5"><span class="section-number-6">1.1.3.2.4</span> 再看 list_head</h6>
<div class="outline-text-6" id="text-1-1-3-2-4">
<p>
list_head 实际有几种不同的用法:
</p>

<ol class="org-ol">
<li>list_head 可以用来表示它是链表的头, 这个 list_head 本身不代表链表的
任何元素, 所以通过 list_entry 也是没有意义的. 链表的第一个元素是
list_entry(list_head-next). 这种 list_head 的目的就是标识一个链表</li>

<li>list_head 是链表头, 但它也是代表链表的一个元素, 这种链表头的用法并
不常见, 因为它无法使用 list_for_each 宏 (因为 list_for_each 会把
head 作为 case 1 中的链表头来处理). 比如 for_each_process 时使用的
init_task-&gt;tasks 就是这种链表头</li>

<li>list_head 不是链表头, 而是链表中某个节点 (list entry), 这种
list_head 通过 list_entry 可以找到对应的外层数据结构</li>
</ol>

<p>
所以 list_head 实现的链表并不是一般意义上的"循环双向链表", 因为这个链
表中的链表头是一个很特殊的节点: 它并不对应一个"有效"的元素, 而且链表的
遍历必须从这个链表头开始: 因为如果从链表中任意一个节点遍历的话, 你无法
区分遍历到的 list_head 是否是一个有效的 list entry
</p>
</div>
</div>
</div>

<div id="outline-container-org01b6ef8" class="outline-5">
<h5 id="org01b6ef8"><span class="section-number-5">1.1.3.3</span> 遍历所有进程</h5>
<div class="outline-text-5" id="text-1-1-3-3">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">#define</span> <span style="font-weight: bold;">for_each_process</span>(<span style="font-weight: bold; font-style: italic;">p</span>) \
      <span style="font-weight: bold;">for</span> (p=&amp;init_task;
           (p=list_entry((p)-&gt;tasks.next, <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">task_struct</span>, tasks)) != &amp;init_task; )

</pre>
</div>
</div>
</div>

<div id="outline-container-orgb733052" class="outline-5">
<h5 id="orgb733052"><span class="section-number-5">1.1.3.4</span> 遍历所有 TASK_RUNNING 进程</h5>
<div class="outline-text-5" id="text-1-1-3-4">
<p>
遍历 TASK_RUNNING 进程是进程调度的工作之一, 为了快速找到对应某一优先级
的 TASK_RUNNING 进程, linux 将所有 TASK_RUNNING 进程分为 140 个链表来
管理, 每个链表对应一个优先级.
</p>

<p>
其中, task_struct-&gt;array 中保存着相应的链表头, 而
task_struct-&gt;run_list 是对应的 list entry
</p>

<p>
关于 prio_array_t, run_list 以及 runqueue-&gt;{active, expired}, 参考

</p>
</div>
</div>

<div id="outline-container-orgc456e2f" class="outline-5">
<h5 id="orgc456e2f"><span class="section-number-5">1.1.3.5</span> 遍历所有子进程</h5>
<div class="outline-text-5" id="text-1-1-3-5">
<p>
task_struct 中的 children, sibling 两个 list_head 来实现遍历所有子进程.
</p>

<p>
假设要遍历 p 的子进程, 则 p-&gt;children 是对应的链表头, 各个子进程的
sibling 是 list entry
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#33719;&#21462; task &#30340;&#25152;&#26377;&#23376;&#36827;&#31243;&#30340;&#20195;&#30721;</span>
<span style="font-weight: bold;">list_for_each</span>(_p,&amp;tsk-&gt;children) {
    p = list_entry(_p,<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">task_struct</span>,sibling);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">...</span>
}
</pre>
</div>


<div id="org6931353" class="figure">
<p><img src="../extra/kernel_process_parent.png" alt="kernel_process_parent.png" />
</p>
</div>

<p>
从上图可以看到, p3 的 sibling.next 是指向 p0 的 (实际上指向
p0-&gt;children), 看起来和 sibling 的语义不符, 但却是正确的: 因为
list_for_each 的结束条件是 p != (head), 所以链表的最后一个元素需要指向
链表头
</p>
</div>
</div>
</div>

<div id="outline-container-org2325cb5" class="outline-4">
<h4 id="org2325cb5"><span class="section-number-4">1.1.4</span> 进程之间的关系</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
进程之间的关系有:
</p>

<ul class="org-ul">
<li>process group</li>

<li>thread group</li>

<li>session</li>
</ul>

<p>
task_struct 维护着各种 id 来表示这些关系
</p>

<ol class="org-ol">
<li><p>
pid
</p>

<p>
pid 唯一标识一个进程或线程. 这个值也是 gettid 系统调用返回的值
</p></li>

<li><p>
tgid
</p>

<p>
线程组 id, 同一个进程 p 的所有线程的 tgid 均为 p-&gt;pid, p 称为
thread group leader. 这个值是 getpid 系统调用返回的值
</p></li>

<li><p>
pgid
</p>

<p>
进程组 id, 若 a fork b, 则 b-&gt;pgid = a-&gt;pgid, 进程组通常和任务管理
有关, 例如 kill 可以给一个进程组发信号导致整个进程组的所有进程都收
到信号. 通过 setpgid 系统调用, 可以给进程设置一个新的进程组, 从而断
开与之前的进程组的关系
</p></li>

<li>sid</li>
</ol>
</div>
</div>

<div id="outline-container-org5d6e37e" class="outline-4">
<h4 id="org5d6e37e"><span class="section-number-4">1.1.5</span> Pid Hashtable</h4>
<div class="outline-text-4" id="text-1-1-5">
<p>
task_struct-&gt;pids 用来维护四个 hash table, 分别对应 pid, tgid, pgid,
sid, 以便能根据某种 id 快速找到对应的 task
</p>


<div id="orga04c4b9" class="figure">
<p><img src="../extra/process_pid_hash.png" alt="process_pid_hash.png" />
</p>
</div>

<p>
相关的函数有:
</p>

<ol class="org-ol">
<li>find_task_by_pid_type</li>

<li>do_each_task_pid</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org98a0d81" class="outline-3">
<h3 id="org98a0d81"><span class="section-number-3">1.2</span> 上下文切换</h3>
<div class="outline-text-3" id="text-1-2">
<p>
进程上下文切换 (context switch) 是进程调度的一部分, 上下文切换的主要动
作有两个:
</p>

<ol class="org-ol">
<li><p>
切换页表
</p>

<p>
switch_mm
</p></li>

<li><p>
切换 kernel stack
</p>

<p>
switch_to
</p></li>
</ol>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">context_switch</span>(prev, next):
  <span style="font-weight: bold;">struct</span> mm_struct *mm = next-&gt;mm;
  <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">mm_struct</span> *<span style="font-weight: bold; font-style: italic;">oldmm</span> = prev-&gt;active_mm;
  <span style="font-weight: bold;">if</span> (unlikely(!mm)):
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">kernel_thread &#30340; mm &#20026; NULL, active_mm &#20026;&#23427; "&#20511;&#29992;" &#30340; mm, &#25152;&#20197;&#36825;&#37324;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">next &#26159;&#19968;&#20010; kernel_thread, &#30452;&#25509;&#20351;&#29992; prev-&gt;active_mm &#20570;&#20026;&#23427;&#30340;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">active_mm, &#19981;&#20877;&#38656;&#35201; switch_mm</span>
    next-&gt;active_mm = oldmm;
  <span style="font-weight: bold;">else</span>:
    switch_mm(oldmm, mm, next);
      <span style="font-weight: bold;">load_cr3</span>(next-&gt;pgd);
  <span style="font-weight: bold;">switch_to</span>(prev, next, prev);
</pre>
</div>
</div>

<div id="outline-container-orgd3484cd" class="outline-4">
<h4 id="orgd3484cd"><span class="section-number-4">1.2.1</span> switch_mm 与 Kernel Thread</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
Context switch 时, switch_mm 的主要作用是切换 pgd, 但考虑到 kernel
thread 的特殊情形: kernel thread 只需要使用 pgd 中的高 1G 的部分,而所
有的页表的这部分都是一致的, 所以 kernel thread 总是会借用 "前一个" 进
程的页表, 以避免因为切换页表造成的 TLB flush.
</p>

<p>
所以 switch_to kernel thread 时, 不需要 switch_mm. 参考 <a href="#orgb49adc0">Kernel Thread</a>
</p>
</div>
</div>

<div id="outline-container-org71d1acc" class="outline-4">
<h4 id="org71d1acc"><span class="section-number-4">1.2.2</span> switch_to</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
switch_to 是实现 kernel stack 切换的主要代码.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">#define</span> <span style="font-weight: bold;">switch_to</span>(<span style="font-weight: bold; font-style: italic;">prev</span>,<span style="font-weight: bold; font-style: italic;">next</span>,<span style="font-weight: bold; font-style: italic;">last</span>)                                       \
    <span style="font-weight: bold;">do</span> {                                                                \
        <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">esi</span>,<span style="font-weight: bold; font-style: italic;">edi</span>;                                          \
        <span style="font-weight: bold;">asm</span> (                                                           \
            <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">&#20445;&#23384; eflags &#21040; prev kernel stack</span><span style="font-weight: bold; font-style: italic;">*/</span>                       \
            <span style="font-style: italic;">"pushfl\n\t"</span>                                                \
            <span style="font-style: italic;">"pushl %%ebp\n\t"</span>                                           \
            <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">&#20445;&#23384; esp &#21040; prev-&gt;thread.esp</span><span style="font-weight: bold; font-style: italic;">*/</span>                           \
            <span style="font-style: italic;">"movl %%esp,%0\n\t"</span> <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">save ESP</span><span style="font-weight: bold; font-style: italic;"> */</span>                          \
            <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">&#20174; next-&gt;thread.esp &#24674;&#22797; esp</span><span style="font-weight: bold; font-style: italic;">*/</span>                           \
            <span style="font-style: italic;">"movl %5,%%esp\n\t"</span>                                         \
            <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">&#23558; label 1 &#35774;&#32622;&#20026; prev-&gt;thread.eip</span><span style="font-weight: bold; font-style: italic;">*/</span>                     \
            <span style="font-style: italic;">"movl $1f,%1\n\t"</span>                                           \
            <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">&#23558; next-&gt;thread.eip push &#21040; stack, jmp _switch_to        \</span>
<span style="font-weight: bold; font-style: italic;">             * &#36820;&#22238;&#26102;&#30340; ret &#25351;&#20196;&#20250;&#20174; stack &#19978;&#21462;&#36825;&#20010; eip &#20570;&#20026; PC         \</span>
<span style="font-weight: bold; font-style: italic;">             * &#20174;&#32780;&#23454;&#29616;&#36339;&#36716;&#21040; next-&gt;thread.eip. &#23454;&#38469;&#19978;, &#36825;&#20010;            \</span>
<span style="font-weight: bold; font-style: italic;">             * next-&gt;thread.eip                                         \</span>
<span style="font-weight: bold; font-style: italic;">             * &#19968;&#33324;&#24773;&#20917;&#19979;&#20063;&#26159; label 1, &#26377;&#19968;&#20010;&#20363;&#22806;&#23601;&#26159; do_fork           \</span>
<span style="font-weight: bold; font-style: italic;">             * &#26102;&#30340; ret_from_fork</span><span style="font-weight: bold; font-style: italic;">*/</span>                                     \
            <span style="font-style: italic;">"pushl %6\n\t"</span>                                              \
            <span style="font-weight: bold; font-style: italic;">/*</span><span style="font-weight: bold; font-style: italic;">__switch_to &#20250;&#20445;&#23384;&#19968;&#20123; FPU &#31561;, &#26368;&#37325;&#35201;&#30340;&#19968;&#28857;&#26159;, &#23427;&#20250;&#23558;     \</span>
<span style="font-weight: bold; font-style: italic;">             * esp (&#19979;&#19968;&#20010;&#36827;&#31243;&#30340; kernel stack ) &#20445;&#23384;&#22312; tss &#20013;&#20197;&#20415;&#36827;&#31243;   \</span>
<span style="font-weight: bold; font-style: italic;">             * &#36827;&#20837; kernel mode &#26102;&#33021;&#25214;&#21040; kernel stack</span><span style="font-weight: bold; font-style: italic;">*/</span>                 \
            <span style="font-style: italic;">"jmp __switch_to\n"</span>                                         \
              tss-&gt;esp0 = thread-&gt;esp0;
            <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">jmp ret &#21518;, eip &#21644; esp &#22343;&#20026; next-&gt;thread &#30456;&#24212;&#30340;&#20540;,       \</span>
<span style="font-weight: bold; font-style: italic;">             * &#26631;&#24535;&#30528;&#20999;&#25442;&#24443;&#24213;&#23436;&#25104;</span><span style="font-weight: bold; font-style: italic;"> */</span>                                    \
            <span style="font-style: italic;">"1:\t"</span>                                                      \
            <span style="font-style: italic;">"popl %%ebp\n\t"</span>                                            \
            <span style="font-style: italic;">"popfl"</span>                                                     \
            :<span style="font-style: italic;">"=m"</span> (prev-&gt;thread.esp),<span style="font-style: italic;">"=m"</span> (prev-&gt;thread.eip),             \
             <span style="font-style: italic;">"=a"</span> (last),<span style="font-style: italic;">"=S"</span> (esi),<span style="font-style: italic;">"=D"</span> (edi)                          \
            :<span style="font-style: italic;">"m"</span> (next-&gt;thread.esp),<span style="font-style: italic;">"m"</span> (next-&gt;thread.eip),               \
             <span style="font-style: italic;">"2"</span> (prev), <span style="font-style: italic;">"d"</span> (next));                                   \
    } <span style="font-weight: bold;">while</span> (0)

</pre>
</div>

<p>
需要注意的是 switch_to 时并没有保存 ebx, ecx, edx 等寄存器, 这是因为
switch_to (或者更外层的 schedule) 调用之前, p 的 user mode 的这些寄存
器已经通过 SAVE_ALL (通过 system_call 或 interrupt handler) 保存在 p
的 kernel stack 了. 所以 switch_to 只需要切换 kernel stack 就可以了.
</p>
</div>
</div>
</div>

<div id="outline-container-org9fce248" class="outline-3">
<h3 id="org9fce248"><span class="section-number-3">1.3</span> 创建进程</h3>
<div class="outline-text-3" id="text-1-3">
<p>
存在三个相关的库函数以及三个相关的系统调用: fork, vfork, clone, 但通常
情况下, 三个库函数最终都会调到同一个系统调用 sys_clone. sys_fork 及
sys_vfork 也是存在的, 但一般并不会使用.
</p>
</div>

<div id="outline-container-orgb3658de" class="outline-4">
<h4 id="orgb3658de"><span class="section-number-4">1.3.1</span> fork 系统调用</h4>
<div class="outline-text-4" id="text-1-3-1">
</div>
<div id="outline-container-org1458339" class="outline-5">
<h5 id="org1458339"><span class="section-number-5">1.3.1.1</span> FORK_FLAGS</h5>
<div class="outline-text-5" id="text-1-3-1-1">
<ol class="org-ol">
<li>CLONE_VM</li>

<li>CLONE_FS</li>

<li>CLONE_FILES</li>

<li>CLONE_VFORK</li>

<li>CLONE_NEWNS</li>

<li>CLONE_SIGHAND</li>

<li>CLONE_STOPPED</li>

<li>CLONE_THREAD</li>

<li>CLONE_PARENT</li>
</ol>

<p>
这些 flag 主要在 copy_process 时被处理, 例如 copy_mm 时若发现 CLONE_VM,
则 child-&gt;mm = parent-&gt;mm
</p>
</div>
</div>

<div id="outline-container-org69af67c" class="outline-5">
<h5 id="org69af67c"><span class="section-number-5">1.3.1.2</span> user mode</h5>
<div class="outline-text-5" id="text-1-3-1-2">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">fork</span>() {
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">result</span> = syscall(
        __NR_clone,
        FORK_FLAGS,
        <span style="font-weight: bold; text-decoration: underline;">NULL</span>,                          <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">child_stack</span><span style="font-weight: bold; font-style: italic;"> */</span>
        <span style="font-weight: bold; text-decoration: underline;">NULL</span>,                          <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">ptid</span><span style="font-weight: bold; font-style: italic;"> */</span>
        <span style="font-weight: bold; text-decoration: underline;">NULL</span>,
        &amp;(self-&gt;tid)             <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">ctid</span><span style="font-weight: bold; font-style: italic;"> */</span>
        );
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">ENTRY</span>(syscall)
    <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">Push the callee save registers.</span><span style="font-weight: bold; font-style: italic;"> */</span>
    push    %ebx
    push    %esi
    push    %edi
    push    %ebp

    <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">20(%esp) &#21363; syscall &#30340;&#31532;&#19968;&#20010;&#21442;&#25968; __NR_clone, &#20043;&#25152;&#20197;&#26159; 20(%esp) &#32780;&#19981;&#26159; 16(%esp)</span><span style="font-weight: bold; font-style: italic;"> */</span>
    <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">&#26159;&#22240;&#20026; syscall() &#26102;&#20250;&#22312;&#26632;&#19978; push &#19968;&#20010; eip, &#21363;&#24403;&#21069;&#26632;&#19978;&#30340;&#26679;&#23376;&#20026;:</span><span style="font-weight: bold; font-style: italic;"> */</span>
    <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">ebp|edi|esi|ebx|eip|__NR_clone|FORK_FLAGS|NULL|NULL|NULL|tid</span><span style="font-weight: bold; font-style: italic;"> */</span>
    <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">24(%esp) &#21363; FORK_FLAGS,....&#20197;&#27492;&#31867;&#25512;</span><span style="font-weight: bold; font-style: italic;"> */</span>
    <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">&#25353;&#29031;&#31995;&#32479;&#35843;&#29992;&#30340;&#32422;&#23450;, user mode &#38656;&#35201;&#23558; __NR__xxx &#21644;&#25152;&#26377;&#21442;&#25968;&#20381;&#27425;&#25918;&#22312; eax,</span><span style="font-weight: bold; font-style: italic;"> */</span>
    <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">ebx, ... &#20013;</span><span style="font-weight: bold; font-style: italic;"> */</span>

    mov     20(%esp),%eax
    mov     24(%esp),%ebx
    mov     28(%esp),%ecx
    mov     32(%esp),%edx
    mov     36(%esp),%esi
    mov     40(%esp),%edi
    mov     44(%esp),%ebp

    <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">&#31995;&#32479;&#35843;&#29992;</span><span style="font-weight: bold; font-style: italic;"> */</span>
    <span style="font-weight: bold; text-decoration: underline;">int</span>     $0x80

    pop    %ebp
    pop    %edi
    pop    %esi
    pop    %ebx
    ret
END(syscall)
</pre>
</div>
</div>
</div>

<div id="outline-container-org7b0bf7e" class="outline-5">
<h5 id="org7b0bf7e"><span class="section-number-5">1.3.1.3</span> kernel mode</h5>
<div class="outline-text-5" id="text-1-3-1-3">
<p>
进入 kernel mode 前, 硬件会保证:
</p>

<ol class="org-ol">
<li>esp 被切换为 kernel stack (通过 tss-&gt;esp0)</li>

<li>user mode 的 esp, eip, eflags 等被 push 到 kernel stack</li>

<li>检查 int 0x80 对应的 gate descriptor 的 DPL 与 xcs 的 CPL 一致</li>

<li>xcs 切换到 __KERNEL_CS (通过 date descriptor 的 segment selector) 以
进入 kernel mode</li>
</ol>

<p>
进入 kernel mode 后, system_call 被调用.
</p>
</div>

<div id="outline-container-org5bf0545" class="outline-6">
<h6 id="org5bf0545"><span class="section-number-6">1.3.1.3.1</span> system_call</h6>
<div class="outline-text-6" id="text-1-3-1-3-1">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">ENTRY</span>(system_call)
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#30340; pushl %eax &#23454;&#38469;&#19978;&#20462;&#25913;&#30340;&#26159; pt_regs-&gt;orig_eax, &#21518;&#32493;&#20250;&#26681;&#25454;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">orig_eax &#20540;&#21028;&#26029;&#24403;&#21069;&#26159;&#21542;&#26159;&#22312;&#25191;&#34892;&#19968;&#20010; syscall (&#20363;&#22914; handle_signal).</span>
    <span style="font-weight: bold; font-style: italic;">// </span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#32780; SAVE_ALL &#26102;&#20063;&#20250;&#20445;&#23384;&#19968;&#27425; %eax &#21040; pt_regs-&gt;eax..., &#36825;&#20004;&#20010; eax</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#30340;&#20316;&#29992;&#26159;?</span>
    <span style="font-weight: bold; font-style: italic;">// </span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">pt_regs-&gt;eax &#27599;&#27425; interrupt &#37117;&#20250;&#35774;&#32622;, &#36890;&#36807; pt_regs-&gt;eax &#26080;&#27861;&#21028;&#26029;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24403;&#21069;&#26159;&#21542;&#26159; syscall. &#36890;&#36807;&#21482;&#22312; system_call &#26102;&#35774;&#32622; orig_eax &#21487;&#20197;&#25226;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">orig_eax &#20570;&#25104; syscall &#30340;&#26631;&#35760; (&#22788;&#29702; irq &#26102;&#20063;&#20250; push &#19968;&#20010; orig_eax,</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20294;&#20026;&#19968;&#20010;&#36127;&#25968;, &#21487;&#20197;&#19982; syscall &#21306;&#20998;, &#20855;&#20307;&#21442;&#32771; do_IRQ)      </span>
    pushl %eax
    SAVE_ALL
    GET_THREAD_INFO(%ebp)
    <span style="font-weight: bold; text-decoration: underline;">call</span> *<span style="font-weight: bold;">sys_call_table</span>(,%eax,4)

    <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">&#22312;&#26631;&#20934;&#30340; c &#35843;&#29992;&#32422;&#23450;&#20013;,  eax &#20445;&#23384;&#20989;&#25968;&#30340;&#36820;&#22238;&#20540;, &#25152;&#20197; sys_clone &#36820;&#22238;&#21518;,</span><span style="font-weight: bold; font-style: italic;">  */</span>
    <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">eax &#20445;&#23384;&#36820;&#22238;&#20540; (&#23376;&#36827;&#31243; pid), &#19979;&#38754;&#30340; movl &#25351;&#20196;</span><span style="font-weight: bold; font-style: italic;"> */</span>
    <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">&#23558; eax &#20445;&#23384;&#22312; 24%(esp) &#22788;, &#21363; kernel stack &#20013;&#23545;&#24212;&#20110; SAVE_ALL &#26102; eax</span><span style="font-weight: bold; font-style: italic;"> */</span>
    <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">&#30340;&#20301;&#32622;, &#24403; syscall &#36820;&#22238;&#21040;&#29238;&#36827;&#31243;&#30340; user mode &#26102;, RESTORE_ALL &#20250;&#36890;&#36807; kernel stack</span><span style="font-weight: bold; font-style: italic;"> */</span>
    <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">&#24674;&#22797; eax, &#20174;&#32780;&#20351; user mode &#33021;&#25343;&#21040; sys_clone &#30340;&#36820;&#22238;&#20540;</span><span style="font-weight: bold; font-style: italic;"> */</span>
    movl %eax,EAX(%esp)

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35843;&#29992; RESTORE_ALL &#36820;&#22238;&#21069;&#21457;&#29616;&#26377;&#20854;&#23427;&#24037;&#20316;&#35201;&#20570;:  pending signal,</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">need_resched &#31561;, &#21017;&#36339;&#36716;&#21040; syscall_exit_work</span>
    <span style="font-weight: bold; text-decoration: underline;">movl</span> <span style="font-weight: bold;">TI_flags</span>(%ebp), %ecx
    testw $_TIF_ALLWORK_MASK, %cx       # current-&gt;work
    jne syscall_exit_work

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27809;&#26377;&#20854;&#23427;&#24037;&#20316;, &#30452;&#25509;&#35843;&#29992; RESTORE_ALL, &#36890;&#36807; iret &#36820;&#22238;</span>
    RESTORE_ALL

syscall_exit_work:
    movl TI_flags(%ebp), %ecx
    andl $_TIF_WORK_MASK, %ecx
    jne work_pending
    jmp restore_all
      RESTORE_ALL

work_pending:
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26816;&#26597; TIF_NEED_RESCHED</span>
    testb $_TIF_NEED_RESCHED, %cl
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#33509; TIF_NEED_RESCHED &#27809;&#26377;&#32622;&#20301;, &#36339;&#36716;&#21040; work_notifysig &#26816;&#26597;&#26159;&#21542;&#26377;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">pending signal, &#33509; TIF_NEED_RESCHED &#32622;&#20301;, &#35843;&#29992; schedule</span>
    jz work_notifysig
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21644;&#20449;&#21495;&#22788;&#29702;&#26377;&#20851;</span>
      do_signal
    call schedule
    jmp restore_all
</pre>
</div>
</div>
</div>

<div id="outline-container-org0cce7d4" class="outline-6">
<h6 id="org0cce7d4"><span class="section-number-6">1.3.1.3.2</span> SAVE_ALL</h6>
<div class="outline-text-6" id="text-1-3-1-3-2">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">#define</span> <span style="font-weight: bold; font-style: italic;">SAVE_ALL</span>                                \
    cld;                                        \
    pushl %es;                                  \
    pushl %ds;                                  \
    pushl %eax;                                 \
    pushl %ebp;                                 \
    pushl %edi;                                 \
    pushl %esi;                                 \
    pushl %edx;                                 \
    pushl %ecx;                                 \
    pushl %ebx;                                 \
    movl $(__USER_DS), %edx;                    \
    movl %edx, %ds;                             \
    movl %edx, %es;
</pre>
</div>

<p>
按照系统调用的约定, user mode 需要将 __NR__xxx 和所有参数依次放在 eax,
ebx, &#x2026; 中, 而 sys_clone 是一个标准的 c 函数, 会从 kernel stack 中取
参数, 所以在 sys_clone 之前, system_call 需要通过 SAVE_ALL 将 ebx,
ecx, &#x2026; 复制到 kernel stack 上
</p>
</div>
</div>

<div id="outline-container-org4b717d8" class="outline-6">
<h6 id="org4b717d8"><span class="section-number-6">1.3.1.3.3</span> RESTORE_ALL</h6>
<div class="outline-text-6" id="text-1-3-1-3-3">
<p>
RESTORE_ALL 与 SAVE_ALL 相反, 在 syscall 返回到 user mode 之前从 kernel
stack 恢复 ebx 等寄存器
</p>

<div class="org-src-container">
<pre class="src src-c">popl %ebx;      \
popl %ecx;      \
popl %edx;      \
popl %esi;      \
popl %edi;      \
popl %ebp;      \
popl %eax;  \
</pre>
</div>
</div>
</div>

<div id="outline-container-org43e6e7e" class="outline-6">
<h6 id="org43e6e7e"><span class="section-number-6">1.3.1.3.4</span> sys_clone</h6>
<div class="outline-text-6" id="text-1-3-1-3-4">
<p>
与一般 syscall 不同的是, sys_clone 的参数为 pt_regs 结构体, 实际上这个
结构体与 kernel stack 是对应的, pt_regs.ebx 即对应于 SAVE_ALL 时 pushl
的 ebx
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">pt_regs</span> {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20960;&#20010;&#23492;&#23384;&#22120;&#19982; SAVE_ALL &#26159;&#23545;&#24212;&#30340;</span>
    <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">ebx</span>;
    <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">ecx</span>;
    <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">edx</span>;
    <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">esi</span>;
    <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">edi</span>;
    <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">ebp</span>;
    <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">eax</span>;
    <span style="font-weight: bold; text-decoration: underline;">int</span>  <span style="font-weight: bold; font-style: italic;">xds</span>;
    <span style="font-weight: bold; text-decoration: underline;">int</span>  <span style="font-weight: bold; font-style: italic;">xes</span>;
    <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">orig_eax</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21518;&#38754;&#36825;&#20960;&#20010;&#23492;&#23384;&#22120;&#26159;&#21457;&#29983; interrupt &#26102;&#30828;&#20214;&#33258;&#21160;&#20445;&#23384;&#22312; kernel stack</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19978;&#30340;, &#20013;&#26029;&#32467;&#26463;&#26102; (&#25110; syscall &#36820;&#22238;&#21040; user mode &#26102;) iret &#20250;&#36127;&#36131;&#23558;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">kernel stack &#20013;&#30340;&#36825;&#20123;&#20869;&#23481;&#24674;&#22797;&#21040; user mode &#30456;&#24212;&#30340;&#23492;&#23384;&#22120;&#20013;.</span>
    <span style="font-weight: bold; font-style: italic;">//</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21478;&#22806;, &#36890;&#36807;&#26597;&#30475; pt_regs &#20013; xcs &#30340;&#20540;, interrupt handler &#21487;&#20197;&#21028;&#26029;&#20986;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">interrupt &#26102;&#31995;&#32479;&#26159;&#21542;&#26159;&#22788;&#20110; user mode &#25110; kernel mode (&#21442;&#32771;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">user_mode &#20989;&#25968;)</span>
    <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">eip</span>;
    <span style="font-weight: bold; text-decoration: underline;">int</span>  <span style="font-weight: bold; font-style: italic;">xcs</span>;
    <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">eflags</span>;
    <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">esp</span>;
    <span style="font-weight: bold; text-decoration: underline;">int</span>  <span style="font-weight: bold; font-style: italic;">xss</span>;
};
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">sys_clone</span>(<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">pt_regs</span> <span style="font-weight: bold; font-style: italic;">regs</span>):
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> clone_flags;
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">newsp</span>;
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">__user</span> *parent_tidptr, *<span style="font-weight: bold; font-style: italic;">child_tidptr</span>;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">regs.ebx &#23545;&#24212;&#20110; kernel stack &#19978;&#19968;&#22359;&#21306;&#22495;, &#36825;&#20010;&#21306;&#22495;&#30340;&#20540;&#20043;&#21069;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22312; SAVE_ALL &#26102;&#34987;&#36171;&#20540;&#20026; ebx, &#36861;&#28335;&#21040; user mode &#30340; fork &#23454;&#38469;&#23601;&#26159; FORK_FLAGS</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#21442;&#25968;</span>
    clone_flags = regs.ebx;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21516;&#29702;, regs.ecx &#23545;&#24212; clone &#30340;&#31532;&#20108;&#20010;&#21442;&#25968; child_stack NULL</span>
    newsp = regs.ecx;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">edx &#23545;&#24212;&#20110; ptid</span>
    parent_tidptr = (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">__user</span> *)regs.edx;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">edi &#23545;&#24212;&#20110; ctid</span>
    child_tidptr = (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">__user</span> *)regs.edi;
    <span style="font-weight: bold;">if</span> (!newsp)
        newsp = regs.esp;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">regs &#20316;&#20026; do_fork &#30340;&#21442;&#25968;, &#21518;&#38754; do_fork &#20250;&#22312; copy_thread &#26102;&#20351;&#29992;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">regs &#26469;&#21021;&#22987;&#21270;&#23376;&#36827;&#31243;&#30340; kernel stack</span>
    <span style="font-weight: bold;">return</span> do_fork(clone_flags, newsp, &amp;regs, 0, parent_tidptr, child_tidptr);
</pre>
</div>
</div>
</div>

<div id="outline-container-orge3b6bf8" class="outline-6">
<h6 id="orge3b6bf8"><span class="section-number-6">1.3.1.3.5</span> do_fork</h6>
<div class="outline-text-6" id="text-1-3-1-3-5">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">do_fork</span>:
  <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">pid</span> = alloc_pidmap();
  p = copy_process(clone_flags, stack_start, regs, stack_size,
                   parent_tidptr, child_tidptr, pid);
    p = dup_task_struct(current);
    <span style="font-weight: bold;">copy_files</span>(clone_flags, p)
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22788;&#29702; CLONE_FILES</span>
    <span style="font-weight: bold;">copy_fs</span>(clone_flags, p)
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22788;&#29702; CLONE_FS</span>
    <span style="font-weight: bold;">copy_sighand</span>(clone_flags, p)
    <span style="font-weight: bold;">copy_signal</span>(clone_flags, p)
    <span style="font-weight: bold;">copy_mm</span>(clone_flags, p)
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">CLONE_VM</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">....</span>
    copy_thread(0, clone_flags, stack_start, stack_size, p, regs);
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22797;&#21046; kernel stack</span>
      childregs = ((<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">pt_regs</span> *) (THREAD_SIZE + (<span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span>) p-&gt;thread_info)) - 1;
      *childregs = *regs;
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20294; kernel stack &#20013;&#23545;&#24212; eax &#30340;&#37096;&#20998;&#24378;&#21046;&#20026; 0, &#22240;&#20026;&#23545;&#23376;&#36827;&#31243;&#26469;&#35828;, fork &#30340;&#36820;&#22238;&#20540;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24212;&#35813;&#20026; 0, &#32780;&#31995;&#32479;&#35843;&#29992;&#30340;&#36820;&#22238;&#20540;&#26159;&#25918;&#22312; eax &#20013;&#30340;. &#21518;&#38754; RESTORE_ALL &#20351;&#29992; kernel stack</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24674;&#22797; eax &#20174;&#32780;&#20351;&#23427;&#20026; 0</span>
      childregs-&gt;eax = 0;
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19978;&#23618;&#20256;&#36807;&#26469;&#30340; start_stack &#22312;&#36825;&#37324;&#34987;&#36171;&#32473; childregs-&gt;esp, &#38543;&#21518; child &#34987;&#35843;&#24230;&#26102;,</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">iret &#20250;&#23548;&#33268; user mode &#30340; esp &#34987;&#24674;&#22797;&#20026; stack_start</span>
      childregs-&gt;esp = stack_start;
      p-&gt;thread.esp = (<span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span>) childregs;
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">eip &#35774;&#32622;&#20026; ret_from_fork, &#21518;&#38754; switch_to &#26102;&#23545;&#23376;&#36827;&#31243;&#26469;&#35828;&#20250;&#25191;&#34892; ret_from_fork</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20063;&#26159;&#23569;&#25968;&#30340; thread.eip &#19981;&#31561;&#20110; switch_to:label 1 &#30340;&#24773;&#20917;</span>
      p-&gt;thread.eip = (<span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span>) ret_from_fork;
  <span style="font-weight: bold;">wake_up_new_task</span>(p, clone_flags);
  <span style="font-weight: bold;">return</span> pid;
</pre>
</div>
</div>
</div>

<div id="outline-container-org4aa39d1" class="outline-6">
<h6 id="org4aa39d1"><span class="section-number-6">1.3.1.3.6</span> ret_from_fork</h6>
<div class="outline-text-6" id="text-1-3-1-3-6">
<p>
ret_from_fork 会调用 RESTORE_ALL 然后 iret 返回到 user mode
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org2b36a4e" class="outline-4">
<h4 id="org2b36a4e"><span class="section-number-4">1.3.2</span> 关于系统调用 (syscall)</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
系统调用的过程在前面介绍 fork 的时候已经比较详细, 下面再总结一下:
</p>
</div>

<div id="outline-container-orged48261" class="outline-5">
<h5 id="orged48261"><span class="section-number-5">1.3.2.1</span> syscall 的过程</h5>
<div class="outline-text-5" id="text-1-3-2-1">
<ol class="org-ol">
<li>system call 首先是一个 interrupt, 所以硬件会先走正常 interrupt 的流
程

<ol class="org-ol">
<li>从 idt 中找到 gate descriptor, 判断 xcs 的 CPL 与对应的 system
gate 的 DPL 是否一致, 对 system call 来说, CPL 为 3, gate DPL 也
为 3, 所以是一致的</li>

<li>比较 xcs 的 CPL 与 system gate 中指定的 segment descriptor 的
DPL 是否一致, 对于 system call 来说, xcs 对应的是 __USER_CS, 而
segment descriptor 对应的是 __KERNEL_CS, 所以是不一致的, 这时会
发生 stack 的切换

<ul class="org-ul">
<li>先从 tss-&gt;esp0 获得 kernel stack 的 esp, 切换到 kernel stack</li>

<li>保存 ss, esp 到 kernel stack</li>
</ul></li>

<li>如果 interrupt 的原因是 fault (例如 page fault), 这时会将 eip 修
改为导致 fault 的指令的地址, 因为导致 fault 的代码需要在 interrupt
结束后重新开始, 对于 system call 来说, 并不需要这一步</li>

<li>保存 user mode 的 eip, xcs, eflags  到 kernel stack, 其中, 针对
interrupt 的类型: trap, fault, abort, 保存的 eip 会有差别</li>

<li>从 gate descriptor 中加载 kernel mode xcs (实际上就是__KERNEL_CS),
以及对应 handler 的 eip (system_call), 从而切换到 kernel mode 并
执行 system_call</li>
</ol></li>

<li>system_call 会通过 SAVE_ALL 将 eax, ebx, ecx, edx, esi, edi, ebp 六
个寄存器 push 到 kernel stack 上</li>

<li>根据 eax 的值 call 相应的 sys_xxx</li>

<li>sys_xxx 会从 kernel stack 上取参数并执行</li>

<li>sys_xxx 返回后 system_call 负责将用 eax 的值覆盖 kernel stack 上对
应 eax 的位置</li>

<li>RESTORE_ALL 会用 kernel stack 来恢复前面的六个寄存器</li>

<li>执行 iret 指令

<ol class="org-ol">
<li>恢复 eip, xcs, eip  寄存器, 由于 xcs 被恢复为 user mode 的 xcs, 所以返回到 user mode</li>

<li>检查 CPL 与 system gate 中的 segment descriptor 的 DPL 是否一致,
对 system call 来说, 必然是不一致的, 这里需要从 kernel stack 中
恢复 ss 和 esp</li>
</ol></li>
</ol>
</div>
</div>

<div id="outline-container-org12db36b" class="outline-5">
<h5 id="org12db36b"><span class="section-number-5">1.3.2.2</span> 64bit 上的 syscall</h5>
<div class="outline-text-5" id="text-1-3-2-2">
<p>
需要注意的是 64 位系统上 syscall 的定义与 32 位是不一样的, 例如
</p>

<ol class="org-ol">
<li>__NR_read 在 32 位上是 3, 在 64 位上是 0</li>

<li>有些系统调用只存在于 64 位上, 例如 sys_pread64</li>
</ol>

<p>
但是对于同样是 32 位的 x86, arm, &#x2026; 等, syscall 的定义是一样的
</p>

<p>
详细的差别参考:
</p>

<ol class="org-ol">
<li><a href="http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html">http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html</a></li>

<li><a href="http://blog.rchapman.org/post/36801038863/linux-system-call-table-for-x86-64">http://blog.rchapman.org/post/36801038863/linux-system-call-table-for-x86-64</a></li>

<li><a href="https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_64.tbl">https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_64.tbl</a></li>
</ol>
</div>

<div id="outline-container-org1d209d8" class="outline-6">
<h6 id="org1d209d8"><span class="section-number-6">1.3.2.2.1</span> x86_64 如何同时兼容 32 位和 64 的 syscall</h6>
<div class="outline-text-6" id="text-1-3-2-2-1">
<p>
由于 x86_64 指令是兼容 x86 指令的, 所以 32 位的程序的用户态部分可以直
接在 64 位上执行, 但 32 位程序在调用 syscall 时会有问题, 因为 32 位和
64 位对 syscall 的定义是不同的, 因此需要针对 32 位程序额外提供一张
sys_call_table: 32 位使用 ia32_sys_call_table, 64 位使用
sys_call_table
</p>

<p>
但有一个问题: int 0x80 对应的 interrupt handler 如何能区分使用哪张
sys_call_table?
</p>

<p>
实际上, 在 x86_64 上, int 0x80 注册的 interrupt handler 会直接调用
ia32_sys_call_table, 因为 64 位的程序是不会通过 int 0x80 发起 syscall
的, 它们会通过 syscall 这个指令, 而 syscall 指令会根据 MSR 寄存器的值
找到对应的 sys_call_table. <a href="https://lwn.net/Articles/604515/">Anatomy of a system call</a>
</p>
</div>

<ol class="org-ol">
<li><a id="orgd175666"></a>sys_call_table 的初始化<br />
<div class="outline-text-7" id="text-1-3-2-2-1-1">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">syscall_init</span>:
  <span style="font-weight: bold;">wrmsrl</span>(MSR_LSTAR, system_call);

<span style="font-weight: bold;">ENTRY</span>(system_call):
  andl $__SYSCALL_MASK,%eax                  
  call *sys_call_table(,%rax,8)

<span style="font-weight: bold; text-decoration: underline;">sys_call_table</span>[__NR_syscall_max+1] = { 
<span style="font-weight: bold;">  #define</span> <span style="font-weight: bold; font-style: italic;">__NR_read</span>    0
  __SYSCALL(__NR_read, sys_read)
<span style="font-weight: bold;">  #define</span> <span style="font-weight: bold; font-style: italic;">__NR_write</span>   1
  __SYSCALL(__NR_write, sys_write)
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">...      </span>
};
</pre>
</div>
</div>
</li>

<li><a id="org6227fb2"></a>ia32_sys_call_table 的初始化<br />
<div class="outline-text-7" id="text-1-3-2-2-1-2">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">trap_init</span>:
  <span style="font-weight: bold;">set_system_gate</span>(IA32_SYSCALL_VECTOR, ia32_syscall);

<span style="font-weight: bold;">ENTRY</span>(ia32_syscall):
  call *ia32_sys_call_table(,%rax,8)

ia32_sys_call_table:
  .quad sys_restart_syscall
  .quad sys_exit
  .quad stub32_fork
  .quad sys_read                   
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org7a503dd" class="outline-6">
<h6 id="org7a503dd"><span class="section-number-6">1.3.2.2.2</span> x86_64 上的 x32 ABI 与 syscall</h6>
<div class="outline-text-6" id="text-1-3-2-2-2">
<p>
Kernel 支持一种称为 x32 的 ABI, 这种 ABI 可以利用 64 位的优点(更多的寄
存器, 使用寄存器传递参数, 更快的系统调用&#x2026;), 但使用 32 位的指针和
long 类型, 避免 64 位指针的开销. <a href="https://zh.wikipedia.org/wiki/X32_ABI">https://zh.wikipedia.org/wiki/X32_ABI</a>
<a href="https://lwn.net/Articles/456731/">The x32 system call ABI</a>
</p>

<p>
X32 ABI 需要编译器, libc 和 Kernel 的支持, 其中 libc 中通过 <span class="underline"><span class="underline">ILP32</span></span>
(Int, Long, Pointer 32 bit) 表示使用 X32 ABI (与 <span class="underline"><span class="underline">ILP32</span></span> 相对的
是__LP64__, 即 Long Pointer 64 bit, 这是 x86_64 标准的模式)
</p>

<p>
Kernel Kernel 如何知道当前进程是使用的 X32 ABI? 通过在发起 syscall 时使用的
syscall number 上做标记:
</p>

<ol class="org-ol">
<li><p>
libc 使用 <span class="underline"><span class="underline">ILP32</span></span> 时发起 syscall
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">#ifdefined</span>(__ILP32__)
<span style="font-weight: bold;">  #include</span> <span style="font-style: italic;">&lt;asm/unistd_x32.h&gt;</span>
<span style="font-weight: bold;">#else</span>
<span style="font-weight: bold;">  #include</span> <span style="font-style: italic;">&lt;asm/unistd_64.h&gt;</span>
<span style="font-weight: bold;">#endif</span>

unistd_x32.<span style="font-weight: bold; text-decoration: underline;">h</span>:
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20854;&#20013; __X32_SYSCALL_BIT &#20026; 0x40000000, &#21363; bit 31     </span>
<span style="font-weight: bold;">#define</span> <span style="font-weight: bold; font-style: italic;">__NR_read</span> (__X32_SYSCALL_BIT + 0)
<span style="font-weight: bold;">#define</span> <span style="font-weight: bold; font-style: italic;">__NR_write</span> (__X32_SYSCALL_BIT + 1)
</pre>
</div></li>

<li><p>
64 位 kernel 响应 syscall
</p>

<p>
由于 X32 ABI 下 syscall number 有额外的置位, 所以 syscall 时需要将
它们 mask 掉
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">system_call</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">__SYSCALL_MASK &#20026; (~(__X32_SYSCALL_BIT))  </span>
  andl $__SYSCALL_MASK,%eax
  call *sys_call_table(,%rax,8)
</pre>
</div></li>

<li><p>
kernel 使用 rax 的 __X32_SYSCALL_BIT 判断是否是 X32 ABI
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">is_compat_task</span>:
  <span style="font-weight: bold;">return</span> is_ia32_task() || is_x32_task();

<span style="font-weight: bold; text-decoration: underline;">is_x32_task</span>:
  <span style="font-weight: bold;">if</span> (task_pt_regs(current)-&gt;orig_ax &amp; __X32_SYSCALL_BIT):
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>;
  <span style="font-weight: bold;">else</span>:
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;  
</pre>
</div></li>
</ol>
</div>
</div>
</div>

<div id="outline-container-orgcc67565" class="outline-5">
<h5 id="orgcc67565"><span class="section-number-5">1.3.2.3</span> sysenter, syscall, vsyscall</h5>
<div class="outline-text-5" id="text-1-3-2-3">
<p>
vsyscall page 和一块特殊的 page: 这个 page 是由 kernel 分配的, 并映射
到所有进程的同一块虚拟地址空间.
</p>
</div>

<div id="outline-container-orgfc94c75" class="outline-6">
<h6 id="orgfc94c75"><span class="section-number-6">1.3.2.3.1</span> x86_32 下 vsyscall page 的初始化</h6>
<div class="outline-text-6" id="text-1-3-2-3-1">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">sysenter_setup</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20998;&#37197;&#19968;&#20010; page  </span>
  <span style="font-weight: bold; text-decoration: underline;">void</span> *<span style="font-weight: bold; font-style: italic;">page</span> = (<span style="font-weight: bold; text-decoration: underline;">void</span> *)<span style="font-weight: bold;">get_zeroed_page</span>(GFP_ATOMIC);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36890;&#36807; fixmap &#26144;&#23556;, &#24182;&#19988;&#25351;&#23450; page &#30340;&#26435;&#38480;&#20026; PAGE_READONLY_EXEC, &#21518;&#32773;&#20855;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20307;&#20026;: __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED),</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">_PAGE_USER &#36825;&#20010; flag &#34920;&#31034;&#36825;&#20010; page &#26159;&#21487;&#20197;&#34987; user mode &#35775;&#38382;&#30340;</span>
  <span style="font-weight: bold; font-style: italic;">// </span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">FIX_VSYSCALL &#36825;&#20010; fixmap &#23545;&#24212;&#30340;&#29289;&#29702;&#22320;&#22336;&#21363;&#26159; 0xffffe000</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">(VSYSCALL_BASE):</span>
  <span style="font-weight: bold; font-style: italic;">// </span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">#define VSYSCALL_BASE      (__fix_to_virt(FIX_VSYSCALL))  </span>
  <span style="font-weight: bold;">__set_fixmap</span>(FIX_VSYSCALL, <span style="font-weight: bold; text-decoration: underline;">__pa</span>(<span style="font-weight: bold; font-style: italic;">page</span>), PAGE_READONLY_EXEC);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524; CPU &#19981;&#25903;&#25345; sysenter/sysexit, &#21017;&#23558; vsyscall_int80_start &#22788;&#30340;&#20195;&#30721;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22797;&#21046;&#21040;&#36825;&#20010; page, &#21542;&#21017;&#23558; vsyscall_sysenter_start &#22788;&#30340;&#20195;&#30721;&#22797;&#29616;&#36807;&#26469;  </span>
  <span style="font-weight: bold;">if</span> (!boot_cpu_has(X86_FEATURE_SEP)):
    memcpy(page,&amp;vsyscall_int80_start,&amp;vsyscall_int80_end - &amp;vsyscall_int80_start);
    <span style="font-weight: bold;">return</span> 0;

  <span style="font-weight: bold;">memcpy</span>(page,&amp;vsyscall_sysenter_start,&amp;vsyscall_sysenter_end - &amp;vsyscall_sysenter_start);

  <span style="font-weight: bold;">on_each_cpu</span>(enable_sep_cpu, <span style="font-weight: bold; text-decoration: underline;">NULL</span>, 1, 1);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25351;&#23450;&#20102; sysenter &#23545;&#24212;&#30340;&#22788;&#29702;&#20989;&#25968;(&#31867;&#20284;&#20110; syscall &#36825;&#20010; entry):</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">sysenter_entry    </span>
    <span style="font-weight: bold;">wrmsr</span>(MSR_IA32_SYSENTER_EIP, (<span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span>) sysenter_entry, 0);
</pre>
</div>
</div>
</div>

<div id="outline-container-org3017c8f" class="outline-6">
<h6 id="org3017c8f"><span class="section-number-6">1.3.2.3.2</span> vsyscall page 的内容</h6>
<div class="outline-text-6" id="text-1-3-2-3-2">
<p>
vsyscall page 被映射到的 fixmap (FIX_VSYSCALL) 的虚拟地址固定为
0xffffe000 (VSYSCALL_BASE), 通过 maps 可以看到:
</p>


<div id="orgd0d1ad9" class="figure">
<p><img src="../extra/kernel_vdso.png" alt="kernel_vdso.png" />
</p>
</div>

<p>
maps 显示的 [vdso] 部分大小为 4k, 刚好为一个 page.
</p>

<p>
用 ldd 命令查看对应的 elf 文件:
</p>

<pre class="example" id="org47e3e6f">
linux-gate.so.1 =&gt;  (0xffffe000)
libc.so.6 =&gt; /lib/tls/i686/cmov/libc.so.6 (0xb7e45000)
/lib/ld-linux.so.2 (0xb7f7a000)
</pre>

<p>
其中的 linux-gate.so.1 (也可能叫 linux-vdso.so.1) 是一个虚拟的 so, 对
应于前面提到的 vsyscall page.
</p>

<p>
通过下面的测试程序可以把这个 page dump 出来 (也可以用 gdb 的 dump
memory 命令):
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;unistd.h&gt;</span>
<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;string.h&gt;</span>

<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">main</span>() {
    <span style="font-weight: bold; text-decoration: underline;">char</span> *<span style="font-weight: bold; font-style: italic;">p</span> = (<span style="font-weight: bold; text-decoration: underline;">char</span> *) 0xffffe000;
    <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">buf</span>[4096];
    memcpy(buf, p, 4096);
    write(1, buf, 4096);
    <span style="font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
察看 dump 出来的 page 的内容:
</p>

<pre class="example" id="org6eeedae">
$&gt; file syspage
syspage: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, stripped

$&gt; objdump -d syspage

syspage:     file format elf32-i386


Disassembly of section .text:

ffffe400 &lt;__kernel_vsyscall@@LINUX_2.5&gt;:
ffffe400:	51                   	push   %ecx
ffffe401:	52                   	push   %edx
ffffe402:	55                   	push   %ebp
ffffe403:	89 e5                	mov    %esp,%ebp
ffffe405:	0f 34                	sysenter 
ffffe407:	90                   	nop
ffffe408:	90                   	nop
ffffe409:	90                   	nop
ffffe40a:	90                   	nop
ffffe40b:	90                   	nop
ffffe40c:	90                   	nop
ffffe40d:	90                   	nop
ffffe40e:	eb f3                	jmp    ffffe403 &lt;__kernel_vsyscall@@LINUX_2.5+0x3&gt;
ffffe410:	5d                   	pop    %ebp
ffffe411:	5a                   	pop    %edx
ffffe412:	59                   	pop    %ecx
ffffe413:	c3                   	ret    
	...

ffffe420 &lt;__kernel_sigreturn@@LINUX_2.5&gt;:
ffffe420:	58                   	pop    %eax
ffffe421:	b8 77 00 00 00       	mov    $0x77,%eax
ffffe426:	cd 80                	int    $0x80

ffffe440 &lt;__kernel_rt_sigreturn@@LINUX_2.5&gt;:
ffffe440:	b8 ad 00 00 00       	mov    $0xad,%eax
ffffe445:	cd 80                	int    $0x80
ffffe447:	90                   	nop

</pre>

<p>
显示这个 page 实际是包含一个 elf, 其中定义了三个函数:
</p>

<ol class="org-ol">
<li>__kernel_vsyscall</li>

<li>__kernel_sigreturn</li>

<li>__kernel_rt_sigreturn</li>
</ol>

<p>
其中后两个与信号的处理有关 (参考<a href="signal.html#org9076922">_kernel_sigreturn</a>), 第一个
__kernel_vsyscall 和 syscall 有关
</p>
</div>
</div>

<div id="outline-container-org694a6f9" class="outline-6">
<h6 id="org694a6f9"><span class="section-number-6">1.3.2.3.3</span> __kernel_vsyscall</h6>
<div class="outline-text-6" id="text-1-3-2-3-3">
<p>
vsyscall 的想法是这样的: x86 上最初通过 int 0x80 指令发起 syscall, 但
这种做法需要 CPU 做无谓的 ring 检查和切换, 所以后来 CPU 提供了一个
sysenter 指令来代替 int 0x80. 那么 libc 怎么知道当前 CPU 是否支持
sysenter?
</p>

<p>
为了简化 libc 的工作, kernel 提供了一个 __kernel_vsyscall 函数放在
vsyscall page, 确切的说, 就是 0xffffe400 这个地址. sysenter_setup 时会
根据 CPU 的情况向这个地址写入对应于 sysenter 或 int 的指令, libc 在发
起 syscall 时只需要 call 0xffffe400 就可以了.
</p>

<p>
需要注意的是 x86_64 下 vsyscall page 中并不存在 __kernel_vsyscall,因为
x86_64 提供了一个 `syscall` 指令, 不再需要 int 0x80 或 sysenter
</p>
</div>
</div>

<div id="outline-container-orgd425706" class="outline-6">
<h6 id="orgd425706"><span class="section-number-6">1.3.2.3.4</span> 更底什么是 vsyscall</h6>
<div class="outline-text-6" id="text-1-3-2-3-4">
<p>
__kernel_vsyscall 并不是 vsyscall. 无论使用 __kernel_vsyscall 还是使用
x86_64 上更快的 `syscall` 指令, 在进行 syscall 都无法避免 user mode 与
kernel mode 的切换.
</p>

<p>
那么能否更快一些, 直接避免这种切换呢?
</p>

<p>
vsyscall (virtual syscall) 就是这么一种机制. 以 gettimeofday 为例, 采
用 vsyscall 调用 gettimeofday 的流程是:
</p>

<ol class="org-ol">
<li>kernel 每次 update tick 时, 会向 vsyscall page 的特定区域写入当前的
时间</li>

<li>当上层发起 gettimeofday syscall 时, libc 会像调用 __kernel_vsyscall
一样调用 vgettimeofday</li>

<li>vgettimeofday 与 __kernel_vsyscall 一样存在于 vsyscall page 中, 这
个函数只是简单的读一下 vsyscall page 中的那个时间</li>
</ol>

<p>
实际上, x86_32 上并没有 vsyscall, x86_64 上才有&#x2026;所以前面 dump
syspage 时并没有找到 vgettimeofday.
</p>

<p>
x86_64 上关于 vsyscall 的代码主要在 arch/x86_64/kernel/vsyscall.c 中
</p>
</div>
</div>

<div id="outline-container-org4a720cb" class="outline-6">
<h6 id="org4a720cb"><span class="section-number-6">1.3.2.3.5</span> libc 如何知道 __kernel_vsyscall, vgettimeofday 这些函数在 vsyscall page 中的地址?</h6>
<div class="outline-text-6" id="text-1-3-2-3-5">
</div>
<ol class="org-ol">
<li><a id="org2c8e870"></a>__kernel_vsyscall<br />
<div class="outline-text-7" id="text-1-3-2-3-5-1">
<ol class="org-ol">
<li><p>
kernel 将 __kernel_vsyscall 的地址放在 elf 的 aux vector 中
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">do_execve</span>:
  <span style="font-weight: bold; text-decoration: underline;">create_elf_tables</span>:
    <span style="font-weight: bold; text-decoration: underline;">ARCH_DLINFO</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">VSYSCALL_ENTRY &#21363;&#20026; __kernel_vsyscall &#30340;&#22320;&#22336;: 0xffffe400</span>
      <span style="font-weight: bold;">NEW_AUX_ENT</span>(AT_SYSINFO,   VSYSCALL_ENTRY);
</pre>
</div></li>

<li>libc 从 aux vector 中取出 __kernel_vsyscall 的地址</li>
</ol>
</div>
</li>

<li><a id="org3c9cb64"></a>vgettimeofday<br />
<div class="outline-text-7" id="text-1-3-2-3-5-2">
<p>
vsyscall 实际上只支持三个 syscall:
</p>

<ol class="org-ol">
<li>gettimeofday</li>

<li>getcpu</li>

<li>time</li>
</ol>

<p>
这三个 syscall 对应的 vsyscall page 中的 vgettimeofday, vgetcpu 以及
vtime 的地址是固定的&#x2026;
</p>

<p>
glibc 中关于 __gettimeofday 的代码:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">#define</span> <span style="font-weight: bold; font-style: italic;">VSYSCALL_ADDR_vgettimeofday</span>     0xffffffffff600000
<span style="font-weight: bold;">ENTRY</span> (__gettimeofday):
  movq  $VSYSCALL_ADDR_vgettimeofday, %rax
  callq *%rax
  ...  
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org4b76037" class="outline-6">
<h6 id="org4b76037"><span class="section-number-6">1.3.2.3.6</span> VDSO</h6>
<div class="outline-text-6" id="text-1-3-2-3-6">
<p>
vsyscall page 被映射到固定的地址 (例如 x86_32 上的 0xffffe000, x86_64
上的 0xffffffffff600000), 所以存在安全问题. 因此 kernel 又采用了一种称为
vdso 的机制来代替 vsyscall.
</p>

<p>
vdso 可以被加载到非固定的位置, 所以通过它来实现 __kernel_vsyscall 和
vgettimeofday 会更安全. 但 vsyscall page 中的 __kernel_sigreturn 函数
由于信号处理的特殊要求无法像 __kernel_vsyscall 那样被动态加载到非固定
的地址, 所以 vdso 与 vsyscall page 是并存的. 在最新的 linux 4.6 x86_64
上可以看到两者共存的情况:
</p>

<pre class="example" id="orgaa84352">
...
7ffd165e0000-7ffd16601000 rw-p 00000000 00:00 0                          [stack]
7ffd1668c000-7ffd1668f000 r--p 00000000 00:00 0                          [vvar]
7ffd1668f000-7ffd16691000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]
</pre>
</div>
</div>

<div id="outline-container-org4af85a2" class="outline-6">
<h6 id="org4af85a2"><span class="section-number-6">1.3.2.3.7</span> See also</h6>
<div class="outline-text-6" id="text-1-3-2-3-7">
<p>
<a href="http://www.ibm.com/developerworks/cn/linux/kernel/l-k26ncpu/index.html">Linux 2.6 对新型 CPU 快速系统调用的支持</a>
</p>

<p>
<a href="https://www.win.tue.nl/~aeb/linux/lk/lk-4.html">https://www.win.tue.nl/~aeb/linux/lk/lk-4.html</a>
</p>

<p>
<a href="http://www.lenky.info/archives/2013/02/2199">http://www.lenky.info/archives/2013/02/2199</a>
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb49adc0" class="outline-4">
<h4 id="orgb49adc0"><span class="section-number-4">1.3.3</span> Kernel Thread</h4>
<div class="outline-text-4" id="text-1-3-3">
</div>
<div id="outline-container-orgb04f3fe" class="outline-5">
<h5 id="orgb04f3fe"><span class="section-number-5">1.3.3.1</span> Overview</h5>
<div class="outline-text-5" id="text-1-3-3-1">
<p>
Kernel thread 与普通 task 一样, 也是通过 fork 创建的, 有相应的
task_struct 结构, 与普通 task 一样进行调度&#x2026;等, 但也有它特殊的地方:
</p>

<ol class="org-ol">
<li>kernel thread 只会在 kernel mode 执行, 它永远不会 "返回" 到 user
mode</li>

<li>它只会访问高 1G 的内存, 即它只会使用页表中对应高 1G 的部分</li>

<li>kernel thread 没有任何 vma, 所以 task_struct-&gt;mm 为 NULL, 但 kernel
thread 还是需要使用页表的 (mm-&gt;pgd), 所以它虽然没有 mm, 但会通过
task_struct-&gt;active_mm "借用" switch_to 的前一个进程的页表, 以避免
TLB flush</li>
</ol>
</div>
</div>

<div id="outline-container-orgc789bdd" class="outline-5">
<h5 id="orgc789bdd"><span class="section-number-5">1.3.3.2</span> 创建 kernel thread</h5>
<div class="outline-text-5" id="text-1-3-3-2">
</div>
<div id="outline-container-orgdcc59cc" class="outline-6">
<h6 id="orgdcc59cc"><span class="section-number-6">1.3.3.2.1</span> kernel_thread</h6>
<div class="outline-text-6" id="text-1-3-3-2-1">
<p>
kernel thread 与普通进程一样, 也是通过 do_fork 创建的, 但有些差别
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">kernel_thread</span>:
  <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">pt_regs</span> <span style="font-weight: bold; font-style: italic;">regs</span>;
  memset(&amp;regs, 0, <span style="font-weight: bold;">sizeof</span>(regs));

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21518;&#38754;&#30340; kernel_thread_helper &#20250;&#20351;&#29992;&#36825;&#20004;&#20010;&#20540;</span>
  regs.ebx = (<span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span>) fn;
  regs.edx = (<span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span>) arg;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22312;&#36825;&#37324;&#20462;&#25913;&#20102; regs.eip &#21644; regs.xcs, &#24403; do_fork &#20986;&#26469;&#30340;&#23376;&#36827;&#31243;&#36890;&#36807;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">ret_from_fork &#36820;&#22238;&#26102;, interrupt &#30340;&#36890;&#29992;&#20195;&#30721;&#20250;&#20351;&#29992; regs &#24674;&#22797; eip, xcs,</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">esp..., &#23545;&#20110; syscall &#26469;&#35828;, &#36825;&#37096;&#20998;&#25805;&#20316;&#30456;&#24403;&#20110;"&#36820;&#22238; user mode", &#20294;&#23545;&#20110;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">kernel_thread &#26469;&#35828;, &#36825;&#19968;&#27493;&#25805;&#20316;&#20250;&#23548;&#33268;&#25191;&#34892;&#36335;&#24452;&#36339;&#36716;&#21040; kernel thread &#30340;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">fn</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">regs.xcs &#20026; __KERNEL_CS, &#34920;&#26126; kernel thread &#36816;&#34892;&#22312; kernel mode</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">regs.esp &#36825;&#37324;&#24182;&#27809;&#26377;&#29305;&#21035;&#36171;&#20540;, &#26159;&#22240;&#20026; iret &#26102;&#22240;&#20026; regs.xcs &#25552;&#21069;&#24050;&#32463;&#20462;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25913;&#20026; __KERNEL_CS, &#23548;&#33268; cpu &#35748;&#20026;&#26412;&#27425; interrupt &#24182;&#27809;&#26377;&#21457;&#29983; stack &#30340;&#20999;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25442;, &#25152;&#20197; esp &#22312; iret &#26102;&#24182;&#19981;&#38656;&#35201;&#20999;&#25442;&#20026; regs.esp, &#20855;&#20307;&#21442;&#32771;[[*&#20851;&#20110;&#31995;&#32479;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35843;&#29992;][&#20851;&#20110;&#31995;&#32479;&#35843;&#29992;]] &#30340;&#31532; 2 &#28857;</span>
  regs.eip = (<span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span>) kernel_thread_helper;
  regs.xcs = __KERNEL_CS;
  regs.eflags = X86_EFLAGS_IF | X86_EFLAGS_SF | X86_EFLAGS_PF | 0x2;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">do_fork &#30340;&#31532;&#20108;&#20010;&#21442;&#25968;&#20026; stack_start, &#36825;&#37324;&#20026; 0, &#25152;&#20197; ret_from_fork &#26102;,</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">regs.esp &#20250;&#34987;&#20462;&#25913;&#20026; 0, &#20294;&#24182;&#27809;&#26377;&#20160;&#20040;&#29992;, &#22240;&#20026; iret &#26102;&#24182;&#19981;&#20250;&#36890;&#36807;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">regs.esp &#24674;&#22797; esp</span>
  <span style="font-weight: bold;">return</span> do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &amp;regs, 0, <span style="font-weight: bold; text-decoration: underline;">NULL</span>, <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="orgc62c701"></a>kernel_thread_helper<br />
<div class="outline-text-7" id="text-1-3-3-2-1-1">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">__asm__</span>(
    <span style="font-style: italic;">".section .text\n"</span>
    <span style="font-style: italic;">"kernel_thread_helper:\n\t"</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">kernel_thread_helper &#34987;&#35843;&#29992;&#26102;, ebx, edx &#24050;&#32463;&#36890;&#36807; RESTORE_ALL &#24674;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22797;&#20026; regs &#20013;&#30340;&#20540;</span>
    <span style="font-style: italic;">"pushl %edx\n\t"</span>
    <span style="font-style: italic;">"call *%ebx\n\t"</span>
    <span style="font-style: italic;">"pushl %eax\n\t"</span>
    <span style="font-style: italic;">"call do_exit\n"</span>
    );
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-orgb411926" class="outline-6">
<h6 id="orgb411926"><span class="section-number-6">1.3.3.2.2</span> kthread_create</h6>
<div class="outline-text-6" id="text-1-3-3-2-2">
<p>
kernel thread 是通过 fork 创建的, 那么 fork from "who" 是一个问题.
</p>

<p>
如果一个普通进程进入 kernel 后通过 kernel_thread 创建了一个 kernel
thread, 那么这个 kernel_thread 会与这个普通进程共享许多东西: mm, fs,
files &#x2026; 然而这些共享并没有必要, 因为 kernel thread 根本不需要它们.
</p>

<p>
另外, fork 还会导致 kernel thread 继承普通进程的属性, 例如 priority,
schedule policy, uid 等, 这些也不是 kernel 期望的
</p>

<p>
因此, kernel 提供了一个函数 daemonize, 让 kernel thread 可以释放这些不
必要的资源, 并且恢复一些进程属性到默认值
</p>

<p>
以 loop.c 为例:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">lo_ioctl</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">ioctl &#26469;&#33258; syscall, &#25152;&#20197;&#36825;&#37324;&#35843;&#29992; kernel_thread &#30340;&#35805;&#20250;&#23548;&#33268;&#21019;&#24314;&#30340;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">kernel thread &#19982;&#21457;&#36215; ioctl &#30340;&#26222;&#36890;&#36827;&#31243;&#20849;&#20139;&#36164;&#28304;</span>
  <span style="font-weight: bold; text-decoration: underline;">loop_set_fd</span>
    <span style="font-weight: bold;">kernel_thread</span>(loop_thread, lo, CLONE_KERNEL);

<span style="font-weight: bold; text-decoration: underline;">loop_thread</span>:
  daemonize(<span style="font-style: italic;">"loop%d"</span>, lo-&gt;lo_number);
    <span style="font-weight: bold;">exit_mm</span>(current);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Block and flush all signals    </span>
    sigfillset(&amp;blocked);
    <span style="font-weight: bold;">sigprocmask</span>(SIG_BLOCK, &amp;blocked, <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
    <span style="font-weight: bold;">flush_signals</span>(current);
    <span style="font-weight: bold;">exit_fs</span>(current); */
    fs = init_task.fs;
    current-&gt;fs = fs;
    <span style="font-weight: bold;">exit_files</span>(current);
    current-&gt;files = init_task.files;
    <span style="font-weight: bold;">reparent_to_init</span>();
      current-&gt;parent = child_reaper;
      current-&gt;real_parent = child_reaper;
      <span style="font-weight: bold;">if</span> ((current-&gt;policy == SCHED_NORMAL) &amp;&amp; (task_nice(current) &lt; 0)):
        set_user_nice(current, 0);
      <span style="font-weight: bold;">memcpy</span>(current-&gt;signal-&gt;rlim, init_task.signal-&gt;rlim,
        <span style="font-weight: bold;">sizeof</span>(current-&gt;signal-&gt;rlim));
    switch_uid(&amp;root_user);
</pre>
</div>

<p>
既然这样, 为什么不直接从一个 kernel thread 来 fork 出另一个 kernel
thread 呢?
</p>

<p>
kthread_create 就是做的这件事: 通过 kthread_create 可以给 keventd 发送
一个消息 (workqueue), keventd 负责调用 kernel_thread 来创建 kernel
thread.
</p>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org8979291" class="outline-3">
<h3 id="org8979291"><span class="section-number-3">1.4</span> 销毁进程</h3>
<div class="outline-text-3" id="text-1-4">
<p>
进程销毁有两个相关系统调用:
</p>

<ol class="org-ol">
<li><p>
exit_group
</p>

<p>
整个线程组的所有线程都会退出, libc 中的 exit 函数会调用 exit_group
</p></li>

<li><p>
_exit
</p>

<p>
只会导致当前线程退出, libc 中的 pthread_exit 会调用 _exit
</p></li>
</ol>
</div>

<div id="outline-container-org73edf8f" class="outline-4">
<h4 id="org73edf8f"><span class="section-number-4">1.4.1</span> main 返回</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
c 程序中 main 函数的调用路径为:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">__start</span>:
  <span style="font-weight: bold; text-decoration: underline;">__libc_start_main</span>
    <span style="font-weight: bold;">exit</span>(<span style="font-weight: bold; text-decoration: underline;">main</span>())
</pre>
</div>

<p>
所以 main 返回后 exit 会被调用, 整个线程组都会退出.
</p>
</div>
</div>
</div>

<div id="outline-container-orgbfb280e" class="outline-3">
<h3 id="orgbfb280e"><span class="section-number-3">1.5</span> Appendix</h3>
<div class="outline-text-3" id="text-1-5">
</div>
<div id="outline-container-orgca2919f" class="outline-4">
<h4 id="orgca2919f"><span class="section-number-4">1.5.1</span> 0 号进程与 1 号进程</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
0 号进程, 即 swapper, idle 或 init_task. kernel 启动时是以 0 号进程(后
面统称 swapper) 的身份在运行的
</p>

<ol class="org-ol">
<li>首先, swapper 对应的 task_struct 为 init_task, 是静态初始化的, 其中
最重要的数据结构是 init_task-&gt;thread_info, 也是静态初始化的, 为
init_thread_info.</li>

<li><p>
head.S 定义了一个 entry 为 stack_start
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">ENTRY</span>(stack_start)
.<span style="font-weight: bold; text-decoration: underline;">long</span> init_thread_union+THREAD_SIZE
.<span style="font-weight: bold; text-decoration: underline;">long</span> __BOOT_DS
ready:  .byte 0
</pre>
</div>

<p>
其中的 init_thread_union 与 init_thread_info 地址相同
</p></li>

<li>startup_32 时会将 stack_start 设置为初始的 esp, 从此以后 kernel 相
当于以 swapper 进程的身份在运行了</li>

<li><p>
kernel 启动的最后阶段, 调用了 rest_init 来启动 1 号进程 (init), 同
时自身通过运行 cpu_idle 变成名副其实的 idle 进程
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">rest_init</span>:
  <span style="font-weight: bold;">kernel_thread</span>(init, <span style="font-weight: bold; text-decoration: underline;">NULL</span>, CLONE_FS | CLONE_SIGHAND);
  <span style="font-weight: bold;">cpu_idle</span>();
    <span style="font-weight: bold;">while</span> (1):
      <span style="font-weight: bold;">while</span> (!need_resched()):
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">idle          </span>
        cpu_relax()  
      <span style="font-weight: bold;">schedule</span>()
</pre>
</div></li>

<li>swapper 也是一个进程, 所以它也会参与到进程调试中, 只不过它是进程调
试最后的选择</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

<p class="author">Author: sunway (sunwayforever@gmail.com)<br />
Date: 2016-07-08 Fri 00:00<br />
Last updated: 2022-01-19 Wed 13:25</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。
<br />

<div id="disqus_thread"></div>
<script>

(function() { // DON'T EDIT BELOW THIS LINE
         var d = document, s = d.createElement('script');
         s.src = '//sunwayforever-github-io.disqus.com/embed.js';
         s.setAttribute('data-timestamp', +new Date());
         (d.head || d.body).appendChild(s);
         })();
</script>
</div>
</body>
</html>
