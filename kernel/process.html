<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-01-19 三 13:26 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Linux Kernel: Process</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wei Sun (孙伟)" />
<link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
<link rel = "icon" href = "/icon.png"  type = "image/x-icon">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">Linux Kernel: Process</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org0715a2e">1. Linux Kernel: Process</a>
<ul>
<li><a href="#org4bc623d">1.1. 进程描述符</a>
<ul>
<li><a href="#orgf22881a">1.1.1. task_struct</a></li>
<li><a href="#org1bfc7c7">1.1.2. 进程状态</a></li>
<li><a href="#orgfa6bff6">1.1.3. 识别一个进程</a></li>
<li><a href="#orgf843691">1.1.4. 进程之间的关系</a></li>
<li><a href="#org58e9855">1.1.5. Pid Hashtable</a></li>
</ul>
</li>
<li><a href="#org64b5265">1.2. 上下文切换</a>
<ul>
<li><a href="#org0f5dbbf">1.2.1. switch_mm 与 Kernel Thread</a></li>
<li><a href="#org6a0efc7">1.2.2. switch_to</a></li>
</ul>
</li>
<li><a href="#orgab3e1ad">1.3. 创建进程</a>
<ul>
<li><a href="#org4d9053a">1.3.1. fork 系统调用</a></li>
<li><a href="#orgf48eef5">1.3.2. 关于系统调用 (syscall)</a></li>
<li><a href="#org98c43a0">1.3.3. Kernel Thread</a></li>
</ul>
</li>
<li><a href="#org69ebcc2">1.4. 销毁进程</a>
<ul>
<li><a href="#orgb89a706">1.4.1. main 返回</a></li>
</ul>
</li>
<li><a href="#orgfd95808">1.5. Appendix</a>
<ul>
<li><a href="#org5524804">1.5.1. 0 号进程与 1 号进程</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org0715a2e" class="outline-2">
<h2 id="org0715a2e"><span class="section-number-2">1</span> Linux Kernel: Process</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org4bc623d" class="outline-3">
<h3 id="org4bc623d"><span class="section-number-3">1.1</span> 进程描述符</h3>
<div class="outline-text-3" id="text-1-1">
<p>
进程描述符, 即 process descriptor, 是 kernel 用来表示进程的数据结构
</p>
</div>

<div id="outline-container-orgf22881a" class="outline-4">
<h4 id="orgf22881a"><span class="section-number-4">1.1.1</span> task_struct</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
Process Descriptor 即 task_struct 结构体, 它的主要成员有:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">task_struct</span> <span style="color: #757575;">{</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#36827;&#31243;&#29366;&#24577;</span>
    <span style="color: #859900;">volatile</span> <span style="color: #b58900;">long</span> <span style="color: #268bd2;">state</span>;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">thread_info &#21450; kernel_stack</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">thread_info</span> *<span style="color: #268bd2;">thread_info</span>;

    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">prio</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">static_prio</span>;

    <span style="color: #586e75;">/* </span><span style="color: #586e75;">process &#30340;&#31532;&#19968;&#31181;&#32452;&#32455;&#26041;&#24335;: prio_array_t &#26159;&#19968;&#20010;&#21253;&#21547; 140 &#20010;</span>
<span style="color: #586e75;">     * list_head &#30340;&#25968;&#32452;, &#23545;&#24212; 140 &#20010;&#36827;&#31243;&#20248;&#20808;&#32423;. p-&gt;run_list &#26159;&#36827;&#31243; p</span>
<span style="color: #586e75;">     * &#22312; array[p-&gt;prio] &#36825;&#20010; list_head &#38142;&#34920;&#20013;&#30340; list entry.</span>
<span style="color: #586e75;">     *</span>
<span style="color: #586e75;">     * &#26681;&#25454; task &#30340;&#29366;&#24577;, task-&gt;array &#24517;&#23450;&#25351;&#21521; runqueue &#20013; active &#25110;</span>
<span style="color: #586e75;">     * expire &#20013;&#30340;&#26576;&#19968;&#20010; prio_array_t. &#25152;&#26377; state &#20026; running (active)</span>
<span style="color: #586e75;">     * &#30340;&#36827;&#31243; p &#32452;&#32455;&#22312; runqueue-&gt;active &#20013;, &#19988; p-&gt;array =</span>
<span style="color: #586e75;">     * runqueue-&gt;active. &#25152;&#26377; state &#20026; running (expired) &#30340;&#36827;&#31243; p &#32452;&#32455;</span>
<span style="color: #586e75;">     * &#22312; running-&gt;expired &#20013;, &#19988; p-&gt;array = runqueue-&gt;expired, &#20855;&#20307;&#30340;</span>
<span style="color: #586e75;">     * &#21442;&#32771; process scheduling</span><span style="color: #586e75;"> */</span>

    <span style="color: #859900;">struct</span> <span style="color: #b58900;">list_head</span> <span style="color: #268bd2;">run_list</span>;
    <span style="color: #b58900;">prio_array_t</span> *<span style="color: #268bd2;">array</span>;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">process &#30340;&#31532;&#20108;&#31181;&#32452;&#32455;&#26041;&#24335;: tasks &#23558;&#25152;&#26377;&#36827;&#31243;&#32452;&#32455;&#20026;&#19968;&#20010; list, &#23545;&#24212;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#30340; list_head &#20026; init_task.tasks</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">list_head</span> <span style="color: #268bd2;">tasks</span>;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#21644;&#20869;&#23384;&#30456;&#20851;&#30340;&#23383;&#27573;, &#21253;&#25324; vma, pgd &#31561;</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">mm_struct</span> *<span style="color: #268bd2;">mm</span><span style="color: #757575;">,</span> *<span style="color: #268bd2;">active_mm</span>;

    <span style="color: #b58900;">long</span> <span style="color: #268bd2;">exit_state</span>;
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">exit_code</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">exit_signal</span>;

    <span style="color: #b58900;">pid_t</span> <span style="color: #268bd2;">pid</span>;
    <span style="color: #b58900;">pid_t</span> <span style="color: #268bd2;">tgid</span>;

    <span style="color: #859900;">struct</span> <span style="color: #b58900;">task_struct</span> *<span style="color: #268bd2;">parent</span>;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">process &#30340;&#31532;&#19977;&#31181;&#32452;&#32455;&#26041;&#24335;: &#36890;&#36807; children &#21644; sibling, &#21487;&#20197;&#25214;&#21040;&#36827;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#31243;&#30340;&#25152;&#26377;&#23376;&#36827;&#31243;</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">list_head</span> <span style="color: #268bd2;">children</span>;
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">list_head</span> <span style="color: #268bd2;">sibling</span>;

    <span style="color: #859900;">struct</span> <span style="color: #b58900;">task_struct</span> *<span style="color: #268bd2;">group_leader</span>;   <span style="color: #586e75;">/* </span><span style="color: #586e75;">threadgroup leader</span><span style="color: #586e75;"> */</span>

    <span style="color: #586e75;">// </span><span style="color: #586e75;">process &#30340;&#31532;&#22235;&#31181;&#32452;&#32455;&#26041;&#24335;: &#25152;&#26377;&#36827;&#31243;&#26681;&#25454;&#20854; pid, tgid, pgid, sid &#32452;&#32455;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#22312;&#22235;&#26465;&#19981;&#21516;&#30340; hash table &#20445;&#23384;&#22312; pids &#25968;&#32452;&#20013;</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">pid</span> <span style="color: #268bd2;">pids</span>[PIDTYPE_MAX];

    <span style="color: #586e75;">// </span><span style="color: #586e75;">user time &#19982; system time, timer interrupt &#26102;&#36890;&#36807;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">update_process_times &#26356;&#26032;</span>
    <span style="color: #b58900;">cputime_t</span> <span style="color: #268bd2;">utime</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">stime</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">minor fault &#19982; major fault &#30340;&#32479;&#35745;</span>
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span> <span style="color: #268bd2;">min_flt</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">maj_flt</span>;

    <span style="color: #b58900;">uid_t</span> <span style="color: #268bd2;">uid</span><span style="color: #757575;">,</span><span style="color: #268bd2;">euid</span><span style="color: #757575;">,</span><span style="color: #268bd2;">suid</span><span style="color: #757575;">,</span><span style="color: #268bd2;">fsuid</span>;
    <span style="color: #b58900;">gid_t</span> <span style="color: #268bd2;">gid</span><span style="color: #757575;">,</span><span style="color: #268bd2;">egid</span><span style="color: #757575;">,</span><span style="color: #268bd2;">sgid</span><span style="color: #757575;">,</span><span style="color: #268bd2;">fsgid</span>;

    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">oomkilladj</span>; */
    <span style="color: #b58900;">char</span> comm[TASK_COMM_LEN];

    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#36827;&#31243;&#20999;&#25442;&#26102;&#38656;&#35201;&#20174; thread &#20013;&#33719;&#21462;&#20445;&#23384;&#30340; kernel mode &#19979; esp, eip &#31561;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20449;&#24687;</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">thread_struct</span> <span style="color: #268bd2;">thread</span>;

    <span style="color: #859900;">struct</span> <span style="color: #b58900;">fs_struct</span> *<span style="color: #268bd2;">fs</span>;

    <span style="color: #859900;">struct</span> <span style="color: #b58900;">files_struct</span> *<span style="color: #268bd2;">files</span>;

    <span style="color: #859900;">struct</span> <span style="color: #b58900;">signal_struct</span> *<span style="color: #268bd2;">signal</span>;
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">sighand_struct</span> *<span style="color: #268bd2;">sighand</span>;
<span style="color: #757575;">}</span>;

</pre>
</div>
</div>
</div>

<div id="outline-container-org1bfc7c7" class="outline-4">
<h4 id="org1bfc7c7"><span class="section-number-4">1.1.2</span> 进程状态</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
task_struct.state 表示进程的状态:
</p>

<ol class="org-ol">
<li><p>
TASK_RUNNING
</p>

<p>
进程处于 running 状态, 只是表示 schedule 时该进程可以被选择, 而并不是表示该进程一直在 "执行" 的状态.
</p>

<p>
TASK_RUNNING 状态的进程一定处于 p-&gt;array[p-&gt;prio] 链表中
</p></li>

<li><p>
TASK_INTERRUPTIBLE
</p>

<p>
TASK_INTERRUPTIBLE 的进程处于 sleeping 状态, 但可以被信号唤醒 (信号唤醒进程的过程参考 signal 相关的部分 <a href="signal.html#orgeb2ba10">specific_send_sig_info</a>) 而变成
TASK_RUNNING 状态.
</p>

<p>
典型的例子比如 nanosleep 和 read(pipe) 这种阻塞
</p></li>

<li><p>
TASK_UNINTERRUPTIBLE
</p>

<p>
TASK_UNINTERRUPTIBLE 的进程处于 sleeping 状态, 但无法被信号唤醒, 典型的例子比如做 IO 时的 lock_page
</p></li>

<li>TASK_STOPPED</li>

<li>TASK_TRACED</li>

<li><p>
EXIT_ZOMBIE
</p>

<p>
由于 wait4, waitpid 这类系统调用在存在, 进程终止时无法直接变为
EXIT_DEAD 状态, 因为它还需要维护一些信息等待父进程调用 wait4 时返回给父进程
</p></li>

<li>EXIT_DEAD</li>
</ol>
</div>
</div>

<div id="outline-container-orgfa6bff6" class="outline-4">
<h4 id="orgfa6bff6"><span class="section-number-4">1.1.3</span> 识别一个进程</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
识别一个进程 (identifing a process), 主要是指下面这些需求:
</p>

<ol class="org-ol">
<li>如何知道当前正在执行的是哪个进程</li>

<li>如何遍历进程:

<ol class="org-ol">
<li>遍历所有进程</li>

<li>根据 pid, tgid</li>

<li>根据进程的关系</li>

<li>根据进程的状态</li>
</ol></li>
</ol>
</div>

<div id="outline-container-org6e05b19" class="outline-5">
<h5 id="org6e05b19"><span class="section-number-5">1.1.3.1</span> 当前进程</h5>
<div class="outline-text-5" id="text-1-1-3-1">
<p>
首先, task_struct, thread_info 及 kernel stack 有密切的关系:
</p>


<div id="orgdb42a00" class="figure">
<p><img src="../extra/kernel_process_thread_info.png" alt="kernel_process_thread_info.png" />
</p>
</div>

<p>
相关的数据结构的定义如下:
</p>

<ol class="org-ol">
<li><p>
task_struct
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">task_struct</span> <span style="color: #757575;">{</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">...</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">thread_info</span> *<span style="color: #268bd2;">thread_info</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">...</span>
<span style="color: #757575;">}</span>
</pre>
</div></li>

<li><p>
thread_info
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">thread_info</span> <span style="color: #757575;">{</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">task_struct</span>  *<span style="color: #268bd2;">task</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">...</span>
    <span style="color: #b58900;">__u8</span>            <span style="color: #268bd2;">supervisor_stack</span>[0];
<span style="color: #757575;">}</span>;

</pre>
</div></li>
</ol>

<p>
thread_info 是通过 kmalloc(THREAD_SIZE) 分配的, THREAD_SIZE 根据配置不同可能是 4K 或 8K, thread_info 是通过 kmalloc 分配的, kmalloc 会保证
thread_info 一定是 4K 或 8K 对齐的 (参考 OFF_SLAB 的布局)
</p>

<p>
由于 thread_info 的对齐以及它与 kernel stack 的关系, 可以很容易的从
esp (kernel_stack) 的值得于 thread_info 的地址, 进而得到 task_struct,
这就是 current 宏的原理.
</p>
</div>

<ol class="org-ol">
<li><a id="org3b9d24f"></a>current 宏<br />
<div class="outline-text-6" id="text-1-1-3-1-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">current</span>:
  <span style="color: #268bd2;">current_thread_info</span><span style="color: #757575;">()</span>-&gt;task;
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">thread_info</span> *<span style="color: #268bd2;">ti</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20551;&#35774; THREAD_SIZE &#20026; 4k (0100 0000000000), &#21017; ~(THREAD_SIZE-1)</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20540;&#20026; 11 1111111111</span>
    <span style="color: #859900;">__asm__</span><span style="color: #757575;">(</span><span style="color: #2aa198;">"andl %%esp,%0; "</span>:<span style="color: #2aa198;">"=r"</span> <span style="color: #757575;">(</span>ti<span style="color: #757575;">)</span> : <span style="color: #2aa198;">"0"</span> <span style="color: #757575;">(</span>~<span style="color: #757575;">(</span>THREAD_SIZE - 1<span style="color: #757575;">)))</span>;
    <span style="color: #859900;">return</span> ti;
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-orgf06d1e1" class="outline-5">
<h5 id="orgf06d1e1"><span class="section-number-5">1.1.3.2</span> 双向链表</h5>
<div class="outline-text-5" id="text-1-1-3-2">
<p>
task_struct 是用许多双向链表组织起来的, 比如:
</p>

<ol class="org-ol">
<li>所有进程</li>

<li>同 tgid 的所有进程</li>

<li>同优先级的处于 TASK_RUNNING 状态的进程</li>

<li>一个进程的所有子进程</li>
</ol>

<p>
linux 使用 list_head 数据结构来实现一个通用的链表, 并提供了一些通用的函数, 比如 list_add, list_for_each_entry 等
</p>


<div id="org27158fa" class="figure">
<p><img src="../extra/kernel_list.png" alt="kernel_list.png" />
</p>
</div>
</div>

<ol class="org-ol">
<li><a id="org8a9f1f0"></a>list_head<br />
<div class="outline-text-6" id="text-1-1-3-2-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">list_head</span> <span style="color: #757575;">{</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">list_head</span> *<span style="color: #268bd2;">next</span><span style="color: #757575;">,</span> *<span style="color: #268bd2;">prev</span>;
<span style="color: #757575;">}</span>;
</pre>
</div>
</div>
</li>

<li><a id="org80a5a91"></a>list_entry (container_of)<br />
<div class="outline-text-6" id="text-1-1-3-2-2">
<p>
list_entry 的作用是给定一个 list_head, 得到外层的数据结构的地址(对应于上图中的 data structure {1,2,3})
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #586e75;">// </span><span style="color: #586e75;">ptr &#26159; list_head, type &#20026; data struct &#30340;&#31867;&#22411;, member &#20026; data</span>
<span style="color: #586e75;">// </span><span style="color: #586e75;">structure &#20013; list_head &#23545;&#24212;&#30340;&#23383;&#27573;&#21517;</span>
<span style="color: #268bd2;">#define</span> <span style="color: #268bd2;">container_of</span><span style="color: #757575;">(</span><span style="color: #268bd2;">ptr</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">type</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">member</span><span style="color: #757575;">)</span> <span style="color: #757575;">({</span>                              \
            <span style="color: #859900;">const</span> <span style="color: #859900;">typeof</span><span style="color: #757575;">(</span> <span style="color: #757575;">((</span><span style="color: #b58900;">type</span> *<span style="color: #757575;">)</span>0<span style="color: #757575;">)</span>-&gt;member <span style="color: #757575;">)</span> *<span style="color: #268bd2;">__mptr</span> = <span style="color: #757575;">(</span>ptr<span style="color: #757575;">)</span>;         \
            <span style="color: #757575;">(</span><span style="color: #b58900;">type</span> *<span style="color: #757575;">)(</span> <span style="color: #757575;">(</span><span style="color: #b58900;">char</span> *<span style="color: #757575;">)</span>__mptr - offsetof<span style="color: #757575;">(</span>type<span style="color: #757575;">,</span>member<span style="color: #757575;">)</span> <span style="color: #757575;">)</span>;<span style="color: #757575;">})</span>

</pre>
</div>

<p>
以遍历 all tasks 为例, 假设通过 list_for_each 已经拿到一个对应于
task_struct-&gt;tasks 这个 list_head 的指针为 p, 则 list_entry(p,
struct task_struct, tasks) 宏可以得到对应的外层的 task_struct
</p>
</div>
</li>

<li><a id="orgc67f659"></a>list_for_each<br />
<div class="outline-text-6" id="text-1-1-3-2-3">
<p>
list_for_each 是通用的遍历链表的代码
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #586e75;">// </span><span style="color: #586e75;">pos &#26159;&#19968;&#20010;&#20020;&#26102;&#21464;&#37327;, &#34920;&#31034;&#36941;&#21382;&#36807;&#31243;&#20013;&#30340;"&#24403;&#21069;" list_head,</span>
<span style="color: #586e75;">// </span><span style="color: #586e75;">head &#26159;&#20195;&#34920;&#38142;&#34920;&#22836;&#30340; list_head</span>
<span style="color: #268bd2;">#define</span> <span style="color: #268bd2;">list_for_each</span><span style="color: #757575;">(</span><span style="color: #268bd2;">pos</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">head</span><span style="color: #757575;">)</span>                                \
    <span style="color: #859900;">for</span> <span style="color: #757575;">(</span>pos = <span style="color: #757575;">(</span>head<span style="color: #757575;">)</span>-&gt;next; pos != <span style="color: #757575;">(</span>head<span style="color: #757575;">)</span>; pos = pos-&gt;next<span style="color: #757575;">)</span>
</pre>
</div>

<p>
可见遍历结束的条件是 pos != (head), 因为 linux 的链表是双向的循环链表.
</p>

<p>
list_for_each 每次迭代拿到一个 list_head 后, 通过 list_entry 宏可以拿到对应的数据结构
</p>
</div>
</li>

<li><a id="org8c76db0"></a>再看 list_head<br />
<div class="outline-text-6" id="text-1-1-3-2-4">
<p>
list_head 实际有几种不同的用法:
</p>

<ol class="org-ol">
<li>list_head 可以用来表示它是链表的头, 这个 list_head 本身不代表链表的任何元素, 所以通过 list_entry 也是没有意义的. 链表的第一个元素是
list_entry(list_head-next). 这种 list_head 的目的就是标识一个链表</li>

<li>list_head 是链表头, 但它也是代表链表的一个元素, 这种链表头的用法并不常见, 因为它无法使用 list_for_each 宏 (因为 list_for_each 会把
head 作为 case 1 中的链表头来处理). 比如 for_each_process 时使用的
init_task-&gt;tasks 就是这种链表头</li>

<li>list_head 不是链表头, 而是链表中某个节点 (list entry), 这种
list_head 通过 list_entry 可以找到对应的外层数据结构</li>
</ol>

<p>
所以 list_head 实现的链表并不是一般意义上的"循环双向链表", 因为这个链表中的链表头是一个很特殊的节点: 它并不对应一个"有效"的元素, 而且链表的遍历必须从这个链表头开始: 因为如果从链表中任意一个节点遍历的话, 你无法区分遍历到的 list_head 是否是一个有效的 list entry
</p>
</div>
</li>
</ol>
</div>

<div id="outline-container-orgcf37091" class="outline-5">
<h5 id="orgcf37091"><span class="section-number-5">1.1.3.3</span> 遍历所有进程</h5>
<div class="outline-text-5" id="text-1-1-3-3">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2;">#define</span> <span style="color: #268bd2;">for_each_process</span><span style="color: #757575;">(</span><span style="color: #268bd2;">p</span><span style="color: #757575;">)</span> \
      <span style="color: #859900;">for</span> <span style="color: #757575;">(</span>p=&amp;init_task;
           <span style="color: #757575;">(</span>p=list_entry<span style="color: #757575;">((</span>p<span style="color: #757575;">)</span>-&gt;tasks.next<span style="color: #757575;">,</span> <span style="color: #859900;">struct</span> <span style="color: #b58900;">task_struct</span><span style="color: #757575;">,</span> tasks<span style="color: #757575;">))</span> != &amp;init_task; <span style="color: #757575;">)</span>

</pre>
</div>
</div>
</div>

<div id="outline-container-orgd79ceb6" class="outline-5">
<h5 id="orgd79ceb6"><span class="section-number-5">1.1.3.4</span> 遍历所有 TASK_RUNNING 进程</h5>
<div class="outline-text-5" id="text-1-1-3-4">
<p>
遍历 TASK_RUNNING 进程是进程调度的工作之一, 为了快速找到对应某一优先级的 TASK_RUNNING 进程, linux 将所有 TASK_RUNNING 进程分为 140 个链表来管理, 每个链表对应一个优先级.
</p>

<p>
其中, task_struct-&gt;array 中保存着相应的链表头, 而
task_struct-&gt;run_list 是对应的 list entry
</p>

<p>
关于 prio_array_t, run_list 以及 runqueue-&gt;{active, expired}, 参考

</p>
</div>
</div>

<div id="outline-container-org2cbe67b" class="outline-5">
<h5 id="org2cbe67b"><span class="section-number-5">1.1.3.5</span> 遍历所有子进程</h5>
<div class="outline-text-5" id="text-1-1-3-5">
<p>
task_struct 中的 children, sibling 两个 list_head 来实现遍历所有子进程.
</p>

<p>
假设要遍历 p 的子进程, 则 p-&gt;children 是对应的链表头, 各个子进程的
sibling 是 list entry
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #586e75;">// </span><span style="color: #586e75;">&#33719;&#21462; task &#30340;&#25152;&#26377;&#23376;&#36827;&#31243;&#30340;&#20195;&#30721;</span>
<span style="color: #268bd2;">list_for_each</span><span style="color: #757575;">(</span><span style="color: #b58900;">_p</span><span style="color: #757575;">,</span>&amp;tsk-&gt;children<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
    p = list_entry<span style="color: #757575;">(</span>_p<span style="color: #757575;">,</span><span style="color: #859900;">struct</span> <span style="color: #b58900;">task_struct</span><span style="color: #757575;">,</span>sibling<span style="color: #757575;">)</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">...</span>
<span style="color: #757575;">}</span>
</pre>
</div>


<div id="org886b279" class="figure">
<p><img src="../extra/kernel_process_parent.png" alt="kernel_process_parent.png" />
</p>
</div>

<p>
从上图可以看到, p3 的 sibling.next 是指向 p0 的 (实际上指向
p0-&gt;children), 看起来和 sibling 的语义不符, 但却是正确的: 因为
list_for_each 的结束条件是 p != (head), 所以链表的最后一个元素需要指向链表头
</p>
</div>
</div>
</div>

<div id="outline-container-orgf843691" class="outline-4">
<h4 id="orgf843691"><span class="section-number-4">1.1.4</span> 进程之间的关系</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
进程之间的关系有:
</p>

<ul class="org-ul">
<li>process group</li>

<li>thread group</li>

<li>session</li>
</ul>

<p>
task_struct 维护着各种 id 来表示这些关系
</p>

<ol class="org-ol">
<li><p>
pid
</p>

<p>
pid 唯一标识一个进程或线程. 这个值也是 gettid 系统调用返回的值
</p></li>

<li><p>
tgid
</p>

<p>
线程组 id, 同一个进程 p 的所有线程的 tgid 均为 p-&gt;pid, p 称为
thread group leader. 这个值是 getpid 系统调用返回的值
</p></li>

<li><p>
pgid
</p>

<p>
进程组 id, 若 a fork b, 则 b-&gt;pgid = a-&gt;pgid, 进程组通常和任务管理有关, 例如 kill 可以给一个进程组发信号导致整个进程组的所有进程都收到信号. 通过 setpgid 系统调用, 可以给进程设置一个新的进程组, 从而断开与之前的进程组的关系
</p></li>

<li>sid</li>
</ol>
</div>
</div>

<div id="outline-container-org58e9855" class="outline-4">
<h4 id="org58e9855"><span class="section-number-4">1.1.5</span> Pid Hashtable</h4>
<div class="outline-text-4" id="text-1-1-5">
<p>
task_struct-&gt;pids 用来维护四个 hash table, 分别对应 pid, tgid, pgid,
sid, 以便能根据某种 id 快速找到对应的 task
</p>


<div id="orgf00efaf" class="figure">
<p><img src="../extra/process_pid_hash.png" alt="process_pid_hash.png" />
</p>
</div>

<p>
相关的函数有:
</p>

<ol class="org-ol">
<li>find_task_by_pid_type</li>

<li>do_each_task_pid</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org64b5265" class="outline-3">
<h3 id="org64b5265"><span class="section-number-3">1.2</span> 上下文切换</h3>
<div class="outline-text-3" id="text-1-2">
<p>
进程上下文切换 (context switch) 是进程调度的一部分, 上下文切换的主要动作有两个:
</p>

<ol class="org-ol">
<li><p>
切换页表
</p>

<p>
switch_mm
</p></li>

<li><p>
切换 kernel stack
</p>

<p>
switch_to
</p></li>
</ol>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2;">context_switch</span><span style="color: #757575;">(</span><span style="color: #b58900;">prev</span><span style="color: #757575;">,</span> <span style="color: #b58900;">next</span><span style="color: #757575;">)</span>:
  <span style="color: #859900;">struct</span> mm_struct *mm = next-&gt;mm;
  <span style="color: #859900;">struct</span> <span style="color: #b58900;">mm_struct</span> *<span style="color: #268bd2;">oldmm</span> = prev-&gt;active_mm;
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>unlikely<span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>mm<span style="color: #757575;">))</span>:
    <span style="color: #586e75;">// </span><span style="color: #586e75;">kernel_thread &#30340; mm &#20026; NULL, active_mm &#20026;&#23427; "&#20511;&#29992;" &#30340; mm, &#25152;&#20197;&#36825;&#37324;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">next &#26159;&#19968;&#20010; kernel_thread, &#30452;&#25509;&#20351;&#29992; prev-&gt;active_mm &#20570;&#20026;&#23427;&#30340;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">active_mm, &#19981;&#20877;&#38656;&#35201; switch_mm</span>
    next-&gt;active_mm = oldmm;
  <span style="color: #859900;">else</span>:
    switch_mm<span style="color: #757575;">(</span>oldmm<span style="color: #757575;">,</span> mm<span style="color: #757575;">,</span> next<span style="color: #757575;">)</span>;
      <span style="color: #268bd2;">load_cr3</span><span style="color: #757575;">(</span>next-&gt;pgd<span style="color: #757575;">)</span>;
  <span style="color: #268bd2;">switch_to</span><span style="color: #757575;">(</span><span style="color: #b58900;">prev</span><span style="color: #757575;">,</span> <span style="color: #b58900;">next</span><span style="color: #757575;">,</span> <span style="color: #b58900;">prev</span><span style="color: #757575;">)</span>;
</pre>
</div>
</div>

<div id="outline-container-org0f5dbbf" class="outline-4">
<h4 id="org0f5dbbf"><span class="section-number-4">1.2.1</span> switch_mm 与 Kernel Thread</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
Context switch 时, switch_mm 的主要作用是切换 pgd, 但考虑到 kernel
thread 的特殊情形: kernel thread 只需要使用 pgd 中的高 1G 的部分,而所有的页表的这部分都是一致的, 所以 kernel thread 总是会借用 "前一个" 进程的页表, 以避免因为切换页表造成的 TLB flush.
</p>

<p>
所以 switch_to kernel thread 时, 不需要 switch_mm. 参考 <a href="#org98c43a0">Kernel Thread</a>
</p>
</div>
</div>

<div id="outline-container-org6a0efc7" class="outline-4">
<h4 id="org6a0efc7"><span class="section-number-4">1.2.2</span> switch_to</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
switch_to 是实现 kernel stack 切换的主要代码.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2;">#define</span> <span style="color: #268bd2;">switch_to</span><span style="color: #757575;">(</span><span style="color: #268bd2;">prev</span><span style="color: #757575;">,</span><span style="color: #268bd2;">next</span><span style="color: #757575;">,</span><span style="color: #268bd2;">last</span><span style="color: #757575;">)</span>                                       \
    <span style="color: #859900;">do</span> <span style="color: #757575;">{</span>                                                                \
        <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span> <span style="color: #268bd2;">esi</span><span style="color: #757575;">,</span><span style="color: #268bd2;">edi</span>;                      \
        <span style="color: #859900;">asm</span> <span style="color: #757575;">(</span>                                                           \
            <span style="color: #586e75;">/* </span><span style="color: #586e75;">&#20445;&#23384; eflags &#21040; prev kernel stack</span><span style="color: #586e75;">*/</span>                       \
            <span style="color: #2aa198;">"pushfl\n\t"</span>                                                \
            <span style="color: #2aa198;">"pushl %%ebp\n\t"</span>                                           \
            <span style="color: #586e75;">/* </span><span style="color: #586e75;">&#20445;&#23384; esp &#21040; prev-&gt;thread.esp</span><span style="color: #586e75;">*/</span>                           \
            <span style="color: #2aa198;">"movl %%esp,%0\n\t"</span> <span style="color: #586e75;">/* </span><span style="color: #586e75;">save ESP</span><span style="color: #586e75;"> */</span>                          \
            <span style="color: #586e75;">/* </span><span style="color: #586e75;">&#20174; next-&gt;thread.esp &#24674;&#22797; esp</span><span style="color: #586e75;">*/</span>                           \
            <span style="color: #2aa198;">"movl %5,%%esp\n\t"</span>                                         \
            <span style="color: #586e75;">/* </span><span style="color: #586e75;">&#23558; label 1 &#35774;&#32622;&#20026; prev-&gt;thread.eip</span><span style="color: #586e75;">*/</span>                     \
            <span style="color: #2aa198;">"movl $1f,%1\n\t"</span>                                           \
            <span style="color: #586e75;">/* </span><span style="color: #586e75;">&#23558; next-&gt;thread.eip push &#21040; stack, jmp _switch_to        \</span>
<span style="color: #586e75;">             * &#36820;&#22238;&#26102;&#30340; ret &#25351;&#20196;&#20250;&#20174; stack &#19978;&#21462;&#36825;&#20010; eip &#20570;&#20026; PC         \</span>
<span style="color: #586e75;">             * &#20174;&#32780;&#23454;&#29616;&#36339;&#36716;&#21040; next-&gt;thread.eip. &#23454;&#38469;&#19978;, &#36825;&#20010;            \</span>
<span style="color: #586e75;">             * next-&gt;thread.eip                                         \</span>
<span style="color: #586e75;">             * &#19968;&#33324;&#24773;&#20917;&#19979;&#20063;&#26159; label 1, &#26377;&#19968;&#20010;&#20363;&#22806;&#23601;&#26159; do_fork           \</span>
<span style="color: #586e75;">             * &#26102;&#30340; ret_from_fork</span><span style="color: #586e75;">*/</span>                                     \
            <span style="color: #2aa198;">"pushl %6\n\t"</span>                                              \
            <span style="color: #586e75;">/*</span><span style="color: #586e75;">__switch_to &#20250;&#20445;&#23384;&#19968;&#20123; FPU &#31561;, &#26368;&#37325;&#35201;&#30340;&#19968;&#28857;&#26159;, &#23427;&#20250;&#23558;     \</span>
<span style="color: #586e75;">             * esp (&#19979;&#19968;&#20010;&#36827;&#31243;&#30340; kernel stack ) &#20445;&#23384;&#22312; tss &#20013;&#20197;&#20415;&#36827;&#31243;   \</span>
<span style="color: #586e75;">             * &#36827;&#20837; kernel mode &#26102;&#33021;&#25214;&#21040; kernel stack</span><span style="color: #586e75;">*/</span>                 \
            <span style="color: #2aa198;">"jmp __switch_to\n"</span>                                         \
              tss-&gt;esp0 = thread-&gt;esp0;
            <span style="color: #586e75;">/* </span><span style="color: #586e75;">jmp ret &#21518;, eip &#21644; esp &#22343;&#20026; next-&gt;thread &#30456;&#24212;&#30340;&#20540;,       \</span>
<span style="color: #586e75;">             * &#26631;&#24535;&#30528;&#20999;&#25442;&#24443;&#24213;&#23436;&#25104;</span><span style="color: #586e75;"> */</span>                                    \
            <span style="color: #2aa198;">"1:\t"</span>                                                      \
            <span style="color: #2aa198;">"popl %%ebp\n\t"</span>                                            \
            <span style="color: #2aa198;">"popfl"</span>                                                     \
            :<span style="color: #2aa198;">"=m"</span> <span style="color: #757575;">(</span>prev-&gt;thread.esp<span style="color: #757575;">),</span><span style="color: #2aa198;">"=m"</span> <span style="color: #757575;">(</span>prev-&gt;thread.eip<span style="color: #757575;">),</span>             \
             <span style="color: #2aa198;">"=a"</span> <span style="color: #757575;">(</span>last<span style="color: #757575;">),</span><span style="color: #2aa198;">"=S"</span> <span style="color: #757575;">(</span>esi<span style="color: #757575;">),</span><span style="color: #2aa198;">"=D"</span> <span style="color: #757575;">(</span>edi<span style="color: #757575;">)</span>                          \
            :<span style="color: #2aa198;">"m"</span> <span style="color: #757575;">(</span>next-&gt;thread.esp<span style="color: #757575;">),</span><span style="color: #2aa198;">"m"</span> <span style="color: #757575;">(</span>next-&gt;thread.eip<span style="color: #757575;">),</span>               \
             <span style="color: #2aa198;">"2"</span> <span style="color: #757575;">(</span>prev<span style="color: #757575;">),</span> <span style="color: #2aa198;">"d"</span> <span style="color: #757575;">(</span>next<span style="color: #757575;">))</span>;                                   \
    <span style="color: #757575;">}</span> <span style="color: #859900;">while</span> <span style="color: #757575;">(</span>0<span style="color: #757575;">)</span>

</pre>
</div>

<p>
需要注意的是 switch_to 时并没有保存 ebx, ecx, edx 等寄存器, 这是因为
switch_to (或者更外层的 schedule) 调用之前, p 的 user mode 的这些寄存器已经通过 SAVE_ALL (通过 system_call 或 interrupt handler) 保存在 p
的 kernel stack 了. 所以 switch_to 只需要切换 kernel stack 就可以了.
</p>
</div>
</div>
</div>

<div id="outline-container-orgab3e1ad" class="outline-3">
<h3 id="orgab3e1ad"><span class="section-number-3">1.3</span> 创建进程</h3>
<div class="outline-text-3" id="text-1-3">
<p>
存在三个相关的库函数以及三个相关的系统调用: fork, vfork, clone, 但通常情况下, 三个库函数最终都会调到同一个系统调用 sys_clone. sys_fork 及
sys_vfork 也是存在的, 但一般并不会使用.
</p>
</div>

<div id="outline-container-org4d9053a" class="outline-4">
<h4 id="org4d9053a"><span class="section-number-4">1.3.1</span> fork 系统调用</h4>
<div class="outline-text-4" id="text-1-3-1">
</div>
<div id="outline-container-org4fb522a" class="outline-5">
<h5 id="org4fb522a"><span class="section-number-5">1.3.1.1</span> FORK_FLAGS</h5>
<div class="outline-text-5" id="text-1-3-1-1">
<ol class="org-ol">
<li>CLONE_VM</li>

<li>CLONE_FS</li>

<li>CLONE_FILES</li>

<li>CLONE_VFORK</li>

<li>CLONE_NEWNS</li>

<li>CLONE_SIGHAND</li>

<li>CLONE_STOPPED</li>

<li>CLONE_THREAD</li>

<li>CLONE_PARENT</li>
</ol>

<p>
这些 flag 主要在 copy_process 时被处理, 例如 copy_mm 时若发现 CLONE_VM,
则 child-&gt;mm = parent-&gt;mm
</p>
</div>
</div>

<div id="outline-container-org88145ee" class="outline-5">
<h5 id="org88145ee"><span class="section-number-5">1.3.1.2</span> user mode</h5>
<div class="outline-text-5" id="text-1-3-1-2">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #b58900;">int</span> <span style="color: #268bd2;">fork</span><span style="color: #757575;">()</span> <span style="color: #757575;">{</span>
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">result</span> = syscall<span style="color: #757575;">(</span>
        __NR_clone<span style="color: #757575;">,</span>
        FORK_FLAGS<span style="color: #757575;">,</span>
        <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #757575;">,</span>                          <span style="color: #586e75;">/* </span><span style="color: #586e75;">child_stack</span><span style="color: #586e75;"> */</span>
        <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #757575;">,</span>                          <span style="color: #586e75;">/* </span><span style="color: #586e75;">ptid</span><span style="color: #586e75;"> */</span>
        <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #757575;">,</span>
        &amp;<span style="color: #757575;">(</span>self-&gt;tid<span style="color: #757575;">)</span>             <span style="color: #586e75;">/* </span><span style="color: #586e75;">ctid</span><span style="color: #586e75;"> */</span>
        <span style="color: #757575;">)</span>;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2;">ENTRY</span><span style="color: #757575;">(</span><span style="color: #b58900;">syscall</span><span style="color: #757575;">)</span>
    <span style="color: #586e75;">/* </span><span style="color: #586e75;">Push the callee save registers.</span><span style="color: #586e75;"> */</span>
    push    %ebx
    push    %esi
    push    %edi
    push    %ebp

    <span style="color: #586e75;">/* </span><span style="color: #586e75;">20(%esp) &#21363; syscall &#30340;&#31532;&#19968;&#20010;&#21442;&#25968; __NR_clone, &#20043;&#25152;&#20197;&#26159; 20(%esp) &#32780;&#19981;&#26159; 16(%esp)</span><span style="color: #586e75;"> */</span>
    <span style="color: #586e75;">/* </span><span style="color: #586e75;">&#26159;&#22240;&#20026; syscall() &#26102;&#20250;&#22312;&#26632;&#19978; push &#19968;&#20010; eip, &#21363;&#24403;&#21069;&#26632;&#19978;&#30340;&#26679;&#23376;&#20026;:</span><span style="color: #586e75;"> */</span>
    <span style="color: #586e75;">/* </span><span style="color: #586e75;">ebp|edi|esi|ebx|eip|__NR_clone|FORK_FLAGS|NULL|NULL|NULL|tid</span><span style="color: #586e75;"> */</span>
    <span style="color: #586e75;">/* </span><span style="color: #586e75;">24(%esp) &#21363; FORK_FLAGS,....&#20197;&#27492;&#31867;&#25512;</span><span style="color: #586e75;"> */</span>
    <span style="color: #586e75;">/* </span><span style="color: #586e75;">&#25353;&#29031;&#31995;&#32479;&#35843;&#29992;&#30340;&#32422;&#23450;, user mode &#38656;&#35201;&#23558; __NR__xxx &#21644;&#25152;&#26377;&#21442;&#25968;&#20381;&#27425;&#25918;&#22312; eax,</span><span style="color: #586e75;"> */</span>
    <span style="color: #586e75;">/* </span><span style="color: #586e75;">ebx, ... &#20013;</span><span style="color: #586e75;"> */</span>

    mov     20<span style="color: #757575;">(</span>%esp<span style="color: #757575;">),</span>%eax
    mov     24<span style="color: #757575;">(</span>%esp<span style="color: #757575;">),</span>%ebx
    mov     28<span style="color: #757575;">(</span>%esp<span style="color: #757575;">),</span>%ecx
    mov     32<span style="color: #757575;">(</span>%esp<span style="color: #757575;">),</span>%edx
    mov     36<span style="color: #757575;">(</span>%esp<span style="color: #757575;">),</span>%esi
    mov     40<span style="color: #757575;">(</span>%esp<span style="color: #757575;">),</span>%edi
    mov     44<span style="color: #757575;">(</span>%esp<span style="color: #757575;">),</span>%ebp

    <span style="color: #586e75;">/* </span><span style="color: #586e75;">&#31995;&#32479;&#35843;&#29992;</span><span style="color: #586e75;"> */</span>
    <span style="color: #b58900;">int</span>     $0x80

    pop    %ebp
    pop    %edi
    pop    %esi
    pop    %ebx
    ret
END<span style="color: #757575;">(</span>syscall<span style="color: #757575;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org63179a8" class="outline-5">
<h5 id="org63179a8"><span class="section-number-5">1.3.1.3</span> kernel mode</h5>
<div class="outline-text-5" id="text-1-3-1-3">
<p>
进入 kernel mode 前, 硬件会保证:
</p>

<ol class="org-ol">
<li>esp 被切换为 kernel stack (通过 tss-&gt;esp0)</li>

<li>user mode 的 esp, eip, eflags 等被 push 到 kernel stack</li>

<li>检查 int 0x80 对应的 gate descriptor 的 DPL 与 xcs 的 CPL 一致</li>

<li>xcs 切换到 __KERNEL_CS (通过 date descriptor 的 segment selector) 以进入 kernel mode</li>
</ol>

<p>
进入 kernel mode 后, system_call 被调用.
</p>
</div>

<ol class="org-ol">
<li><a id="org77891bb"></a>system_call<br />
<div class="outline-text-6" id="text-1-3-1-3-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2;">ENTRY</span><span style="color: #757575;">(</span><span style="color: #b58900;">system_call</span><span style="color: #757575;">)</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#36825;&#37324;&#30340; pushl %eax &#23454;&#38469;&#19978;&#20462;&#25913;&#30340;&#26159; pt_regs-&gt;orig_eax, &#21518;&#32493;&#20250;&#26681;&#25454;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">orig_eax &#20540;&#21028;&#26029;&#24403;&#21069;&#26159;&#21542;&#26159;&#22312;&#25191;&#34892;&#19968;&#20010; syscall (&#20363;&#22914; handle_signal).</span>
    <span style="color: #586e75;">// </span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#28982;&#32780; SAVE_ALL &#26102;&#20063;&#20250;&#20445;&#23384;&#19968;&#27425; %eax &#21040; pt_regs-&gt;eax..., &#36825;&#20004;&#20010; eax</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#30340;&#20316;&#29992;&#26159;?</span>
    <span style="color: #586e75;">// </span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">pt_regs-&gt;eax &#27599;&#27425; interrupt &#37117;&#20250;&#35774;&#32622;, &#36890;&#36807; pt_regs-&gt;eax &#26080;&#27861;&#21028;&#26029;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#24403;&#21069;&#26159;&#21542;&#26159; syscall. &#36890;&#36807;&#21482;&#22312; system_call &#26102;&#35774;&#32622; orig_eax &#21487;&#20197;&#25226;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">orig_eax &#20570;&#25104; syscall &#30340;&#26631;&#35760; (&#22788;&#29702; irq &#26102;&#20063;&#20250; push &#19968;&#20010; orig_eax,</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20294;&#20026;&#19968;&#20010;&#36127;&#25968;, &#21487;&#20197;&#19982; syscall &#21306;&#20998;, &#20855;&#20307;&#21442;&#32771; do_IRQ)      </span>
    pushl %eax
    SAVE_ALL
    GET_THREAD_INFO<span style="color: #757575;">(</span>%ebp<span style="color: #757575;">)</span>
    <span style="color: #b58900;">call</span> *<span style="color: #268bd2;">sys_call_table</span><span style="color: #757575;">(,</span>%eax<span style="color: #757575;">,</span>4<span style="color: #757575;">)</span>

    <span style="color: #586e75;">/* </span><span style="color: #586e75;">&#22312;&#26631;&#20934;&#30340; c &#35843;&#29992;&#32422;&#23450;&#20013;,  eax &#20445;&#23384;&#20989;&#25968;&#30340;&#36820;&#22238;&#20540;, &#25152;&#20197; sys_clone &#36820;&#22238;&#21518;,</span><span style="color: #586e75;">  */</span>
    <span style="color: #586e75;">/* </span><span style="color: #586e75;">eax &#20445;&#23384;&#36820;&#22238;&#20540; (&#23376;&#36827;&#31243; pid), &#19979;&#38754;&#30340; movl &#25351;&#20196;</span><span style="color: #586e75;"> */</span>
    <span style="color: #586e75;">/* </span><span style="color: #586e75;">&#23558; eax &#20445;&#23384;&#22312; 24%(esp) &#22788;, &#21363; kernel stack &#20013;&#23545;&#24212;&#20110; SAVE_ALL &#26102; eax</span><span style="color: #586e75;"> */</span>
    <span style="color: #586e75;">/* </span><span style="color: #586e75;">&#30340;&#20301;&#32622;, &#24403; syscall &#36820;&#22238;&#21040;&#29238;&#36827;&#31243;&#30340; user mode &#26102;, RESTORE_ALL &#20250;&#36890;&#36807; kernel stack</span><span style="color: #586e75;"> */</span>
    <span style="color: #586e75;">/* </span><span style="color: #586e75;">&#24674;&#22797; eax, &#20174;&#32780;&#20351; user mode &#33021;&#25343;&#21040; sys_clone &#30340;&#36820;&#22238;&#20540;</span><span style="color: #586e75;"> */</span>
    movl %eax<span style="color: #757575;">,</span>EAX<span style="color: #757575;">(</span>%esp<span style="color: #757575;">)</span>

    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#35843;&#29992; RESTORE_ALL &#36820;&#22238;&#21069;&#21457;&#29616;&#26377;&#20854;&#23427;&#24037;&#20316;&#35201;&#20570;:  pending signal,</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">need_resched &#31561;, &#21017;&#36339;&#36716;&#21040; syscall_exit_work</span>
    <span style="color: #b58900;">movl</span> <span style="color: #268bd2;">TI_flags</span><span style="color: #757575;">(</span>%ebp<span style="color: #757575;">),</span> %ecx
    testw $_TIF_ALLWORK_MASK<span style="color: #757575;">,</span> %cx   # current-&gt;work
    jne syscall_exit_work

    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#27809;&#26377;&#20854;&#23427;&#24037;&#20316;, &#30452;&#25509;&#35843;&#29992; RESTORE_ALL, &#36890;&#36807; iret &#36820;&#22238;</span>
    RESTORE_ALL

syscall_exit_work:
    movl TI_flags<span style="color: #757575;">(</span>%ebp<span style="color: #757575;">),</span> %ecx
    andl $_TIF_WORK_MASK<span style="color: #757575;">,</span> %ecx
    jne work_pending
    jmp restore_all
      RESTORE_ALL

work_pending:
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#26816;&#26597; TIF_NEED_RESCHED</span>
    testb $_TIF_NEED_RESCHED<span style="color: #757575;">,</span> %cl
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#33509; TIF_NEED_RESCHED &#27809;&#26377;&#32622;&#20301;, &#36339;&#36716;&#21040; work_notifysig &#26816;&#26597;&#26159;&#21542;&#26377;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">pending signal, &#33509; TIF_NEED_RESCHED &#32622;&#20301;, &#35843;&#29992; schedule</span>
    jz work_notifysig
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#21644;&#20449;&#21495;&#22788;&#29702;&#26377;&#20851;</span>
      do_signal
    call schedule
    jmp restore_all
</pre>
</div>
</div>
</li>

<li><a id="org828ae96"></a>SAVE_ALL<br />
<div class="outline-text-6" id="text-1-3-1-3-2">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2;">#define</span> <span style="color: #268bd2;">SAVE_ALL</span>                                \
    cld;                                        \
    pushl %es;                                  \
    pushl %ds;                                  \
    pushl %eax;                                 \
    pushl %ebp;                                 \
    pushl %edi;                                 \
    pushl %esi;                                 \
    pushl %edx;                                 \
    pushl %ecx;                                 \
    pushl %ebx;                                 \
    movl $<span style="color: #757575;">(</span>__USER_DS<span style="color: #757575;">),</span> %edx;                    \
    movl %edx<span style="color: #757575;">,</span> %ds;                             \
    movl %edx<span style="color: #757575;">,</span> %es;
</pre>
</div>

<p>
按照系统调用的约定, user mode 需要将 __NR__xxx 和所有参数依次放在 eax,
ebx, &#x2026; 中, 而 sys_clone 是一个标准的 c 函数, 会从 kernel stack 中取参数, 所以在 sys_clone 之前, system_call 需要通过 SAVE_ALL 将 ebx,
ecx, &#x2026; 复制到 kernel stack 上
</p>
</div>
</li>

<li><a id="orge82bf50"></a>RESTORE_ALL<br />
<div class="outline-text-6" id="text-1-3-1-3-3">
<p>
RESTORE_ALL 与 SAVE_ALL 相反, 在 syscall 返回到 user mode 之前从 kernel
stack 恢复 ebx 等寄存器
</p>

<div class="org-src-container">
<pre class="src src-c">popl %ebx;  \
popl %ecx;  \
popl %edx;  \
popl %esi;  \
popl %edi;  \
popl %ebp;  \
popl %eax;  \
</pre>
</div>
</div>
</li>

<li><a id="orgf57a5c0"></a>sys_clone<br />
<div class="outline-text-6" id="text-1-3-1-3-4">
<p>
与一般 syscall 不同的是, sys_clone 的参数为 pt_regs 结构体, 实际上这个结构体与 kernel stack 是对应的, pt_regs.ebx 即对应于 SAVE_ALL 时 pushl
的 ebx
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">pt_regs</span> <span style="color: #757575;">{</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#36825;&#20960;&#20010;&#23492;&#23384;&#22120;&#19982; SAVE_ALL &#26159;&#23545;&#24212;&#30340;</span>
    <span style="color: #b58900;">long</span> <span style="color: #268bd2;">ebx</span>;
    <span style="color: #b58900;">long</span> <span style="color: #268bd2;">ecx</span>;
    <span style="color: #b58900;">long</span> <span style="color: #268bd2;">edx</span>;
    <span style="color: #b58900;">long</span> <span style="color: #268bd2;">esi</span>;
    <span style="color: #b58900;">long</span> <span style="color: #268bd2;">edi</span>;
    <span style="color: #b58900;">long</span> <span style="color: #268bd2;">ebp</span>;
    <span style="color: #b58900;">long</span> <span style="color: #268bd2;">eax</span>;
    <span style="color: #b58900;">int</span>  <span style="color: #268bd2;">xds</span>;
    <span style="color: #b58900;">int</span>  <span style="color: #268bd2;">xes</span>;
    <span style="color: #b58900;">long</span> <span style="color: #268bd2;">orig_eax</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#21518;&#38754;&#36825;&#20960;&#20010;&#23492;&#23384;&#22120;&#26159;&#21457;&#29983; interrupt &#26102;&#30828;&#20214;&#33258;&#21160;&#20445;&#23384;&#22312; kernel stack</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#19978;&#30340;, &#20013;&#26029;&#32467;&#26463;&#26102; (&#25110; syscall &#36820;&#22238;&#21040; user mode &#26102;) iret &#20250;&#36127;&#36131;&#23558;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">kernel stack &#20013;&#30340;&#36825;&#20123;&#20869;&#23481;&#24674;&#22797;&#21040; user mode &#30456;&#24212;&#30340;&#23492;&#23384;&#22120;&#20013;.</span>
    <span style="color: #586e75;">//</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#21478;&#22806;, &#36890;&#36807;&#26597;&#30475; pt_regs &#20013; xcs &#30340;&#20540;, interrupt handler &#21487;&#20197;&#21028;&#26029;&#20986;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">interrupt &#26102;&#31995;&#32479;&#26159;&#21542;&#26159;&#22788;&#20110; user mode &#25110; kernel mode (&#21442;&#32771;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">user_mode &#20989;&#25968;)</span>
    <span style="color: #b58900;">long</span> <span style="color: #268bd2;">eip</span>;
    <span style="color: #b58900;">int</span>  <span style="color: #268bd2;">xcs</span>;
    <span style="color: #b58900;">long</span> <span style="color: #268bd2;">eflags</span>;
    <span style="color: #b58900;">long</span> <span style="color: #268bd2;">esp</span>;
    <span style="color: #b58900;">int</span>  <span style="color: #268bd2;">xss</span>;
<span style="color: #757575;">}</span>;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b58900;">int</span> <span style="color: #268bd2;">sys_clone</span><span style="color: #757575;">(</span><span style="color: #859900;">struct</span> <span style="color: #b58900;">pt_regs</span> <span style="color: #268bd2;">regs</span><span style="color: #757575;">)</span>:
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span> clone_flags;
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span> <span style="color: #268bd2;">newsp</span>;
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">__user</span> *parent_tidptr<span style="color: #757575;">,</span> *<span style="color: #268bd2;">child_tidptr</span>;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">regs.ebx &#23545;&#24212;&#20110; kernel stack &#19978;&#19968;&#22359;&#21306;&#22495;, &#36825;&#20010;&#21306;&#22495;&#30340;&#20540;&#20043;&#21069;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#22312; SAVE_ALL &#26102;&#34987;&#36171;&#20540;&#20026; ebx, &#36861;&#28335;&#21040; user mode &#30340; fork &#23454;&#38469;&#23601;&#26159; FORK_FLAGS</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#36825;&#20010;&#21442;&#25968;</span>
    clone_flags = regs.ebx;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#21516;&#29702;, regs.ecx &#23545;&#24212; clone &#30340;&#31532;&#20108;&#20010;&#21442;&#25968; child_stack NULL</span>
    newsp = regs.ecx;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">edx &#23545;&#24212;&#20110; ptid</span>
    parent_tidptr = <span style="color: #757575;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">__user</span> *<span style="color: #757575;">)</span>regs.edx;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">edi &#23545;&#24212;&#20110; ctid</span>
    child_tidptr = <span style="color: #757575;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">__user</span> *<span style="color: #757575;">)</span>regs.edi;
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>newsp<span style="color: #757575;">)</span>
        newsp = regs.esp;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">regs &#20316;&#20026; do_fork &#30340;&#21442;&#25968;, &#21518;&#38754; do_fork &#20250;&#22312; copy_thread &#26102;&#20351;&#29992;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">regs &#26469;&#21021;&#22987;&#21270;&#23376;&#36827;&#31243;&#30340; kernel stack</span>
    <span style="color: #859900;">return</span> do_fork<span style="color: #757575;">(</span>clone_flags<span style="color: #757575;">,</span> newsp<span style="color: #757575;">,</span> &amp;regs<span style="color: #757575;">,</span> 0<span style="color: #757575;">,</span> parent_tidptr<span style="color: #757575;">,</span> child_tidptr<span style="color: #757575;">)</span>;
</pre>
</div>
</div>
</li>

<li><a id="org422df55"></a>do_fork<br />
<div class="outline-text-6" id="text-1-3-1-3-5">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">do_fork</span>:
  <span style="color: #b58900;">long</span> <span style="color: #268bd2;">pid</span> = alloc_pidmap<span style="color: #757575;">()</span>;
  p = copy_process<span style="color: #757575;">(</span>clone_flags<span style="color: #757575;">,</span> stack_start<span style="color: #757575;">,</span> regs<span style="color: #757575;">,</span> stack_size<span style="color: #757575;">,</span>
                   parent_tidptr<span style="color: #757575;">,</span> child_tidptr<span style="color: #757575;">,</span> pid<span style="color: #757575;">)</span>;
    p = dup_task_struct<span style="color: #757575;">(</span>current<span style="color: #757575;">)</span>;
    <span style="color: #268bd2;">copy_files</span><span style="color: #757575;">(</span><span style="color: #b58900;">clone_flags</span><span style="color: #757575;">,</span> <span style="color: #b58900;">p</span><span style="color: #757575;">)</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#22788;&#29702; CLONE_FILES</span>
    <span style="color: #268bd2;">copy_fs</span><span style="color: #757575;">(</span><span style="color: #b58900;">clone_flags</span><span style="color: #757575;">,</span> <span style="color: #b58900;">p</span><span style="color: #757575;">)</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#22788;&#29702; CLONE_FS</span>
    <span style="color: #268bd2;">copy_sighand</span><span style="color: #757575;">(</span><span style="color: #b58900;">clone_flags</span><span style="color: #757575;">,</span> <span style="color: #b58900;">p</span><span style="color: #757575;">)</span>
    <span style="color: #268bd2;">copy_signal</span><span style="color: #757575;">(</span><span style="color: #b58900;">clone_flags</span><span style="color: #757575;">,</span> <span style="color: #b58900;">p</span><span style="color: #757575;">)</span>
    <span style="color: #268bd2;">copy_mm</span><span style="color: #757575;">(</span><span style="color: #b58900;">clone_flags</span><span style="color: #757575;">,</span> <span style="color: #b58900;">p</span><span style="color: #757575;">)</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">CLONE_VM</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">....</span>
    copy_thread<span style="color: #757575;">(</span>0<span style="color: #757575;">,</span> clone_flags<span style="color: #757575;">,</span> stack_start<span style="color: #757575;">,</span> stack_size<span style="color: #757575;">,</span> p<span style="color: #757575;">,</span> regs<span style="color: #757575;">)</span>;
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#22797;&#21046; kernel stack</span>
      childregs = <span style="color: #757575;">((</span><span style="color: #859900;">struct</span> <span style="color: #b58900;">pt_regs</span> *<span style="color: #757575;">)</span> <span style="color: #757575;">(</span>THREAD_SIZE + <span style="color: #757575;">(</span><span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span><span style="color: #757575;">)</span> p-&gt;thread_info<span style="color: #757575;">))</span> - 1;
      *childregs = *regs;
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20294; kernel stack &#20013;&#23545;&#24212; eax &#30340;&#37096;&#20998;&#24378;&#21046;&#20026; 0, &#22240;&#20026;&#23545;&#23376;&#36827;&#31243;&#26469;&#35828;, fork &#30340;&#36820;&#22238;&#20540;</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#24212;&#35813;&#20026; 0, &#32780;&#31995;&#32479;&#35843;&#29992;&#30340;&#36820;&#22238;&#20540;&#26159;&#25918;&#22312; eax &#20013;&#30340;. &#21518;&#38754; RESTORE_ALL &#20351;&#29992; kernel stack</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#24674;&#22797; eax &#20174;&#32780;&#20351;&#23427;&#20026; 0</span>
      childregs-&gt;eax = 0;
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#19978;&#23618;&#20256;&#36807;&#26469;&#30340; start_stack &#22312;&#36825;&#37324;&#34987;&#36171;&#32473; childregs-&gt;esp, &#38543;&#21518; child &#34987;&#35843;&#24230;&#26102;,</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">iret &#20250;&#23548;&#33268; user mode &#30340; esp &#34987;&#24674;&#22797;&#20026; stack_start</span>
      childregs-&gt;esp = stack_start;
      p-&gt;thread.esp = <span style="color: #757575;">(</span><span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span><span style="color: #757575;">)</span> childregs;
      <span style="color: #586e75;">// </span><span style="color: #586e75;">eip &#35774;&#32622;&#20026; ret_from_fork, &#21518;&#38754; switch_to &#26102;&#23545;&#23376;&#36827;&#31243;&#26469;&#35828;&#20250;&#25191;&#34892; ret_from_fork</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#36825;&#20063;&#26159;&#23569;&#25968;&#30340; thread.eip &#19981;&#31561;&#20110; switch_to:label 1 &#30340;&#24773;&#20917;</span>
      p-&gt;thread.eip = <span style="color: #757575;">(</span><span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span><span style="color: #757575;">)</span> ret_from_fork;
  <span style="color: #268bd2;">wake_up_new_task</span><span style="color: #757575;">(</span><span style="color: #b58900;">p</span><span style="color: #757575;">,</span> <span style="color: #b58900;">clone_flags</span><span style="color: #757575;">)</span>;
  <span style="color: #859900;">return</span> pid;
</pre>
</div>
</div>
</li>

<li><a id="org0edf553"></a>ret_from_fork<br />
<div class="outline-text-6" id="text-1-3-1-3-6">
<p>
ret_from_fork 会调用 RESTORE_ALL 然后 iret 返回到 user mode
</p>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-orgf48eef5" class="outline-4">
<h4 id="orgf48eef5"><span class="section-number-4">1.3.2</span> 关于系统调用 (syscall)</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
系统调用的过程在前面介绍 fork 的时候已经比较详细, 下面再总结一下:
</p>
</div>

<div id="outline-container-org0750c06" class="outline-5">
<h5 id="org0750c06"><span class="section-number-5">1.3.2.1</span> syscall 的过程</h5>
<div class="outline-text-5" id="text-1-3-2-1">
<ol class="org-ol">
<li>system call 首先是一个 interrupt, 所以硬件会先走正常 interrupt 的流程

<ol class="org-ol">
<li>从 idt 中找到 gate descriptor, 判断 xcs 的 CPL 与对应的 system
gate 的 DPL 是否一致, 对 system call 来说, CPL 为 3, gate DPL 也为 3, 所以是一致的</li>

<li>比较 xcs 的 CPL 与 system gate 中指定的 segment descriptor 的
DPL 是否一致, 对于 system call 来说, xcs 对应的是 __USER_CS, 而
segment descriptor 对应的是 __KERNEL_CS, 所以是不一致的, 这时会发生 stack 的切换

<ul class="org-ul">
<li>先从 tss-&gt;esp0 获得 kernel stack 的 esp, 切换到 kernel stack</li>

<li>保存 ss, esp 到 kernel stack</li>
</ul></li>

<li>如果 interrupt 的原因是 fault (例如 page fault), 这时会将 eip 修改为导致 fault 的指令的地址, 因为导致 fault 的代码需要在 interrupt
结束后重新开始, 对于 system call 来说, 并不需要这一步</li>

<li>保存 user mode 的 eip, xcs, eflags  到 kernel stack, 其中, 针对
interrupt 的类型: trap, fault, abort, 保存的 eip 会有差别</li>

<li>从 gate descriptor 中加载 kernel mode xcs (实际上就是__KERNEL_CS),
以及对应 handler 的 eip (system_call), 从而切换到 kernel mode 并执行 system_call</li>
</ol></li>

<li>system_call 会通过 SAVE_ALL 将 eax, ebx, ecx, edx, esi, edi, ebp 六个寄存器 push 到 kernel stack 上</li>

<li>根据 eax 的值 call 相应的 sys_xxx</li>

<li>sys_xxx 会从 kernel stack 上取参数并执行</li>

<li>sys_xxx 返回后 system_call 负责将用 eax 的值覆盖 kernel stack 上对应 eax 的位置</li>

<li>RESTORE_ALL 会用 kernel stack 来恢复前面的六个寄存器</li>

<li>执行 iret 指令

<ol class="org-ol">
<li>恢复 eip, xcs, eip  寄存器, 由于 xcs 被恢复为 user mode 的 xcs, 所以返回到 user mode</li>

<li>检查 CPL 与 system gate 中的 segment descriptor 的 DPL 是否一致,
对 system call 来说, 必然是不一致的, 这里需要从 kernel stack 中恢复 ss 和 esp</li>
</ol></li>
</ol>
</div>
</div>

<div id="outline-container-orgb7ee17d" class="outline-5">
<h5 id="orgb7ee17d"><span class="section-number-5">1.3.2.2</span> 64bit 上的 syscall</h5>
<div class="outline-text-5" id="text-1-3-2-2">
<p>
需要注意的是 64 位系统上 syscall 的定义与 32 位是不一样的, 例如
</p>

<ol class="org-ol">
<li>__NR_read 在 32 位上是 3, 在 64 位上是 0</li>

<li>有些系统调用只存在于 64 位上, 例如 sys_pread64</li>
</ol>

<p>
但是对于同样是 32 位的 x86, arm, &#x2026; 等, syscall 的定义是一样的
</p>

<p>
详细的差别参考:
</p>

<ol class="org-ol">
<li><a href="http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html">http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html</a></li>

<li><a href="http://blog.rchapman.org/post/36801038863/linux-system-call-table-for-x86-64">http://blog.rchapman.org/post/36801038863/linux-system-call-table-for-x86-64</a></li>

<li><a href="https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_64.tbl">https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_64.tbl</a></li>
</ol>
</div>

<ol class="org-ol">
<li><a id="org4c248a4"></a>x86_64 如何同时兼容 32 位和 64 的 syscall<br />
<div class="outline-text-6" id="text-1-3-2-2-1">
<p>
由于 x86_64 指令是兼容 x86 指令的, 所以 32 位的程序的用户态部分可以直接在 64 位上执行, 但 32 位程序在调用 syscall 时会有问题, 因为 32 位和
64 位对 syscall 的定义是不同的, 因此需要针对 32 位程序额外提供一张
sys_call_table: 32 位使用 ia32_sys_call_table, 64 位使用
sys_call_table
</p>

<p>
但有一个问题: int 0x80 对应的 interrupt handler 如何能区分使用哪张
sys_call_table?
</p>

<p>
实际上, 在 x86_64 上, int 0x80 注册的 interrupt handler 会直接调用
ia32_sys_call_table, 因为 64 位的程序是不会通过 int 0x80 发起 syscall
的, 它们会通过 syscall 这个指令, 而 syscall 指令会根据 MSR 寄存器的值找到对应的 sys_call_table. <a href="https://lwn.net/Articles/604515/">Anatomy of a system call</a>
</p>
</div>

<ol class="org-ol">
<li><a id="orge4d098e"></a>sys_call_table 的初始化<br />
<div class="outline-text-7" id="text-1-3-2-2-1-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">syscall_init</span>:
  <span style="color: #268bd2;">wrmsrl</span><span style="color: #757575;">(</span><span style="color: #b58900;">MSR_LSTAR</span><span style="color: #757575;">,</span> <span style="color: #b58900;">system_call</span><span style="color: #757575;">)</span>;

<span style="color: #268bd2;">ENTRY</span><span style="color: #757575;">(</span><span style="color: #b58900;">system_call</span><span style="color: #757575;">)</span>:
  andl $__SYSCALL_MASK<span style="color: #757575;">,</span>%eax                  
  call *sys_call_table<span style="color: #757575;">(,</span>%rax<span style="color: #757575;">,</span>8<span style="color: #757575;">)</span>

<span style="color: #b58900;">sys_call_table</span>[__NR_syscall_max+1] = <span style="color: #757575;">{</span> 
<span style="color: #268bd2;">  #define</span> <span style="color: #268bd2;">__NR_read</span>    0
  __SYSCALL<span style="color: #757575;">(</span>__NR_read<span style="color: #757575;">,</span> sys_read<span style="color: #757575;">)</span>
<span style="color: #268bd2;">  #define</span> <span style="color: #268bd2;">__NR_write</span>   1
  __SYSCALL<span style="color: #757575;">(</span>__NR_write<span style="color: #757575;">,</span> sys_write<span style="color: #757575;">)</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">...      </span>
<span style="color: #757575;">}</span>;
</pre>
</div>
</div>
</li>

<li><a id="orgef68a3e"></a>ia32_sys_call_table 的初始化<br />
<div class="outline-text-7" id="text-1-3-2-2-1-2">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">trap_init</span>:
  <span style="color: #268bd2;">set_system_gate</span><span style="color: #757575;">(</span><span style="color: #b58900;">IA32_SYSCALL_VECTOR</span><span style="color: #757575;">,</span> <span style="color: #b58900;">ia32_syscall</span><span style="color: #757575;">)</span>;

<span style="color: #268bd2;">ENTRY</span><span style="color: #757575;">(</span><span style="color: #b58900;">ia32_syscall</span><span style="color: #757575;">)</span>:
  call *ia32_sys_call_table<span style="color: #757575;">(,</span>%rax<span style="color: #757575;">,</span>8<span style="color: #757575;">)</span>

ia32_sys_call_table:
  .quad sys_restart_syscall
  .quad sys_exit
  .quad stub32_fork
  .quad sys_read                   
</pre>
</div>
</div>
</li>
</ol>
</li>

<li><a id="orgc02569f"></a>x86_64 上的 x32 ABI 与 syscall<br />
<div class="outline-text-6" id="text-1-3-2-2-2">
<p>
Kernel 支持一种称为 x32 的 ABI, 这种 ABI 可以利用 64 位的优点(更多的寄存器, 使用寄存器传递参数, 更快的系统调用&#x2026;), 但使用 32 位的指针和
long 类型, 避免 64 位指针的开销. <a href="https://zh.wikipedia.org/wiki/X32_ABI">https://zh.wikipedia.org/wiki/X32_ABI</a>
<a href="https://lwn.net/Articles/456731/">The x32 system call ABI</a>
</p>

<p>
X32 ABI 需要编译器, libc 和 Kernel 的支持, 其中 libc 中通过 <span class="underline"><span class="underline">ILP32</span></span>
(Int, Long, Pointer 32 bit) 表示使用 X32 ABI (与 <span class="underline"><span class="underline">ILP32</span></span> 相对的是__LP64__, 即 Long Pointer 64 bit, 这是 x86_64 标准的模式)
</p>

<p>
Kernel Kernel 如何知道当前进程是使用的 X32 ABI? 通过在发起 syscall 时使用的
syscall number 上做标记:
</p>

<ol class="org-ol">
<li><p>
libc 使用 <span class="underline"><span class="underline">ILP32</span></span> 时发起 syscall
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2;">#ifdefined</span><span style="color: #757575;">(</span>__ILP32__<span style="color: #757575;">)</span>
<span style="color: #268bd2;">  #include</span> <span style="color: #2aa198;">&lt;asm/unistd_x32.h&gt;</span>
<span style="color: #268bd2;">#else</span>
<span style="color: #268bd2;">  #include</span> <span style="color: #2aa198;">&lt;asm/unistd_64.h&gt;</span>
<span style="color: #268bd2;">#endif</span>

unistd_x32.<span style="color: #268bd2; font-weight: bold;">h</span>:
<span style="color: #586e75;">// </span><span style="color: #586e75;">&#20854;&#20013; __X32_SYSCALL_BIT &#20026; 0x40000000, &#21363; bit 31     </span>
<span style="color: #268bd2;">#define</span> <span style="color: #268bd2;">__NR_read</span> <span style="color: #757575;">(</span>__X32_SYSCALL_BIT + 0<span style="color: #757575;">)</span>
<span style="color: #268bd2;">#define</span> <span style="color: #268bd2;">__NR_write</span> <span style="color: #757575;">(</span>__X32_SYSCALL_BIT + 1<span style="color: #757575;">)</span>
</pre>
</div></li>

<li><p>
64 位 kernel 响应 syscall
</p>

<p>
由于 X32 ABI 下 syscall number 有额外的置位, 所以 syscall 时需要将它们 mask 掉
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">system_call</span>:
  <span style="color: #586e75;">// </span><span style="color: #586e75;">__SYSCALL_MASK &#20026; (~(__X32_SYSCALL_BIT))  </span>
  andl $__SYSCALL_MASK<span style="color: #757575;">,</span>%eax
  call *sys_call_table<span style="color: #757575;">(,</span>%rax<span style="color: #757575;">,</span>8<span style="color: #757575;">)</span>
</pre>
</div></li>

<li><p>
kernel 使用 rax 的 __X32_SYSCALL_BIT 判断是否是 X32 ABI
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">is_compat_task</span>:
  <span style="color: #859900;">return</span> is_ia32_task<span style="color: #757575;">()</span> || is_x32_task<span style="color: #757575;">()</span>;

<span style="color: #268bd2; font-weight: bold;">is_x32_task</span>:
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>task_pt_regs<span style="color: #757575;">(</span>current<span style="color: #757575;">)</span>-&gt;orig_ax &amp; __X32_SYSCALL_BIT<span style="color: #757575;">)</span>:
    <span style="color: #859900;">return</span> <span style="color: #268bd2; font-weight: bold;">true</span>;
  <span style="color: #859900;">else</span>:
    <span style="color: #859900;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>;  
</pre>
</div></li>
</ol>
</div>
</li>
</ol>
</div>

<div id="outline-container-orge129aff" class="outline-5">
<h5 id="orge129aff"><span class="section-number-5">1.3.2.3</span> sysenter, syscall, vsyscall</h5>
<div class="outline-text-5" id="text-1-3-2-3">
<p>
vsyscall page 和一块特殊的 page: 这个 page 是由 kernel 分配的, 并映射到所有进程的同一块虚拟地址空间.
</p>
</div>

<ol class="org-ol">
<li><a id="org9070092"></a>x86_32 下 vsyscall page 的初始化<br />
<div class="outline-text-6" id="text-1-3-2-3-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">sysenter_setup</span>:
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20998;&#37197;&#19968;&#20010; page  </span>
  <span style="color: #b58900;">void</span> *<span style="color: #268bd2;">page</span> = <span style="color: #757575;">(</span><span style="color: #b58900;">void</span> *<span style="color: #757575;">)</span><span style="color: #268bd2;">get_zeroed_page</span><span style="color: #757575;">(</span><span style="color: #b58900;">GFP_ATOMIC</span><span style="color: #757575;">)</span>;
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#36890;&#36807; fixmap &#26144;&#23556;, &#24182;&#19988;&#25351;&#23450; page &#30340;&#26435;&#38480;&#20026; PAGE_READONLY_EXEC, &#21518;&#32773;&#20855;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20307;&#20026;: __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED),</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">_PAGE_USER &#36825;&#20010; flag &#34920;&#31034;&#36825;&#20010; page &#26159;&#21487;&#20197;&#34987; user mode &#35775;&#38382;&#30340;</span>
  <span style="color: #586e75;">// </span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">FIX_VSYSCALL &#36825;&#20010; fixmap &#23545;&#24212;&#30340;&#29289;&#29702;&#22320;&#22336;&#21363;&#26159; 0xffffe000</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">(VSYSCALL_BASE):</span>
  <span style="color: #586e75;">// </span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">#define VSYSCALL_BASE  (__fix_to_virt(FIX_VSYSCALL))  </span>
  <span style="color: #268bd2;">__set_fixmap</span><span style="color: #757575;">(</span><span style="color: #b58900;">FIX_VSYSCALL</span><span style="color: #757575;">,</span> <span style="color: #b58900;">__pa</span><span style="color: #757575;">(</span><span style="color: #268bd2;">page</span><span style="color: #757575;">),</span> <span style="color: #b58900;">PAGE_READONLY_EXEC</span><span style="color: #757575;">)</span>;
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#22914;&#26524; CPU &#19981;&#25903;&#25345; sysenter/sysexit, &#21017;&#23558; vsyscall_int80_start &#22788;&#30340;&#20195;&#30721;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#22797;&#21046;&#21040;&#36825;&#20010; page, &#21542;&#21017;&#23558; vsyscall_sysenter_start &#22788;&#30340;&#20195;&#30721;&#22797;&#29616;&#36807;&#26469;  </span>
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>boot_cpu_has<span style="color: #757575;">(</span>X86_FEATURE_SEP<span style="color: #757575;">))</span>:
    memcpy<span style="color: #757575;">(</span>page<span style="color: #757575;">,</span>&amp;vsyscall_int80_start<span style="color: #757575;">,</span>&amp;vsyscall_int80_end - &amp;vsyscall_int80_start<span style="color: #757575;">)</span>;
    <span style="color: #859900;">return</span> 0;

  <span style="color: #268bd2;">memcpy</span><span style="color: #757575;">(</span><span style="color: #b58900;">page</span><span style="color: #757575;">,</span>&amp;vsyscall_sysenter_start<span style="color: #757575;">,</span>&amp;vsyscall_sysenter_end - &amp;vsyscall_sysenter_start<span style="color: #757575;">)</span>;

  <span style="color: #268bd2;">on_each_cpu</span><span style="color: #757575;">(</span><span style="color: #b58900;">enable_sep_cpu</span><span style="color: #757575;">,</span> <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #757575;">,</span> 1<span style="color: #757575;">,</span> 1<span style="color: #757575;">)</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#25351;&#23450;&#20102; sysenter &#23545;&#24212;&#30340;&#22788;&#29702;&#20989;&#25968;(&#31867;&#20284;&#20110; syscall &#36825;&#20010; entry):</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">sysenter_entry    </span>
    <span style="color: #268bd2;">wrmsr</span><span style="color: #757575;">(</span><span style="color: #b58900;">MSR_IA32_SYSENTER_EIP</span><span style="color: #757575;">,</span> <span style="color: #757575;">(</span><span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span><span style="color: #757575;">)</span> sysenter_entry<span style="color: #757575;">,</span> 0<span style="color: #757575;">)</span>;
</pre>
</div>
</div>
</li>

<li><a id="org73f63cd"></a>vsyscall page 的内容<br />
<div class="outline-text-6" id="text-1-3-2-3-2">
<p>
vsyscall page 被映射到的 fixmap (FIX_VSYSCALL) 的虚拟地址固定为
0xffffe000 (VSYSCALL_BASE), 通过 maps 可以看到:
</p>


<div id="org29e208d" class="figure">
<p><img src="../extra/kernel_vdso.png" alt="kernel_vdso.png" />
</p>
</div>

<p>
maps 显示的 [vdso] 部分大小为 4k, 刚好为一个 page.
</p>

<p>
用 ldd 命令查看对应的 elf 文件:
</p>

<pre class="example" id="org88221e4">
linux-gate.so.1 =&gt;  (0xffffe000)
libc.so.6 =&gt; /lib/tls/i686/cmov/libc.so.6 (0xb7e45000)
/lib/ld-linux.so.2 (0xb7f7a000)
</pre>

<p>
其中的 linux-gate.so.1 (也可能叫 linux-vdso.so.1) 是一个虚拟的 so, 对应于前面提到的 vsyscall page.
</p>

<p>
通过下面的测试程序可以把这个 page dump 出来 (也可以用 gdb 的 dump
memory 命令):
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;unistd.h&gt;</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;string.h&gt;</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #757575;">()</span> <span style="color: #757575;">{</span>
    <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">p</span> = <span style="color: #757575;">(</span><span style="color: #b58900;">char</span> *<span style="color: #757575;">)</span> 0xffffe000;
    <span style="color: #b58900;">char</span> <span style="color: #268bd2;">buf</span>[4096];
    memcpy<span style="color: #757575;">(</span>buf<span style="color: #757575;">,</span> p<span style="color: #757575;">,</span> 4096<span style="color: #757575;">)</span>;
    write<span style="color: #757575;">(</span>1<span style="color: #757575;">,</span> buf<span style="color: #757575;">,</span> 4096<span style="color: #757575;">)</span>;
    <span style="color: #859900;">return</span> 0;
<span style="color: #757575;">}</span>
</pre>
</div>

<p>
察看 dump 出来的 page 的内容:
</p>

<pre class="example" id="orgb1001f5">
$&gt; file syspage
syspage: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, stripped

$&gt; objdump -d syspage

syspage:     file format elf32-i386


Disassembly of section .text:

ffffe400 &lt;__kernel_vsyscall@@LINUX_2.5&gt;:
ffffe400:	51                   	push   %ecx
ffffe401:	52                   	push   %edx
ffffe402:	55                   	push   %ebp
ffffe403:	89 e5                	mov    %esp,%ebp
ffffe405:	0f 34                	sysenter 
ffffe407:	90                   	nop
ffffe408:	90                   	nop
ffffe409:	90                   	nop
ffffe40a:	90                   	nop
ffffe40b:	90                   	nop
ffffe40c:	90                   	nop
ffffe40d:	90                   	nop
ffffe40e:	eb f3                	jmp    ffffe403 &lt;__kernel_vsyscall@@LINUX_2.5+0x3&gt;
ffffe410:	5d                   	pop    %ebp
ffffe411:	5a                   	pop    %edx
ffffe412:	59                   	pop    %ecx
ffffe413:	c3                   	ret    
	...

ffffe420 &lt;__kernel_sigreturn@@LINUX_2.5&gt;:
ffffe420:	58                   	pop    %eax
ffffe421:	b8 77 00 00 00       	mov    $0x77,%eax
ffffe426:	cd 80                	int    $0x80

ffffe440 &lt;__kernel_rt_sigreturn@@LINUX_2.5&gt;:
ffffe440:	b8 ad 00 00 00       	mov    $0xad,%eax
ffffe445:	cd 80                	int    $0x80
ffffe447:	90                   	nop

</pre>

<p>
显示这个 page 实际是包含一个 elf, 其中定义了三个函数:
</p>

<ol class="org-ol">
<li>__kernel_vsyscall</li>

<li>__kernel_sigreturn</li>

<li>__kernel_rt_sigreturn</li>
</ol>

<p>
其中后两个与信号的处理有关 (参考<a href="signal.html#org3235c0e">_kernel_sigreturn</a>), 第一个
__kernel_vsyscall 和 syscall 有关
</p>
</div>
</li>

<li><a id="orgf28725e"></a>__kernel_vsyscall<br />
<div class="outline-text-6" id="text-1-3-2-3-3">
<p>
vsyscall 的想法是这样的: x86 上最初通过 int 0x80 指令发起 syscall, 但这种做法需要 CPU 做无谓的 ring 检查和切换, 所以后来 CPU 提供了一个
sysenter 指令来代替 int 0x80. 那么 libc 怎么知道当前 CPU 是否支持
sysenter?
</p>

<p>
为了简化 libc 的工作, kernel 提供了一个 __kernel_vsyscall 函数放在
vsyscall page, 确切的说, 就是 0xffffe400 这个地址. sysenter_setup 时会根据 CPU 的情况向这个地址写入对应于 sysenter 或 int 的指令, libc 在发起 syscall 时只需要 call 0xffffe400 就可以了.
</p>

<p>
需要注意的是 x86_64 下 vsyscall page 中并不存在 __kernel_vsyscall,因为
x86_64 提供了一个 `syscall` 指令, 不再需要 int 0x80 或 sysenter
</p>
</div>
</li>

<li><a id="org3fc8088"></a>更底什么是 vsyscall<br />
<div class="outline-text-6" id="text-1-3-2-3-4">
<p>
__kernel_vsyscall 并不是 vsyscall. 无论使用 __kernel_vsyscall 还是使用
x86_64 上更快的 `syscall` 指令, 在进行 syscall 都无法避免 user mode 与
kernel mode 的切换.
</p>

<p>
那么能否更快一些, 直接避免这种切换呢?
</p>

<p>
vsyscall (virtual syscall) 就是这么一种机制. 以 gettimeofday 为例, 采用 vsyscall 调用 gettimeofday 的流程是:
</p>

<ol class="org-ol">
<li>kernel 每次 update tick 时, 会向 vsyscall page 的特定区域写入当前的时间</li>

<li>当上层发起 gettimeofday syscall 时, libc 会像调用 __kernel_vsyscall
一样调用 vgettimeofday</li>

<li>vgettimeofday 与 __kernel_vsyscall 一样存在于 vsyscall page 中, 这个函数只是简单的读一下 vsyscall page 中的那个时间</li>
</ol>

<p>
实际上, x86_32 上并没有 vsyscall, x86_64 上才有&#x2026;所以前面 dump
syspage 时并没有找到 vgettimeofday.
</p>

<p>
x86_64 上关于 vsyscall 的代码主要在 arch/x86_64/kernel/vsyscall.c 中
</p>
</div>
</li>

<li><a id="org6ecf1b3"></a>libc 如何知道 __kernel_vsyscall, vgettimeofday 这些函数在 vsyscall page 中的地址?<br />
<ol class="org-ol">
<li><a id="orgbb39298"></a>__kernel_vsyscall<br />
<div class="outline-text-7" id="text-1-3-2-3-5-1">
<ol class="org-ol">
<li><p>
kernel 将 __kernel_vsyscall 的地址放在 elf 的 aux vector 中
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">do_execve</span>:
  <span style="color: #268bd2; font-weight: bold;">create_elf_tables</span>:
    <span style="color: #b58900;">ARCH_DLINFO</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">VSYSCALL_ENTRY &#21363;&#20026; __kernel_vsyscall &#30340;&#22320;&#22336;: 0xffffe400</span>
      <span style="color: #268bd2;">NEW_AUX_ENT</span><span style="color: #757575;">(</span><span style="color: #b58900;">AT_SYSINFO</span><span style="color: #757575;">,</span>   <span style="color: #b58900;">VSYSCALL_ENTRY</span><span style="color: #757575;">)</span>;
</pre>
</div></li>

<li>libc 从 aux vector 中取出 __kernel_vsyscall 的地址</li>
</ol>
</div>
</li>

<li><a id="org2869a74"></a>vgettimeofday<br />
<div class="outline-text-7" id="text-1-3-2-3-5-2">
<p>
vsyscall 实际上只支持三个 syscall:
</p>

<ol class="org-ol">
<li>gettimeofday</li>

<li>getcpu</li>

<li>time</li>
</ol>

<p>
这三个 syscall 对应的 vsyscall page 中的 vgettimeofday, vgetcpu 以及
vtime 的地址是固定的&#x2026;
</p>

<p>
glibc 中关于 __gettimeofday 的代码:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2;">#define</span> <span style="color: #268bd2;">VSYSCALL_ADDR_vgettimeofday</span> 0xffffffffff600000
<span style="color: #268bd2;">ENTRY</span> <span style="color: #757575;">(</span><span style="color: #b58900;">__gettimeofday</span><span style="color: #757575;">)</span>:
  movq  $VSYSCALL_ADDR_vgettimeofday<span style="color: #757575;">,</span> %rax
  callq *%rax
  ...  
</pre>
</div>
</div>
</li>
</ol>
</li>

<li><a id="org326c40f"></a>VDSO<br />
<div class="outline-text-6" id="text-1-3-2-3-6">
<p>
vsyscall page 被映射到固定的地址 (例如 x86_32 上的 0xffffe000, x86_64
上的 0xffffffffff600000), 所以存在安全问题. 因此 kernel 又采用了一种称为
vdso 的机制来代替 vsyscall.
</p>

<p>
vdso 可以被加载到非固定的位置, 所以通过它来实现 __kernel_vsyscall 和
vgettimeofday 会更安全. 但 vsyscall page 中的 __kernel_sigreturn 函数由于信号处理的特殊要求无法像 __kernel_vsyscall 那样被动态加载到非固定的地址, 所以 vdso 与 vsyscall page 是并存的. 在最新的 linux 4.6 x86_64
上可以看到两者共存的情况:
</p>

<pre class="example" id="org0babaa6">
...
7ffd165e0000-7ffd16601000 rw-p 00000000 00:00 0                          [stack]
7ffd1668c000-7ffd1668f000 r--p 00000000 00:00 0                          [vvar]
7ffd1668f000-7ffd16691000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]
</pre>
</div>
</li>

<li><a id="org5d3be89"></a>See also<br />
<div class="outline-text-6" id="text-1-3-2-3-7">
<p>
<a href="http://www.ibm.com/developerworks/cn/linux/kernel/l-k26ncpu/index.html">Linux 2.6 对新型 CPU 快速系统调用的支持</a>
</p>

<p>
<a href="https://www.win.tue.nl/~aeb/linux/lk/lk-4.html">https://www.win.tue.nl/~aeb/linux/lk/lk-4.html</a>
</p>

<p>
<a href="http://www.lenky.info/archives/2013/02/2199">http://www.lenky.info/archives/2013/02/2199</a>
</p>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org98c43a0" class="outline-4">
<h4 id="org98c43a0"><span class="section-number-4">1.3.3</span> Kernel Thread</h4>
<div class="outline-text-4" id="text-1-3-3">
</div>
<div id="outline-container-org30db92a" class="outline-5">
<h5 id="org30db92a"><span class="section-number-5">1.3.3.1</span> Overview</h5>
<div class="outline-text-5" id="text-1-3-3-1">
<p>
Kernel thread 与普通 task 一样, 也是通过 fork 创建的, 有相应的
task_struct 结构, 与普通 task 一样进行调度&#x2026;等, 但也有它特殊的地方:
</p>

<ol class="org-ol">
<li>kernel thread 只会在 kernel mode 执行, 它永远不会 "返回" 到 user
mode</li>

<li>它只会访问高 1G 的内存, 即它只会使用页表中对应高 1G 的部分</li>

<li>kernel thread 没有任何 vma, 所以 task_struct-&gt;mm 为 NULL, 但 kernel
thread 还是需要使用页表的 (mm-&gt;pgd), 所以它虽然没有 mm, 但会通过
task_struct-&gt;active_mm "借用" switch_to 的前一个进程的页表, 以避免
TLB flush</li>
</ol>
</div>
</div>

<div id="outline-container-org892db59" class="outline-5">
<h5 id="org892db59"><span class="section-number-5">1.3.3.2</span> 创建 kernel thread</h5>
<div class="outline-text-5" id="text-1-3-3-2">
</div>
<ol class="org-ol">
<li><a id="org05009b5"></a>kernel_thread<br />
<div class="outline-text-6" id="text-1-3-3-2-1">
<p>
kernel thread 与普通进程一样, 也是通过 do_fork 创建的, 但有些差别
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">kernel_thread</span>:
  <span style="color: #859900;">struct</span> <span style="color: #b58900;">pt_regs</span> <span style="color: #268bd2;">regs</span>;
  memset<span style="color: #757575;">(</span>&amp;regs<span style="color: #757575;">,</span> 0<span style="color: #757575;">,</span> <span style="color: #859900;">sizeof</span><span style="color: #757575;">(</span>regs<span style="color: #757575;">))</span>;

  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#21518;&#38754;&#30340; kernel_thread_helper &#20250;&#20351;&#29992;&#36825;&#20004;&#20010;&#20540;</span>
  regs.ebx = <span style="color: #757575;">(</span><span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span><span style="color: #757575;">)</span> fn;
  regs.edx = <span style="color: #757575;">(</span><span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span><span style="color: #757575;">)</span> arg;

  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#22312;&#36825;&#37324;&#20462;&#25913;&#20102; regs.eip &#21644; regs.xcs, &#24403; do_fork &#20986;&#26469;&#30340;&#23376;&#36827;&#31243;&#36890;&#36807;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">ret_from_fork &#36820;&#22238;&#26102;, interrupt &#30340;&#36890;&#29992;&#20195;&#30721;&#20250;&#20351;&#29992; regs &#24674;&#22797; eip, xcs,</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">esp..., &#23545;&#20110; syscall &#26469;&#35828;, &#36825;&#37096;&#20998;&#25805;&#20316;&#30456;&#24403;&#20110;"&#36820;&#22238; user mode", &#20294;&#23545;&#20110;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">kernel_thread &#26469;&#35828;, &#36825;&#19968;&#27493;&#25805;&#20316;&#20250;&#23548;&#33268;&#25191;&#34892;&#36335;&#24452;&#36339;&#36716;&#21040; kernel thread &#30340;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">fn</span>
  <span style="color: #586e75;">//</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">regs.xcs &#20026; __KERNEL_CS, &#34920;&#26126; kernel thread &#36816;&#34892;&#22312; kernel mode</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">regs.esp &#36825;&#37324;&#24182;&#27809;&#26377;&#29305;&#21035;&#36171;&#20540;, &#26159;&#22240;&#20026; iret &#26102;&#22240;&#20026; regs.xcs &#25552;&#21069;&#24050;&#32463;&#20462;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#25913;&#20026; __KERNEL_CS, &#23548;&#33268; cpu &#35748;&#20026;&#26412;&#27425; interrupt &#24182;&#27809;&#26377;&#21457;&#29983; stack &#30340;&#20999;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#25442;, &#25152;&#20197; esp &#22312; iret &#26102;&#24182;&#19981;&#38656;&#35201;&#20999;&#25442;&#20026; regs.esp, &#20855;&#20307;&#21442;&#32771;[[*&#20851;&#20110;&#31995;&#32479;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#35843;&#29992;][&#20851;&#20110;&#31995;&#32479;&#35843;&#29992;]] &#30340;&#31532; 2 &#28857;</span>
  regs.eip = <span style="color: #757575;">(</span><span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span><span style="color: #757575;">)</span> kernel_thread_helper;
  regs.xcs = __KERNEL_CS;
  regs.eflags = X86_EFLAGS_IF | X86_EFLAGS_SF | X86_EFLAGS_PF | 0x2;
  <span style="color: #586e75;">// </span><span style="color: #586e75;">do_fork &#30340;&#31532;&#20108;&#20010;&#21442;&#25968;&#20026; stack_start, &#36825;&#37324;&#20026; 0, &#25152;&#20197; ret_from_fork &#26102;,</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">regs.esp &#20250;&#34987;&#20462;&#25913;&#20026; 0, &#20294;&#24182;&#27809;&#26377;&#20160;&#20040;&#29992;, &#22240;&#20026; iret &#26102;&#24182;&#19981;&#20250;&#36890;&#36807;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">regs.esp &#24674;&#22797; esp</span>
  <span style="color: #859900;">return</span> do_fork<span style="color: #757575;">(</span>flags | CLONE_VM | CLONE_UNTRACED<span style="color: #757575;">,</span> 0<span style="color: #757575;">,</span> &amp;regs<span style="color: #757575;">,</span> 0<span style="color: #757575;">,</span> <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #757575;">,</span> <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #757575;">)</span>;
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org6b9afe7"></a>kernel_thread_helper<br />
<div class="outline-text-7" id="text-1-3-3-2-1-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #859900;">__asm__</span><span style="color: #757575;">(</span>
    <span style="color: #2aa198;">".section .text\n"</span>
    <span style="color: #2aa198;">"kernel_thread_helper:\n\t"</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">kernel_thread_helper &#34987;&#35843;&#29992;&#26102;, ebx, edx &#24050;&#32463;&#36890;&#36807; RESTORE_ALL &#24674;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#22797;&#20026; regs &#20013;&#30340;&#20540;</span>
    <span style="color: #2aa198;">"pushl %edx\n\t"</span>
    <span style="color: #2aa198;">"call *%ebx\n\t"</span>
    <span style="color: #2aa198;">"pushl %eax\n\t"</span>
    <span style="color: #2aa198;">"call do_exit\n"</span>
    <span style="color: #757575;">)</span>;
</pre>
</div>
</div>
</li>
</ol>
</li>

<li><a id="orgbfcfe54"></a>kthread_create<br />
<div class="outline-text-6" id="text-1-3-3-2-2">
<p>
kernel thread 是通过 fork 创建的, 那么 fork from "who" 是一个问题.
</p>

<p>
如果一个普通进程进入 kernel 后通过 kernel_thread 创建了一个 kernel
thread, 那么这个 kernel_thread 会与这个普通进程共享许多东西: mm, fs,
files &#x2026; 然而这些共享并没有必要, 因为 kernel thread 根本不需要它们.
</p>

<p>
另外, fork 还会导致 kernel thread 继承普通进程的属性, 例如 priority,
schedule policy, uid 等, 这些也不是 kernel 期望的
</p>

<p>
因此, kernel 提供了一个函数 daemonize, 让 kernel thread 可以释放这些不必要的资源, 并且恢复一些进程属性到默认值
</p>

<p>
以 loop.c 为例:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">lo_ioctl</span>:
  <span style="color: #586e75;">// </span><span style="color: #586e75;">ioctl &#26469;&#33258; syscall, &#25152;&#20197;&#36825;&#37324;&#35843;&#29992; kernel_thread &#30340;&#35805;&#20250;&#23548;&#33268;&#21019;&#24314;&#30340;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">kernel thread &#19982;&#21457;&#36215; ioctl &#30340;&#26222;&#36890;&#36827;&#31243;&#20849;&#20139;&#36164;&#28304;</span>
  <span style="color: #b58900;">loop_set_fd</span>
    <span style="color: #268bd2;">kernel_thread</span><span style="color: #757575;">(</span><span style="color: #b58900;">loop_thread</span><span style="color: #757575;">,</span> <span style="color: #b58900;">lo</span><span style="color: #757575;">,</span> <span style="color: #b58900;">CLONE_KERNEL</span><span style="color: #757575;">)</span>;

<span style="color: #268bd2; font-weight: bold;">loop_thread</span>:
  daemonize<span style="color: #757575;">(</span><span style="color: #2aa198;">"loop%d"</span><span style="color: #757575;">,</span> lo-&gt;lo_number<span style="color: #757575;">)</span>;
    <span style="color: #268bd2;">exit_mm</span><span style="color: #757575;">(</span><span style="color: #b58900;">current</span><span style="color: #757575;">)</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">Block and flush all signals    </span>
    sigfillset<span style="color: #757575;">(</span>&amp;blocked<span style="color: #757575;">)</span>;
    <span style="color: #268bd2;">sigprocmask</span><span style="color: #757575;">(</span><span style="color: #b58900;">SIG_BLOCK</span><span style="color: #757575;">,</span> &amp;blocked<span style="color: #757575;">,</span> <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #757575;">)</span>;
    <span style="color: #268bd2;">flush_signals</span><span style="color: #757575;">(</span><span style="color: #b58900;">current</span><span style="color: #757575;">)</span>;
    <span style="color: #268bd2;">exit_fs</span><span style="color: #757575;">(</span><span style="color: #b58900;">current</span><span style="color: #757575;">)</span>; */
    fs = init_task.fs;
    current-&gt;fs = fs;
    <span style="color: #268bd2;">exit_files</span><span style="color: #757575;">(</span><span style="color: #b58900;">current</span><span style="color: #757575;">)</span>;
    current-&gt;files = init_task.files;
    <span style="color: #268bd2;">reparent_to_init</span><span style="color: #757575;">()</span>;
      current-&gt;parent = child_reaper;
      current-&gt;real_parent = child_reaper;
      <span style="color: #859900;">if</span> <span style="color: #757575;">((</span>current-&gt;policy == SCHED_NORMAL<span style="color: #757575;">)</span> &amp;&amp; <span style="color: #757575;">(</span>task_nice<span style="color: #757575;">(</span>current<span style="color: #757575;">)</span> &lt; 0<span style="color: #757575;">))</span>:
        set_user_nice<span style="color: #757575;">(</span>current<span style="color: #757575;">,</span> 0<span style="color: #757575;">)</span>;
      <span style="color: #268bd2;">memcpy</span><span style="color: #757575;">(</span>current-&gt;signal-&gt;rlim<span style="color: #757575;">,</span> init_task.signal-&gt;rlim<span style="color: #757575;">,</span>
        <span style="color: #859900;">sizeof</span><span style="color: #757575;">(</span>current-&gt;signal-&gt;rlim<span style="color: #757575;">))</span>;
    switch_uid<span style="color: #757575;">(</span>&amp;root_user<span style="color: #757575;">)</span>;
</pre>
</div>

<p>
既然这样, 为什么不直接从一个 kernel thread 来 fork 出另一个 kernel
thread 呢?
</p>

<p>
kthread_create 就是做的这件事: 通过 kthread_create 可以给 keventd 发送一个消息 (workqueue), keventd 负责调用 kernel_thread 来创建 kernel
thread.
</p>
</div>
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org69ebcc2" class="outline-3">
<h3 id="org69ebcc2"><span class="section-number-3">1.4</span> 销毁进程</h3>
<div class="outline-text-3" id="text-1-4">
<p>
进程销毁有两个相关系统调用:
</p>

<ol class="org-ol">
<li><p>
exit_group
</p>

<p>
整个线程组的所有线程都会退出, libc 中的 exit 函数会调用 exit_group
</p></li>

<li><p>
_exit
</p>

<p>
只会导致当前线程退出, libc 中的 pthread_exit 会调用 _exit
</p></li>
</ol>
</div>

<div id="outline-container-orgb89a706" class="outline-4">
<h4 id="orgb89a706"><span class="section-number-4">1.4.1</span> main 返回</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
c 程序中 main 函数的调用路径为:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">__start</span>:
  <span style="color: #b58900;">__libc_start_main</span>
    <span style="color: #268bd2;">exit</span><span style="color: #757575;">(</span><span style="color: #b58900;">main</span><span style="color: #757575;">())</span>
</pre>
</div>

<p>
所以 main 返回后 exit 会被调用, 整个线程组都会退出.
</p>
</div>
</div>
</div>

<div id="outline-container-orgfd95808" class="outline-3">
<h3 id="orgfd95808"><span class="section-number-3">1.5</span> Appendix</h3>
<div class="outline-text-3" id="text-1-5">
</div>
<div id="outline-container-org5524804" class="outline-4">
<h4 id="org5524804"><span class="section-number-4">1.5.1</span> 0 号进程与 1 号进程</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
0 号进程, 即 swapper, idle 或 init_task. kernel 启动时是以 0 号进程(后面统称 swapper) 的身份在运行的
</p>

<ol class="org-ol">
<li>首先, swapper 对应的 task_struct 为 init_task, 是静态初始化的, 其中最重要的数据结构是 init_task-&gt;thread_info, 也是静态初始化的, 为
init_thread_info.</li>

<li><p>
head.S 定义了一个 entry 为 stack_start
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2;">ENTRY</span><span style="color: #757575;">(</span><span style="color: #b58900;">stack_start</span><span style="color: #757575;">)</span>
.<span style="color: #b58900;">long</span> init_thread_union+THREAD_SIZE
.<span style="color: #b58900;">long</span> __BOOT_DS
ready:  .byte 0
</pre>
</div>

<p>
其中的 init_thread_union 与 init_thread_info 地址相同
</p></li>

<li>startup_32 时会将 stack_start 设置为初始的 esp, 从此以后 kernel 相当于以 swapper 进程的身份在运行了</li>

<li><p>
kernel 启动的最后阶段, 调用了 rest_init 来启动 1 号进程 (init), 同时自身通过运行 cpu_idle 变成名副其实的 idle 进程
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">rest_init</span>:
  <span style="color: #268bd2;">kernel_thread</span><span style="color: #757575;">(</span><span style="color: #b58900;">init</span><span style="color: #757575;">,</span> <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #757575;">,</span> CLONE_FS | CLONE_SIGHAND<span style="color: #757575;">)</span>;
  <span style="color: #268bd2;">cpu_idle</span><span style="color: #757575;">()</span>;
    <span style="color: #859900;">while</span> <span style="color: #757575;">(</span>1<span style="color: #757575;">)</span>:
      <span style="color: #859900;">while</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>need_resched<span style="color: #757575;">())</span>:
        <span style="color: #586e75;">// </span><span style="color: #586e75;">idle          </span>
        cpu_relax<span style="color: #757575;">()</span>  
      <span style="color: #268bd2;">schedule</span><span style="color: #757575;">()</span>
</pre>
</div></li>

<li>swapper 也是一个进程, 所以它也会参与到进程调试中, 只不过它是进程调试最后的选择</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

<p class="author">Author: sunway (sunwayforever@gmail.com)<br />
Date: 2016-07-08 五 00:00<br />
Last updated: 2022-01-19 三 13:25</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。
<br />

<div id="disqus_thread"></div>
<script>

(function() { // DON'T EDIT BELOW THIS LINE
         var d = document, s = d.createElement('script');
         s.src = '//sunwayforever-github-io.disqus.com/embed.js';
         s.setAttribute('data-timestamp', +new Date());
         (d.head || d.body).appendChild(s);
         })();
</script>
</div>
</body>
</html>
