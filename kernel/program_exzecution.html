<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>Linux Kernel: Program Exzecution</title>


<link rel="stylesheet" type="text/css" href="/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="./htmlize.css"/>
<link rel="stylesheet" type="text/css" href="../htmlize.css"/>
<link rel="stylesheet" type="text/css" href="/readtheorg.css"/>
<link rel="stylesheet" type="text/css" href="./readtheorg.css"/>
<link rel="stylesheet" type="text/css" href="../readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
<link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
<link rel="stylesheet" type="text/css" href="../main.css" media="screen" />
<link rel="stylesheet" type="text/css" href="./main.css" media="screen" />
<link rel = "icon" href = "/icon.png"  type = "image/x-icon">
</head>
<body>
<div id="content" class="content">
<h1 class="title">Linux Kernel: Program Exzecution</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org0000037">1. Linux Kernel: Program Exzecution</a>
<ul>
<li><a href="#org0000010">1.1. do_execve</a>
<ul>
<li><a href="#org0000001">1.1.1. copy_strings</a></li>
<li><a href="#org000000d">1.1.2. search_binary_handler</a></li>
</ul>
</li>
<li><a href="#org000002e">1.2. ELF 的加载</a>
<ul>
<li><a href="#org0000013">1.2.1. load_elf_binary</a></li>
<li><a href="#org0000016">1.2.2. setup_arg_pages</a></li>
<li><a href="#org0000019">1.2.3. create_elf_tables</a></li>
<li><a href="#org000001c">1.2.4. load_elf_interp</a></li>
<li><a href="#org000002b">1.2.5. ELF 程序引用 argc, argv</a></li>
</ul>
</li>
<li><a href="#org0000031">1.3. script 的加载</a></li>
<li><a href="#org0000034">1.4. 用户自定义加载</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org0000037" class="outline-2">
<h2 id="org0000037"><span class="section-number-2">1.</span> Linux Kernel: Program Exzecution</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org0000010" class="outline-3">
<h3 id="org0000010"><span class="section-number-3">1.1.</span> do_execve</h3>
<div class="outline-text-3" id="text-1-1">
<div class="org-src-container">
<pre class="src src-c"><span class="org-function-name">do_execve</span> <span class="org-parenthesis">(</span><span class="org-type">filename</span><span class="org-parenthesis">,</span> <span class="org-type">argv</span><span class="org-parenthesis">,</span> <span class="org-type">envp</span><span class="org-parenthesis">,</span> <span class="org-type">regs</span><span class="org-parenthesis">)</span>:
  <span class="org-keyword">struct</span> linux_binprm *bprm = kmalloc<span class="org-parenthesis">(</span><span class="org-keyword">sizeof</span><span class="org-parenthesis">(</span>*bprm<span class="org-parenthesis">),</span> GFP_KERNEL<span class="org-parenthesis">)</span>;
  <span class="org-function-name">memset</span><span class="org-parenthesis">(</span><span class="org-type">bprm</span><span class="org-parenthesis">,</span> 0<span class="org-parenthesis">,</span> <span class="org-keyword">sizeof</span><span class="org-parenthesis">(</span>*bprm<span class="org-parenthesis">))</span>;
  file = open_exec<span class="org-parenthesis">(</span>filename<span class="org-parenthesis">)</span>;
    <span class="org-function-name">path_lookup</span><span class="org-parenthesis">(</span><span class="org-type">name</span><span class="org-parenthesis">,</span> LOOKUP_FOLLOW|LOOKUP_OPEN<span class="org-parenthesis">,</span> &amp;nd<span class="org-parenthesis">)</span>;
    <span class="org-function-name">permission</span><span class="org-parenthesis">(</span><span class="org-type">inode</span><span class="org-parenthesis">,</span> <span class="org-type">MAY_EXEC</span><span class="org-parenthesis">,</span> &amp;nd<span class="org-parenthesis">)</span>;
    <span class="org-keyword">return</span> dentry_open<span class="org-parenthesis">(</span>nd.dentry<span class="org-parenthesis">,</span> nd.mnt<span class="org-parenthesis">,</span> O_RDONLY<span class="org-parenthesis">)</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">sched_exec &#21644; cpu load balance &#26377;&#20851;, &#20855;&#20307;&#21442;&#32771;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">[[file:process_scheduling.org::*push%20task][push task]]</span>
  <span class="org-function-name">sched_exec</span><span class="org-parenthesis">()</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">MAX_ARG_PAGES &#40664;&#35748;&#20026; 32, &#34920;&#31034;&#32473; argv &#21644; env &#39044;&#30041;&#26368;&#22810; 32 &#20010; page, &#33509;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">page &#20026; 4k, &#21017;&#26368;&#32456;&#39044;&#30041; 128K</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#21518;&#32493; argv &#21644; env &#38656;&#35201;&#20174; user &#22797;&#21046;&#21040; bprm-&gt;page &#20013;, &#22797;&#21046;&#26102;&#38656;&#35201;&#26681;&#25454;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">bprm-&gt;p &#25351;&#31034;&#22797;&#21046;&#21040; page &#30340;&#20160;&#20040;&#20301;&#32622;</span>
  bprm-&gt;p = PAGE_SIZE*MAX_ARG_PAGES-<span class="org-keyword">sizeof</span><span class="org-parenthesis">(</span><span class="org-type">void</span> *<span class="org-parenthesis">)</span>;

  bprm-&gt;file = file;
  <span class="org-comment-delimiter">// </span><span class="org-comment">bprm-&gt;filename &#21644; bprm-&gt;interp &#19968;&#33324;&#26159;&#19968;&#33268;&#30340;, &#20294;&#26377;&#20363;&#22806;:</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20363;&#22914;&#23545;&#20110;&#21160;&#24577;&#38142;&#25509;&#30340; elf &#26469;&#35828;, filename &#20026; elf &#26412;&#36523;, interp &#20026; elf &#25351;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#31034;&#30340; interp, &#20363;&#22914; /lib/ld-linux.so.2</span>
  bprm-&gt;filename = filename;
  bprm-&gt;interp = filename;
  bprm-&gt;mm = mm_alloc<span class="org-parenthesis">()</span>;

  bprm-&gt;argc = count<span class="org-parenthesis">(</span>argv<span class="org-parenthesis">)</span>;
  bprm-&gt;envc = count<span class="org-parenthesis">(</span>envp<span class="org-parenthesis">)</span>;

  <span class="org-function-name">prepare_binprm</span><span class="org-parenthesis">(</span><span class="org-type">bprm</span><span class="org-parenthesis">)</span>
    mode = inode-&gt;i_mode;
    bprm-&gt;e_uid = current-&gt;euid;
    bprm-&gt;e_gid = current-&gt;egid;
    <span class="org-comment-delimiter">// </span><span class="org-comment">setuid</span>
    <span class="org-keyword">if</span> <span class="org-parenthesis">(</span>mode &amp; S_ISUID<span class="org-parenthesis">)</span>:
      bprm-&gt;e_uid = inode-&gt;i_uid;
    <span class="org-comment-delimiter">// </span><span class="org-comment">setgid</span>
    <span class="org-keyword">if</span> <span class="org-parenthesis">((</span>mode &amp; <span class="org-parenthesis">(</span>S_ISGID | S_IXGRP<span class="org-parenthesis">))</span> == <span class="org-parenthesis">(</span>S_ISGID | S_IXGRP<span class="org-parenthesis">))</span>:
      bprm-&gt;e_gid = inode-&gt;i_gid;
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#25991;&#20214;&#24320;&#22836;&#30340; BINPRM_BUF_SIZE (128) &#23383;&#33410;&#30340;&#25968;&#25454;&#35835;&#21040; bprm-&gt;buf &#20013;, &#21518;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#32493;&#21508;&#20010; linux_binfmt &#20250;&#36890;&#36807; bprm-&gt;buf &#26469;&#30830;&#35748;&#23427;&#26159;&#21542;&#25903;&#25345;&#36825;&#31181;&#21487;&#25191;&#34892;&#25991;&#20214;&#26684;&#24335;</span>
    <span class="org-keyword">return</span> kernel_read<span class="org-parenthesis">(</span>bprm-&gt;file<span class="org-parenthesis">,</span>0<span class="org-parenthesis">,</span>bprm-&gt;buf<span class="org-parenthesis">,</span>BINPRM_BUF_SIZE<span class="org-parenthesis">)</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">copy_strings &#23558; argv, envp &#20197;&#21450; filename &#22797;&#21046;&#21040; bprm-&gt;page &#20013;, &#21518;&#32493;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20123;&#20869;&#23481;&#23558;&#36890;&#36807;&#35774;&#32622;&#39029;&#34920;&#30340;&#26041;&#24335;&#20986;&#29616;&#22312;&#36827;&#31243;&#22320;&#22336;&#31354;&#38388;&#20013; stack &#20043;&#19978;&#30340;&#37096;&#20998;</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36890;&#36807; copy_strings &#30340;&#20195;&#30721;, &#21487;&#20197;&#30475;&#21040;&#26368;&#32456;&#30340;&#29992;&#25143;&#31354;&#38388;&#24067;&#23616;&#19978;&#20174;&#39640;&#21040;&#20302;&#30340;&#39034;&#24207;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20026;:</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">1. filename</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">2. env</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">3. argv</span>
  copy_strings_kernel<span class="org-parenthesis">(</span>1<span class="org-parenthesis">,</span> &amp;bprm-&gt;filename<span class="org-parenthesis">,</span> bprm<span class="org-parenthesis">)</span>;
  <span class="org-function-name">copy_strings</span><span class="org-parenthesis">(</span>bprm-&gt;envc<span class="org-parenthesis">,</span> <span class="org-type">envp</span><span class="org-parenthesis">,</span> <span class="org-type">bprm</span><span class="org-parenthesis">)</span>;
  <span class="org-function-name">copy_strings</span><span class="org-parenthesis">(</span>bprm-&gt;argc<span class="org-parenthesis">,</span> <span class="org-type">argv</span><span class="org-parenthesis">,</span> <span class="org-type">bprm</span><span class="org-parenthesis">)</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">execve &#26368;&#20851;&#38190;&#30340;&#37096;&#20998;: &#36941;&#21382;&#25152;&#26377; linux_binfmt, &#26399;&#26395;&#26576;&#19968;&#20010; binfmt &#21487;&#20197;&#25903;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#25345;&#36825;&#20010;&#21487;&#25191;&#34892;&#25991;&#20214;&#24182;&#23436;&#25104;&#21518;&#32493;&#30340;&#36807;&#31243;(&#20363;&#22914;&#25991;&#20214;&#20013;&#21508;&#20010; section &#30340;&#21152;&#36733;,</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#31243;&#24207;&#20837;&#21475;&#30340;&#30830;&#23450;&#31561;)</span>
  <span class="org-function-name">search_binary_handler</span><span class="org-parenthesis">(</span><span class="org-type">bprm</span><span class="org-parenthesis">,</span><span class="org-type">regs</span><span class="org-parenthesis">)</span>;
</pre>
</div>
</div>

<div id="outline-container-org0000001" class="outline-4">
<h4 id="org0000001"><span class="section-number-4">1.1.1.</span> copy_strings</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
do_execve 的一个重要的任务是根据 user mode 的 argv, envp 设置好新进程的
argv 和 envp.
</p>

<p>
进程的 argv, envp 及 stack 有的关系如图所示:
</p>


<div id="org0000000" class="figure">
<p><img src="../extra/kernel_argv_envp.png" alt="kernel_argv_envp.png" />
</p>
</div>

<p>
这个布局并不是一步到位的: 在 do_execve 的早期, 比如 copy_strings 阶段,
只会将 argv, envp 复制到 bprm-&gt;page 中, 但复制时就会考虑最终的布局, 以便后面可以通过设置页表完成最后的布局
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-function-name">copy_strings</span><span class="org-parenthesis">(</span><span class="org-type">argc</span><span class="org-parenthesis">,</span> <span class="org-type">argv</span><span class="org-parenthesis">,</span> <span class="org-type">bprm</span><span class="org-parenthesis">)</span>:
  <span class="org-keyword">while</span> <span class="org-parenthesis">(</span>argc-- &gt; 0<span class="org-parenthesis">)</span>:
    <span class="org-type">char</span> __user *str;
    <span class="org-comment-delimiter">// </span><span class="org-comment">str &#20195;&#34920; argv &#20013;&#30340;&#19968;&#39033;</span>
    <span class="org-function-name">get_user</span><span class="org-parenthesis">(</span><span class="org-type">str</span><span class="org-parenthesis">,</span> argv+argc<span class="org-parenthesis">)</span>;
    len = strnlen_user<span class="org-parenthesis">(</span>str<span class="org-parenthesis">,</span> bprm-&gt;p<span class="org-parenthesis">)</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#35843;&#25972; bprm-&gt;p, &#32473; str &#30041;&#20986;&#31354;&#38388;, &#21487;&#20197;&#30475;&#21040;, argv[1] &#23545;&#24212;&#30340; bprm-&gt;p &#27604;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">argv[0] &#30340;&#26356;&#22823;, &#32780;&#21518;&#38754; copy &#21040; bprm-&gt;page &#26102;&#20351;&#29992; bprm-&gt;p &#20570;&#20026;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">offset, &#25152;&#20197; argv[0] &#23558;&#20301;&#20110; bprm-&gt;page &#30340;&#39640;&#22320;&#22336;, &#32780;&#26368;&#32456; bprm-&gt;page</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20250;&#34987;&#36890;&#36807;&#26144;&#23556;&#39029;&#34920;&#30340;&#26041;&#24335; "&#24179;&#31227;" &#21040; stack &#39030;&#31471;, &#25152;&#20197; argv[1] &#25351;&#21521;&#30340;&#22320;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#22336;&#26368;&#32456;&#20250;&#22312; argv[0] &#20043;&#19978;</span>
    bprm-&gt;p -= len;
    pos = bprm-&gt;p;

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#23545;&#24212;&#30340; argv &#22797;&#21046;&#21040;&#21512;&#36866;&#30340; bprm-&gt;page[i] &#30340;&#21512;&#36866;&#30340;&#20301;&#32622; (&#26681;&#25454; bprm-&gt;p)</span>
    offset = pos % PAGE_SIZE;
    i = pos/PAGE_SIZE;
    page = bprm-&gt;page[i];
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#25353;&#38656;&#35201;&#20998;&#37197;&#26032;&#30340; page &#24182;&#29992; kmap &#26144;&#23556;, &#20197;&#20415;&#21518;&#38754;&#22797;&#21046;&#21040;&#36825;&#20010; page</span>
    <span class="org-keyword">if</span> <span class="org-parenthesis">(</span><span class="org-negation-char">!</span>page<span class="org-parenthesis">)</span>:
      page = alloc_page<span class="org-parenthesis">(</span>GFP_HIGHUSER<span class="org-parenthesis">)</span>;
      bprm-&gt;page[i] = page;
    <span class="org-keyword">if</span> <span class="org-parenthesis">(</span>page != kmapped_page<span class="org-parenthesis">)</span>:
      <span class="org-keyword">if</span> <span class="org-parenthesis">(</span>kmapped_page<span class="org-parenthesis">)</span>:
        kunmap<span class="org-parenthesis">(</span>kmapped_page<span class="org-parenthesis">)</span>;
      kmapped_page = page;
      kaddr = kmap<span class="org-parenthesis">(</span>kmapped_page<span class="org-parenthesis">)</span>;
    <span class="org-function-name">copy_from_user</span><span class="org-parenthesis">(</span>kaddr+offset<span class="org-parenthesis">,</span> <span class="org-type">str</span><span class="org-parenthesis">,</span> <span class="org-type">bytes_to_copy</span><span class="org-parenthesis">)</span>;
</pre>
</div>

<p>
针对 argv, envp 的 copy_strings 完成后, bprm-&gt;page 中的布局已经与上面图中的 "Environment Strings" 和 "Command-line arguments" 是一致的了,
后续会把它们 "平移" 到最终的用户空间布局上, 并且需要设置好 envp[],
argv[] 和 argc
</p>
</div>
</div>

<div id="outline-container-org000000d" class="outline-4">
<h4 id="org000000d"><span class="section-number-4">1.1.2.</span> search_binary_handler</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
search_binary_handler 是 do_execve 最重要的一步, 它所做的并不仅仅是
"search": 当 search_binary_handler 返回后, 整个用户地址空间都已经设置好了, pt_regs 上 esp, eip 的值已经被设置为正确的值, 当 do_execve
syscall 返回后, 进程就会从可执行文件的入口开始执行了
</p>

<p>
所谓的 binary handler, 是指 linux_binfmt, 系统启动时会注册几个
linux_binfmt, 对应不同的可执行文件格式, 例如:
</p>

<ol class="org-ol">
<li>aout_format</li>

<li>elf_format</li>

<li>script_format</li>

<li>misc_format</li>
</ol>

<p>
kernel 通过 register_binfmt 完成 linux_binfmt 的注册
</p>
</div>

<div id="outline-container-org0000004" class="outline-5">
<h5 id="org0000004"><span class="section-number-5">1.1.2.1.</span> register_binfmt</h5>
<div class="outline-text-5" id="text-1-1-2-1">
<div class="org-src-container">
<pre class="src src-c"><span class="org-function-name">register_binfmt</span><span class="org-parenthesis">(</span><span class="org-type">fmt</span><span class="org-parenthesis">)</span>:
  <span class="org-keyword">struct</span> linux_binfmt ** tmp = &amp;formats;
  fmt-&gt;next = formats;
  formats = fmt;
</pre>
</div>

<p>
register_binfmt 的过程仅仅是将一种 linux_binfmt 插入到一个全局的
formats 链表的末尾
</p>
</div>
</div>

<div id="outline-container-org0000007" class="outline-5">
<h5 id="org0000007"><span class="section-number-5">1.1.2.2.</span> linux_binfmt</h5>
<div class="outline-text-5" id="text-1-1-2-2">
<div class="org-src-container">
<pre class="src src-c"><span class="org-keyword">struct</span> <span class="org-type">linux_binfmt</span> <span class="org-parenthesis">{</span>
    <span class="org-keyword">struct</span> <span class="org-type">linux_binfmt</span> * <span class="org-variable-name">next</span>;
    <span class="org-keyword">struct</span> <span class="org-type">module</span> *<span class="org-variable-name">module</span>;
    <span class="org-type">int</span> <span class="org-parenthesis">(</span>*<span class="org-function-name">load_binary</span><span class="org-parenthesis">)(</span><span class="org-keyword">struct</span> <span class="org-type">linux_binprm</span> *<span class="org-parenthesis">,</span> <span class="org-keyword">struct</span>  <span class="org-type">pt_regs</span> * <span class="org-variable-name">regs</span><span class="org-parenthesis">)</span>;
    <span class="org-type">int</span> <span class="org-parenthesis">(</span>*<span class="org-function-name">load_shlib</span><span class="org-parenthesis">)(</span><span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-parenthesis">)</span>;
    <span class="org-type">int</span> <span class="org-parenthesis">(</span>*<span class="org-function-name">core_dump</span><span class="org-parenthesis">)(</span><span class="org-type">long</span> <span class="org-variable-name">signr</span><span class="org-parenthesis">,</span> <span class="org-keyword">struct</span> <span class="org-type">pt_regs</span> * <span class="org-variable-name">regs</span><span class="org-parenthesis">,</span> <span class="org-keyword">struct</span> <span class="org-type">file</span> * <span class="org-variable-name">file</span><span class="org-parenthesis">)</span>;
    <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">min_coredump</span>; <span class="org-comment-delimiter">/* </span><span class="org-comment">minimal dump size</span><span class="org-comment-delimiter"> */</span>
<span class="org-parenthesis">}</span>;
</pre>
</div>

<p>
其中最重要的是 load_binary 这个回调函数, search_binary_handler 时会
formats 中所有的 linux_binfmt 并调用其 load_binary, 直到某个
load_binary 成功为止.
</p>
</div>
</div>

<div id="outline-container-org000000a" class="outline-5">
<h5 id="org000000a"><span class="section-number-5">1.1.2.3.</span> search_binary_handler</h5>
<div class="outline-text-5" id="text-1-1-2-3">
<div class="org-src-container">
<pre class="src src-c"><span class="org-function-name">search_binary_handler</span><span class="org-parenthesis">(</span><span class="org-type">bprm</span><span class="org-parenthesis">,</span><span class="org-type">regs</span><span class="org-parenthesis">)</span>:
  <span class="org-keyword">for</span> <span class="org-parenthesis">(</span>fmt = formats ; fmt ; fmt = fmt-&gt;next<span class="org-parenthesis">)</span>:
    <span class="org-type">int</span> <span class="org-parenthesis">(</span>*fn<span class="org-parenthesis">)(</span><span class="org-keyword">struct</span> <span class="org-type">linux_binprm</span> *<span class="org-parenthesis">,</span> <span class="org-keyword">struct</span> <span class="org-type">pt_regs</span> *<span class="org-parenthesis">)</span> = fmt-&gt;load_binary;
    retval = fn<span class="org-parenthesis">(</span>bprm<span class="org-parenthesis">,</span> regs<span class="org-parenthesis">)</span>;
    <span class="org-keyword">if</span> <span class="org-parenthesis">(</span>retval &gt;= 0<span class="org-parenthesis">)</span>:
      <span class="org-keyword">return</span> retval;
</pre>
</div>

<p>
可见 do_execve 最主要的工作由 linux_binfmt-&gt;load_binary 完成
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org000002e" class="outline-3">
<h3 id="org000002e"><span class="section-number-3">1.2.</span> ELF 的加载</h3>
<div class="outline-text-3" id="text-1-2">
<p>
load_elf_binary 是 elf_format 对应的 load_binary 实现
</p>
</div>

<div id="outline-container-org0000013" class="outline-4">
<h4 id="org0000013"><span class="section-number-4">1.2.1.</span> load_elf_binary</h4>
<div class="outline-text-4" id="text-1-2-1">
<div class="org-src-container">
<pre class="src src-c"><span class="org-function-name">load_elf_binary</span><span class="org-parenthesis">(</span><span class="org-type">bprm</span><span class="org-parenthesis">,</span> <span class="org-type">regs</span><span class="org-parenthesis">)</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#21160;&#24577;&#38142;&#25509;&#30340; elf &#31243;&#24207;&#20250;&#25351;&#23450; interpreter, &#21017;&#31243;&#24207;&#30340;&#20837;&#21475;&#19981;&#20877;&#26159; elf &#26412;&#36523;&#30340;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">e_entry, &#32780;&#26159; interpreter &#30340; e_entry</span>
  loc-&gt;elf_ex = *<span class="org-parenthesis">((</span><span class="org-keyword">struct</span> <span class="org-type">elfhdr</span> *<span class="org-parenthesis">)</span> bprm-&gt;buf<span class="org-parenthesis">)</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#30475; elf &#20013;&#26159;&#21542;&#21253;&#21547; PT_INTERP section (.interp)</span>
  <span class="org-keyword">for</span> <span class="org-parenthesis">(</span>i = 0; i &lt; loc-&gt;elf_ex.e_phnum; i++<span class="org-parenthesis">)</span>:
    <span class="org-keyword">if</span> <span class="org-parenthesis">(</span>elf_ppnt-&gt;p_type == PT_INTERP<span class="org-parenthesis">)</span>:
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#35835;&#21462; interp &#30340;&#21517;&#23383; (&#20363;&#22914; /lib/ld-linux.so.2) &#20445;&#23384;&#22312;</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">elf_interpreter &#20013;</span>
      elf_interpreter = <span class="org-parenthesis">(</span><span class="org-type">char</span> *<span class="org-parenthesis">)</span> <span class="org-function-name">kmalloc</span><span class="org-parenthesis">(</span>elf_ppnt-&gt;p_filesz<span class="org-parenthesis">,</span> <span class="org-type">GFP_KERNEL</span><span class="org-parenthesis">)</span>;
      <span class="org-function-name">kernel_read</span><span class="org-parenthesis">(</span>bprm-&gt;file<span class="org-parenthesis">,</span> elf_ppnt-&gt;p_offset<span class="org-parenthesis">,</span><span class="org-type">elf_interpreter</span><span class="org-parenthesis">,</span> elf_ppnt-&gt;p_filesz<span class="org-parenthesis">)</span>;
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#25171;&#24320; interpreter &#25991;&#20214;</span>
      interpreter = open_exec<span class="org-parenthesis">(</span>elf_interpreter<span class="org-parenthesis">)</span>;
      <span class="org-function-name">kernel_read</span><span class="org-parenthesis">(</span><span class="org-type">interpreter</span><span class="org-parenthesis">,</span> 0<span class="org-parenthesis">,</span> bprm-&gt;buf<span class="org-parenthesis">,</span> <span class="org-type">BINPRM_BUF_SIZE</span><span class="org-parenthesis">)</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#26432;&#27515;&#20854;&#23427;&#32447;&#31243;, &#25353;&#29031; man 2 execve &#30340;&#35828;&#27861;:</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">All threads other than</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">the calling thread are destroyed during an execve().</span>
  <span class="org-function-name">flush_old_exec</span><span class="org-parenthesis">(</span><span class="org-type">bprm</span><span class="org-parenthesis">)</span>;
    <span class="org-function-name">de_thread</span><span class="org-parenthesis">(</span><span class="org-type">current</span><span class="org-parenthesis">)</span>;
      <span class="org-function-name">zap_other_threads</span><span class="org-parenthesis">(</span><span class="org-type">current</span><span class="org-parenthesis">)</span>;
        <span class="org-keyword">for</span> <span class="org-parenthesis">(</span>t = next_thread<span class="org-parenthesis">(</span>p<span class="org-parenthesis">)</span>; t != p; t = next_thread<span class="org-parenthesis">(</span>t<span class="org-parenthesis">))</span>:
          sigaddset<span class="org-parenthesis">(</span>&amp;t-&gt;pending.signal<span class="org-parenthesis">,</span> SIGKILL<span class="org-parenthesis">)</span>;
          <span class="org-function-name">signal_wake_up</span><span class="org-parenthesis">(</span><span class="org-type">t</span><span class="org-parenthesis">,</span> 1<span class="org-parenthesis">)</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36873;&#25321; mmap layout, &#21442;&#32771; [[file:memory.org::*get_unmapped_area][get_unmapped_area]]</span>
  <span class="org-function-name">arch_pick_mmap_layout</span><span class="org-parenthesis">(</span>current-&gt;mm<span class="org-parenthesis">)</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#20445;&#23384;&#30528; argv &#21644; envp &#30340; bprm-&gt;page "&#24179;&#31227;" &#21040;&#26368;&#32456;&#30340;&#29992;&#25143;&#22320;&#22336;&#31354;&#38388;&#20013;</span>
  <span class="org-function-name">setup_arg_pages</span><span class="org-parenthesis">(</span><span class="org-type">bprm</span><span class="org-parenthesis">,</span> <span class="org-type">STACK_TOP</span><span class="org-parenthesis">,</span> <span class="org-type">executable_stack</span><span class="org-parenthesis">)</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;&#20540;&#21518;&#38754;&#20250;&#34987;&#35774;&#32622;&#20026; regs-&gt;esp, &#20174;&#32780;&#25104;&#20026;&#26032;&#36827;&#31243;&#30340;&#26632;&#39030;</span>
  current-&gt;mm-&gt;start_stack = bprm-&gt;p;

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#25226; elf &#20013;&#25152;&#26377;&#20026; PT_LOAD &#30340; segment &#36890;&#36807; mmap &#26144;&#23556;&#36827;&#26469;, PT_LOAD &#30340;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">segment &#20027;&#35201;&#21253;&#25324;: text, init, rodata, data, bss &#31561; section</span>
  <span class="org-keyword">for</span><span class="org-parenthesis">(</span>i = 0<span class="org-parenthesis">,</span> elf_ppnt = elf_phdata; i &lt; loc-&gt;elf_ex.e_phnum; i++<span class="org-parenthesis">,</span> elf_ppnt++<span class="org-parenthesis">)</span>:
    <span class="org-keyword">if</span> <span class="org-parenthesis">(</span>elf_ppnt-&gt;p_type != PT_LOAD<span class="org-parenthesis">)</span>: <span class="org-keyword">continue</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#35774;&#32622; mmap &#30340; prot &#21644; flags</span>
    <span class="org-keyword">if</span> <span class="org-parenthesis">(</span>elf_ppnt-&gt;p_flags &amp; PF_R<span class="org-parenthesis">)</span> elf_prot |= PROT_READ;
    <span class="org-keyword">if</span> <span class="org-parenthesis">(</span>elf_ppnt-&gt;p_flags &amp; PF_W<span class="org-parenthesis">)</span> elf_prot |= PROT_WRITE;
    <span class="org-keyword">if</span> <span class="org-parenthesis">(</span>elf_ppnt-&gt;p_flags &amp; PF_X<span class="org-parenthesis">)</span> elf_prot |= PROT_EXEC;

    elf_flags = MAP_PRIVATE|MAP_DENYWRITE|MAP_EXECUTABLE;
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#38656;&#35201; mmap &#21040;&#30340;&#22320;&#22336;, &#32534;&#35793;&#26102;&#30001;&#38142;&#25509;&#22120;&#33050;&#26412; (ld script) &#25351;&#23450;, &#20889;&#20837;&#22312;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">elf &#25991;&#20214;&#20013;</span>
    vaddr = elf_ppnt-&gt;p_vaddr;
    <span class="org-comment-delimiter">// </span><span class="org-comment">mmap</span>
    <span class="org-function-name">elf_map</span><span class="org-parenthesis">(</span>bprm-&gt;file<span class="org-parenthesis">,</span> load_bias + vaddr<span class="org-parenthesis">,</span> <span class="org-type">elf_ppnt</span><span class="org-parenthesis">,</span> <span class="org-type">elf_prot</span><span class="org-parenthesis">,</span> <span class="org-type">elf_flags</span><span class="org-parenthesis">)</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#21160;&#24577;&#32534;&#35793;&#30340; elf &#31243;&#24207;&#25351;&#23450;&#20102; interpreter, &#25152;&#20197;&#20854;&#20837;&#21475;&#19981;&#20877;&#26159; e_entry, &#32780;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#26159; interpreter &#23545;&#24212;&#30340; e_entry</span>
  <span class="org-keyword">if</span> <span class="org-parenthesis">(</span>elf_interpreter<span class="org-parenthesis">)</span>:
    elf_entry = load_elf_interp<span class="org-parenthesis">(</span>&amp;loc-&gt;interp_elf_ex<span class="org-parenthesis">,</span>interpreter<span class="org-parenthesis">,</span>&amp;interp_load_addr<span class="org-parenthesis">)</span>;
  <span class="org-keyword">else</span>:
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#38745;&#24577;&#32534;&#35793;&#30340;&#31243;&#24207;, &#30452;&#25509;&#20351;&#29992; e_entry &#20570;&#20026;&#20837;&#21475;, e_entry &#22312; x86_32 &#19979;&#19968;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#33324;&#22266;&#23450;&#20026; 0x80482c0, &#23545;&#24212;&#20110; crt1.o &#20013;&#30340; __start &#20989;&#25968;, &#30001; ld script</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#25351;&#23450;        </span>
    elf_entry = loc-&gt;elf_ex.e_entry;

  <span class="org-function-name">create_elf_tables</span><span class="org-parenthesis">(</span><span class="org-type">bprm</span><span class="org-parenthesis">,</span> &amp;loc-&gt;elf_ex<span class="org-parenthesis">,</span>
                    <span class="org-parenthesis">(</span>interpreter_type == INTERPRETER_AOUT<span class="org-parenthesis">),</span><span class="org-type">load_addr</span><span class="org-parenthesis">,</span> <span class="org-type">interp_load_addr</span><span class="org-parenthesis">)</span>;
  current-&gt;mm-&gt;end_code = end_code;
  current-&gt;mm-&gt;start_code = start_code;
  current-&gt;mm-&gt;start_data = start_data;
  current-&gt;mm-&gt;end_data = end_data;
  current-&gt;mm-&gt;start_stack = bprm-&gt;p;

  <span class="org-comment-delimiter">// </span><span class="org-comment">do_execve &#36820;&#22238;&#21040; user mode &#30340;&#26368;&#21518;&#19968;&#27493;: &#35774;&#32622; regs-&gt;{eip,esp, ...} &#20197;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20415;&#20174; syscall &#36820;&#22238;&#21518;&#33021;&#25191;&#34892; elf &#31243;&#24207;</span>
  <span class="org-function-name">start_thread</span><span class="org-parenthesis">(</span><span class="org-type">regs</span><span class="org-parenthesis">,</span> <span class="org-type">elf_entry</span><span class="org-parenthesis">,</span> bprm-&gt;p<span class="org-parenthesis">)</span>;
    regs-&gt;xds = __USER_DS;
    regs-&gt;xes = __USER_DS;
    regs-&gt;xss = __USER_DS;
    regs-&gt;xcs = __USER_CS;
    regs-&gt;eip = elf_entry;
    regs-&gt;esp = bprm-&gt;p;
</pre>
</div>
</div>
</div>

<div id="outline-container-org0000016" class="outline-4">
<h4 id="org0000016"><span class="section-number-4">1.2.2.</span> setup_arg_pages</h4>
<div class="outline-text-4" id="text-1-2-2">
<div class="org-src-container">
<pre class="src src-c"><span class="org-function-name">setup_arg_pages</span><span class="org-parenthesis">(</span><span class="org-type">bprm</span><span class="org-parenthesis">,</span><span class="org-type">stack_top</span><span class="org-parenthesis">)</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">stack_top &#30340;&#20540;&#20026; STACK_TOP &#20026; 3G, &#19979;&#38754;&#20004;&#34892;&#20195;&#30721;&#23558; bprm-&gt;p "&#24179;&#31227;" &#21040;&#20102;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">3G &#20197;&#19979;&#23545;&#24212;&#30340;&#20301;&#32622;. &#23454;&#38469;&#19978;&#22312;&#26032;&#29256;&#26412;&#30340; kernel &#20013;, &#36825;&#37324;&#30340; stack_top &#20256;&#36827;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#26469;&#20043;&#21069;&#24050;&#32463;&#38543;&#26426;&#36807;&#20102;, &#23454;&#38469;&#30340;&#20540;&#26159; STACK_TOP - random_offset (&#21442;&#32771;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">randomize_stack_top)</span>
  stack_base = stack_top - MAX_ARG_PAGES * PAGE_SIZE;
  bprm-&gt;p += stack_base;

  mm-&gt;arg_start = bprm-&gt;p;
  arg_size = stack_top - <span class="org-parenthesis">(</span>PAGE_MASK &amp; <span class="org-parenthesis">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-parenthesis">)</span> mm-&gt;arg_start<span class="org-parenthesis">)</span>;

  mpnt = kmem_cache_alloc<span class="org-parenthesis">(</span>vm_area_cachep<span class="org-parenthesis">,</span> SLAB_KERNEL<span class="org-parenthesis">)</span>;
  mpnt-&gt;vm_mm = current-&gt;mm;

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010; vma &#23545;&#24212; args+stack, &#20294;&#21021;&#22987;&#22823;&#23567;&#21482;&#21253;&#25324; args &#30340;&#37096;&#20998; (argv, envp),</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20294;&#36825;&#24182;&#27809;&#26377;&#38382;&#39064;, &#22240;&#20026; vma &#30340; VM_GROWSDOWN flag &#20445;&#35777;&#35775;&#38382; stack &#26102;&#24182;&#19981;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20250;&#20986;&#38169;</span>
  mpnt-&gt;vm_end = stack_top;
  mpnt-&gt;vm_start = mpnt-&gt;vm_end - arg_size;
  mpnt-&gt;vm_flags = VM_STACK_FLAGS;
  mpnt-&gt;vm_flags |= mm-&gt;def_flags;
  mpnt-&gt;vm_page_prot = protection_map[mpnt-&gt;vm_flags &amp; 0x7];
  <span class="org-function-name">insert_vm_struct</span><span class="org-parenthesis">(</span><span class="org-type">mm</span><span class="org-parenthesis">,</span> <span class="org-type">mpnt</span><span class="org-parenthesis">)</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558; bprm-&gt;page &#26144;&#23556;&#21040;&#21069;&#38754;&#30340; vma &#20013;</span>
  <span class="org-keyword">for</span> <span class="org-parenthesis">(</span>i = 0 ; i &lt; MAX_ARG_PAGES ; i++<span class="org-parenthesis">)</span>:
    <span class="org-keyword">struct</span> page *page = bprm-&gt;page[i];
      <span class="org-keyword">if</span> <span class="org-parenthesis">(</span>page<span class="org-parenthesis">)</span>:
        bprm-&gt;page[i] = <span class="org-constant">NULL</span>;
        <span class="org-function-name">install_arg_page</span><span class="org-parenthesis">(</span><span class="org-type">mpnt</span><span class="org-parenthesis">,</span> <span class="org-type">page</span><span class="org-parenthesis">,</span> <span class="org-type">stack_base</span><span class="org-parenthesis">)</span>;
    stack_base += PAGE_SIZE;
</pre>
</div>
</div>
</div>

<div id="outline-container-org0000019" class="outline-4">
<h4 id="org0000019"><span class="section-number-4">1.2.3.</span> create_elf_tables</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
create_elf_tables 主要还是和 argv, envp 的处理有关:
</p>

<ol class="org-ol">
<li>copy_strings 负责复制 argv, envp 到 bprm-&gt;page 并维护 bprm-&gt;p</li>

<li>setup_arg_pages 负责将 bprm-&gt;p "平移" 到最终的地址空间 (STACK_TOP),
创建 VMA 并将 bprm-&gt;page 映射到 VMA</li>
</ol>

<p>
但还有一部分没有 ready: 前面两步只是设置好了 argv, envp 指向的数据, 紧接着栈底之上 argc 和 argv, envp 本身呢?
</p>

<p>
create_elf_tables 会 setup 最后这一部分
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-constant">create_elf_tables</span>:
  <span class="org-type">int</span> <span class="org-variable-name">argc</span> = bprm-&gt;argc;
  <span class="org-comment-delimiter">// </span><span class="org-comment">bprm-&gt;p &#26159;&#26632;&#24213;</span>
  sp = <span class="org-parenthesis">(</span>elf_addr_t <span class="org-type">__user</span> *<span class="org-parenthesis">)</span>bprm-&gt;p;
  <span class="org-comment-delimiter">// </span><span class="org-comment">argc</span>
  <span class="org-function-name">__put_user</span><span class="org-parenthesis">(</span><span class="org-type">argc</span><span class="org-parenthesis">,</span> sp++<span class="org-parenthesis">)</span>

  argv = sp;
  <span class="org-comment-delimiter">// </span><span class="org-comment">+1 &#26159;&#22240;&#20026; argv[] &#26368;&#21518;&#19968;&#20010;&#20803;&#32032;&#26159; NULL</span>
  envp = argv + argc + 1;

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#22635;&#20805; argv[]</span>
  p = current-&gt;mm-&gt;arg_start;
  <span class="org-keyword">while</span> <span class="org-parenthesis">(</span>argc-- &gt; 0<span class="org-parenthesis">)</span>:
    size_t len;
    <span class="org-function-name">__put_user</span><span class="org-parenthesis">((</span><span class="org-type">elf_addr_t</span><span class="org-parenthesis">)</span>p<span class="org-parenthesis">,</span> argv++<span class="org-parenthesis">)</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">strnlen_user &#19982; libc &#20013;&#30340; strnlen &#24182;&#19981;&#19968;&#26679;: strnlen_user &#36820;&#22238;&#30340;&#38271;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#24230;&#26159;&#21253;&#25324;&#32467;&#23614;&#30340; NULL &#30340;</span>
    len = strnlen_user<span class="org-parenthesis">((</span><span class="org-type">void</span> <span class="org-variable-name">__user</span> *<span class="org-parenthesis">)</span>p<span class="org-parenthesis">)</span>;
    p += len;
  <span class="org-comment-delimiter">// </span><span class="org-comment">finally, argv</span>
  __put_user<span class="org-parenthesis">(</span>0<span class="org-parenthesis">,</span> argv<span class="org-parenthesis">)</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#22635;&#20805; envp[]</span>
  <span class="org-keyword">while</span> <span class="org-parenthesis">(</span>envc-- &gt; 0<span class="org-parenthesis">)</span>:
    size_t len;
    <span class="org-function-name">__put_user</span><span class="org-parenthesis">((</span><span class="org-type">elf_addr_t</span><span class="org-parenthesis">)</span>p<span class="org-parenthesis">,</span> envp++<span class="org-parenthesis">)</span>;
    len = strnlen_user<span class="org-parenthesis">((</span><span class="org-type">void</span> <span class="org-variable-name">__user</span> *<span class="org-parenthesis">)</span>p<span class="org-parenthesis">,</span> PAGE_SIZE*MAX_ARG_PAGES<span class="org-parenthesis">)</span>;
    p += len;
  <span class="org-comment-delimiter">// </span><span class="org-comment">finally, envp</span>
  __put_user<span class="org-parenthesis">(</span>0<span class="org-parenthesis">,</span> envp<span class="org-parenthesis">)</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-org000001c" class="outline-4">
<h4 id="org000001c"><span class="section-number-4">1.2.4.</span> load_elf_interp</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
当 elf 指定了 .interp 时, 程序的入口不再是 elf 本身的 entry, 而是
interp 的 entry
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-function-name">load_elf_interp</span><span class="org-parenthesis">(</span><span class="org-type">interpreter</span><span class="org-parenthesis">)</span>:
  kernel_read<span class="org-parenthesis">(</span>interpreter<span class="org-parenthesis">,</span>interp_elf_ex-&gt;e_phoff<span class="org-parenthesis">,(</span><span class="org-type">char</span> *<span class="org-parenthesis">)</span>elf_phdata<span class="org-parenthesis">,</span>size<span class="org-parenthesis">)</span>;
  <span class="org-keyword">for</span> <span class="org-parenthesis">(</span>i=0; i&lt;interp_elf_ex-&gt;e_phnum; i++<span class="org-parenthesis">,</span> eppnt++<span class="org-parenthesis">)</span>:
    <span class="org-keyword">if</span> <span class="org-parenthesis">(</span>eppnt-&gt;p_type == PT_LOAD<span class="org-parenthesis">)</span> <span class="org-parenthesis">{</span>
      <span class="org-type">int</span> <span class="org-variable-name">elf_type</span> = MAP_PRIVATE | MAP_DENYWRITE;
      <span class="org-type">int</span> <span class="org-variable-name">elf_prot</span> = 0;
      <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">vaddr</span> = 0;
      <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">k</span><span class="org-parenthesis">,</span> <span class="org-variable-name">map_addr</span>;

      <span class="org-keyword">if</span> <span class="org-parenthesis">(</span>eppnt-&gt;p_flags &amp; PF_R<span class="org-parenthesis">)</span> elf_prot =  PROT_READ;
      <span class="org-keyword">if</span> <span class="org-parenthesis">(</span>eppnt-&gt;p_flags &amp; PF_W<span class="org-parenthesis">)</span> elf_prot |= PROT_WRITE;
      <span class="org-keyword">if</span> <span class="org-parenthesis">(</span>eppnt-&gt;p_flags &amp; PF_X<span class="org-parenthesis">)</span> elf_prot |= PROT_EXEC;
      vaddr = eppnt-&gt;p_vaddr;

      map_addr = elf_map<span class="org-parenthesis">(</span>interpreter<span class="org-parenthesis">,</span> load_addr + vaddr<span class="org-parenthesis">,</span> eppnt<span class="org-parenthesis">,</span> elf_prot<span class="org-parenthesis">,</span> elf_type<span class="org-parenthesis">)</span>;

      <span class="org-comment-delimiter">// </span><span class="org-comment">&#31532;&#19968;&#20010;&#34987; mmap &#24517;&#23450;&#26159; .text?</span>
      <span class="org-keyword">if</span> <span class="org-parenthesis">(</span><span class="org-negation-char">!</span>load_addr_set &amp;&amp; interp_elf_ex-&gt;e_type == ET_DYN<span class="org-parenthesis">)</span>:
          load_addr = map_addr - ELF_PAGESTART<span class="org-parenthesis">(</span>vaddr<span class="org-parenthesis">)</span>;
          load_addr_set = 1;

      load_addr = map_addr - ELF_PAGESTART<span class="org-parenthesis">(</span>vaddr<span class="org-parenthesis">)</span>;

  <span class="org-keyword">return</span> <span class="org-parenthesis">((</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-parenthesis">)</span> interp_elf_ex-&gt;e_entry<span class="org-parenthesis">)</span> + load_addr;
</pre>
</div>
</div>
</div>

<div id="outline-container-org000002b" class="outline-4">
<h4 id="org000002b"><span class="section-number-4">1.2.5.</span> ELF 程序引用 argc, argv</h4>
<div class="outline-text-4" id="text-1-2-5">
<p>
argc 和 argv 已经放在栈上了, 那么应用程序如何引用到它们?
</p>
</div>

<div id="outline-container-org0000020" class="outline-5">
<h5 id="org0000020"><span class="section-number-5">1.2.5.1.</span> 示例程序</h5>
<div class="outline-text-5" id="text-1-2-5-1">
<div class="org-src-container">
<pre class="src src-c"><span class="org-type">void</span> <span class="org-function-name">hello</span><span class="org-parenthesis">(</span><span class="org-type">int</span> <span class="org-variable-name">a</span><span class="org-parenthesis">)</span> <span class="org-parenthesis">{</span>
    printf<span class="org-parenthesis">(</span><span class="org-string">"%d\n"</span><span class="org-parenthesis">,</span> a<span class="org-parenthesis">)</span>;
<span class="org-parenthesis">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-parenthesis">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span><span class="org-parenthesis">,</span> <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]<span class="org-parenthesis">)</span> <span class="org-parenthesis">{</span>
    <span class="org-keyword">return</span> 0;
<span class="org-parenthesis">}</span>
</pre>
</div>

<p>
通过如下的命令编译. 为了避免 libc 自动加入的入口 (_start) 的影响, 编译时直接指定了 entry 为 hello.
</p>

<pre class="example" id="org000001f">
gcc -g test.c -m32  -Wl,-ehello -O0
</pre>

<p>
示例中的 main 函数并没什么用, 但由于编译时使用 libc 会默认插入一个
_start 并会引用 main, 通过 `gcc -nostdlib` 可以避免上述情况, 但用了
nostdlib 后又无法使用 libc 中提供的函数例如 printf&#x2026;为了能编译通过,
只好写一个无用的 main&#x2026;
</p>
</div>
</div>

<div id="outline-container-org0000024" class="outline-5">
<h5 id="org0000024"><span class="section-number-5">1.2.5.2.</span> 使用 gdb 分析</h5>
<div class="outline-text-5" id="text-1-2-5-2">
<pre class="example" id="org0000023">
#&gt; gdb ./a.out
(gdb) set args "hello"
(gdb) b hello
(gdb) r
(gdb) p $esp
$1 = (void *) 0xffffc444
(gdb) p $ebp
$2 = (void *) 0xffffc44c
(gdb) disass
Dump of assembler code for function hello:
   0x080483eb &lt;+0&gt;:     push   %ebp
   0x080483ec &lt;+1&gt;:     mov    %esp,%ebp
   0x080483ee &lt;+3&gt;:     sub    $0x8,%esp
=&gt; 0x080483f1 &lt;+6&gt;:     sub    $0x8,%esp
   0x080483f4 &lt;+9&gt;:     pushl  0x8(%ebp)
   0x080483f7 &lt;+12&gt;:    push   $0x80484c0
   0x080483fc &lt;+17&gt;:    call   0x80482c0 &lt;printf@plt&gt;
   0x08048401 &lt;+22&gt;:    add    $0x10,%esp
   0x08048404 &lt;+25&gt;:    nop
   0x08048405 &lt;+26&gt;:    leave
   0x08048406 &lt;+27&gt;:    ret
End of assembler dump.

(gdb) x /10x $ebp
0xffffc44c:     0x00000000      0x00000002      0xffffc611      0xffffc624
0xffffc45c:     0x00000000      0xffffc62b      0xffffc636      0xffffc655
0xffffc46c:     0xffffc667      0xffffc67a

# 当前的栈布局:
#
# 1. 0x00000000 是 hello 第一行的 `push $ebp` push 到栈里的 "上一个
#    stack frame" 的 ebp, 由于 hello 是 elf 的 entry, 所以并不存在 "上一
#    个 stack frame", 所以这里会是 0
# 2. 0x00000002 是 argc
# 3. 0xffffc611 是 argv[0]
# 4. 0xffffc624 是 argv[1]
# 5. 0x00000000 是 argv 结尾的 NULL
# 6. 0xffffc62b 是 envp[0]
# 7. ....

(gdb) p (char*)0xffffc611
$2 = 0xffffc611 "/home/sunway/a.out"
(gdb) p (char*)0xffffc624
$3 = 0xffffc624 " hello"
(gdb) p (char*)0xffffc62b
$4 = 0xffffc62b "XDG_VTNR=1"

# hello 函数的参数 a 实际上对应 0xffffc611 即 argv[0], 从前面 disass 的
# 结果看, a 是通过 ebp+8 引用的: 为什么是 ebp + 8?
#
# 根据 c 的调用约定:
#
# 1. 首先参数入栈
# 2. call 导致返回地址入栈 (4B)
# 3. 旧的 ebp 入栈 (4B)
# 4. ebp 设置为当前的 esp
#
# 所以 hello 认为的栈布局是:
#
# 1. 0x00000000 是旧的 ebp
# 2. 0x00000002 是返回地址...
# 3. 0xffffc611 是第一个参数的值, 也就是 a 的值
#
# 根据这个认识, hello 通过 a 必然无法拿到真正的 argc, 而且因为 hello 认
# 为返回地址是 0x00000002, 导致 hello 返回时会报错
(gdb) x a
0xffffc611:     0x6d6f682f

(gdb) n
-14831
3       }

# 把 0x00000002 误认为是返回地址
(gdb) n
0x00000002 in ?? ()

# 栈上在 0x00000002 后面直接就是平铺的 argv[0], argv[1] (`0xffffc611
# 0xffffc624`), 而普通的 main 函数的原型是 main(int argc, char ** argv),
# 即 main 函数期望栈上在 argc 之后是一个 char ** 指针, 而不是平铺的
# argv[0], argv[1]...
#
# 另一方面, 有些平台上函数的参数并不是像 x86 一样从栈上取的, 以 arm 为例,
# 它的调用约定要求 r0, r1, r2, r3 保存前四个参数, 其它参数才需要从栈上取,
# 这种情况下 hello 函数更不可能直接取到相应的参数
#
# 因此, elf 的 entry 要么自己用 trick 来获取参数, 要么由更高层的 entry 帮
# 自己获取参数, 毕竟 kernel 调用 entry 时是通过直接修改 eip 跳转的, 并不
# 考虑它做为一个函数的调用约定
</pre>
</div>
</div>

<div id="outline-container-org0000028" class="outline-5">
<h5 id="org0000028"><span class="section-number-5">1.2.5.3.</span> 实现一个简单的 entry</h5>
<div class="outline-text-5" id="text-1-2-5-3">
<div class="org-src-container">
<pre class="src src-c"><span class="org-type">void</span> <span class="org-function-name">entry</span> <span class="org-parenthesis">()</span> <span class="org-parenthesis">{</span>
    <span class="org-type">int</span> <span class="org-variable-name">ebp</span> = 0;
    <span class="org-keyword">__asm__</span><span class="org-parenthesis">(</span><span class="org-string">"movl %%ebp,%0"</span>:<span class="org-string">"=r"</span> <span class="org-parenthesis">(</span>ebp<span class="org-parenthesis">))</span>;
    exit<span class="org-parenthesis">(</span>hello<span class="org-parenthesis">(</span>*<span class="org-parenthesis">((</span><span class="org-type">int</span> *<span class="org-parenthesis">)(</span>ebp + 4<span class="org-parenthesis">)),</span> <span class="org-parenthesis">(</span><span class="org-type">char</span> **<span class="org-parenthesis">)(</span>ebp+8<span class="org-parenthesis">)))</span>;
<span class="org-parenthesis">}</span>

<span class="org-type">int</span> <span class="org-function-name">hello</span><span class="org-parenthesis">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span><span class="org-parenthesis">,</span> <span class="org-type">char</span> ** <span class="org-variable-name">argv</span><span class="org-parenthesis">)</span> <span class="org-parenthesis">{</span>
    printf<span class="org-parenthesis">(</span><span class="org-string">"%d\n"</span><span class="org-parenthesis">,</span> argc<span class="org-parenthesis">)</span>;
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = 0;
    <span class="org-keyword">for</span> <span class="org-parenthesis">(</span>i = 0; i &lt; argc; i++<span class="org-parenthesis">)</span> <span class="org-parenthesis">{</span>
        printf<span class="org-parenthesis">(</span><span class="org-string">"%s\n"</span><span class="org-parenthesis">,</span> argv[i]<span class="org-parenthesis">)</span>;
    <span class="org-parenthesis">}</span>
    <span class="org-keyword">return</span> 0;
<span class="org-parenthesis">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-parenthesis">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span><span class="org-parenthesis">,</span> <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]<span class="org-parenthesis">)</span> <span class="org-parenthesis">{</span>
    <span class="org-keyword">return</span> 0;
<span class="org-parenthesis">}</span>
</pre>
</div>

<p>
测试:
</p>

<pre class="example" id="org0000027">
$&gt; gcc -g test.c -m32 -Wl,-eentry -O0

$&gt; ./a.out
1
./a.out

$&gt; ./a.out hello
2
./a.out
hello
</pre>

<p>
实际上, 正常编译的 c 程序会使用 libc 提供的 entry (_start) 来调用 main
函数, 以便 main 函数可以直接使用 argc 和 argv
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org0000031" class="outline-3">
<h3 id="org0000031"><span class="section-number-3">1.3.</span> script 的加载</h3>
<div class="outline-text-3" id="text-1-3">
<p>
load_script 负责 script (bash, perl, python &#x2026;) 的加载
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-function-name">load_script</span><span class="org-parenthesis">(</span><span class="org-type">bprm</span><span class="org-parenthesis">,</span> <span class="org-type">regs</span><span class="org-parenthesis">)</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">script &#37117;&#26159;&#20197; #! &#24320;&#22836;</span>
  <span class="org-keyword">if</span> <span class="org-parenthesis">((</span>bprm-&gt;buf[0] != <span class="org-string">'#'</span><span class="org-parenthesis">)</span> || <span class="org-parenthesis">(</span>bprm-&gt;buf[1] != <span class="org-string">'!'</span><span class="org-parenthesis">)</span> || <span class="org-parenthesis">(</span>bprm-&gt;sh_bang<span class="org-parenthesis">))</span>:
    <span class="org-keyword">return</span> -ENOEXEC;
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#35299;&#26512; #! &#21518;&#30340; interpreter &#21517;&#23383;&#21644;&#21442;&#25968;, &#20445;&#23384;&#22312; interp &#21644; i_arg &#20013;</span>
  <span class="org-function-name">strcpy</span> <span class="org-parenthesis">(</span><span class="org-type">interp</span><span class="org-parenthesis">,</span> <span class="org-type">i_name</span><span class="org-parenthesis">)</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558; bprm-&gt;interp &#22797;&#21046;&#21040; bprm-&gt;page &#20013;, &#36825;&#26102; page &#30340;&#24067;&#23616;&#20026; (&#30001;&#20302;&#21040;&#39640;):</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">bprm-&gt;interp | argv |  envp |  bprm-&gt;filename</span>
  copy_strings_kernel<span class="org-parenthesis">(</span>1<span class="org-parenthesis">,</span> &amp;bprm-&gt;interp<span class="org-parenthesis">,</span> bprm<span class="org-parenthesis">)</span>;
  bprm-&gt;argc++;
  <span class="org-keyword">if</span> <span class="org-parenthesis">(</span>i_arg<span class="org-parenthesis">)</span>:
    <span class="org-comment-delimiter">// </span><span class="org-comment">sh_bang &#20013;&#33050;&#26412;&#35299;&#37322;&#22120;&#30340;&#21442;&#25968;&#20063;&#34987;&#36861;&#21152;&#21040; bprm-&gt;page &#20013;</span>
    copy_strings_kernel<span class="org-parenthesis">(</span>1<span class="org-parenthesis">,</span> &amp;i_arg<span class="org-parenthesis">,</span> bprm<span class="org-parenthesis">)</span>;
    bprm-&gt;argc++;
  copy_strings_kernel<span class="org-parenthesis">(</span>1<span class="org-parenthesis">,</span> &amp;i_name<span class="org-parenthesis">,</span> bprm<span class="org-parenthesis">)</span>;
  bprm-&gt;argc++;
  bprm-&gt;interp = interp;
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#29616;&#22312; bprm-&gt;page &#30340;&#24067;&#23616;, &#20197; she-bang &#20026; '#!/bin/bash -i' &#30340; 'test.sh</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">hello' &#20026;&#20363;:</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">/bin/bash | -i | test.sh | hello | envp | test.sh</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#25152;&#20197;&#24403; bash &#21551;&#21160;&#26102;, argv &#20250;&#26159; {/bin/bash, -i, test.sh, hello}    </span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#29616;&#22312; bprm-&gt;interp &#21644; bprm-&gt;file &#24050;&#32463;&#34987;&#26367;&#25442;&#20026; /bin/bash, &#28982;&#21518;&#36882;&#24402;&#30340;&#35843;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#29992; search_binary_handler, &#30475;&#30475;&#22914;&#20309;&#25191;&#34892; /bin/bash</span>
  bprm-&gt;file = open_exec<span class="org-parenthesis">(</span>interp<span class="org-parenthesis">)</span>;
  <span class="org-function-name">search_binary_handler</span><span class="org-parenthesis">(</span><span class="org-type">bprm</span><span class="org-parenthesis">,</span><span class="org-type">regs</span><span class="org-parenthesis">)</span>;
</pre>
</div>

<p>
可见 load_script 的方式允许嵌套的指定, 例如 script 指定 #!/bin/interp1,
而 interp1 也是一个 script, 指定 #!/bin/inter2 &#x2026; 这种嵌套的处理过程并不复杂: kernel 只需要相应的调整 argv 就可以.
</p>

<p>
但需要注意的是最内部的一层嵌套必然是一个 "非 script" 类型的可执行程序,
例如 ELF, 后者会通过 setup_arg_pages 和 create_elf_tables 完成 argv 最终的布局
</p>
</div>
</div>

<div id="outline-container-org0000034" class="outline-3">
<h3 id="org0000034"><span class="section-number-3">1.4.</span> 用户自定义加载</h3>
<div class="outline-text-3" id="text-1-4">
<p>
load_misc_binary 实现用户自定义的加载, 它的过程和 load_script 非常类似,
只不过寻找下一级 interp 的过程不是通过读取 script 的 she-bang, 而是通过用户写到的 '/proc/sys/fs/binfmt_misc/register' 的设定决定的.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

<p class="author">Author: sunway@dogdog.run<br />
Date: 2016-08-02 Tue 00:00<br />
Last updated: 2022-01-19 Wed 13:42</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
</div>
</body>
</html>
