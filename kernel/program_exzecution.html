<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-01-25 Tue 15:41 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Linux Kernel: Program Exzecution</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wei Sun (孙伟)" />
<link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
<link rel = "icon" href = "/icon.png"  type = "image/x-icon">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">Linux Kernel: Program Exzecution</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org1584cd3">1. Linux Kernel: Program Exzecution</a>
<ul>
<li><a href="#org20d71d5">1.1. do_execve</a>
<ul>
<li><a href="#orgf730667">1.1.1. copy_strings</a></li>
<li><a href="#org0eab85d">1.1.2. search_binary_handler</a></li>
</ul>
</li>
<li><a href="#orgb3dd63e">1.2. ELF 的加载</a>
<ul>
<li><a href="#org8057872">1.2.1. load_elf_binary</a></li>
<li><a href="#orgd94d2be">1.2.2. setup_arg_pages</a></li>
<li><a href="#org12497a8">1.2.3. create_elf_tables</a></li>
<li><a href="#org892bf11">1.2.4. load_elf_interp</a></li>
<li><a href="#org0fa1a2a">1.2.5. ELF 程序引用 argc, argv</a></li>
</ul>
</li>
<li><a href="#orga8cc8c3">1.3. script 的加载</a></li>
<li><a href="#orgf834594">1.4. 用户自定义加载</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org1584cd3" class="outline-2">
<h2 id="org1584cd3"><span class="section-number-2">1</span> Linux Kernel: Program Exzecution</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org20d71d5" class="outline-3">
<h3 id="org20d71d5"><span class="section-number-3">1.1</span> do_execve</h3>
<div class="outline-text-3" id="text-1-1">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">do_execve</span> (filename, argv, envp, regs):
  <span style="font-weight: bold;">struct</span> linux_binprm *bprm = kmalloc(<span style="font-weight: bold;">sizeof</span>(*bprm), GFP_KERNEL);
  <span style="font-weight: bold;">memset</span>(bprm, 0, <span style="font-weight: bold;">sizeof</span>(*bprm));
  file = open_exec(filename);
    <span style="font-weight: bold;">path_lookup</span>(name, LOOKUP_FOLLOW|LOOKUP_OPEN, &amp;nd);
    <span style="font-weight: bold;">permission</span>(inode, MAY_EXEC, &amp;nd);
    <span style="font-weight: bold;">return</span> dentry_open(nd.dentry, nd.mnt, O_RDONLY);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">sched_exec &#21644; cpu load balance &#26377;&#20851;, &#20855;&#20307;&#21442;&#32771;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">[[file:process_scheduling.org::*push%20task][push task]]</span>
  <span style="font-weight: bold;">sched_exec</span>()
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">MAX_ARG_PAGES &#40664;&#35748;&#20026; 32, &#34920;&#31034;&#32473; argv &#21644; env &#39044;&#30041;&#26368;&#22810; 32 &#20010; page, &#33509;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">page &#20026; 4k, &#21017;&#26368;&#32456;&#39044;&#30041; 128K</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21518;&#32493; argv &#21644; env &#38656;&#35201;&#20174; user &#22797;&#21046;&#21040; bprm-&gt;page &#20013;, &#22797;&#21046;&#26102;&#38656;&#35201;&#26681;&#25454;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">bprm-&gt;p &#25351;&#31034;&#22797;&#21046;&#21040; page &#30340;&#20160;&#20040;&#20301;&#32622;</span>
  bprm-&gt;p = PAGE_SIZE*MAX_ARG_PAGES-<span style="font-weight: bold;">sizeof</span>(<span style="font-weight: bold; text-decoration: underline;">void</span> *);

  bprm-&gt;file = file;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">bprm-&gt;filename &#21644; bprm-&gt;interp &#19968;&#33324;&#26159;&#19968;&#33268;&#30340;, &#20294;&#26377;&#20363;&#22806;:</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20363;&#22914;&#23545;&#20110;&#21160;&#24577;&#38142;&#25509;&#30340; elf &#26469;&#35828;, filename &#20026; elf &#26412;&#36523;, interp &#20026; elf &#25351;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#31034;&#30340; interp, &#20363;&#22914; /lib/ld-linux.so.2</span>
  bprm-&gt;filename = filename;
  bprm-&gt;interp = filename;
  bprm-&gt;mm = mm_alloc();

  bprm-&gt;argc = count(argv);
  bprm-&gt;envc = count(envp);

  <span style="font-weight: bold;">prepare_binprm</span>(bprm)
    mode = inode-&gt;i_mode;
    bprm-&gt;e_uid = current-&gt;euid;
    bprm-&gt;e_gid = current-&gt;egid;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">setuid</span>
    <span style="font-weight: bold;">if</span> (mode &amp; S_ISUID):
      bprm-&gt;e_uid = inode-&gt;i_uid;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">setgid</span>
    <span style="font-weight: bold;">if</span> ((mode &amp; (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)):
      bprm-&gt;e_gid = inode-&gt;i_gid;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;&#25991;&#20214;&#24320;&#22836;&#30340; BINPRM_BUF_SIZE (128) &#23383;&#33410;&#30340;&#25968;&#25454;&#35835;&#21040; bprm-&gt;buf &#20013;, &#21518;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#32493;&#21508;&#20010; linux_binfmt &#20250;&#36890;&#36807; bprm-&gt;buf &#26469;&#30830;&#35748;&#23427;&#26159;&#21542;&#25903;&#25345;&#36825;&#31181;&#21487;&#25191;&#34892;&#25991;&#20214;&#26684;&#24335;</span>
    <span style="font-weight: bold;">return</span> kernel_read(bprm-&gt;file,0,bprm-&gt;buf,BINPRM_BUF_SIZE);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">copy_strings &#23558; argv, envp &#20197;&#21450; filename &#22797;&#21046;&#21040; bprm-&gt;page &#20013;, &#21518;&#32493;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20123;&#20869;&#23481;&#23558;&#36890;&#36807;&#35774;&#32622;&#39029;&#34920;&#30340;&#26041;&#24335;&#20986;&#29616;&#22312;&#36827;&#31243;&#22320;&#22336;&#31354;&#38388;&#20013; stack &#20043;&#19978;&#30340;&#37096;&#20998;</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36890;&#36807; copy_strings &#30340;&#20195;&#30721;, &#21487;&#20197;&#30475;&#21040;&#26368;&#32456;&#30340;&#29992;&#25143;&#31354;&#38388;&#24067;&#23616;&#19978;&#20174;&#39640;&#21040;&#20302;&#30340;&#39034;&#24207;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20026;:</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">1. filename</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">2. env</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">3. argv</span>
  copy_strings_kernel(1, &amp;bprm-&gt;filename, bprm);
  <span style="font-weight: bold;">copy_strings</span>(bprm-&gt;envc, envp, bprm);
  <span style="font-weight: bold;">copy_strings</span>(bprm-&gt;argc, argv, bprm);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">execve &#26368;&#20851;&#38190;&#30340;&#37096;&#20998;: &#36941;&#21382;&#25152;&#26377; linux_binfmt, &#26399;&#26395;&#26576;&#19968;&#20010; binfmt &#21487;&#20197;&#25903;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25345;&#36825;&#20010;&#21487;&#25191;&#34892;&#25991;&#20214;&#24182;&#23436;&#25104;&#21518;&#32493;&#30340;&#36807;&#31243;(&#20363;&#22914;&#25991;&#20214;&#20013;&#21508;&#20010; section &#30340;&#21152;&#36733;,</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#31243;&#24207;&#20837;&#21475;&#30340;&#30830;&#23450;&#31561;)</span>
  <span style="font-weight: bold;">search_binary_handler</span>(bprm,regs);
</pre>
</div>
</div>

<div id="outline-container-orgf730667" class="outline-4">
<h4 id="orgf730667"><span class="section-number-4">1.1.1</span> copy_strings</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
do_execve 的一个重要的任务是根据 user mode 的 argv, envp 设置好新进程的
argv 和 envp.
</p>

<p>
进程的 argv, envp 及 stack 有的关系如图所示:
</p>


<div id="org6f10c96" class="figure">
<p><img src="../extra/kernel_argv_envp.png" alt="kernel_argv_envp.png" />
</p>
</div>

<p>
这个布局并不是一步到位的: 在 do_execve 的早期, 比如 copy_strings 阶段,
只会将 argv, envp 复制到 bprm-&gt;page 中, 但复制时就会考虑最终的布局, 以
便后面可以通过设置页表完成最后的布局
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">copy_strings</span>(argc, argv, bprm):
  <span style="font-weight: bold;">while</span> (argc-- &gt; 0):
    <span style="font-weight: bold; text-decoration: underline;">char</span> __user *str;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">str &#20195;&#34920; argv &#20013;&#30340;&#19968;&#39033;</span>
    <span style="font-weight: bold;">get_user</span>(str, argv+argc);
    len = strnlen_user(str, bprm-&gt;p)

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35843;&#25972; bprm-&gt;p, &#32473; str &#30041;&#20986;&#31354;&#38388;, &#21487;&#20197;&#30475;&#21040;, argv[1] &#23545;&#24212;&#30340; bprm-&gt;p &#27604;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">argv[0] &#30340;&#26356;&#22823;, &#32780;&#21518;&#38754; copy &#21040; bprm-&gt;page &#26102;&#20351;&#29992; bprm-&gt;p &#20570;&#20026;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">offset, &#25152;&#20197; argv[0] &#23558;&#20301;&#20110; bprm-&gt;page &#30340;&#39640;&#22320;&#22336;, &#32780;&#26368;&#32456; bprm-&gt;page</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20250;&#34987;&#36890;&#36807;&#26144;&#23556;&#39029;&#34920;&#30340;&#26041;&#24335; "&#24179;&#31227;" &#21040; stack &#39030;&#31471;, &#25152;&#20197; argv[1] &#25351;&#21521;&#30340;&#22320;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22336;&#26368;&#32456;&#20250;&#22312; argv[0] &#20043;&#19978;</span>
    bprm-&gt;p -= len;
    pos = bprm-&gt;p;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;&#23545;&#24212;&#30340; argv &#22797;&#21046;&#21040;&#21512;&#36866;&#30340; bprm-&gt;page[i] &#30340;&#21512;&#36866;&#30340;&#20301;&#32622; (&#26681;&#25454; bprm-&gt;p)</span>
    offset = pos % PAGE_SIZE;
    i = pos/PAGE_SIZE;
    page = bprm-&gt;page[i];
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25353;&#38656;&#35201;&#20998;&#37197;&#26032;&#30340; page &#24182;&#29992; kmap &#26144;&#23556;, &#20197;&#20415;&#21518;&#38754;&#22797;&#21046;&#21040;&#36825;&#20010; page</span>
    <span style="font-weight: bold;">if</span> (!page):
      page = alloc_page(GFP_HIGHUSER);
      bprm-&gt;page[i] = page;
    <span style="font-weight: bold;">if</span> (page != kmapped_page):
      <span style="font-weight: bold;">if</span> (kmapped_page):
        kunmap(kmapped_page);
      kmapped_page = page;
      kaddr = kmap(kmapped_page);
    <span style="font-weight: bold;">copy_from_user</span>(kaddr+offset, str, bytes_to_copy);
</pre>
</div>

<p>
针对 argv, envp 的 copy_strings 完成后, bprm-&gt;page 中的布局已经与上面
图中的 "Environment Strings" 和 "Command-line arguments" 是一致的了,
后续会把它们 "平移" 到最终的用户空间布局上, 并且需要设置好 envp[],
argv[] 和 argc
</p>
</div>
</div>

<div id="outline-container-org0eab85d" class="outline-4">
<h4 id="org0eab85d"><span class="section-number-4">1.1.2</span> search_binary_handler</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
search_binary_handler 是 do_execve 最重要的一步, 它所做的并不仅仅是
"search": 当 search_binary_handler 返回后, 整个用户地址空间都已经设置
好了, pt_regs 上 esp, eip 的值已经被设置为正确的值, 当 do_execve
syscall 返回后, 进程就会从可执行文件的入口开始执行了
</p>

<p>
所谓的 binary handler, 是指 linux_binfmt, 系统启动时会注册几个
linux_binfmt, 对应不同的可执行文件格式, 例如:
</p>

<ol class="org-ol">
<li>aout_format</li>

<li>elf_format</li>

<li>script_format</li>

<li>misc_format</li>
</ol>

<p>
kernel 通过 register_binfmt 完成 linux_binfmt 的注册
</p>
</div>

<div id="outline-container-org47031f0" class="outline-5">
<h5 id="org47031f0"><span class="section-number-5">1.1.2.1</span> register_binfmt</h5>
<div class="outline-text-5" id="text-1-1-2-1">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">register_binfmt</span>(fmt):
  <span style="font-weight: bold;">struct</span> linux_binfmt ** tmp = &amp;formats;
  fmt-&gt;next = formats;
  formats = fmt;
</pre>
</div>

<p>
register_binfmt 的过程仅仅是将一种 linux_binfmt 插入到一个全局的
formats 链表的末尾
</p>
</div>
</div>

<div id="outline-container-org8ce043b" class="outline-5">
<h5 id="org8ce043b"><span class="section-number-5">1.1.2.2</span> linux_binfmt</h5>
<div class="outline-text-5" id="text-1-1-2-2">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">linux_binfmt</span> {
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">linux_binfmt</span> * <span style="font-weight: bold; font-style: italic;">next</span>;
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">module</span> *<span style="font-weight: bold; font-style: italic;">module</span>;
    <span style="font-weight: bold; text-decoration: underline;">int</span> (*<span style="font-weight: bold;">load_binary</span>)(<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">linux_binprm</span> *, <span style="font-weight: bold;">struct</span>  <span style="font-weight: bold; text-decoration: underline;">pt_regs</span> * <span style="font-weight: bold; font-style: italic;">regs</span>);
    <span style="font-weight: bold; text-decoration: underline;">int</span> (*<span style="font-weight: bold;">load_shlib</span>)(<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">file</span> *);
    <span style="font-weight: bold; text-decoration: underline;">int</span> (*<span style="font-weight: bold;">core_dump</span>)(<span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">signr</span>, <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">pt_regs</span> * <span style="font-weight: bold; font-style: italic;">regs</span>, <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">file</span> * <span style="font-weight: bold; font-style: italic;">file</span>);
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">min_coredump</span>; <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">minimal dump size</span><span style="font-weight: bold; font-style: italic;"> */</span>
};
</pre>
</div>

<p>
其中最重要的是 load_binary 这个回调函数, search_binary_handler 时会
formats 中所有的 linux_binfmt 并调用其 load_binary, 直到某个
load_binary 成功为止.
</p>
</div>
</div>

<div id="outline-container-orgc9ad3a9" class="outline-5">
<h5 id="orgc9ad3a9"><span class="section-number-5">1.1.2.3</span> search_binary_handler</h5>
<div class="outline-text-5" id="text-1-1-2-3">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">search_binary_handler</span>(bprm,regs):
  <span style="font-weight: bold;">for</span> (fmt = formats ; fmt ; fmt = fmt-&gt;next):
    <span style="font-weight: bold; text-decoration: underline;">int</span> (*fn)(<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">linux_binprm</span> *, <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">pt_regs</span> *) = fmt-&gt;load_binary;
    retval = fn(bprm, regs);
    <span style="font-weight: bold;">if</span> (retval &gt;= 0):
      <span style="font-weight: bold;">return</span> retval;
</pre>
</div>

<p>
可见 do_execve 最主要的工作由 linux_binfmt-&gt;load_binary 完成
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb3dd63e" class="outline-3">
<h3 id="orgb3dd63e"><span class="section-number-3">1.2</span> ELF 的加载</h3>
<div class="outline-text-3" id="text-1-2">
<p>
load_elf_binary 是 elf_format 对应的 load_binary 实现
</p>
</div>

<div id="outline-container-org8057872" class="outline-4">
<h4 id="org8057872"><span class="section-number-4">1.2.1</span> load_elf_binary</h4>
<div class="outline-text-4" id="text-1-2-1">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">load_elf_binary</span>(bprm, regs):
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21160;&#24577;&#38142;&#25509;&#30340; elf &#31243;&#24207;&#20250;&#25351;&#23450; interpreter, &#21017;&#31243;&#24207;&#30340;&#20837;&#21475;&#19981;&#20877;&#26159; elf &#26412;&#36523;&#30340;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">e_entry, &#32780;&#26159; interpreter &#30340; e_entry</span>
  loc-&gt;elf_ex = *((<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">elfhdr</span> *) bprm-&gt;buf);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#30475; elf &#20013;&#26159;&#21542;&#21253;&#21547; PT_INTERP section (.interp)</span>
  <span style="font-weight: bold;">for</span> (i = 0; i &lt; loc-&gt;elf_ex.e_phnum; i++):
    <span style="font-weight: bold;">if</span> (elf_ppnt-&gt;p_type == PT_INTERP):
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35835;&#21462; interp &#30340;&#21517;&#23383; (&#20363;&#22914; /lib/ld-linux.so.2) &#20445;&#23384;&#22312;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">elf_interpreter &#20013;</span>
      elf_interpreter = (<span style="font-weight: bold; text-decoration: underline;">char</span> *) <span style="font-weight: bold;">kmalloc</span>(elf_ppnt-&gt;p_filesz, GFP_KERNEL);
      <span style="font-weight: bold;">kernel_read</span>(bprm-&gt;file, elf_ppnt-&gt;p_offset,elf_interpreter, elf_ppnt-&gt;p_filesz);
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25171;&#24320; interpreter &#25991;&#20214;</span>
      interpreter = open_exec(elf_interpreter);
      <span style="font-weight: bold;">kernel_read</span>(interpreter, 0, bprm-&gt;buf, BINPRM_BUF_SIZE);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26432;&#27515;&#20854;&#23427;&#32447;&#31243;, &#25353;&#29031; man 2 execve &#30340;&#35828;&#27861;:</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">All threads other than</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the calling thread are destroyed during an execve().</span>
  <span style="font-weight: bold;">flush_old_exec</span>(bprm);
    <span style="font-weight: bold;">de_thread</span>(current);
      <span style="font-weight: bold;">zap_other_threads</span>(current);
        <span style="font-weight: bold;">for</span> (t = next_thread(p); t != p; t = next_thread(t)):
          sigaddset(&amp;t-&gt;pending.signal, SIGKILL);
          <span style="font-weight: bold;">signal_wake_up</span>(t, 1);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36873;&#25321; mmap layout, &#21442;&#32771; [[file:memory.org::*get_unmapped_area][get_unmapped_area]]</span>
  <span style="font-weight: bold;">arch_pick_mmap_layout</span>(current-&gt;mm);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;&#20445;&#23384;&#30528; argv &#21644; envp &#30340; bprm-&gt;page "&#24179;&#31227;" &#21040;&#26368;&#32456;&#30340;&#29992;&#25143;&#22320;&#22336;&#31354;&#38388;&#20013;</span>
  <span style="font-weight: bold;">setup_arg_pages</span>(bprm, STACK_TOP, executable_stack);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#20540;&#21518;&#38754;&#20250;&#34987;&#35774;&#32622;&#20026; regs-&gt;esp, &#20174;&#32780;&#25104;&#20026;&#26032;&#36827;&#31243;&#30340;&#26632;&#39030;</span>
  current-&gt;mm-&gt;start_stack = bprm-&gt;p;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25226; elf &#20013;&#25152;&#26377;&#20026; PT_LOAD &#30340; segment &#36890;&#36807; mmap &#26144;&#23556;&#36827;&#26469;, PT_LOAD &#30340;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">segment &#20027;&#35201;&#21253;&#25324;: text, init, rodata, data, bss &#31561; section</span>
  <span style="font-weight: bold;">for</span>(i = 0, elf_ppnt = elf_phdata; i &lt; loc-&gt;elf_ex.e_phnum; i++, elf_ppnt++):
    <span style="font-weight: bold;">if</span> (elf_ppnt-&gt;p_type != PT_LOAD): <span style="font-weight: bold;">continue</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35774;&#32622; mmap &#30340; prot &#21644; flags</span>
    <span style="font-weight: bold;">if</span> (elf_ppnt-&gt;p_flags &amp; PF_R) elf_prot |= PROT_READ;
    <span style="font-weight: bold;">if</span> (elf_ppnt-&gt;p_flags &amp; PF_W) elf_prot |= PROT_WRITE;
    <span style="font-weight: bold;">if</span> (elf_ppnt-&gt;p_flags &amp; PF_X) elf_prot |= PROT_EXEC;

    elf_flags = MAP_PRIVATE|MAP_DENYWRITE|MAP_EXECUTABLE;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#38656;&#35201; mmap &#21040;&#30340;&#22320;&#22336;, &#32534;&#35793;&#26102;&#30001;&#38142;&#25509;&#22120;&#33050;&#26412; (ld script) &#25351;&#23450;, &#20889;&#20837;&#22312;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">elf &#25991;&#20214;&#20013;</span>
    vaddr = elf_ppnt-&gt;p_vaddr;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">mmap</span>
    <span style="font-weight: bold;">elf_map</span>(bprm-&gt;file, load_bias + vaddr, elf_ppnt, elf_prot, elf_flags);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21160;&#24577;&#32534;&#35793;&#30340; elf &#31243;&#24207;&#25351;&#23450;&#20102; interpreter, &#25152;&#20197;&#20854;&#20837;&#21475;&#19981;&#20877;&#26159; e_entry, &#32780;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26159; interpreter &#23545;&#24212;&#30340; e_entry</span>
  <span style="font-weight: bold;">if</span> (elf_interpreter):
    elf_entry = load_elf_interp(&amp;loc-&gt;interp_elf_ex,interpreter,&amp;interp_load_addr);
  <span style="font-weight: bold;">else</span>:
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#38745;&#24577;&#32534;&#35793;&#30340;&#31243;&#24207;, &#30452;&#25509;&#20351;&#29992; e_entry &#20570;&#20026;&#20837;&#21475;, e_entry &#22312; x86_32 &#19979;&#19968;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#33324;&#22266;&#23450;&#20026; 0x80482c0, &#23545;&#24212;&#20110; crt1.o &#20013;&#30340; __start &#20989;&#25968;, &#30001; ld script</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25351;&#23450;        </span>
    elf_entry = loc-&gt;elf_ex.e_entry;

  <span style="font-weight: bold;">create_elf_tables</span>(bprm, &amp;loc-&gt;elf_ex,
                    (interpreter_type == INTERPRETER_AOUT),load_addr, interp_load_addr);
  current-&gt;mm-&gt;end_code = end_code;
  current-&gt;mm-&gt;start_code = start_code;
  current-&gt;mm-&gt;start_data = start_data;
  current-&gt;mm-&gt;end_data = end_data;
  current-&gt;mm-&gt;start_stack = bprm-&gt;p;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">do_execve &#36820;&#22238;&#21040; user mode &#30340;&#26368;&#21518;&#19968;&#27493;: &#35774;&#32622; regs-&gt;{eip,esp, ...} &#20197;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20415;&#20174; syscall &#36820;&#22238;&#21518;&#33021;&#25191;&#34892; elf &#31243;&#24207;</span>
  <span style="font-weight: bold;">start_thread</span>(regs, elf_entry, bprm-&gt;p);
    regs-&gt;xds = __USER_DS;
    regs-&gt;xes = __USER_DS;
    regs-&gt;xss = __USER_DS;
    regs-&gt;xcs = __USER_CS;
    regs-&gt;eip = elf_entry;
    regs-&gt;esp = bprm-&gt;p;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd94d2be" class="outline-4">
<h4 id="orgd94d2be"><span class="section-number-4">1.2.2</span> setup_arg_pages</h4>
<div class="outline-text-4" id="text-1-2-2">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">setup_arg_pages</span>(bprm,stack_top):
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">stack_top &#30340;&#20540;&#20026; STACK_TOP &#20026; 3G, &#19979;&#38754;&#20004;&#34892;&#20195;&#30721;&#23558; bprm-&gt;p "&#24179;&#31227;" &#21040;&#20102;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">3G &#20197;&#19979;&#23545;&#24212;&#30340;&#20301;&#32622;. &#23454;&#38469;&#19978;&#22312;&#26032;&#29256;&#26412;&#30340; kernel &#20013;, &#36825;&#37324;&#30340; stack_top &#20256;&#36827;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26469;&#20043;&#21069;&#24050;&#32463;&#38543;&#26426;&#36807;&#20102;, &#23454;&#38469;&#30340;&#20540;&#26159; STACK_TOP - random_offset (&#21442;&#32771;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">randomize_stack_top)</span>
  stack_base = stack_top - MAX_ARG_PAGES * PAGE_SIZE;
  bprm-&gt;p += stack_base;

  mm-&gt;arg_start = bprm-&gt;p;
  arg_size = stack_top - (PAGE_MASK &amp; (<span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span>) mm-&gt;arg_start);

  mpnt = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);
  mpnt-&gt;vm_mm = current-&gt;mm;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010; vma &#23545;&#24212; args+stack, &#20294;&#21021;&#22987;&#22823;&#23567;&#21482;&#21253;&#25324; args &#30340;&#37096;&#20998; (argv, envp),</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20294;&#36825;&#24182;&#27809;&#26377;&#38382;&#39064;, &#22240;&#20026; vma &#30340; VM_GROWSDOWN flag &#20445;&#35777;&#35775;&#38382; stack &#26102;&#24182;&#19981;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20250;&#20986;&#38169;</span>
  mpnt-&gt;vm_end = stack_top;
  mpnt-&gt;vm_start = mpnt-&gt;vm_end - arg_size;
  mpnt-&gt;vm_flags = VM_STACK_FLAGS;
  mpnt-&gt;vm_flags |= mm-&gt;def_flags;
  mpnt-&gt;vm_page_prot = protection_map[mpnt-&gt;vm_flags &amp; 0x7];
  <span style="font-weight: bold;">insert_vm_struct</span>(mm, mpnt)

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558; bprm-&gt;page &#26144;&#23556;&#21040;&#21069;&#38754;&#30340; vma &#20013;</span>
  <span style="font-weight: bold;">for</span> (i = 0 ; i &lt; MAX_ARG_PAGES ; i++):
    <span style="font-weight: bold;">struct</span> page *page = bprm-&gt;page[i];
      <span style="font-weight: bold;">if</span> (page):
        bprm-&gt;page[i] = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
        <span style="font-weight: bold;">install_arg_page</span>(mpnt, page, stack_base);
    stack_base += PAGE_SIZE;
</pre>
</div>
</div>
</div>

<div id="outline-container-org12497a8" class="outline-4">
<h4 id="org12497a8"><span class="section-number-4">1.2.3</span> create_elf_tables</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
create_elf_tables 主要还是和 argv, envp 的处理有关:
</p>

<ol class="org-ol">
<li>copy_strings 负责复制 argv, envp 到 bprm-&gt;page 并维护 bprm-&gt;p</li>

<li>setup_arg_pages 负责将 bprm-&gt;p "平移" 到最终的地址空间 (STACK_TOP),
创建 VMA 并将 bprm-&gt;page 映射到 VMA</li>
</ol>

<p>
但还有一部分没有 ready: 前面两步只是设置好了 argv, envp 指向的数据, 紧
接着栈底之上 argc 和 argv, envp 本身呢?
</p>

<p>
create_elf_tables 会 setup 最后这一部分
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">create_elf_tables</span>:
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">argc</span> = bprm-&gt;argc;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">bprm-&gt;p &#26159;&#26632;&#24213;</span>
  sp = (elf_addr_t <span style="font-weight: bold; text-decoration: underline;">__user</span> *)bprm-&gt;p;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">argc</span>
  <span style="font-weight: bold;">__put_user</span>(argc, sp++)

  argv = sp;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">+1 &#26159;&#22240;&#20026; argv[] &#26368;&#21518;&#19968;&#20010;&#20803;&#32032;&#26159; NULL</span>
  envp = argv + argc + 1;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22635;&#20805; argv[]</span>
  p = current-&gt;mm-&gt;arg_start;
  <span style="font-weight: bold;">while</span> (argc-- &gt; 0):
    size_t len;
    <span style="font-weight: bold;">__put_user</span>((<span style="font-weight: bold; text-decoration: underline;">elf_addr_t</span>)p, argv++);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">strnlen_user &#19982; libc &#20013;&#30340; strnlen &#24182;&#19981;&#19968;&#26679;: strnlen_user &#36820;&#22238;&#30340;&#38271;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24230;&#26159;&#21253;&#25324;&#32467;&#23614;&#30340; NULL &#30340;</span>
    len = strnlen_user((<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; font-style: italic;">__user</span> *)p);
    p += len;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">finally, argv</span>
  __put_user(0, argv)
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22635;&#20805; envp[]</span>
  <span style="font-weight: bold;">while</span> (envc-- &gt; 0):
    size_t len;
    <span style="font-weight: bold;">__put_user</span>((<span style="font-weight: bold; text-decoration: underline;">elf_addr_t</span>)p, envp++);
    len = strnlen_user((<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; font-style: italic;">__user</span> *)p, PAGE_SIZE*MAX_ARG_PAGES);
    p += len;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">finally, envp</span>
  __put_user(0, envp)
</pre>
</div>
</div>
</div>


<div id="outline-container-org892bf11" class="outline-4">
<h4 id="org892bf11"><span class="section-number-4">1.2.4</span> load_elf_interp</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
当 elf 指定了 .interp 时, 程序的入口不再是 elf 本身的 entry, 而是
interp 的 entry
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">load_elf_interp</span>(interpreter):
  kernel_read(interpreter,interp_elf_ex-&gt;e_phoff,(<span style="font-weight: bold; text-decoration: underline;">char</span> *)elf_phdata,size);
  <span style="font-weight: bold;">for</span> (i=0; i&lt;interp_elf_ex-&gt;e_phnum; i++, eppnt++):
    <span style="font-weight: bold;">if</span> (eppnt-&gt;p_type == PT_LOAD) {
      <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">elf_type</span> = MAP_PRIVATE | MAP_DENYWRITE;
      <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">elf_prot</span> = 0;
      <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">vaddr</span> = 0;
      <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">k</span>, <span style="font-weight: bold; font-style: italic;">map_addr</span>;

      <span style="font-weight: bold;">if</span> (eppnt-&gt;p_flags &amp; PF_R) elf_prot =  PROT_READ;
      <span style="font-weight: bold;">if</span> (eppnt-&gt;p_flags &amp; PF_W) elf_prot |= PROT_WRITE;
      <span style="font-weight: bold;">if</span> (eppnt-&gt;p_flags &amp; PF_X) elf_prot |= PROT_EXEC;
      vaddr = eppnt-&gt;p_vaddr;

      map_addr = elf_map(interpreter, load_addr + vaddr, eppnt, elf_prot, elf_type);

      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#31532;&#19968;&#20010;&#34987; mmap &#24517;&#23450;&#26159; .text?</span>
      <span style="font-weight: bold;">if</span> (!load_addr_set &amp;&amp; interp_elf_ex-&gt;e_type == ET_DYN):
          load_addr = map_addr - ELF_PAGESTART(vaddr);
          load_addr_set = 1;

      load_addr = map_addr - ELF_PAGESTART(vaddr);

  <span style="font-weight: bold;">return</span> ((<span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span>) interp_elf_ex-&gt;e_entry) + load_addr;
</pre>
</div>
</div>
</div>

<div id="outline-container-org0fa1a2a" class="outline-4">
<h4 id="org0fa1a2a"><span class="section-number-4">1.2.5</span> ELF 程序引用 argc, argv</h4>
<div class="outline-text-4" id="text-1-2-5">
<p>
argc 和 argv 已经放在栈上了, 那么应用程序如何引用到它们?
</p>
</div>

<div id="outline-container-org5c48be1" class="outline-5">
<h5 id="org5c48be1"><span class="section-number-5">1.2.5.1</span> 示例程序</h5>
<div class="outline-text-5" id="text-1-2-5-1">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">hello</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">a</span>) {
    printf(<span style="font-style: italic;">"%d\n"</span>, a);
}

<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">main</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">argc</span>, <span style="font-weight: bold; text-decoration: underline;">char</span> *<span style="font-weight: bold; font-style: italic;">argv</span>[]) {
    <span style="font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
通过如下的命令编译. 为了避免 libc 自动加入的入口 (_start) 的影响, 编译
时直接指定了 entry 为 hello.
</p>

<pre class="example" id="org6230ae9">
gcc -g test.c -m32  -Wl,-ehello -O0
</pre>

<p>
示例中的 main 函数并没什么用, 但由于编译时使用 libc 会默认插入一个
_start 并会引用 main, 通过 `gcc -nostdlib` 可以避免上述情况, 但用了
nostdlib 后又无法使用 libc 中提供的函数例如 printf&#x2026;为了能编译通过,
只好写一个无用的 main&#x2026;
</p>
</div>
</div>

<div id="outline-container-org3027ee2" class="outline-5">
<h5 id="org3027ee2"><span class="section-number-5">1.2.5.2</span> 使用 gdb 分析</h5>
<div class="outline-text-5" id="text-1-2-5-2">
<pre class="example" id="org66f3f64">
#&gt; gdb ./a.out
(gdb) set args "hello"
(gdb) b hello
(gdb) r
(gdb) p $esp
$1 = (void *) 0xffffc444
(gdb) p $ebp
$2 = (void *) 0xffffc44c
(gdb) disass
Dump of assembler code for function hello:
   0x080483eb &lt;+0&gt;:     push   %ebp
   0x080483ec &lt;+1&gt;:     mov    %esp,%ebp
   0x080483ee &lt;+3&gt;:     sub    $0x8,%esp
=&gt; 0x080483f1 &lt;+6&gt;:     sub    $0x8,%esp
   0x080483f4 &lt;+9&gt;:     pushl  0x8(%ebp)
   0x080483f7 &lt;+12&gt;:    push   $0x80484c0
   0x080483fc &lt;+17&gt;:    call   0x80482c0 &lt;printf@plt&gt;
   0x08048401 &lt;+22&gt;:    add    $0x10,%esp
   0x08048404 &lt;+25&gt;:    nop
   0x08048405 &lt;+26&gt;:    leave
   0x08048406 &lt;+27&gt;:    ret
End of assembler dump.

(gdb) x /10x $ebp
0xffffc44c:     0x00000000      0x00000002      0xffffc611      0xffffc624
0xffffc45c:     0x00000000      0xffffc62b      0xffffc636      0xffffc655
0xffffc46c:     0xffffc667      0xffffc67a

# 当前的栈布局:
#
# 1. 0x00000000 是 hello 第一行的 `push $ebp` push 到栈里的 "上一个
#    stack frame" 的 ebp, 由于 hello 是 elf 的 entry, 所以并不存在 "上一
#    个 stack frame", 所以这里会是 0
# 2. 0x00000002 是 argc
# 3. 0xffffc611 是 argv[0]
# 4. 0xffffc624 是 argv[1]
# 5. 0x00000000 是 argv 结尾的 NULL
# 6. 0xffffc62b 是 envp[0]
# 7. ....

(gdb) p (char*)0xffffc611
$2 = 0xffffc611 "/home/sunway/a.out"
(gdb) p (char*)0xffffc624
$3 = 0xffffc624 " hello"
(gdb) p (char*)0xffffc62b
$4 = 0xffffc62b "XDG_VTNR=1"

# hello 函数的参数 a 实际上对应 0xffffc611 即 argv[0], 从前面 disass 的
# 结果看, a 是通过 ebp+8 引用的: 为什么是 ebp + 8?
#
# 根据 c 的调用约定:
#
# 1. 首先参数入栈
# 2. call 导致返回地址入栈 (4B)
# 3. 旧的 ebp 入栈 (4B)
# 4. ebp 设置为当前的 esp
#
# 所以 hello 认为的栈布局是:
#
# 1. 0x00000000 是旧的 ebp
# 2. 0x00000002 是返回地址...
# 3. 0xffffc611 是第一个参数的值, 也就是 a 的值
#
# 根据这个认识, hello 通过 a 必然无法拿到真正的 argc, 而且因为 hello 认
# 为返回地址是 0x00000002, 导致 hello 返回时会报错
(gdb) x a
0xffffc611:     0x6d6f682f

(gdb) n
-14831
3       }

# 把 0x00000002 误认为是返回地址
(gdb) n
0x00000002 in ?? ()

# 栈上在 0x00000002 后面直接就是平铺的 argv[0], argv[1] (`0xffffc611
# 0xffffc624`), 而普通的 main 函数的原型是 main(int argc, char ** argv),
# 即 main 函数期望栈上在 argc 之后是一个 char ** 指针, 而不是平铺的
# argv[0], argv[1]...
#
# 另一方面, 有些平台上函数的参数并不是像 x86 一样从栈上取的, 以 arm 为例,
# 它的调用约定要求 r0, r1, r2, r3 保存前四个参数, 其它参数才需要从栈上取,
# 这种情况下 hello 函数更不可能直接取到相应的参数
#
# 因此, elf 的 entry 要么自己用 trick 来获取参数, 要么由更高层的 entry 帮
# 自己获取参数, 毕竟 kernel 调用 entry 时是通过直接修改 eip 跳转的, 并不
# 考虑它做为一个函数的调用约定
</pre>
</div>
</div>

<div id="outline-container-orgb52ad37" class="outline-5">
<h5 id="orgb52ad37"><span class="section-number-5">1.2.5.3</span> 实现一个简单的 entry</h5>
<div class="outline-text-5" id="text-1-2-5-3">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">entry</span> () {
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">ebp</span> = 0;
    <span style="font-weight: bold;">__asm__</span>(<span style="font-style: italic;">"movl %%ebp,%0"</span>:<span style="font-style: italic;">"=r"</span> (ebp));
    exit(hello(*((<span style="font-weight: bold; text-decoration: underline;">int</span> *)(ebp + 4)), (<span style="font-weight: bold; text-decoration: underline;">char</span> **)(ebp+8)));
}

<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">hello</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">argc</span>, <span style="font-weight: bold; text-decoration: underline;">char</span> ** <span style="font-weight: bold; font-style: italic;">argv</span>) {
    printf(<span style="font-style: italic;">"%d\n"</span>, argc);
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0;
    <span style="font-weight: bold;">for</span> (i = 0; i &lt; argc; i++) {
        printf(<span style="font-style: italic;">"%s\n"</span>, argv[i]);
    }
    <span style="font-weight: bold;">return</span> 0;
}

<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">main</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">argc</span>, <span style="font-weight: bold; text-decoration: underline;">char</span> *<span style="font-weight: bold; font-style: italic;">argv</span>[]) {
    <span style="font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
测试:
</p>

<pre class="example" id="orga236913">
$&gt; gcc -g test.c -m32 -Wl,-eentry -O0

$&gt; ./a.out
1
./a.out

$&gt; ./a.out hello
2
./a.out
hello
</pre>

<p>
实际上, 正常编译的 c 程序会使用 libc 提供的 entry (_start) 来调用 main
函数, 以便 main 函数可以直接使用 argc 和 argv
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orga8cc8c3" class="outline-3">
<h3 id="orga8cc8c3"><span class="section-number-3">1.3</span> script 的加载</h3>
<div class="outline-text-3" id="text-1-3">
<p>
load_script 负责 script (bash, perl, python &#x2026;) 的加载
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">load_script</span>(bprm, regs):
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">script &#37117;&#26159;&#20197; #! &#24320;&#22836;</span>
  <span style="font-weight: bold;">if</span> ((bprm-&gt;buf[0] != <span style="font-style: italic;">'#'</span>) || (bprm-&gt;buf[1] != <span style="font-style: italic;">'!'</span>) || (bprm-&gt;sh_bang)):
    <span style="font-weight: bold;">return</span> -ENOEXEC;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35299;&#26512; #! &#21518;&#30340; interpreter &#21517;&#23383;&#21644;&#21442;&#25968;, &#20445;&#23384;&#22312; interp &#21644; i_arg &#20013;</span>
  <span style="font-weight: bold;">strcpy</span> (interp, i_name);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558; bprm-&gt;interp &#22797;&#21046;&#21040; bprm-&gt;page &#20013;, &#36825;&#26102; page &#30340;&#24067;&#23616;&#20026; (&#30001;&#20302;&#21040;&#39640;):</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">bprm-&gt;interp | argv |  envp |  bprm-&gt;filename</span>
  copy_strings_kernel(1, &amp;bprm-&gt;interp, bprm);
  bprm-&gt;argc++;
  <span style="font-weight: bold;">if</span> (i_arg):
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">sh_bang &#20013;&#33050;&#26412;&#35299;&#37322;&#22120;&#30340;&#21442;&#25968;&#20063;&#34987;&#36861;&#21152;&#21040; bprm-&gt;page &#20013;</span>
    copy_strings_kernel(1, &amp;i_arg, bprm);
    bprm-&gt;argc++;
  copy_strings_kernel(1, &amp;i_name, bprm);
  bprm-&gt;argc++;
  bprm-&gt;interp = interp;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#29616;&#22312; bprm-&gt;page &#30340;&#24067;&#23616;, &#20197; she-bang &#20026; '#!/bin/bash -i' &#30340; 'test.sh</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">hello' &#20026;&#20363;:</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">/bin/bash | -i | test.sh | hello | envp | test.sh</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25152;&#20197;&#24403; bash &#21551;&#21160;&#26102;, argv &#20250;&#26159; {/bin/bash, -i, test.sh, hello}    </span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#29616;&#22312; bprm-&gt;interp &#21644; bprm-&gt;file &#24050;&#32463;&#34987;&#26367;&#25442;&#20026; /bin/bash, &#28982;&#21518;&#36882;&#24402;&#30340;&#35843;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#29992; search_binary_handler, &#30475;&#30475;&#22914;&#20309;&#25191;&#34892; /bin/bash</span>
  bprm-&gt;file = open_exec(interp);
  <span style="font-weight: bold;">search_binary_handler</span>(bprm,regs);
</pre>
</div>

<p>
可见 load_script 的方式允许嵌套的指定, 例如 script 指定 #!/bin/interp1,
而 interp1 也是一个 script, 指定 #!/bin/inter2 &#x2026; 这种嵌套的处理过程
并不复杂: kernel 只需要相应的调整 argv 就可以.
</p>

<p>
但需要注意的是最内部的一层嵌套必然是一个 "非 script" 类型的可执行程序,
例如 ELF, 后者会通过 setup_arg_pages 和 create_elf_tables 完成 argv 最
终的布局
</p>
</div>
</div>

<div id="outline-container-orgf834594" class="outline-3">
<h3 id="orgf834594"><span class="section-number-3">1.4</span> 用户自定义加载</h3>
<div class="outline-text-3" id="text-1-4">
<p>
load_misc_binary 实现用户自定义的加载, 它的过程和 load_script 非常类似,
只不过寻找下一级 interp 的过程不是通过读取 script 的 she-bang, 而是通
过用户写到的 '/proc/sys/fs/binfmt_misc/register' 的设定决定的.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

<p class="author">Author: sunway (sunwayforever@gmail.com)<br />
Date: 2016-08-02 Tue 00:00<br />
Last updated: 2022-01-19 Wed 13:25</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。
<br />

<div id="disqus_thread"></div>
<script>

(function() { // DON'T EDIT BELOW THIS LINE
         var d = document, s = d.createElement('script');
         s.src = '//sunwayforever-github-io.disqus.com/embed.js';
         s.setAttribute('data-timestamp', +new Date());
         (d.head || d.body).appendChild(s);
         })();
</script>
</div>
</body>
</html>
