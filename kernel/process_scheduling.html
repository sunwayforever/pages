<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>Linux Kernel: Process Scheduling</title>


<link rel="stylesheet" type="text/css" href="/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="./htmlize.css"/>
<link rel="stylesheet" type="text/css" href="../htmlize.css"/>
<link rel="stylesheet" type="text/css" href="../../htmlize.css"/>
<link rel="stylesheet" type="text/css" href="/readtheorg.css"/>
<link rel="stylesheet" type="text/css" href="./readtheorg.css"/>
<link rel="stylesheet" type="text/css" href="../readtheorg.css"/>
<link rel="stylesheet" type="text/css" href="../../readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
<link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
<link rel="stylesheet" type="text/css" href="../main.css" media="screen" />
<link rel="stylesheet" type="text/css" href="../../main.css" media="screen" />
<link rel="stylesheet" type="text/css" href="./main.css" media="screen" />
<link rel = "icon" href = "/icon.png"  type = "image/x-icon">
</head>
<body>
<div id="content" class="content">
<h1 class="title">Linux Kernel: Process Scheduling</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org0000062">1. Linux Kernel: Process Scheduling</a>
<ul>
<li><a href="#org0000000">1.1. Overview</a></li>
<li><a href="#org000000e">1.2. 相关数据结构</a>
<ul>
<li><a href="#org0000004">1.2.1. runqueue</a></li>
<li><a href="#org0000007">1.2.2. task_struct</a></li>
<li><a href="#org000000b">1.2.3. priority</a></li>
</ul>
</li>
<li><a href="#org000002f">1.3. 相关的函数</a>
<ul>
<li><a href="#org0000020">1.3.1. scheduler_tick</a></li>
<li><a href="#org0000026">1.3.2. try_to_wake_up</a></li>
<li><a href="#org0000023">1.3.3. schedule</a></li>
<li><a href="#org000002c">1.3.4. set_tsk_need_resched</a></li>
</ul>
</li>
<li><a href="#org0000029">1.4. 各种 scheduler</a>
<ul>
<li><a href="#org0000032">1.4.1. SCHED_FIFO</a></li>
<li><a href="#org0000035">1.4.2. SCHED_RR</a></li>
<li><a href="#org0000038">1.4.3. SCHED_NORMAL</a></li>
</ul>
</li>
<li><a href="#org000004a">1.5. CPU 负载均衡</a>
<ul>
<li><a href="#org0000041">1.5.1. pull task</a></li>
<li><a href="#org0000047">1.5.2. push task</a></li>
</ul>
</li>
<li><a href="#org000005f">1.6. 相关 API</a>
<ul>
<li><a href="#org000004d">1.6.1. nice</a></li>
<li><a href="#org0000050">1.6.2. sched_yield</a></li>
<li><a href="#org0000053">1.6.3. sched_setscheduler</a></li>
<li><a href="#org0000056">1.6.4. sched_setaffinity</a></li>
<li><a href="#org0000059">1.6.5. fork</a></li>
<li><a href="#org000005c">1.6.6. See also</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org0000062" class="outline-2">
<h2 id="org0000062"><span class="section-number-2">1.</span> Linux Kernel: Process Scheduling</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org0000000" class="outline-3">
<h3 id="org0000000"><span class="section-number-3">1.1.</span> Overview</h3>
<div class="outline-text-3" id="text-1-1">
<p>
linux 2.6.11 的进程调度的主要特征:
</p>

<ol class="org-ol">
<li>scheduler 是一个基于 roundrobin 的算法: 每个进程有一个时间片 (slice
或 quantum), 时间片是每次 roundrobin 时进程可以执行的时间长度, 大小一般为几毫秒到几百毫秒.一次 roundrobin 完成后所有进程的时间片得到补充进行下一次 roundrobin</li>

<li>每个 cpu 的 runqueue 有 active 和 expired 两个数组, 每个数组包含
140 条链表, 对应 140 个优先级, 所有本次 roundrobin 时间片已经耗尽的进程按优先级组织在 expired 数组中,还有时间片的组织在 active 数组中,
scheduler 在 pick next 时在 active 数组中通过一个 bitmap 可以在 O(1)
内找到最高优先级的一个 task, 所以 2.6.11 的 scheduler 称为 O(1)
scheduler, 2.6 之前的 scheduler 称为 O(n) scheduler, 因为它只有一条链表, 每次 pick next 时需要通过排序找到一个最高优先级的.</li>

<li>进程有静态优先级 (static priority), scheduler 会根据静态优先级给进程分配不同长度的时间片, 静态优先级越高, 时间片越长</li>

<li>进程有动态优先级 (dynamic priority), 在 roundrobin 时 scheduler 根据动态优先级来选择进程执行的顺序</li>

<li>动态优先级是在静态优先级基础上使用 "平均睡眠时间" 进行补偿或惩罚而来, 简单的说, 平均睡眠时间越长, 对动态优先级的补偿越多</li>

<li>除了一般的基于时间片与动态优先级的调度外, scheduler 还支持实时调度来调度实时进程, 但实时进程与普通进程还是要竞争同一个 cpu, linux 的实时进程只是有更高的优先级和更多的调度机会, 但它无法保证实时进程能在"确定的时间"内完成, 所以它只软实时(soft real time)</li>

<li>通过 "平均睡眠时间", scheduler 可以识别出 "交互式进程" (interactive
process) 与 "批处理进程" (batch process), scheduler 会通过调整
roundrobin 分配给 "交互式进程" 更多的执行机会</li>

<li>多 CPU 的负载均衡, 可以将繁忙的 CPU 中的 task pull 到当前 CPU 中, 或者将当前 task push 到空闲的 CPU 中</li>
</ol>
</div>
</div>

<div id="outline-container-org000000e" class="outline-3">
<h3 id="org000000e"><span class="section-number-3">1.2.</span> 相关数据结构</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-org0000004" class="outline-4">
<h4 id="org0000004"><span class="section-number-4">1.2.1.</span> runqueue</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
runqueue 是一个 Per-CPU variable, 即每个 CPU 都有一个 runqueue, 这个
runqueue 是进程调度最主要的数据结构, 它维护了一个 running 进程的队列,
scheduler 需要从这个队列中选择进程来执行
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-keyword">struct</span> <span class="org-type">runqueue</span> {
    <span class="org-comment-delimiter">// </span><span class="org-comment">runqueue &#32500;&#25252;&#30340;&#25152;&#26377; running &#36827;&#31243;&#30340;&#20010;&#25968;, &#26159; active &#21644; expired &#20043;&#21644;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;&#20540;&#21453;&#24212;&#20102;&#24403;&#21069; cpu &#30340;&#36127;&#36733;&#31243;&#24230;</span>
    <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">nr_running</span>;
    <span class="org-comment-delimiter">/* </span><span class="org-comment">curr &#21363; current, idle &#21363; swapper</span><span class="org-comment-delimiter"> */</span>
    <span class="org-type">task_t</span> *<span class="org-variable-name">curr</span>, *<span class="org-variable-name">idle</span>;
    <span class="org-comment-delimiter">/* </span><span class="org-comment">&#26368;&#20027;&#35201;&#30340;&#25968;&#25454;&#32467;&#26500;: runqueue &#20013;&#25152;&#26377;&#30340;&#36827;&#31243;&#34987;&#20998;&#20026;&#20004;&#31867;: active &#19982;</span>
<span class="org-comment">     * expired, active &#26159;&#25351;&#26102;&#38388;&#29255;&#23578;&#27809;&#26377;&#32791;&#23613;&#30340;&#36827;&#31243;, expired &#26159;&#25351;&#26412;&#27425;</span>
<span class="org-comment">     * roundrobin &#36807;&#31243;&#20013;&#26102;&#38388;&#29255;&#24050;&#32463;&#32791;&#23613;&#30340;&#36827;&#31243;, scheduler &#21482;&#20250;&#20174; active</span>
<span class="org-comment">     * &#20013;&#23547;&#25214; candidate, &#21442;&#32771; process</span><span class="org-comment-delimiter"> */</span>
    <span class="org-type">prio_array_t</span> *<span class="org-variable-name">active</span>, *<span class="org-variable-name">expired</span>, <span class="org-variable-name">arrays</span>[2];
    <span class="org-comment-delimiter">/* </span><span class="org-comment">&#25351;&#31034;&#26159;&#21542;&#38656;&#35201;&#23558;&#24403;&#21069; runqueue &#30340; task &#36716;&#25442;&#21040;&#20854;&#23427; cpu</span><span class="org-comment-delimiter"> */</span>
    <span class="org-type">int</span> <span class="org-variable-name">active_balance</span>;
}
</pre>
</div>

<p>
关于 runqueue 中的 arrays, active, expired:
</p>


<div id="org0000003" class="figure">
<p><img src="../extra/kernel_scheduler_runqueue.png" alt="kernel_scheduler_runqueue.png" />
</p>
</div>

<p>
其中 p 组成的链表对应的 list entry 是 task_struct-&gt;run_list
</p>
</div>
</div>

<div id="outline-container-org0000007" class="outline-4">
<h4 id="org0000007"><span class="section-number-4">1.2.2.</span> task_struct</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
具体的参考 <a href="process.html#org0000000">task_struct</a>, 其中和 scheduler 相关的部分:
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-keyword">struct</span> <span class="org-type">task_struct</span> {
    <span class="org-keyword">volatile</span> <span class="org-type">long</span> <span class="org-variable-name">state</span>;

    <span class="org-comment-delimiter">/* </span><span class="org-comment">dynamic priority</span><span class="org-comment-delimiter"> */</span>
    <span class="org-type">int</span> <span class="org-variable-name">prio</span>
    <span class="org-comment-delimiter">/* </span><span class="org-comment">static priority</span><span class="org-comment-delimiter"> */</span>
    <span class="org-type">int</span> static_prio;

    <span class="org-comment-delimiter">/* </span><span class="org-comment">&#21644; runqueue &#26377;&#20851;</span><span class="org-comment-delimiter"> */</span>
    <span class="org-keyword">struct</span> <span class="org-type">list_head</span> <span class="org-variable-name">run_list</span>;
    <span class="org-type">prio_array_t</span> *<span class="org-variable-name">array</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#24179;&#22343;&#30561;&#30496;&#26102;&#38388;, &#21644; time slice &#22823;&#23567;&#21450; interactive process &#30340;&#21028;&#23450;&#26377;&#20851;,</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#38656;&#35201;&#27880;&#24847;&#30340;&#26159; sleep_avg &#26159;&#25351; 1s &#20043;&#20869;&#22788;&#20110; sleeping &#30340;&#26102;&#38388;, &#20294;&#23427;&#30340;&#32479;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#35745;&#26041;&#27861;&#24182;&#19981;&#26159;&#20005;&#26684;&#24847;&#20041;&#19978;&#30340;&#24179;&#22343;, &#21482;&#26159;&#19968;&#31181;&#36817;&#20284;&#30340;&#26041;&#27861;</span>
    <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">sleep_avg</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">timestamp &#26159;&#35760;&#24405; task &#19982;&#35745;&#31639; sleep_avg &#30456;&#20851;&#30340;&#26102;&#38388;&#25139;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">1. &#34987; schedule in &#25110; out &#30340;&#26102;&#38388; (schedule)</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">2. &#34987;&#21796;&#37266;&#30340;&#26102;&#38388; (try_to_wake_up)</span>
    <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-type">long</span> <span class="org-variable-name">timestamp</span>, <span class="org-variable-name">last_ran</span>;
    <span class="org-type">int</span> <span class="org-variable-name">activated</span>;

    <span class="org-comment-delimiter">/* </span><span class="org-comment">scheduler: SCHED_FIFO, SCHED_RR &#25110; SCHED_NORMAL</span><span class="org-comment-delimiter"> */</span>
    <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">policy</span>;

    <span class="org-comment-delimiter">/* </span><span class="org-comment">CPU mask</span><span class="org-comment-delimiter"> */</span>
    <span class="org-type">cpumask_t</span> <span class="org-variable-name">cpus_allowed</span>;

    <span class="org-comment-delimiter">/* </span><span class="org-comment">&#24403;&#21069;&#36827;&#31243;&#21097;&#20313;&#30340;&#26102;&#38388;&#29255;</span><span class="org-comment-delimiter"> */</span>
    <span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">time_slice</span>
    <span class="org-type">unsigned</span> <span class="org-type">int</span> first_time_slice;

    <span class="org-comment-delimiter">/* </span><span class="org-comment">&#23454;&#26102;&#20248;&#20808;&#32423;(policy &#38656;&#35201;&#26159; FIFO &#25110; RR)</span><span class="org-comment-delimiter"> */</span>
    <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">rt_priority</span>;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-org000000b" class="outline-4">
<h4 id="org000000b"><span class="section-number-4">1.2.3.</span> priority</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
dynamic priority 的范围为 0~139, 但上层 API 中 priority 的含义与
kernel 内部的 dynamic priority 定义有些差别:
</p>


<div id="org000000a" class="figure">
<p><img src="../extra/kernel_scheduler_priority.png" alt="kernel_scheduler_priority.png" />
</p>
</div>

<ol class="org-ol">
<li>kernel 内部定义的范围为 0~139, 其中 0~99 对应 real time priority,
100~139 对应 conventional priority, 而且 0 是最高优先级, 139 是最低优先级</li>

<li>通过 nice 系统调用可以设置的参数范围为 -20~+19, 它只会影响
conventional process 的 static priority, 实际上 static_prio = 120 +
nice, 即 nice 为 -20 时, static_prio 为 100, 为 conventional
process 的最高优先级, 相反, nice 为 19 时, static_prio 为 139, 为
conventional process 的最低优先级. 默认的 static_prio 为 120, 即
nice 为 0</li>

<li>bash 中 ps 或 top 看到的值的范围为 39~-100, 与 kernel 的 139~0 对应,
即 static_prio = ps_prio + 100</li>

<li>real time process 的 rt_priority 通过 sched_setscheduler 来设置, 但与 conventional 不同的是, rt_priority 会影响 dynamic priority 而不是 static_prio: prio = 99 - rt_priority, 所以, 当 rt_priority 为
99 时, prio 为 0, 是系统最高的优先级, 当 rt_priority 为 1 时, prio
为 98, 是 real time 最低优先级, 但仍比 conventional 的最高优先级
(100) 高</li>
</ol>
</div>
</div>
</div>


<div id="outline-container-org000002f" class="outline-3">
<h3 id="org000002f"><span class="section-number-3">1.3.</span> 相关的函数</h3>
<div class="outline-text-3" id="text-1-3">
<p>
进程调度的主要入口是 schedule 函数, 但 schedule 函数工作时要依赖于两个数据的维护:
</p>

<ol class="org-ol">
<li><p>
task_struct-&gt;slice_time
</p>

<p>
进程本次 roundrobin 剩余的时间片, 时间片为 0 的进程需要变成
expired 状态, 本次 roundrobin 不能再调度它, slice_time 由
scheduler_tick 维护
</p></li>

<li><p>
task_struct-&gt;prio
</p>

<p>
动态优先级, roundrobin 时需要根据 sleep_avg 调整动态优先级以选择进程, 由 try_to_wake_up 时的 recalc_task_prio 维护
</p></li>
</ol>
</div>

<div id="outline-container-org0000020" class="outline-4">
<h4 id="org0000020"><span class="section-number-4">1.3.1.</span> scheduler_tick</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
每次时钟中断发生时<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>, scheduler_tick 会被调用, 更新当前进程的
slice_time
</p>
</div>

<div id="outline-container-org0000011" class="outline-5">
<h5 id="org0000011"><span class="section-number-5">1.3.1.1.</span> scheduler_tick</h5>
<div class="outline-text-5" id="text-1-3-1-1">
<div class="org-src-container">
<pre class="src src-c"><span class="org-constant">scheduler_tick</span>:
  <span class="org-type">runqueue_t</span> *<span class="org-variable-name">rq</span> = this_rq();
  <span class="org-type">task_t</span> *<span class="org-variable-name">p</span> = current;
  <span class="org-keyword">if</span> (rt_task(p)):
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#33509; task &#26159;&#23454;&#26102;&#36827;&#31243; (p-&gt;prio &lt; 100), &#21017;&#36827;&#34892;&#29305;&#27530;&#22788;&#29702;:</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">1. &#33509; scheduler &#20026; SCHED_RR, &#21017; p-&gt;time_slice &#20943;&#19968;, &#33509; time_slice</span>
    <span class="org-comment-delimiter">//    </span><span class="org-comment">&#24050;&#32463;&#32791;&#23613;, &#21017;&#34917;&#20805; time_slice &#24182;&#25226; task &#25918;&#22312; active &#30340;&#26411;&#23614; (&#32780;&#19981;</span>
    <span class="org-comment-delimiter">//    </span><span class="org-comment">&#26159;&#20687; SCHED_NORMAL &#37027;&#26679;&#25918;&#22312; expired &#20013;), &#28982;&#21518;&#36890;&#36807;</span>
    <span class="org-comment-delimiter">//    </span><span class="org-comment">set_tsk_need_resched &#22312;&#23558;&#26469;&#35843;&#29992; schedule &#26469;&#35843;&#24230;&#21478;&#19968;&#20010;&#36827;&#31243;&#25191;&#34892;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">2. &#33509; schedule &#20026; SCHED_FIFO, &#21017;&#19981;&#20570;&#20219;&#20309;&#21160;&#20316;, &#30452;&#25509;&#36820;&#22238;, &#22240;&#20026; FIFO</span>
    <span class="org-comment-delimiter">//    </span><span class="org-comment">&#24182;&#19981;&#38656;&#35201;&#32771;&#34385;&#26102;&#38388;&#29255;, &#23427;&#23436;&#20840;&#26159;&#25353;&#29031; FIFO &#26469;&#35843;&#24230;&#30340;: &#20808;&#26469;&#30340;&#20808;&#25191;&#34892;,</span>
    <span class="org-comment-delimiter">//    </span><span class="org-comment">&#30452;&#21040;&#23427;&#25191;&#34892;&#23436;&#25110;&#20027;&#21160;&#25918;&#24323;&#25110;&#34987;&#39640;&#20248;&#20808;&#32423;&#25250;&#21344;&#20026;&#27490;</span>
    <span class="org-keyword">if</span> ((p-&gt;policy == SCHED_RR) &amp;&amp; <span class="org-negation-char">!</span>--p-&gt;time_slice) {
        p-&gt;time_slice = task_timeslice(p);
        set_tsk_need_resched(p);
        requeue_task(p, rq-&gt;active);
    }
    <span class="org-keyword">goto</span> <span class="org-constant">out</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">conventional scheduler</span>
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>--p-&gt;time_slice):
    <span class="org-comment-delimiter">// </span><span class="org-comment">time_slice &#24050;&#32463;&#32791;&#23613;:</span>
    <span class="org-comment-delimiter">//</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">1. &#23558; task &#20174; active &#20013; dequeue</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">2. set_tsk_need_resched &#25250;&#21344;&#24403;&#21069;&#36827;&#31243;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">3. &#37325;&#26032;&#35745;&#31639;&#21160;&#24577;&#20248;&#20808;&#32423;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">4. &#34917;&#20805; time_slice</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">5. &#33509; task &#19981;&#26159; interactive task &#25110;&#32773; expired &#24050;&#32463; startving, &#21017;&#23558;</span>
    <span class="org-comment-delimiter">//    </span><span class="org-comment">task enqueue &#21040; expired, &#21542;&#21017; task &#34987;&#37325;&#26032;&#25918;&#22238; active &#38431;&#23614;</span>
    dequeue_task(p, rq-&gt;active);
    <span class="org-function-name">set_tsk_need_resched</span>(p);

    p-&gt;prio = effective_prio(p);
    p-&gt;time_slice = task_timeslice(p);

    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>TASK_INTERACTIVE(p) || EXPIRED_STARVING(rq)):
      enqueue_task(p, rq-&gt;expired);
      <span class="org-keyword">if</span> (p-&gt;static_prio &lt; rq-&gt;best_expired_prio):
        rq-&gt;best_expired_prio = p-&gt;static_prio;
    <span class="org-keyword">else</span>:
      enqueue_task(p, rq-&gt;active);
  <span class="org-keyword">else</span>:
    <span class="org-comment-delimiter">// </span><span class="org-comment">interactive &#36827;&#31243;&#30340; time_slice &#26377;&#21487;&#33021;&#24456;&#38271;, &#32780;&#19988;&#23427;&#20204;&#20250;&#21453;&#22797;&#30340;&#37325;&#26032;&#36827;&#20837;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">active, &#20026;&#36991;&#20813;&#36825;&#31181; task &#38271;&#26102;&#38388;&#21344;&#29992; CPU &#23548;&#33268;&#21516;&#20248;&#20808;&#32423;&#30340; task &#26080;&#27861;&#21450;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#26102;&#25191;&#34892;, &#23558; time_slice &#20998;&#20026;&#20960;&#20010; TIMESLICE_GRANULARITY, &#27599;&#24403;&#24050;&#29992;&#30340;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">time_slice &#36798;&#21040; TIMESLICE_GRANULARITY &#30340;&#20493;&#25968;&#26102;((task_timeslice(p)</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">- p-&gt;time_slice) % TIMESLICE_GRANULARITY(p)), &#21017;&#20027;&#21160;&#25918;&#24323;&#19968;&#27425; (&#23558;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">task &#31227;&#21160;&#21040; active &#38431;&#23614;),</span>
    <span class="org-keyword">if</span> (TASK_INTERACTIVE(p) &amp;&amp;
          <span class="org-negation-char">!</span>((task_timeslice(p) - p-&gt;time_slice) % TIMESLICE_GRANULARITY(p)) &amp;&amp;
          (p-&gt;time_slice &gt;= TIMESLICE_GRANULARITY(p)) &amp;&amp;
          (p-&gt;array == rq-&gt;active)):
      requeue_task(p, rq-&gt;active);
      <span class="org-function-name">set_tsk_need_resched</span>(p);

</pre>
</div>
</div>
</div>

<div id="outline-container-org0000014" class="outline-5">
<h5 id="org0000014"><span class="section-number-5">1.3.1.2.</span> task_timeslice</h5>
<div class="outline-text-5" id="text-1-3-1-2">
<p>
task_timeslice 是根据 static_prio 来决定 task 的 time_slice
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-keyword">static</span> <span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-function-name">task_timeslice</span>(<span class="org-type">task_t</span> *<span class="org-variable-name">p</span>)
  <span class="org-keyword">if</span> (p-&gt;static_prio &lt; NICE_TO_PRIO(0)):
    <span class="org-keyword">return</span> SCALE_PRIO(DEF_TIMESLICE*4, p-&gt;static_prio);
  <span class="org-keyword">else</span>:
    <span class="org-keyword">return</span> SCALE_PRIO(DEF_TIMESLICE, p-&gt;static_prio);
</pre>
</div>

<p>
根据上面的公式, time_slice 的值的范围为 [800ms &#x2026; 100ms &#x2026; 5ms], 对应的 nice 值为 [ -20 &#x2026; 0 &#x2026; 19 ]
</p>

<p>
另外, 无法是 SCHED_RR 还是 SCHED_NORMAL, 都是通过 task_timeslice 来计算 time_slice 的, 所以 static_prio 对 SCHED_RR 也是有意义的.
</p>
</div>
</div>

<div id="outline-container-org0000017" class="outline-5">
<h5 id="org0000017"><span class="section-number-5">1.3.1.3.</span> effective_prio</h5>
<div class="outline-text-5" id="text-1-3-1-3">
<p>
effective_prio 是根据 static_prio 和 sleep_avg 来计算 prio, 至于
sleep_avg 的计算, 是通过后面的 recalc_task_prio 函数
</p>

<p>
关于动态优先级:
</p>

<ol class="org-ol">
<li>只有 SCHED_NORMAL 能通过 effective_prio 来更新 prio</li>

<li>SCHED_RR 和 SCHED_FIFO 的 prio 与 static_prio 和 sleep_avg 无关, 只有 rt_priority 有关</li>

<li>prio 相对于 static_prio 的 bonus 范围是 [-5 &#x2026;. +5]</li>
</ol>

<div class="org-src-container">
<pre class="src src-c"><span class="org-constant">effective_prio</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110; rt_task, &#30452;&#25509;&#36820;&#22238;</span>
  <span class="org-keyword">if</span> (rt_task(p)):
    <span class="org-keyword">return</span> p-&gt;prio;
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558; [0 .... MAX_SLEEP_AVG] &#26144;&#23556;&#20026; [-5 .... +5] &#30340; bonus, &#21363; sleep_avg</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36234;&#38271;, bonus &#36234;&#22823;, &#30456;&#24212;&#30340; prio &#30340;&#20248;&#20808;&#32423;&#20250;&#36234;&#39640;</span>
  bonus = CURRENT_BONUS(p) - MAX_BONUS / 2;
  prio = p-&gt;static_prio - bonus;
  <span class="org-comment-delimiter">// </span><span class="org-comment">prio &#19981;&#20250;&#27604; MAX_RT_PRIO (100) &#26356;&#39640;</span>
  <span class="org-keyword">if</span> (prio &lt; MAX_RT_PRIO):
    prio = MAX_RT_PRIO;
  <span class="org-keyword">if</span> (prio &gt; MAX_PRIO-1):
    prio = MAX_PRIO-1;
  <span class="org-keyword">return</span> prio
</pre>
</div>
</div>
</div>

<div id="outline-container-org000001a" class="outline-5">
<h5 id="org000001a"><span class="section-number-5">1.3.1.4.</span> TASK_INTERACTIVE</h5>
</div>

<div id="outline-container-org000001d" class="outline-5">
<h5 id="org000001d"><span class="section-number-5">1.3.1.5.</span> EXPIRED_STARVING</h5>
</div>
</div>

<div id="outline-container-org0000026" class="outline-4">
<h4 id="org0000026"><span class="section-number-4">1.3.2.</span> try_to_wake_up</h4>
<div class="outline-text-4" id="text-1-3-2">
<div class="org-src-container">
<pre class="src src-c"><span class="org-constant">try_to_wake_up</span>:
  <span class="org-function-name">activate_task</span>()
    <span class="org-function-name">recalc_task_prio</span>()
      sleep_time = now - p-&gt;timestamp;
      <span class="org-keyword">if</span> (sleep_time &gt; NS_MAX_SLEEP_AVG):
        sleep_time = NS_MAX_SLEEP_AVG;
      p-&gt;sleep_avg += sleep_time;
      <span class="org-keyword">if</span> (p-&gt;sleep_avg &gt; NS_MAX_SLEEP_AVG):
        p-&gt;sleep_avg = NS_MAX_SLEEP_AVG;
      p-&gt;prio = effective_prio(p);
    <span class="org-function-name">__activate_task</span>(p, rq);
      <span class="org-function-name">enqueue_task</span>(p, rq-&gt;active);
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#25250;&#21344;</span>
  <span class="org-keyword">if</span> (TASK_PREEMPTS_CURR(p, rq)):
    resched_task(rq-&gt;curr);
</pre>
</div>

<p>
recalc_task_prio 作用是当 task 从睡眠状态唤醒时 (try_to_wake_up) 时根据 p-&gt;timestamp 计算本次睡眠的时间, 以此更新 sleep_avg 和 prio
</p>

<p>
p-&gt;timestamp 的赋值主要是在 schedule 函数中 (<a href="#org0000023">schedule</a>), 即 schedule 时会将 prev-&gt;timestamp 和 next-&gt;timestamp 均设置为 now
</p>

<p>
对于 next 来说,下一次 schedule (next 被 schedule out) 时可以通过 now -
next-&gt;timestamp 得到 next 本次运行的时间 (run_time) 从而更新
next-&gt;sleep_avg -= run_time
</p>

<p>
对于 prev 来说, 分两种情况:
</p>

<ol class="org-ol">
<li>若 schedule 时 prev 是 sleeping 状态 (TASK_INTERRUPTIBLE 或
TASK_UNINTERRUPTIBLE), 则下一次 try_to_wake_up 时, 通过
prev-&gt;timestamp 可以得到 prev 本次 sleep 的时间</li>

<li>若 schedule 时 prev 是 running 状态 (TASK_RUNNING), 则显然
prev-&gt;timestamp 并不能用来计算 sleep 时间, 但没有关系, 因为后面
prev 并不会被 try_to_wake_up, 因为它还是 TASK_RUNNING, 并没有被放在任何 waitqueue 里</li>
</ol>

<p>
recalc_task_prio 负责 sleep_avg 的增加, 而 schedule 负责 sleep_avg 的减小, 最终 sleep_avg 是 sleeping 与 running 时间的差, 近似于 1s 内的平均睡眠时间 (证明?)
</p>
</div>
</div>

<div id="outline-container-org0000023" class="outline-4">
<h4 id="org0000023"><span class="section-number-4">1.3.3.</span> schedule</h4>
<div class="outline-text-4" id="text-1-3-3">
<div class="org-src-container">
<pre class="src src-c"><span class="org-constant">schedule</span>:
  prev = current;
  rq = this_rq();
  <span class="org-comment-delimiter">// </span><span class="org-comment">schedule &#21482;&#20250;&#20174; active &#20013;&#21462;&#36827;&#31243;</span>
  array = rq-&gt;active;
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>array-&gt;nr_active):
    <span class="org-comment-delimiter">// </span><span class="org-comment">Switch the active and expired arrays.</span>
    rq-&gt;active = rq-&gt;expired;
    rq-&gt;expired = array;
    array = rq-&gt;active;
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#19977;&#34892;&#20195;&#30721;&#21487;&#20197;&#24120;&#25968;&#26102;&#38388;&#20869;&#36873;&#25321; active &#20013;&#19968;&#20010;&#21160;&#24577;&#20248;&#20808;&#32423;&#26368;&#39640;&#30340;&#38142;&#34920;, &#25152;&#20197;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#31216;&#20026; O(1) schedule</span>
  idx = sched_find_first_bit(array-&gt;bitmap);
  queue = array-&gt;queue + idx;
  next = list_entry(queue-&gt;next, task_t, run_list);
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>rt_task(next):
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110; conventional task, &#30452;&#25509;&#31227;&#21160;&#21040; active &#38431;&#23614;, &#22312;&#36825;&#19968;&#28857;&#19978;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">SCHED_FIFO &#21450; SCHED_RR &#19982;&#23427;&#19981;&#21516;: &#23545;&#20110; rt_task, &#21482;&#26377;&#20027;&#21160; yield &#25165;&#20250;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#23548;&#33268;&#23427;&#34987;&#25918;&#22312;&#38431;&#23614;, &#34987;&#25250;&#21344;&#24182;&#19981;&#20250;&#23558;&#23427;&#25918;&#22312;&#38431;&#23614;</span>
    array = next-&gt;array;
    <span class="org-function-name">dequeue_task</span>(next, array);
    <span class="org-function-name">enqueue_task</span>(next, array);

  <span class="org-comment-delimiter">// </span><span class="org-comment">sleep_avg &#30456;&#20851;</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">task_struct-&gt;timestamp &#26159;&#25351; task &#26368;&#36817;&#19968;&#27425;&#34987;&#35843;&#24230;&#30340;&#26102;&#38388; (schedule in</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#25110; out), &#25152;&#20197; run_time &#26159; prev &#26412;&#27425;&#36816;&#34892;&#30340;&#26102;&#38388;</span>
  run_time = now - prev-&gt;timestamp;
  prev-&gt;sleep_avg -= run_time;
  prev-&gt;timestamp = next-&gt;timestamp = now;
  <span class="org-comment-delimiter">// </span><span class="org-comment">switch !</span>
  <span class="org-function-name">prepare_arch_switch</span>(rq, next);
  prev = context_switch(rq, prev, next);
</pre>
</div>

<p>
可见, schedule 函数本身与 scheduler 关系不大, 它只是固定的从 active 中取一个优先级最高的进程来调度, 所以若当前存在 real time process, 由于
real time process 的优先级必然比 conventional process 高, 极有可能导致
conventional process 的 starvation.
</p>

<p>
不同 scheduler 会以不同的方式影响进程在 active 和 expired 中的位置, 从而影响 schedule, 具体参考 <a href="#org0000029">各种 scheduler</a>
</p>
</div>
</div>

<div id="outline-container-org000002c" class="outline-4">
<h4 id="org000002c"><span class="section-number-4">1.3.4.</span> set_tsk_need_resched</h4>
<div class="outline-text-4" id="text-1-3-4">
<p>
除了主动调用 schedule, kernel 还可以通过 set_tsk_need_resched 给当前
task 做个标记 TIF_NEED_RESCHED, 当 kernel 需要返回到 user mode 时 (从
system_call 或 interrupt, execetpion 返回到 user mode), 如果发现 task
的 TIF_NEED_RESCHED 置位, 则会调用 schedule, 实现用户进程的抢占 (user
preemption, 具体参考 interrupt).
</p>

<p>
常见的进程被抢占的场景:
</p>

<ol class="org-ol">
<li>scheduler_tick 时发现当前 task 的 time_slice 耗尽</li>

<li>try_to_wake_up 时被唤醒的 task 的优先级比当前 rq-&gt;curr 更高</li>

<li>通过 nice 或 sched_setscheduler 调整降低了当前 task 优先级或提高了另一个 task 的优先级</li>

<li>load_balance 时 busiest CPU 的某个更高优先级的 task 被迁移到当前 CPU</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org0000029" class="outline-3">
<h3 id="org0000029"><span class="section-number-3">1.4.</span> 各种 scheduler</h3>
<div class="outline-text-3" id="text-1-4">
<p>
各种 scheduler 并没有抽象成单独的实体, 所有 scheduler 的逻辑都散布在相应的函数中, 例如 scheduler_tick, recalc_task_prio, schedule,
effective_prio, task_timeslice, set_user_nice, sys_sched_yield 等
</p>
</div>

<div id="outline-container-org0000032" class="outline-4">
<h4 id="org0000032"><span class="section-number-4">1.4.1.</span> SCHED_FIFO</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
SCHED_FIFO 是 real time scheduler, 它的主要特征有:
</p>

<ol class="org-ol">
<li>完全不考虑 time slice</li>

<li>sched_yield 会导致它被移动到相应链表的队尾</li>

<li>只有下面三种情况下它的执行才会被打断:

<ol class="org-ol">
<li>被高优先级的进程抢占</li>

<li>被 IO 阻塞</li>

<li>sched_yield</li>
</ol></li>

<li>当它被高优先级进程抢占后, 仍然会位于链表的队头</li>

<li>它的 prio (动态优先级) 是固定的, 与 static_prio 和 sleep_avg 并没有关系</li>
</ol>
</div>
</div>

<div id="outline-container-org0000035" class="outline-4">
<h4 id="org0000035"><span class="section-number-4">1.4.2.</span> SCHED_RR</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
SCHED_RR 也是一种 real time scheduler, 在 SCHED_FIFO 上加入了
roundrobin, 避免一个进程长时间占用 CPU 导致同优先级的其它进程无法被调度. 当它运行时间超过 time_slice 时, 会被调度出去并移动到链表的队尾.
</p>

<p>
SCHED_RR 时间片长度与普通进程一样, 都是基于 static_prio
(task_timeslice 函数), 所以对于 SCHED_RR 来说, 通过 nice 虽然不能调整它的 prio, 却可以通过调整它的 static_prio 来调整 time_slice 的大小
</p>
</div>
</div>

<div id="outline-container-org0000038" class="outline-4">
<h4 id="org0000038"><span class="section-number-4">1.4.3.</span> SCHED_NORMAL</h4>
<div class="outline-text-4" id="text-1-4-3">
<p>
SCHED_NORMAL 是 conventional (非 real time) 进程使用的 scheduler, 它的主要特征:
</p>

<ol class="org-ol">
<li>它的动态优先级低于 real time process, 所以它有可能因为 real time 进程而 starving</li>

<li>与 SCHED_RR 一样, 它是基于 roundrobin 的, 而且 time_slice 长度也是由 static_prio 决定的</li>

<li>它通过 sleep_avg 和 static_prio 来调整 prio, sleep_avg 越大, prio
越高</li>

<li>通过 sleep_avg 检测进程是否是 interactive, 对于 interactive 进程,
当它 time_slice 耗尽时, 会被再次放到 active 相应链表的队尾, 而对于
batch 进程, 会被放到 expired 中, 通过这种方式使 interactive 进程更多的执行, 但为了防止 expired 中的进程发生 starvation, interactive
进程有时也会被直接放在 expired 中 (参考 scheduler_tick)</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org000004a" class="outline-3">
<h3 id="org000004a"><span class="section-number-3">1.5.</span> CPU 负载均衡</h3>
<div class="outline-text-3" id="text-1-5">
<p>
在 O(1) scheduler 之前 (O(n) scheduler), 所有 CPU 共享同一个 runqueue,
</p>

<p>
这样的优点是:
</p>

<ol class="org-ol">
<li>可以充分利用所有 CPU</li>

<li>所有进程都可以公平的使用所有 CPU</li>
</ol>

<p>
但也存在缺点:
</p>

<ol class="org-ol">
<li>多个 CPU 在使用同一个 runqueue 时会有 contention</li>

<li>cache locality 很差, 因为共享 runqueue 会导致进程频繁在不同的 CPU
中迁移</li>
</ol>

<p>
因此 O(1) 针对每个 CPU 都有一个 runqueue, CPU 只会从它自己的 runqueue
中取 task 执行, 虽然克服了前面的缺点, 但前面的优点也成为它的缺点: 有可能某个 CPU 的 task 很多, 而有些 CPU 很空闲, 导致 CPU 吞吐率下降, 而且
task 无法公平的调度. 所以 O(1) scheduler 加入了 CPU 负载均衡 (load
balance): 将多核的负载平衡一下, 避免有些 CPU 过忙或过闲.
</p>

<p>
load balance 主要有两种:
</p>

<ol class="org-ol">
<li>pull task</li>

<li>migrate(push) task</li>
</ol>
</div>

<div id="outline-container-org0000041" class="outline-4">
<h4 id="org0000041"><span class="section-number-4">1.5.1.</span> pull task</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
pull task 即 "把其它更忙的 cpu 的 task 拉到当前 cpu 执行", 在
scheduler_tick 时会通过 load_balance 实现 pull task
</p>
</div>

<div id="outline-container-org000003b" class="outline-5">
<h5 id="org000003b"><span class="section-number-5">1.5.1.1.</span> load_balance</h5>
<div class="outline-text-5" id="text-1-5-1-1">
<div class="org-src-container">
<pre class="src src-c"><span class="org-constant">scheduler_tick</span>:
  <span class="org-function-name">rebalance_tick</span>(cpu, rq, NOT_IDLE);
    this_load = this_rq-&gt;nr_running * SCHED_LOAD_SCALE;
    this_rq-&gt;cpu_load = (old_load + this_load) / 2;
    interval = sd-&gt;balance_interval;
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36890;&#36807; interval &#38480;&#21046; load_balance &#30340;&#39057;&#29575;</span>
    <span class="org-keyword">if</span> (j - sd-&gt;last_balance &gt;= interval):
      sd-&gt;last_balance += interval;
      <span class="org-function-name">load_balance</span>(this_cpu, this_rq, sd, idle)
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#26681;&#25454; loading (nr_running) &#25214;&#19968;&#20010;&#26368;&#32321;&#24537;&#30340; cpu</span>
        busiest = find_busiest_queue(group);
        <span class="org-function-name">move_tasks</span>(this_rq, this_cpu, busiest,imbalance, sd, idle);
          <span class="org-comment-delimiter">// </span><span class="org-comment">&#20248;&#20808;&#20174; expired &#20013;&#36873;&#25321;</span>
          <span class="org-keyword">if</span> (busiest-&gt;expired-&gt;nr_active):
            array = busiest-&gt;expired;
            dst_array = this_rq-&gt;expired;
          <span class="org-keyword">else</span>:
            array = busiest-&gt;active;
            dst_array = this_rq-&gt;active;
          <span class="org-constant">LOOP</span>:
          <span class="org-comment-delimiter">// </span><span class="org-comment">&#25214;&#21040; busiest &#20013;&#30340;&#19968;&#20010; task</span>
          idx = find_next_bit(array-&gt;bitmap, MAX_PRIO, idx);
          head = array-&gt;queue + idx;
          curr = head-&gt;prev;
          tmp = list_entry(curr, task_t, run_list);
          <span class="org-comment-delimiter">// </span><span class="org-comment">&#21028;&#26029; tmp &#26159;&#21542;&#21487;&#20197;&#20174; busiest &#36801;&#31227;&#21040; this_cpu</span>
          <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>can_migrate_task(tmp, busiest, this_cpu, sd, idle)):
            <span class="org-keyword">goto</span> <span class="org-constant">LOOP</span>
          <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174; busiest &#36801;&#31227;&#21040; this_cpu</span>
          pull_task(busiest, src_array, tmp, this_rq, dst_array, this_cpu);
            <span class="org-function-name">dequeue_task</span>(tmp, src_array);
            src_rq-&gt;nr_running--;
            this_rq-&gt;nr_running++;
            <span class="org-function-name">enqueue_task</span>(tmp, dst_array);
            <span class="org-comment-delimiter">// </span><span class="org-comment">&#33509;&#36801;&#31227;&#21040; this_rq &#30340;&#36827;&#31243;&#30340;&#20248;&#20808;&#32423;&#39640;&#20110; this_rq-&gt;curr, &#21017;&#36890;&#36807;</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">resched_task &#25250;&#21344; this_rq-&gt;curr</span>
            <span class="org-keyword">if</span> (TASK_PREEMPTS_CURR(p, this_rq)):
              resched_task(this_rq-&gt;curr);
</pre>
</div>
</div>
</div>

<div id="outline-container-org000003e" class="outline-5">
<h5 id="org000003e"><span class="section-number-5">1.5.1.2.</span> can_migrate_task</h5>
<div class="outline-text-5" id="text-1-5-1-2">
<div class="org-src-container">
<pre class="src src-c"><span class="org-constant">can_migrate_task</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#19977;&#31181;&#24773;&#20917;&#19979; migrate &#20250;&#22833;&#36133;:</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">1. p &#26159; busiest-&gt;current, &#21363;&#23427;&#27491;&#22312; busiest &#19978;&#36816;&#34892;, &#26174;&#28982;&#26080;&#27861;&#34987;</span>
  <span class="org-comment-delimiter">//    </span><span class="org-comment">migrate</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">2. p-&gt;cpus_allowed &#19981;&#21253;&#25324; this_cpu (&#36890;&#36807; sched_setaffinity &#35774;&#32622;&#30340;)</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">3. task_hot, &#21363; (now - p-&gt;last_ran) &#23567;&#20110;&#26576;&#20010;&#38376;&#38480;, &#35828;&#26126; task &#26368;&#36817;&#36816;&#34892;</span>
  <span class="org-comment-delimiter">//    </span><span class="org-comment">&#36807;, cache is hot, &#24212;&#35813;&#36991;&#20813; migrate</span>
  <span class="org-keyword">if</span> (task_running(rq, p)):
    <span class="org-keyword">return</span> 0;
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>cpu_isset(this_cpu, p-&gt;cpus_allowed)):
    <span class="org-keyword">return</span> 0;
  <span class="org-keyword">if</span> (task_hot(p, rq-&gt;timestamp_last_tick, sd)):
    <span class="org-keyword">return</span> 0;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org0000047" class="outline-4">
<h4 id="org0000047"><span class="section-number-4">1.5.2.</span> push task</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
push task 即 "将 task push 到空闲的 cpu 去执行", 一个例子就是 do_execve 时的 sched_exec
</p>
</div>

<div id="outline-container-org0000044" class="outline-5">
<h5 id="org0000044"><span class="section-number-5">1.5.2.1.</span> sched_exec</h5>
<div class="outline-text-5" id="text-1-5-2-1">
<div class="org-src-container">
<pre class="src src-c"><span class="org-constant">do_execve</span>:
  <span class="org-function-name">sched_exec</span>();
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069; cpu &#24050;&#32463;&#24456;&#31354;&#38386;, &#19981;&#20877; push</span>
    <span class="org-keyword">if</span> (this_rq()-&gt;nr_running &lt;= 1):
      <span class="org-keyword">goto</span> <span class="org-constant">out</span>;
    new_cpu = find_idlest_cpu(current, this_cpu, sd);
    <span class="org-function-name">sched_migrate_task</span>(current, new_cpu);
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#38656;&#35201;&#32771;&#34385; affinity</span>
      <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>cpu_isset(dest_cpu, p-&gt;cpus_allowed):
        <span class="org-keyword">goto</span> <span class="org-constant">out</span>;
      <span class="org-comment-delimiter">// </span><span class="org-comment">migrate_task &#20250;&#21796;&#37266; migrate_thread &#21435;&#23436;&#25104; task &#30340;&#36801;&#31227;</span>
      <span class="org-function-name">migrate_task</span>(p, dest_cpu, &amp;req)
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org000005f" class="outline-3">
<h3 id="org000005f"><span class="section-number-3">1.6.</span> 相关 API</h3>
<div class="outline-text-3" id="text-1-6">
</div>
<div id="outline-container-org000004d" class="outline-4">
<h4 id="org000004d"><span class="section-number-4">1.6.1.</span> nice</h4>
<div class="outline-text-4" id="text-1-6-1">
<div class="org-src-container">
<pre class="src src-c"><span class="org-constant">set_user_nice</span>:
  <span class="org-keyword">if</span> (rt_task(p)):
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110; rt_task, static_prio &#20063;&#20250;&#34987; nice &#20462;&#25913;, &#22240;&#20026;&#35745;&#31639; time_slice</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36827;&#38656;&#35201;&#29992;&#21040;.</span>
    p-&gt;static_prio = NICE_TO_PRIO(nice);
    <span class="org-keyword">goto</span> <span class="org-constant">out</span>;

  array = p-&gt;array;
  <span class="org-keyword">if</span> (array):
    dequeue_task(p, array);

  old_prio = p-&gt;prio;
  new_prio = NICE_TO_PRIO(nice);
  delta = new_prio - old_prio;
  p-&gt;static_prio = NICE_TO_PRIO(nice);
  p-&gt;prio += delta;

  <span class="org-keyword">if</span> (array):
    enqueue_task(p, array);
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#35201;&#25552;&#39640;&#26576;&#20010; task &#30340;&#20248;&#20808;&#32423;, &#25110;&#32773;&#35201;&#38477;&#20302;&#24403;&#21069; task &#30340;&#20248;&#20808;&#32423;, &#21017;&#36890;&#36807;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">resched_task &#35843;&#29992; scheduler, &#23454;&#29616; task &#30340;&#25250;&#21344;</span>
    <span class="org-keyword">if</span> (delta &lt; 0 || (delta &gt; 0 &amp;&amp; task_running(rq, p))):
      resched_task(rq-&gt;curr);
</pre>
</div>
</div>
</div>

<div id="outline-container-org0000050" class="outline-4">
<h4 id="org0000050"><span class="section-number-4">1.6.2.</span> sched_yield</h4>
<div class="outline-text-4" id="text-1-6-2">
<div class="org-src-container">
<pre class="src src-c"><span class="org-constant">sys_sched_yield</span>:
  <span class="org-type">runqueue_t</span> *<span class="org-variable-name">rq</span> = this_rq_lock();
  <span class="org-type">prio_array_t</span> *<span class="org-variable-name">array</span> = current-&gt;array;
  <span class="org-type">prio_array_t</span> *<span class="org-variable-name">target</span> = rq-&gt;expired;
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110; rt_task &#26469;&#35828;, yield &#24182;&#19981;&#20250;&#23558; task &#31227;&#21160;&#21040; expired, &#32780;&#20165;&#20165;&#26159;&#31227;&#21160;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#21040; active &#30340;&#38431;&#23614;</span>
  <span class="org-keyword">if</span> (rt_task(current)):
    target = rq-&gt;active;

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110; rt_task &#26469;&#35828;, &#36890;&#36807; dequeue_task &#21644; enqueue_task &#23558; task &#31227;&#21160;&#21040;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">active &#38431;&#23614;, &#23545;&#20110; conventional task &#26469;&#35828;, &#23558; task &#20174; active &#31227;&#21160;&#21040;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">expired.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20294;&#30475;&#36215;&#26469; task &#30340; time_slice &#24182;&#27809;&#26377;&#36890;&#36807; task_timeslice &#36827;&#20837;&#34917;&#20805;, &#25152;&#20197;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23427;&#23558;&#34987; schedule &#26102;&#36824;&#20250;&#20351;&#29992;&#26087;&#30340; time_slice?</span>
  <span class="org-function-name">dequeue_task</span>(current, array);
  <span class="org-function-name">enqueue_task</span>(current, target);

  <span class="org-function-name">schedule</span>();
</pre>
</div>
</div>
</div>

<div id="outline-container-org0000053" class="outline-4">
<h4 id="org0000053"><span class="section-number-4">1.6.3.</span> sched_setscheduler</h4>
</div>

<div id="outline-container-org0000056" class="outline-4">
<h4 id="org0000056"><span class="section-number-4">1.6.4.</span> sched_setaffinity</h4>
</div>

<div id="outline-container-org0000059" class="outline-4">
<h4 id="org0000059"><span class="section-number-4">1.6.5.</span> fork</h4>
<div class="outline-text-4" id="text-1-6-5">
<div class="org-src-container">
<pre class="src src-c"><span class="org-constant">fork</span>:
  <span class="org-function-name">sched_fork</span>(p)
    p-&gt;state = TASK_RUNNING;
    p-&gt;array = <span class="org-constant">NULL</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#29238;&#23376;&#36827;&#31243;&#30340; time_slice &#37117;&#21464;&#20026;&#29238;&#36827;&#31243;&#30340;&#19968;&#21322;</span>
    p-&gt;time_slice = (current-&gt;time_slice + 1) &gt;&gt; 1;
    current-&gt;time_slice &gt;&gt;= 1;
  <span class="org-function-name">wake_up_new_task</span>(p)
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#35745;&#31639;&#21160;&#24577;&#20248;&#20808;&#32423;, &#23545;&#20110; conventional process, prio &#30001; static_prio &#21644;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">sleep_avg &#20915;&#23450;, &#23545;&#20110; real time process, prio &#19981;&#20250;&#20877;&#34987;&#20462;&#25913;, &#30452;&#25509;&#20351;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#29992; parent fork &#20986;&#26469;&#30340; prio</span>
    p-&gt;prio = effective_prio(p);
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>(clone_flags &amp; CLONE_VM)):
      <span class="org-comment-delimiter">// </span><span class="org-comment">CLONE_VM &#27809;&#26377;&#32622;&#20301;, &#20808;&#35843;&#24230;&#23376;&#36827;&#31243;&#25191;&#34892;, &#22240;&#20026;&#26377;&#21487;&#33021;&#23376;&#36827;&#31243;&#20250;&#30452;&#25509;&#35843;&#29992;</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">exec. &#36890;&#36807;&#35753;&#23376;&#36827;&#31243;&#20808;&#25191;&#34892; exec, &#21487;&#20197;&#36991;&#20813;&#29238;&#36827;&#31243;&#20889;&#20869;&#23384;&#26102;&#23548;&#33268;&#30340; COW,</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524; CLONE_VM &#32622;&#20301;, &#21017;&#19981;&#20250;&#21457;&#29983; COW, &#20248;&#20808;&#35753;&#29238;&#36827;&#31243;&#25191;&#34892;</span>
      p-&gt;prio = current-&gt;prio;
      list_add_tail(&amp;p-&gt;run_list, &amp;current-&gt;run_list);
      p-&gt;array = current-&gt;array;
      <span class="org-comment-delimiter">// </span><span class="org-comment">"&#35753;&#23376;&#36827;&#31243;&#20808;&#25191;&#34892;"&#26159;&#36890;&#36807;&#20004;&#28857;&#20570;&#21040;&#30340;:</span>
      <span class="org-comment-delimiter">//</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">1. &#36890;&#36807; list_add_tail (&#32780;&#19981;&#26159;&#36890;&#24120;&#30340; enqueue_task) &#23558; p &#28155;&#21152;&#21040;</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">active &#38142;&#34920;&#20013;, &#20294;&#20301;&#20110; current &#20043;&#21069;</span>
      <span class="org-comment-delimiter">//</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">2. set_need_resched &#20250;&#20351; current &#36827;&#31243;&#36820;&#22238;&#21040; user mode &#21069;&#21457;&#29983;</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">schedule, &#30001;&#20110; p &#19978;&#19968;&#27493;&#24050;&#32463;&#22312;&#38142;&#34920;&#20013; current &#20043;&#21069;, &#25152;&#20197;&#23427;&#26497;&#26377;&#21487;&#33021;</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#22312; schedule &#34987;&#36873;&#20013;, &#20294;&#21363;&#20351;&#27809;&#26377;&#36873;&#20013; p, &#20063;&#21487;&#20197;&#20445;&#35777; p &#32943;&#23450;&#22312;</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">current &#20043;&#21069;&#34987;&#35843;&#24230;</span>
      <span class="org-function-name">set_need_resched</span>();
    <span class="org-keyword">else</span>:
      enqueue_task(p, rq-&gt;active);
      rq-&gt;nr_running++;
</pre>
</div>
</div>
</div>

<div id="outline-container-org000005c" class="outline-4">
<h4 id="org000005c"><span class="section-number-4">1.6.6.</span> See also</h4>
<div class="outline-text-4" id="text-1-6-6">
<ol class="org-ol">
<li><a href="https://en.wikipedia.org/wiki/O(1)_scheduler">O(1) scheduler from Wikipedia</a></li>

<li><a href="http://www.informit.com/articles/article.aspx?p=101760&amp;seqNum=2">The Linux Process Scheduler By Robet Love</a></li>

<li><a href="https://www.ibm.com/developerworks/cn/linux/kernel/l-kn26sch/">Linux 2.6 调度系统分析 from IBM developerWorks</a></li>

<li><a href="http://www.cs.columbia.edu/~junfeng/10sp-w4118/lectures/l14-sched-linux.pdf">Scheduling in Linux from cs.columbia.edu</a></li>

<li>sched-design.txt from kernel documentation</li>
</ol>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
时钟中断是每 (1/HZ) s 一次, HZ 一般为 1000, 所以时钟中断为 1ms
一次
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">

<p class="author">Author: <a href="mailto:sunway@dogdog.run">sunway@dogdog.run</a><br />
Date: 2016-07-14 Thu 00:00<br />
Last updated: 2024-09-01 Sun 21:20</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
</div>
</body>
</html>
