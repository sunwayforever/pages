<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-01-25 二 15:54 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Linux Kernel: Memory</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wei Sun (孙伟)" />
<link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
<link rel = "icon" href = "/icon.png"  type = "image/x-icon">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">Linux Kernel: Memory</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org19e7e9b">1. Linux Kernel: Memory</a>
<ul>
<li><a href="#orgdc42fe8">1.1. 内存定址</a>
<ul>
<li><a href="#org0692f35">1.1.1. 分段</a></li>
<li><a href="#org1e4ba2f">1.1.2. 分页</a></li>
</ul>
</li>
<li><a href="#orgd7b63fe">1.2. 内存管理</a>
<ul>
<li><a href="#org237ce19">1.2.1. Page Descriptor</a></li>
<li><a href="#orgc7246ee">1.2.2. Memory Zones</a></li>
<li><a href="#orgd2eba43">1.2.3. Zone Allocator</a></li>
<li><a href="#org86aff85">1.2.4. Physical Mapping</a></li>
<li><a href="#org234e2a0">1.2.5. Mapping High memory</a></li>
<li><a href="#org7856d2c">1.2.6. Buddy System</a></li>
<li><a href="#orgb60fdc8">1.2.7. Slab Allocator</a></li>
<li><a href="#orgf89e667">1.2.8. vmalloc</a></li>
<li><a href="#org28f6186">1.2.9. Bootmem Allocator</a></li>
</ul>
</li>
<li><a href="#orgd5bb960">1.3. 进程地址空间</a>
<ul>
<li><a href="#orgdee8521">1.3.1. mm_struct</a></li>
<li><a href="#org5795af7">1.3.2. Memory Region</a></li>
<li><a href="#org5c6a68b">1.3.3. Page Fault</a></li>
<li><a href="#org4a10846">1.3.4. Creating Process Address Space</a></li>
<li><a href="#orgc30e680">1.3.5. Managing the Heap</a></li>
<li><a href="#org296b1aa">1.3.6. API</a></li>
</ul>
</li>
<li><a href="#org7dbe60e">1.4. 页面回收</a>
<ul>
<li><a href="#orgf064367">1.4.1. Overview</a></li>
<li><a href="#org6b99493">1.4.2. 反向映射</a></li>
<li><a href="#org253fb07">1.4.3. PFRA 的实现</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org19e7e9b" class="outline-2">
<h2 id="org19e7e9b"><span class="section-number-2">1</span> Linux Kernel: Memory</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgdc42fe8" class="outline-3">
<h3 id="orgdc42fe8"><span class="section-number-3">1.1</span> 内存定址</h3>
<div class="outline-text-3" id="text-1-1">
<p>
内存定址 (memory addressing) 是指如何实现虚拟地址与物理地址的转换. 
</p>
</div>

<div id="outline-container-org0692f35" class="outline-4">
<h4 id="org0692f35"><span class="section-number-4">1.1.1</span> 分段</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
分段 (segmentation) 是早期 x86 采用的内存定址方式
</p>
</div>

<div id="outline-container-orga4a5828" class="outline-5">
<h5 id="orga4a5828"><span class="section-number-5">1.1.1.1</span> 实模式</h5>
<div class="outline-text-5" id="text-1-1-1-1">
<p>
实模式 (real mode) 下, 各个段寄存器保存的是段基址
</p>
</div>
</div>

<div id="outline-container-org8e8ff2e" class="outline-5">
<h5 id="org8e8ff2e"><span class="section-number-5">1.1.1.2</span> 保护模式</h5>
<div class="outline-text-5" id="text-1-1-1-2">
<p>
在保护模式 (protected mode) 下, 各个段寄存器中保存的不再是段的基址: 每个段寄存器共 16
位<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> , 其中高 13 位是一个索引, 指向 GDT (Global Descriptor Table)
或 LDT (Local Descriptor Table) 表中的某一项 segment descriptor.
</p>

<p>
对于 cs 寄存器, 它的低两位称为 CPL (Current Privilege Level), cs 的
CPL 位始终与 CPU 当时的 privilege level (ring) 是一致的(参考 ). 若当前处于 kernel mode, 则 CPU 为 ring 0, cs 的 CPL 也为 0, 若当前处于 user mode, 则 CPU 的 ring 和 cs 的 CPL 都为 3
</p>

<p>
保护模式与实模式的切换是通过 cr0 寄存器来完成, 显然这个切换模式的指令在保护模式下必须在 ring 0 时才能进行
</p>
</div>
</div>

<div id="outline-container-org150f3bd" class="outline-5">
<h5 id="org150f3bd"><span class="section-number-5">1.1.1.3</span> 段描述符</h5>
<div class="outline-text-5" id="text-1-1-1-3">
<p>
每个段描述符 (segment descriptor) 大小为 8 bytes, 它主要的结构:
</p>

<ol class="org-ol">
<li><p>
base
</p>

<p>
32 bit 的段基址
</p></li>

<li><p>
limit
</p>

<p>
20 bit 的 limit
</p></li>

<li><p>
G
</p>

<p>
1 bit 的 granularity 标记, 若 clear, 则上面的 limit 单位为 byte, limit 最大可以表示 1MB, 若 set, 则 limit 单位为 4K, limit 最大表示 4G
</p></li>

<li><p>
DPL
</p>

<p>
2 bit 的 descriptor privilege level, 它的作用在后面的 <a href="#org1c5df02">memory 的保护</a>
部分会描述
</p></li>
</ol>

<p>
对 linux 来说, 所有的 segment descriptor:
</p>

<ol class="org-ol">
<li>base 都是 0</li>

<li>G 都置位</li>

<li>limit 都为 0xfffff</li>
</ol>

<p>
所以 logical address (最原始的地址) 与 linear address (被 segment unit
映射过的地址) 是一样的, 所以对 linux 来说, 使用 segmentation 主要的用处是实现 segmentation protection
</p>
</div>
</div>

<div id="outline-container-org5a0907b" class="outline-5">
<h5 id="org5a0907b"><span class="section-number-5">1.1.1.4</span> 基于分段的保护</h5>
<div class="outline-text-5" id="text-1-1-1-4">
<p>
基于分段的保护 (segmentation protection), 主要是指基于 CPL, DPL 的保护,
主要有几方面:
</p>
</div>

<ol class="org-ol">
<li><a id="org1c5df02"></a>memory 的保护<br />
<div class="outline-text-6" id="text-1-1-1-4-1">
<p>
由于 linux 主要依赖 paging 来保护内存, 所以 segmentation 对内存的保护不好体现. 假设存在某种依赖 segmentation 保护内存的 OS, 它的 gtd 表中有几个 segment descriptor, 其中 segment A 通过 base+limit 指定了一个内存区域是设计给 user space 使用的 (DPL = 3), segment B 指定了另一个内存区域给 kernel 使用 (DPL = 0)
</p>

<p>
假设 user space 的进程想非法访问 segment B 指定的那块内存区域, 则它可能会通过 mov 指令修改 ss 或 ds 的值, 使 ss 或 ds 指定 segment B, 但由于 segmentation protection 的存在, 这个指令并不能成功: CPU 会在执行 mov
时会检测于 cs 的 CPL (3) 大于 segment B 的 DPL (0), 从而触发 exception.
</p>

<p>
似乎有一个问题: user space 直接在 GDT 里加一项 DPL 为 3 的 segment
descriptor 不就可以通过个 segment 访问任意内存了么? GDT 所在的内存区域显然不是 ring 3 可以访问的&#x2026;
</p>
</div>
</li>

<li><a id="orgbfc6cb4"></a>指令的保护<br />
<div class="outline-text-6" id="text-1-1-1-4-2">
<p>
有些指令限制了只有 ring 0 才可以使用, 或者限制了只有 ring 0 才能在某些指令中使用特定的操作数.
</p>

<p>
例如, cr0 寄存器的值关系到是否开启 segmentation 和 paging, 以及实模式与保护模式的切换, 所以 mov 指令想修改 cr0 时需要是 ring 0 才行.
</p>
</div>
</li>

<li><a id="org02e9cbb"></a>interrupt 处理<br />
<div class="outline-text-6" id="text-1-1-1-4-3">
<p>
interrupt, trap, syscall 都是通过同一个 idt (中断向量表) 处理的, 例如
page fault 这个 interrupt 在 idt_table 中对应的 index 为 14, 那么 ring
3 是否可以通过 int 14 来模拟一个 page fault?
</p>

<p>
显然不可以, CPU 在执行 int 指令时, 会检查 CPL 与 interrupt descriptor
的 DPL 是否一致. 实际上, 在 idt_table 中, 只有 system gate
(set_system_gate, 0x80) 和 system interrupt gate
(set_system_intr_gate, 0x3) 两项可以被 ring 3 的 int 指令调用
</p>

<p>
因为 int 指令可以指定任意 idt index, 所以每个 int 指令都需要去检查 CPL
与 DPL. 但 int 通常都是用来实现 syscall 的, x86 又提供两个不需要检查
DPL 的 `int 0x80` 指令: sysenter, syscall (参考 )
</p>
</div>
</li>

<li><a id="org5eedef7"></a>See also<br />
<div class="outline-text-6" id="text-1-1-1-4-4">
<p>
<a href="http://duartes.org/gustavo/blog/post/cpu-rings-privilege-and-protection/">CPU-rings-privilege-and-protection</a>
</p>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org1e4ba2f" class="outline-4">
<h4 id="org1e4ba2f"><span class="section-number-4">1.1.2</span> 分页</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
分页 (paging) 是另一种内存定址的方式, 由于它功能更强, 已经代替了上面提到的分段的方式, 但如前面 <a href="#org8e8ff2e">保护模式</a> 所述, linux 还是会使用分段提供的保护模式等和安全相关的功能. 但是不会使用分段机制提供的地址翻译相关的功能
(例如所有段描述符中的 base 都为 0)
</p>
</div>

<div id="outline-container-org1be9b22" class="outline-5">
<h5 id="org1be9b22"><span class="section-number-5">1.1.2.1</span> Overview</h5>
<div class="outline-text-5" id="text-1-1-2-1">
<p>
Paging unit 的作用:
</p>

<ol class="org-ol">
<li>将 linear address 映射为 physical address</li>

<li>检查是否有权限访问 linear address<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup></li>
</ol>

<p>
paging unit 将物理内存划分为连续的定长 (一般为 4K) 的 page frame (或者叫 physical page). page frame 就是一块固定大小的连续物理内存.
</p>

<p>
与 page frame 对应的是 page 结构体 (struct page), struct page 是一个结构体, 与 page frame (已分配的) 有一一对应关系. struct page 本身, 做为一个变量, 必定是保存在某个 page frame 中, 但这个 page frame 与 struct
page "管理" 的那个 page frame 并没有任何关系
</p>
</div>
</div>

<div id="outline-container-org3dd97ee" class="outline-5">
<h5 id="org3dd97ee"><span class="section-number-5">1.1.2.2</span> Paging</h5>
<div class="outline-text-5" id="text-1-1-2-2">
<p>
i386 使用 cr3 保存 Page Directory Table 的物理地址.
</p>

<p>
i386 的 linear address 为 32 位, page frame 大小为 4K (12 位).
</p>

<p>
32 位的 linear address 的高 10 位做为 page directory 中的 index, 因为
page directory 本身占用一个 page frame (4K), 每个 page directory entry
占用 4B (32 位物理地址), 所以一个 page directory 刚好能存放 1024
(2^10) 个 PTE. 这里 page directory 划分为 10 位, 根本的原因是 4K 的 page frame, 每个 entry 大小为 32 位, 最多只能容纳 2^10 个
entry
</p>

<p>
后 10 位做为 page table 中的 index
</p>

<p>
使用前 20 定位到 page table 中的某一个 page frame 的地址后, 加上剩下的
12 位就是最终的物理地址.
</p>


<div id="orgc40bfcc" class="figure">
<p><img src="../extra/kernel_paging.png" alt="kernel_paging.png" />
</p>
</div>

<p>
由于 page frame 的地址是 4K 对齐的, 所以 page directory entry 和 page
table entry 只需要 20 位就可以表示, 但 page directory entry 和 page
table entry 都是用 32 位表示, 所以它们的低 12 位实际是空闲的, 可以用来表示一些和 page frame 相关的的额外信息, 比如权限. 这 12 位空闲比特构成了 page directory/table entry 的 flag
</p>
</div>
</div>

<div id="outline-container-org1c9286d" class="outline-5">
<h5 id="org1c9286d"><span class="section-number-5">1.1.2.3</span> page directory/table entry 的 flag</h5>
<div class="outline-text-5" id="text-1-1-2-3">
<ol class="org-ol">
<li><p>
Present
</p>

<p>
表示 page entry 是否映射了一个 page frame. 若进行地址转换时解析到某个 entry 的 Present 为 0, 则会触发 Page Fault.
</p></li>

<li><p>
Accessed
</p>

<p>
Paging unit 每次进行地址转换时都会将涉及到的 page frame 的 Accessed
置位. kernel 会读取这些标记, 比如选择 page frame 进行 swapped out
的动作时. 另外, CPU 只负责置位, 不会主动对它们复位, kernel 会负责进行复位
</p></li>

<li><p>
Dirty
</p>

<p>
与 Accessed 类似, 但只针对 PTE. CPU 每次对 page frame 的写操作都会将相应的 PTE 的 Dirty 置位
</p></li>

<li><p>
Read/Write
</p>

<p>
是否可读或可读写. 若 flag 为 0, 表示可读, flag 为 1, 表示可读写
</p></li>

<li><p>
User/Supervisor
</p>

<p>
privilege level require to access the page frame, 若 flag 为 0, 则类似于 DPL 为 0, 若 flag 为 1, 则相当于 DPL 为 3
</p></li>
</ol>
</div>
</div>

<div id="outline-container-org144d084" class="outline-5">
<h5 id="org144d084"><span class="section-number-5">1.1.2.4</span> Process page table 初始化</h5>
<div class="outline-text-5" id="text-1-1-2-4">
<p>
一般情况下每个进程有不同的页表, 即 PGD (Page Global Directory) 不同<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup>, 这个页表的 0~0xc0000000(3GB) 的部分是 user space 可以访问的,
0xc0000000~0xffffffff 是只有 kernel 可以访问<sup><a id="fnr.4" class="footref" href="#fn.4">4</a></sup>
</p>

<p>
进程页表是 fork 时分配的, 并且会复制父进程的页表
</p>
</div>

<ol class="org-ol">
<li><a id="org55194c8"></a>do_fork<br />
<div class="outline-text-6" id="text-1-1-2-4-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">do_fork</span>:
  <span style="color: #268bd2;">copy_process</span><span style="color: #757575;">()</span>
    <span style="color: #268bd2;">copy_mm</span><span style="color: #757575;">()</span>
      <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>clone_flags &amp; CLONE_VM<span style="color: #757575;">)</span>:
        tsk-&gt;mm = oldmm;
        <span style="color: #859900;">return</span>
      mm = allocate_mm<span style="color: #757575;">()</span>;
      <span style="color: #268bd2;">memcpy</span><span style="color: #757575;">(</span><span style="color: #b58900;">mm</span><span style="color: #757575;">,</span> <span style="color: #b58900;">oldmm</span><span style="color: #757575;">,</span> <span style="color: #859900;">sizeof</span><span style="color: #757575;">(</span>*mm<span style="color: #757575;">))</span>;
      <span style="color: #268bd2;">mm_init</span><span style="color: #757575;">()</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">1. &#20998;&#37197; pgd</span>
        <span style="color: #268bd2;">mm_alloc_pgd</span><span style="color: #757575;">()</span>
      <span style="color: #268bd2;">dup_mmap</span><span style="color: #757575;">(</span><span style="color: #b58900;">mm</span><span style="color: #757575;">,</span> <span style="color: #b58900;">oldmm</span><span style="color: #757575;">)</span>;
        <span style="color: #586e75;">// </span><span style="color: #586e75;">2. &#22797;&#21046;&#29238;&#36827;&#31243;&#39029;&#34920;</span>
        <span style="color: #268bd2;">copy_page_range</span><span style="color: #757575;">(</span><span style="color: #b58900;">mm</span><span style="color: #757575;">,</span> current-&gt;mm<span style="color: #757575;">,</span> <span style="color: #b58900;">tmp</span><span style="color: #757575;">)</span>;
          copy_pud_range
            copy_pmd_range
              copy_pte_range
                <span style="color: #b58900;">copy_one_pte</span>
      <span style="color: #268bd2;">tsk</span>-&gt;mm = mm;
</pre>
</div>

<p>
需要注意的是, dump_mmap 复制由 vma 控制的区域的页表项, 即 3G 以下的部分, 3G 以上的部分的复制由 mm_alloc_pgd 间接完成 <a href="#orgf7eb715">Kernel page table 与
process page table 的同步</a>
</p>
</div>
</li>

<li><a id="orga5f43ed"></a>Copy On Write<br />
<div class="outline-text-6" id="text-1-1-2-4-2">
<p>
copy_one_pte 只是复制 PTE: 新旧两个 pte 值相同, 指向同一个 page frame, copy_one_pte 会处理 COW 的情况
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">copy_one_pte</span>:
  <span style="color: #859900;">if</span> <span style="color: #757575;">((</span>vm_flags &amp; <span style="color: #757575;">(</span>VM_SHARED | VM_MAYWRITE<span style="color: #757575;">))</span> == VM_MAYWRITE<span style="color: #757575;">)</span>:
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#29238;&#36827;&#31243;&#30340; pte &#37117;&#35774;&#20026;&#21482;&#35835;&#24182;&#22797;&#21046;&#21040;&#23376;&#36827;&#31243;&#30340;&#39029;&#34920;, &#21518;&#32493;&#20219;&#20309;&#19968;&#26041;&#20462;&#25913;</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#30456;&#24212;&#30340; page frame, &#37117;&#20250;&#35302;&#21457; page fault</span>
      ptep_set_wrprotect<span style="color: #757575;">(</span>src_pte<span style="color: #757575;">)</span>;

<span style="color: #268bd2; font-weight: bold;">do_page_fault</span>:
  vma = find_vma<span style="color: #757575;">(</span>mm<span style="color: #757575;">,</span> address<span style="color: #757575;">)</span>;
  <span style="color: #859900;">switch</span> <span style="color: #757575;">(</span>error_code &amp; 3<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">3 &#34920;&#31034;&#20889;&#25805;&#20316;, &#19988; pte &#26159; present</span>
    <span style="color: #859900;">case</span> 3:
        <span style="color: #586e75;">// </span><span style="color: #586e75;">&#34920;&#31034; fault address &#23545;&#24212;&#30340; vma &#26377;&#20889;&#26435;&#38480;</span>
        <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>vma-&gt;vm_flags &amp; VM_WRITE<span style="color: #757575;">)</span>:
          write = 1;
        <span style="color: #859900;">break</span>
  handle_mm_fault<span style="color: #757575;">(</span>mm<span style="color: #757575;">,</span> vma<span style="color: #757575;">,</span> address<span style="color: #757575;">,</span> write<span style="color: #757575;">)</span>
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>write_access &amp;&amp; pte_present<span style="color: #757575;">(</span>entry<span style="color: #757575;">))</span>:
      <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>pte_write<span style="color: #757575;">(</span>entry<span style="color: #757575;">))</span>:
        <span style="color: #586e75;">// </span><span style="color: #586e75;">wp &#25351; write-protected</span>
        do_wp_page<span style="color: #757575;">(</span>mm<span style="color: #757575;">,</span> vma<span style="color: #757575;">,</span> address<span style="color: #757575;">,</span> pte<span style="color: #757575;">,</span> pmd<span style="color: #757575;">,</span> entry<span style="color: #757575;">)</span>;
          <span style="color: #586e75;">// </span><span style="color: #586e75;">&#33509; page count &#20026; 1,  &#23558; pte &#35774;&#20026;&#20889;&#21487;, &#20197;&#20415;&#20849;&#20139; pte &#30340;&#26368;&#21518;&#19968;&#20010;&#36827;&#31243;&#19981;&#20250;&#20877; page fault</span>
          reuse = can_share_swap_page<span style="color: #757575;">(</span>old_page<span style="color: #757575;">)</span>
          <span style="color: #859900;">if</span> reuse:
            pte_mkwrite<span style="color: #757575;">(</span>pte<span style="color: #757575;">)</span>;
          <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20998;&#37197;&#19968;&#20010;&#26032;&#30340; page &#24182;&#22797;&#21046;&#26087;&#30340; page</span>
          new_page = alloc_page_vma<span style="color: #757575;">(</span>GFP_HIGHUSER<span style="color: #757575;">,</span> vma<span style="color: #757575;">,</span> address<span style="color: #757575;">)</span>;
          copy_user_highpage<span style="color: #757575;">(</span>new_page<span style="color: #757575;">,</span> old_page<span style="color: #757575;">,</span> address<span style="color: #757575;">)</span>;
          break_cow<span style="color: #757575;">(</span>vma<span style="color: #757575;">,</span> new_page<span style="color: #757575;">,</span> address<span style="color: #757575;">,</span> page_table<span style="color: #757575;">)</span>;
          entry = maybe_mkwrite<span style="color: #757575;">(</span>pte_mkdirty<span style="color: #757575;">(</span>mk_pte<span style="color: #757575;">(</span>new_page<span style="color: #757575;">,</span> vma-&gt;vm_page_prot<span style="color: #757575;">)),</span>
                                vma<span style="color: #757575;">)</span>;
          ptep_establish<span style="color: #757575;">(</span>vma<span style="color: #757575;">,</span> address<span style="color: #757575;">,</span> page_table<span style="color: #757575;">,</span> entry<span style="color: #757575;">)</span>;
            <span style="color: #586e75;">// </span><span style="color: #586e75;">&#35774;&#32622;&#26032;&#30340;&#39029;&#34920;</span>
            set_pte_atomic<span style="color: #757575;">(</span>__ptep<span style="color: #757575;">,</span> __entry<span style="color: #757575;">)</span>;
</pre>
</div>

<p>
父子两个进程的页表的 pte 都设为只读, 后续任何一方修改相应的 page
frame, 都会触发 page fault, 从而分配新的 page frame
</p>
</div>
</li>
</ol>
</div>

<div id="outline-container-orgec17751" class="outline-5">
<h5 id="orgec17751"><span class="section-number-5">1.1.2.5</span> Kernel page table 初始化</h5>
<div class="outline-text-5" id="text-1-1-2-5">
<p>
kernel page table 是 kernel 使用的 page table, 这个 table 的地址保存在
swapper_pg_dir (linear address) 中.
</p>

<p>
kernel 页表的布局大约是这样的:
</p>

<div class="org-src-container">
<pre class="src src-ditaa">
0                              3G      3G+896M                            4095M 4G
+------------------------------+-----------+-----------+-------------+-------+--+
|                              | physical  |  vmalloc  | perm kmaps  | fixed |  |
+------------------------------+-----------+-----------+-------------+-------+--+
                                  896M         ~124M         4M        ~100 K

</pre>
</div>


<div id="orgd927687" class="figure">
<p><img src="../extra/kernel_address_space.png" alt="kernel_address_space.png" />
</p>
</div>
</div>

<ol class="org-ol">
<li><a id="orgc6e13c0"></a>pagetable_init<br />
<div class="outline-text-6" id="text-1-1-2-5-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">paging_init</span>:
  <span style="color: #268bd2;">pagetable_init</span><span style="color: #757575;">()</span>;
  <span style="color: #268bd2;">load_cr3</span><span style="color: #757575;">(</span><span style="color: #b58900;">swapper_pg_dir</span><span style="color: #757575;">)</span>;
    <span style="color: #859900;">asm</span> <span style="color: #859900;">volatile</span><span style="color: #757575;">(</span><span style="color: #2aa198;">"movl %0,%%cr3"</span>: :<span style="color: #2aa198;">"r"</span> <span style="color: #757575;">(</span>__pa<span style="color: #757575;">(</span>pgdir<span style="color: #757575;">)))</span>
  <span style="color: #268bd2;">kmap_init</span><span style="color: #757575;">()</span>;

<span style="color: #268bd2; font-weight: bold;">pagetable_init</span>:
  <span style="color: #b58900;">pgd_t</span> *<span style="color: #268bd2;">pgd_base</span> = swapper_pg_dir;
  <span style="color: #586e75;">// </span><span style="color: #586e75;">1. &#21069; 896M &#29289;&#29702;&#20869;&#23384;&#30452;&#25509;&#26144;&#23556;&#20110; 3G~3G+896M &#30340;&#34394;&#25311;&#22320;&#22336;</span>
  <span style="color: #268bd2;">kernel_physical_mapping_init</span><span style="color: #757575;">(</span><span style="color: #b58900;">pgd_base</span><span style="color: #757575;">)</span>;
  <span style="color: #586e75;">// </span><span style="color: #586e75;">2. fixed_addresses &#37096;&#20998;&#30340;&#26144;&#23556;, &#36825;&#37096;&#20998;&#26144;&#23556;&#30340;&#34394;&#25311;&#22320;&#22336;&#33539;&#22260;&#26159; 4095M &#20043;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#21069;&#30340;&#20960;&#21313;&#20010; page, &#36825;&#37324;&#30340; vaddr &#23454;&#38469;&#23601;&#26159; 4095M, &#36825;&#37324;&#30475;&#36215;&#26469;&#25351;&#23450;&#30340;&#26159;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#19968;&#20010;&#32467;&#26463;&#22320;&#22336;&#32780;&#38750;&#36215;&#22987;&#22320;&#22336;? &#23454;&#38469;&#19978;, &#21518;&#38754;&#30340; page_table_range_init &#35201;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#26681;&#25454; vaddr &#25805;&#20316;&#30456;&#24212;&#30340; PGD entry, 4092M~4096M &#33539;&#22260;&#37117;&#33853;&#22312;&#21516;&#19968;&#20010; PGD</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">entry &#19978;</span>
  vaddr = __fix_to_virt<span style="color: #757575;">(</span>__end_of_fixed_addresses - 1<span style="color: #757575;">)</span> &amp; PMD_MASK;
  <span style="color: #586e75;">// </span><span style="color: #586e75;">pagetable_init &#21482;&#36127;&#36131;&#21021;&#22987;&#21270;&#30456;&#24212;&#30340; page table: page table &#20013; PTE &#30340;&#20540;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#30001;&#21518;&#32493;&#30340; set_fixmap &#21450; kmap_atomic &#35774;&#32622;</span>
  <span style="color: #268bd2;">page_table_range_init</span><span style="color: #757575;">(</span><span style="color: #b58900;">vaddr</span><span style="color: #757575;">,</span> 0<span style="color: #757575;">,</span> <span style="color: #b58900;">pgd_base</span><span style="color: #757575;">)</span>;
  <span style="color: #586e75;">// </span><span style="color: #586e75;">3. KMAP &#37096;&#20998;&#30340;&#26144;&#23556;</span>
  <span style="color: #268bd2;">permanent_kmaps_init</span><span style="color: #757575;">(</span><span style="color: #b58900;">pgd_base</span><span style="color: #757575;">)</span>;
</pre>
</div>
</div>
</li>

<li><a id="orgb0b559c"></a>kernel_physical_mapping_init<br />
<div class="outline-text-6" id="text-1-1-2-5-2">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">kernel_physical_mapping_init</span>:
  <span style="color: #586e75;">// </span><span style="color: #586e75;">PAGE_OFFSET &#20026; 0xc0000000 pgd_index &#20026; 0xc0000000 &#23545;&#24212;&#30340; pgd &#20013;&#30340;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#32034;&#24341;, &#21363; 768</span>
  pgd_idx = pgd_index<span style="color: #757575;">(</span>PAGE_OFFSET<span style="color: #757575;">)</span>;
  pgd = pgd_base + pgd_idx;
  pfn = 0;
  <span style="color: #586e75;">// </span><span style="color: #586e75;">PTRS_PER_PGD &#20026; 1024</span>
  <span style="color: #859900;">for</span> <span style="color: #757575;">(</span>; pgd_idx &lt; PTRS_PER_PGD; pgd++<span style="color: #757575;">,</span> pgd_idx++<span style="color: #757575;">)</span>:
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20197; 32 bit paging (10-10-12 &#20004;&#32423;&#26144;&#23556;) &#20026;&#20363;, pmd &#19982; pgd &#26159;&#19968;&#26679;&#30340;,</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#19988; PTRS_PER_PMD &#20026; 1 , &#25152;&#20197;&#21518;&#38754;&#20004;&#34892;&#20195;&#30721;&#21487;&#20197;&#24573;&#30053;</span>
    <span style="color: #586e75;">/* </span><span style="color: #586e75;">pmd = one_md_table_init(pgd);</span><span style="color: #586e75;"> */</span>
    <span style="color: #586e75;">/* </span><span style="color: #586e75;">for (pmd_idx = 0; pmd_idx &lt; PTRS_PER_PMD &amp;&amp; pfn &lt; max_low_pfn; pmd++, pmd_idx++):</span><span style="color: #586e75;"> */</span>

    pte = one_page_table_init<span style="color: #757575;">(</span>pgd<span style="color: #757575;">)</span>;
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20998;&#37197;&#19968;&#20010; page table, &#24182;&#25554;&#20837;&#21040; PMD (&#23545;&#20110; 32 bit, &#23454;&#38469;&#23601;&#26159;&#25554;&#20837;&#21040; PGD) &#20013;&#30456;&#24212;&#30340;&#20301;&#32622;</span>
      <span style="color: #b58900;">pte_t</span> *<span style="color: #268bd2;">page_table</span> = <span style="color: #757575;">(</span><span style="color: #b58900;">pte_t</span> *<span style="color: #757575;">)</span> <span style="color: #268bd2;">alloc_bootmem_low_pages</span><span style="color: #757575;">(</span><span style="color: #b58900;">PAGE_SIZE</span><span style="color: #757575;">)</span>;
      <span style="color: #268bd2;">set_pmd</span><span style="color: #757575;">(</span><span style="color: #b58900;">pmd</span><span style="color: #757575;">,</span> __pmd<span style="color: #757575;">(</span><span style="color: #b58900;">__pa</span><span style="color: #757575;">(</span><span style="color: #268bd2;">page_table</span><span style="color: #757575;">)</span> | _PAGE_TABLE<span style="color: #757575;">))</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#23545; page table &#20013;&#27599;&#19968;&#39033;&#35774;&#32622;&#19968;&#20010; pte, PTRS_PER_PTE &#20026; 1024</span>
    <span style="color: #859900;">for</span> <span style="color: #757575;">(</span>pte_ofs = 0; pte_ofs &lt; PTRS_PER_PTE &amp;&amp; pfn &lt; max_low_pfn; pte++<span style="color: #757575;">,</span> pfn++<span style="color: #757575;">,</span> pte_ofs++<span style="color: #757575;">)</span>:
      set_pte<span style="color: #757575;">(</span>pte<span style="color: #757575;">,</span> pfn_pte<span style="color: #757575;">(</span>pfn<span style="color: #757575;">,</span> PAGE_KERNEL<span style="color: #757575;">))</span>;
                     <span style="color: #586e75;">// </span><span style="color: #586e75;">pfn &#26159; page frame number, pfn &#24038;&#31227; 12 &#20301;&#21363;&#26159;&#23427;</span>
                     <span style="color: #586e75;">// </span><span style="color: #586e75;">&#23545;&#24212;&#30340; page frame &#30340;&#29289;&#29702;&#22320;&#22336;</span>
                     <span style="color: #268bd2;">__pte</span><span style="color: #757575;">(((</span><span style="color: #b58900;">pfn</span><span style="color: #757575;">)</span> &lt;&lt; PAGE_SHIFT<span style="color: #757575;">)</span> | pgprot_val<span style="color: #757575;">(</span><span style="color: #b58900;">prot</span><span style="color: #757575;">))</span>

</pre>
</div>
</div>
</li>

<li><a id="org42b0e32"></a>page_table_range_init<br />
<div class="outline-text-6" id="text-1-1-2-5-3">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2;">page_table_range_init</span><span style="color: #757575;">(</span><span style="color: #b58900;">vaddr</span><span style="color: #757575;">,</span> <span style="color: #b58900;">end</span><span style="color: #757575;">,</span> <span style="color: #b58900;">pgd_base</span><span style="color: #757575;">)</span>;
  <span style="color: #586e75;">// </span><span style="color: #586e75;">page_table_range_init &#21482;&#36127;&#36131;&#21021;&#22987;&#21270; PGD &#20013;&#30456;&#24212;&#30340; page table, &#33267;&#20110;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">page table &#20013; PTE &#30340;&#36171;&#20540;&#23427;&#24182;&#19981;&#22788;&#29702;</span>
  pgd_idx = pgd_index<span style="color: #757575;">(</span>vaddr<span style="color: #757575;">)</span>;
  pgd = pgd_base + pgd_idx;
  <span style="color: #859900;">for</span> <span style="color: #757575;">(</span> ; <span style="color: #757575;">(</span>pgd_idx &lt; PTRS_PER_PGD<span style="color: #757575;">)</span> &amp;&amp; <span style="color: #757575;">(</span>vaddr != end<span style="color: #757575;">)</span>; pgd++<span style="color: #757575;">,</span> pgd_idx++<span style="color: #757575;">)</span>:
    one_page_table_init<span style="color: #757575;">(</span>pgd<span style="color: #757575;">)</span>;
    vaddr += 1&lt;&lt;22
</pre>
</div>
</div>
</li>

<li><a id="org801ed90"></a>permanent_kmaps_init<br />
<div class="outline-text-6" id="text-1-1-2-5-4">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2;">permanent_kmaps_init</span><span style="color: #757575;">(</span><span style="color: #b58900;">pgd_base</span><span style="color: #757575;">)</span>:
  <span style="color: #586e75;">// </span><span style="color: #586e75;">permanent_kmaps &#30340;&#34394;&#25311;&#22320;&#22336;&#33539;&#22260;&#26159; fixed_addresses &#21069;&#30340; 4MB &#30340;&#33539;&#22260;,</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#25152;&#20197; PKMAP_BASE &#22823;&#32422;&#26159; 4090M &#24038;&#21491;</span>
  vaddr = PKMAP_BASE;
  <span style="color: #268bd2;">page_table_range_init</span><span style="color: #757575;">(</span><span style="color: #b58900;">vaddr</span><span style="color: #757575;">,</span> vaddr + PAGE_SIZE*LAST_PKMAP<span style="color: #757575;">,</span> <span style="color: #b58900;">pgd_base</span><span style="color: #757575;">)</span>;
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-orgf7eb715" class="outline-5">
<h5 id="orgf7eb715"><span class="section-number-5">1.1.2.6</span> Kernel page table 与 process page table 的同步</h5>
<div class="outline-text-5" id="text-1-1-2-6">
<p>
kernel page table (swapper_pg_dir) 大部分情况<sup><a id="fnr.5" class="footref" href="#fn.5">5</a></sup>只是 process page table
的参考, 而不会被直接使用 (load 到 cr3). 在中断或 syscall 时, kernel
contrl path 都是使用被中断打断或发起 syscall 的进程的 process page table.
</p>

<p>
这是因为 syscall 时 kernel 通常需要访问进程自己的内存, 以 read 为例,
kernel 需要将读到的数据写入到进程自己的地址空间的某个 buffer 中去, 因为 kernel 需要同时能访问到 process 和 kernel 的页表, 所以实现的方法是:
发起 syscall 时 kernel 使用 process page table, 并且保证 process page
table 的 3G 以上的部分与 kernel page table 是一致的, 如何做到一致?
</p>
</div>

<ol class="org-ol">
<li><a id="org4901349"></a>固定映射的部分 (ZONE_DMA+ZONE_NORMAL)<br />
<div class="outline-text-6" id="text-1-1-2-6-1">
<p>
<a href="#org55194c8">do_fork</a> 时已经提到了 mm_alloc_pgd, 但这个函数并不是简单的分配一个 pgd:
</p>

<p>
mm_alloc_pgd 是通过 slab 去分配 pgd 的, 而 slab 支持在分配某个 object
时指定一个 ctor, 分配完这个 object 后 slab 会自动执行这个 ctor.
</p>

<p>
pgtable_cache_init 时指定了一个叫做 pgd_ctor 的函数:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">pgd_ctor</span>:
  <span style="color: #586e75;">// </span><span style="color: #586e75;">USER_PTRS_PER_PGD &#34920;&#31034; PGD &#34920;&#20013;&#30340; 1024 &#20010;&#34920;&#39033;&#26377;&#22810;&#23569;&#26144;&#23556;&#30340; 3G &#20197;&#19979;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#23454;&#38469;&#19978;&#22312; 32 &#20301;&#31995;&#32479;&#19978;&#36825;&#20010;&#20540;&#20026; 768 (1024 * 3 /4)</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#25152;&#20197;&#19979;&#38754;&#20004;&#34892;&#30340;&#20316;&#29992;&#26159;:</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">1. &#23558; pgd &#21069; 3g &#30340;&#37096;&#20998;&#32622; 0</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">2. &#23558; pgd &#21518; 1g &#30340;&#37096;&#20998;&#29992; swapper_pg_dir &#21518; 1g &#30340;&#25968;&#25454;&#35206;&#30422;</span>
  <span style="color: #268bd2;">memcpy</span><span style="color: #757575;">((</span><span style="color: #b58900;">pgd_t</span> *<span style="color: #757575;">)</span>pgd + USER_PTRS_PER_PGD<span style="color: #757575;">,</span>
       swapper_pg_dir + USER_PTRS_PER_PGD<span style="color: #757575;">,</span>
       <span style="color: #757575;">(</span>PTRS_PER_PGD - USER_PTRS_PER_PGD<span style="color: #757575;">)</span> * <span style="color: #859900;">sizeof</span><span style="color: #757575;">(</span><span style="color: #b58900;">pgd_t</span><span style="color: #757575;">))</span>;
  <span style="color: #268bd2;">memset</span><span style="color: #757575;">(</span><span style="color: #b58900;">pgd</span><span style="color: #757575;">,</span> 0<span style="color: #757575;">,</span> <span style="color: #b58900;">USER_PTRS_PER_PGD</span>*<span style="color: #859900;">sizeof</span><span style="color: #757575;">(</span><span style="color: #b58900;">pgd_t</span><span style="color: #757575;">))</span>;
</pre>
</div>

<p>
通过 pgd_ctor, 可以确保每个 process page table 3G~4G 的部分与
swapper_pg_dir 是一致的
</p>
</div>
</li>

<li><a id="org02d3c0d"></a>动态映射的部分 (ZONE_HIGHMEM)<br />
<div class="outline-text-6" id="text-1-1-2-6-2">
<p>
但 swapper_pg_dir 后面 1g 的部分并不是一直固定不变的, 3G~3G+896M 的部分是固定映射, 不会改变, 但 896M 之后的部分 (ZONE_HIGHMEM), 是通过 kmap
和 vmalloc 动态映射的, 前面通过 pgd_ctor 一次性的复制无法应对 kmap,
vmalloc 这种情况.
</p>

<p>
理论上, kmap/vmalloc 需要同时修改 kernel page table 和所有的 process
page table, 但实际上, kernel 采用了一种 lazy 的处理方式:
</p>

<p>
kmap/vmalloc 时 kernel 只修改 swapper_pg_dir, 当用户进程进入到 kernel
并需要访问这个区域上, 会发生 page fault, 因为 pgd entry 或 pt entry 为
null. 这时 do_page_fault 会检查 fault address 是否位于 swapper_pg_dir
的 kmap/vmalloc 区域 (vmalloc_fault), 如果是, 则根据 swapper_pg_dir 修改
process page table.
</p>

<p>
当 vfree 时, swapper_pg_dir 中相应的 PTE 被置 null, 这样后续通过 process page table 访问之前那个 kmap/vmalloc 区域时, 会再次发生 page fault, 但此时就不是 vmalloc_fault 了
</p>

<p>
参考 <a href="#orgea449ea">vmalloc_fault</a>
</p>
</div>
</li>
</ol>
</div>

<div id="outline-container-org11dcb33" class="outline-5">
<h5 id="org11dcb33"><span class="section-number-5">1.1.2.7</span> 页表的切换</h5>
</div>
</div>
</div>

<div id="outline-container-orgd7b63fe" class="outline-3">
<h3 id="orgd7b63fe"><span class="section-number-3">1.2</span> 内存管理</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-org237ce19" class="outline-4">
<h4 id="org237ce19"><span class="section-number-4">1.2.1</span> Page Descriptor</h4>
<div class="outline-text-4" id="text-1-2-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">page</span> <span style="color: #757575;">{</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">PG_dirty, PG_private, PG_uptodate &#31561;&#21478;&#22806;, page &#25152;&#23646;&#30340; zone &#20449;&#24687;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#25918;&#21253;&#21547;&#22312; flag &#20013; (memmap_init_zone)</span>
    <span style="color: #b58900;">page_flags_t</span> <span style="color: #268bd2;">flags</span>;
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span> <span style="color: #268bd2;">private</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">page &#19982; inode &#30340; page cache &#20851;&#32852;</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">address_space</span> *<span style="color: #268bd2;">mapping</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">page &#22312; mapping &#20013;&#30340; index</span>
    <span style="color: #b58900;">pgoff_t</span> <span style="color: #268bd2;">index</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">lru &#26681;&#25454; page &#30340;&#29366;&#24577;&#21644;&#29992;&#27861;&#26377;&#22810;&#31181;&#29992;&#36884;:</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">1. &#24403; page free &#26102;, &#21644; buddy system &#26377;&#20851; (zone-&gt;free_area)</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">2. &#24403; page &#29992;&#20570; slab &#30456;&#20851;&#26102;, &#21644; slab &#26377;&#20851;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">3. &#24403; page &#27491;&#22312;&#34987; user mode &#25110; page cache &#20351;&#29992;&#26102;,</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#21644; PFRA &#26377;&#20851; (zone-&gt;active_list, zone-&gt;inactive_list)</span>
    <span style="color: #586e75;">//</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">lru &#30340;&#21517;&#23383;&#21462;&#30340;&#26159;&#31532;&#19977;&#31181;&#24773;&#20917;</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">list_head</span> <span style="color: #268bd2;">lru</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">...</span>
<span style="color: #757575;">}</span>
</pre>
</div>

<p>
每个 page 结构体的大小为 32 字节, 而且每个 page 结构体与 4K 的 page
frame 有一一对应关系.
</p>
</div>

<div id="outline-container-orgb29bc9a" class="outline-5">
<h5 id="orgb29bc9a"><span class="section-number-5">1.2.1.1</span> mem_map</h5>
<div class="outline-text-5" id="text-1-2-1-1">
<p>
paging_init 时会针对每一个 page frame 都生成一个 page struct, 并会把这些 page struct 按 pfn 的顺序依次保存在 mem_map 数组中. 具体代码在
memmap_init_zone 中.
</p>

<p>
由于每个 page struct 大小为 32B, 所以 mem_map 本身会占用的物理内存大小不到总内存的 1% (32/4K)
</p>

<p>
由于 mem_map 数组的存在, pfn_to_page 与 page_to_pfn 的实现就非常直接了.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">pfn_to_page</span>:
  mem_map + <span style="color: #757575;">(</span>pfn<span style="color: #757575;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">page_to_pfn</span>:
  <span style="color: #757575;">(</span>page<span style="color: #757575;">)</span> - mem_map
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgc7246ee" class="outline-4">
<h4 id="orgc7246ee"><span class="section-number-4">1.2.2</span> Memory Zones</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
kernel 将所有物理内存分为三个 zone:
</p>

<ol class="org-ol">
<li><p>
ZONE_DMA
</p>

<p>
管理低于 16M 的 page frame
</p></li>

<li><p>
ZONE_NORMAL
</p>

<p>
管理 16M ~ 896M 的 page frame
</p></li>

<li><p>
ZONE_HIGHMEM
</p>

<p>
896M 以上的 page frame
</p></li>
</ol>

<p>
由于硬件的限制, 旧式 ISA 设备的 DMA 只能使用 ZONE_DMA 中的 page frame.
</p>

<p>
ZONE_DMA 和 ZONE_NORMAL 中的 page frame 可以被 physical mapping
</p>

<p>
ZONE_HIGHMEM 中的 page frame 无法被 physical mapping (<a href="#org234e2a0">Mapping High
memory</a> )
</p>

<ol class="org-ol">
<li><p>
Non-contiguous Mapping
</p>

<p>
vmalloc
</p></li>

<li><p>
Permanent Kmap
</p>

<p>
kmap
</p></li>

<li>Fixed Mapping

<ol class="org-ol">
<li>kmap_atomic</li>
<li>set_fixmap</li>
</ol></li>
</ol>
</div>
</div>

<div id="outline-container-orgd2eba43" class="outline-4">
<h4 id="orgd2eba43"><span class="section-number-4">1.2.3</span> Zone Allocator</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
所有的 page frame 最终都是通过 zone allocator 来分配, 通过 zone
allocator 可以分配多个物理连续的 page frame. zone allocator 可以根据情况 (GFP Mask 及各个 zone 剩余内存的情况) 选择在哪个 zone 中分配, 最后,
各个 zone 自己的 buddy allocator 会负责最终的分配.
</p>

<p>
分配 page frame 实际就是分配一个可用的 page struct, 因为 page struct
与 page frame 是一一对应的, 而且可能通过 pfn_to_page, page_to_pfn 方便的转换.
</p>

<p>
分配只是分配一个可用的 page struct, 一般这个 page struct 需要通过映射后才能使用, 根据 page struct 所属的 zone, 需要使用不同的映射方法来完成映射.
</p>
</div>

<div id="outline-container-org4ad9f35" class="outline-5">
<h5 id="org4ad9f35"><span class="section-number-5">1.2.3.1</span> 相关的分配函数</h5>
<div class="outline-text-5" id="text-1-2-3-1">
</div>
<ol class="org-ol">
<li><a id="orge6bbf99"></a>alloc_pages(gfp_mask, order)<br />
<div class="outline-text-6" id="text-1-2-3-1-1">
<p>
分配 2^order 个连续的 page frame, 返回第个 page struct 的地址.
gfp_mask 中的 gfp 代表 "get_free_page". Zone allocator 会根据 gfp_mask
选择合适的 zone 来分配
</p>

<p>
alloc_pages 主要逻辑:
</p>

<ol class="org-ol">
<li>判断各个 zone 内存的使用情况</li>

<li>根据各个 zone 的内存情况及 gfp_mask 选择合适的 zone 去分配内存

<ol class="org-ol">
<li>选择一个可用内存大于 zone-&gt;pages_low 的 zone 去分配, pages_low
的值是 pages_min * 5 / 4</li>

<li>若所有 zone 的可用内存都小于 zone-&gt;pages_low, 则唤醒 kswapd 异步的回收内存</li>

<li>选择一个可用内存大于 zone-&gt;pages_min 的 zone 去分配, pages_min 的值和 /proc/sys/vm/min_free_kbytes 有关</li>

<li>若所有 zone 的可用内存都小于 zone-&gt;pages_min, 则通过 try_to_free_pages 同步回收内存</li>
</ol></li>

<li>若所有 zone 都无法分配内存

<ol class="org-ol">
<li>out_of_memory 会通过 oom killer 杀掉某个 victim 进程以释放内存</li>
</ol></li>
</ol>

<p>
具体参考 <a href="#org7dbe60e">页面回收</a>
</p>
</div>
</li>

<li><a id="orgb1ad446"></a>alloc_page(gfp_mask)<br />
<div class="outline-text-6" id="text-1-2-3-1-2">
<p>
即 alloc_page(gfp_mask, 0)
</p>
</div>
</li>

<li><a id="org983d4a0"></a>__get_free_pages(gfp_mask, order)<br />
<div class="outline-text-6" id="text-1-2-3-1-3">
<p>
与 alloc_pages 类似, 但它将第一个 page struct 映射为线性地址后返回
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">__get_free_pages</span>:
  page = alloc_pages<span style="color: #757575;">(</span>gfp_mask<span style="color: #757575;">,</span> order<span style="color: #757575;">)</span>;
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>page<span style="color: #757575;">)</span>:
    <span style="color: #859900;">return</span> 0;
  <span style="color: #859900;">return</span>  page_address<span style="color: #757575;">(</span>page<span style="color: #757575;">)</span>;
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>PageHighMem<span style="color: #757575;">(</span>page<span style="color: #757575;">))</span>
      <span style="color: #859900;">return</span> lowmem_page_address<span style="color: #757575;">(</span>page<span style="color: #757575;">)</span>;
        <span style="color: #268bd2;">__va</span><span style="color: #757575;">(</span><span style="color: #b58900;">page_to_pfn</span><span style="color: #757575;">(</span><span style="color: #268bd2;">page</span><span style="color: #757575;">)</span> &lt;&lt; PAGE_SHIFT<span style="color: #757575;">)</span>;
    <span style="color: #859900;">else</span>:
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#26816;&#26597; page_address_map, &#30001;&#20110; page_address_map &#21482;&#19982; kmap &#26377;&#20851;,</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#25152;&#20197;&#22312; __get_free_pages &#26102;, page &#24182;&#27809;&#26377;&#20107;&#20808;&#36890;&#36807; kmap &#22312;</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">page_address_map &#26377;&#35760;&#24405;, &#25152;&#20197;&#36825;&#37324;&#24517;&#28982;&#20250;&#25214;&#19981;&#21040;, &#23548;&#33268;&#36820;&#22238;&#32447;&#24615;&#22320;</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#22336;&#20026; NULL, &#25152;&#20197; __get_free_pages &#19981;&#24212;&#35813;&#20351;&#29992; __GFP_HIGHMEM &#26469;</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20998;&#37197;</span>
</pre>
</div>
</div>
</li>
<li><a id="org723c3f6"></a>__get_free_page(gfp_mask)<br /></li>
</ol>
</div>

<div id="outline-container-orgee9f71a" class="outline-5">
<h5 id="orgee9f71a"><span class="section-number-5">1.2.3.2</span> GFP Mask</h5>
<div class="outline-text-5" id="text-1-2-3-2">
<ol class="org-ol">
<li><p>
__GFP_DMA
</p>

<p>
必须从 ZONE_DMA 分配
</p></li>

<li><p>
__GFP_HIGH
</p>

<p>
允许使用 zone 的 reserved page frames
</p></li>

<li><p>
__GFP_HIGHMEM
</p>

<p>
可以从 ZONE_HIGHMEM 分配
</p></li>

<li><p>
__GFP_WAIT
</p>

<p>
允许分配动作被阻塞以便等待释放内存
</p></li>

<li><p>
__GFP_IO
</p>

<p>
允许做 IO 以释放内存
</p></li>

<li><p>
GFP_KERNEL / GFP_USER
</p>

<p>
__GFP_WAIT | __GFP_IO | __GFP_F'S
</p>

<p>
即:
</p>

<ul class="org-ul">
<li>可以阻塞</li>
<li>可以做 IO 以释放内存</li>
<li>不可以使用 ZONE_HIGHMEM</li>
</ul></li>

<li><p>
GFP_HIGHUSER
</p>

<p>
GFP_USER | __GFP_HIGHMEM
</p></li>

<li><p>
GFP_ATOMIC
</p>

<p>
__GFP_HIGH
</p></li>
</ol>

<p>
在这些 GFP mask 中, __GFP_DMA 和 __GFP_HIGHMEM 会影响分配内存时选择
zone 的顺序:
</p>

<ol class="org-ol">
<li>若指定了 __GFP_DMA, 则只能从 ZONE_DMA 中分配</li>

<li>若指定了 __GFP_HIGHMEM, 则选择 zone 的顺序为 ZONE_HIGHMEM,
ZONE_NORMAL, ZONE_DMA</li>

<li>若没有指定 __GFP_HIGHMEM, 则选择的顺序为 ZONE_NORMAL, ZONE_DMA</li>
</ol>
</div>
</div>
</div>


<div id="outline-container-org86aff85" class="outline-4">
<h4 id="org86aff85"><span class="section-number-4">1.2.4</span> Physical Mapping</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
ZONE_DMA 和 ZONE_NORMAL 中的 page frame 可以通过 physical mapping 直接映射, 所谓 physical mapping, 是指 0~896M 范围的物理内存直接映射到
3G~3G+896M 的线性地址空间. 前面 <a href="#orgf7eb715">Kernel page table 与 process page
table 的同步</a> 及 <a href="#orgb0b559c">kernel_physical_mapping_init</a> 已经提到了这部分 mapping
建立的过程.
</p>

<p>
由于这部分映射是线性的, 所以可以方便的进行物理地址与线性地址的转换
</p>
</div>

<div id="outline-container-orgdbbb1e7" class="outline-5">
<h5 id="orgdbbb1e7"><span class="section-number-5">1.2.4.1</span> _va</h5>
<div class="outline-text-5" id="text-1-2-4-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2;">#define</span> <span style="color: #268bd2;">__va</span><span style="color: #757575;">(</span><span style="color: #268bd2;">x</span><span style="color: #757575;">)</span>         <span style="color: #757575;">((</span><span style="color: #b58900;">void</span> *<span style="color: #757575;">)((</span><span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span><span style="color: #757575;">)(</span>x<span style="color: #757575;">)</span>+PAGE_OFFSET<span style="color: #757575;">))</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org38964ba" class="outline-5">
<h5 id="org38964ba"><span class="section-number-5">1.2.4.2</span> _pa</h5>
<div class="outline-text-5" id="text-1-2-4-2">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2;">#define</span> <span style="color: #268bd2;">__pa</span><span style="color: #757575;">(</span><span style="color: #268bd2;">x</span><span style="color: #757575;">)</span>         <span style="color: #757575;">((</span><span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span><span style="color: #757575;">)(</span>x<span style="color: #757575;">)</span>-PAGE_OFFSET<span style="color: #757575;">)</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org234e2a0" class="outline-4">
<h4 id="org234e2a0"><span class="section-number-4">1.2.5</span> Mapping High memory</h4>
<div class="outline-text-4" id="text-1-2-5">
<p>
 ZONE_HIGHMEM 中的 page frame 无法被 physical mapping, 必须通过以下几种途径之一映射过才能访问:
</p>

<ol class="org-ol">
<li><p>
Non-contiguous Mapping
</p>

<p>
vmalloc
</p></li>

<li><p>
Permanent Kmap
</p>

<p>
kmap_high
</p></li>

<li>Fixed Mapping

<ol class="org-ol">
<li>kmap_atomic</li>
<li>set_fixmap</li>
</ol></li>
</ol>
</div>

<div id="outline-container-org53716ab" class="outline-5">
<h5 id="org53716ab"><span class="section-number-5">1.2.5.1</span> Permanent Kmap</h5>
<div class="outline-text-5" id="text-1-2-5-1">
<p>
Permanent Kmap 维护 kernel page map 中一段 page table 的映射,
LAST_PKMAP 决定了这段映射大小: 一般 LAST_PKMAP 为 1024, 则 Permanent
Kmap 刚好维护一个 PGD entry, 即 4M 虚拟地址范围
</p>

<p>
Permanent Kmap 内部维护一个数组 pkmap_count[LAST_PKMAP], 分配映射, 释放映射, 查找映射都是通过对这个数组的线程查找完成的.
</p>

<ol class="org-ol">
<li><p>
分配: kmap
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">kmap</span>:
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>PageHighMem<span style="color: #757575;">(</span>page<span style="color: #757575;">))</span>:
    <span style="color: #859900;">return</span> page_address<span style="color: #757575;">(</span>page<span style="color: #757575;">)</span>;
  <span style="color: #859900;">return</span> kmap_high<span style="color: #757575;">(</span>page<span style="color: #757575;">)</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#26597;&#25214;, &#30475;&#36825;&#20010; page &#20043;&#21069;&#26159;&#21542;&#24050;&#32463;&#26144;&#23556;&#36807;</span>
    vaddr = <span style="color: #757575;">(</span><span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span><span style="color: #757575;">)</span><span style="color: #268bd2;">page_address</span><span style="color: #757575;">(</span><span style="color: #b58900;">page</span><span style="color: #757575;">)</span>;
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>vaddr<span style="color: #757575;">)</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#30495;&#27491;&#30340;&#20998;&#37197;&#21160;&#20316;, &#26597;&#25214; pkmap_count &#20013;&#26576;&#19968;&#20010;&#31354;&#30340; slot</span>
      vaddr = map_new_virtual<span style="color: #757575;">(</span>page<span style="color: #757575;">)</span>;
    <span style="color: #b58900;">pkmap_count</span>[PKMAP_NR<span style="color: #757575;">(</span><span style="color: #b58900;">vaddr</span><span style="color: #757575;">)</span>]++;
    <span style="color: #859900;">return</span> vaddr

map_new_virtual:
 <span style="color: #859900;">for</span> <span style="color: #757575;">(</span>;;<span style="color: #757575;">)</span>:
   <span style="color: #586e75;">// </span><span style="color: #586e75;">&#25551;&#36848; pkmap_count &#20013;&#25152;&#26377;&#30340;&#39033;, &#25214;&#19968;&#20010; pkmap_count[x] &#20026; 0 &#30340;</span>
   last_pkmap_nr = <span style="color: #757575;">(</span>last_pkmap_nr + 1<span style="color: #757575;">)</span> &amp; LAST_PKMAP_MASK;
   <span style="color: #586e75;">// </span><span style="color: #586e75;">...</span>

  vaddr = PKMAP_ADDR<span style="color: #757575;">(</span>last_pkmap_nr<span style="color: #757575;">)</span>;
  <span style="color: #586e75;">// </span><span style="color: #586e75;">permanent_kmaps_init &#26102;&#23558; pkmap_page_table &#35774;&#32622;&#20102;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">swapper_pg_dir &#20013;&#23545;&#24212;&#30340;&#37096;&#20998;, &#25152;&#20197; kmap &#20462;&#25913;&#30340;&#26159; swapper_pg_dir         </span>
  set_pte<span style="color: #757575;">(</span>&amp;<span style="color: #757575;">(</span>pkmap_page_table[last_pkmap_nr]<span style="color: #757575;">),</span> mk_pte<span style="color: #757575;">(</span>page<span style="color: #757575;">,</span> kmap_prot<span style="color: #757575;">))</span>;
  <span style="color: #b58900;">pkmap_count</span>[last_pkmap_nr] = 1;
  <span style="color: #586e75;">// </span><span style="color: #586e75;">set_page_address &#20250;&#20462;&#25913; page_address_map &#36825;&#20010; list, &#35760;&#24405; page &#19982;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">vaddr &#30340;&#26144;&#23556;&#20851;&#31995;, &#21518;&#38754; page_address &#20250;&#20351;&#29992;&#23427;</span>
  <span style="color: #268bd2;">set_page_address</span><span style="color: #757575;">(</span><span style="color: #b58900;">page</span><span style="color: #757575;">,</span> <span style="color: #757575;">(</span><span style="color: #b58900;">void</span> *<span style="color: #757575;">)</span>vaddr<span style="color: #757575;">)</span>;
  <span style="color: #859900;">return</span> vaddr;
</pre>
</div></li>

<li><p>
释放: kunmap
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">kunmap</span>:
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>PageHighMem<span style="color: #757575;">(</span>page<span style="color: #757575;">))</span>:
    <span style="color: #859900;">return</span>;
  <span style="color: #268bd2;">kunmap_high</span><span style="color: #757575;">(</span><span style="color: #b58900;">page</span><span style="color: #757575;">)</span>;
    vaddr = <span style="color: #757575;">(</span><span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span><span style="color: #757575;">)</span><span style="color: #268bd2;">page_address</span><span style="color: #757575;">(</span><span style="color: #b58900;">page</span><span style="color: #757575;">)</span>;
    nr = PKMAP_NR<span style="color: #757575;">(</span>vaddr<span style="color: #757575;">)</span>;
    --pkmap_count[nr]
</pre>
</div></li>

<li><p>
查找: page_address
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">page_address</span>:
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>PageHighMem<span style="color: #757575;">(</span>page<span style="color: #757575;">))</span>
    <span style="color: #859900;">return</span> lowmem_page_address<span style="color: #757575;">(</span>page<span style="color: #757575;">)</span>;
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>list_empty<span style="color: #757575;">(</span>&amp;pas-&gt;lh<span style="color: #757575;">))</span>:
    <span style="color: #859900;">struct</span> page_address_map *pam;
    <span style="color: #268bd2;">list_for_each_entry</span><span style="color: #757575;">(</span><span style="color: #b58900;">pam</span><span style="color: #757575;">,</span> &amp;pas-&gt;lh<span style="color: #757575;">,</span> <span style="color: #b58900;">list</span><span style="color: #757575;">)</span>:
      <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>pam-&gt;page == page<span style="color: #757575;">)</span>:
        ret = pam-&gt;virtual;
        <span style="color: #859900;">goto</span> <span style="color: #268bd2; font-weight: bold;">done</span>;
</pre>
</div>

<p>
Permanent Kmap 支持通过 page 查找其线性地址, 主要的依靠
page_address_map, 之前 map_new_virtual 时会使用这个
page_address_map 记录 page 与 vaddr 的映射关系.
</p>

<p>
除了 Permanent Kmap 和 Physical Mapping, 其它的映射方式 (vmalloc,
fix mapping) 无法根据 page 直接查找到其 vaddr (当然通过遍历还是可以查到的&#x2026;)
</p></li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org7856d2c" class="outline-4">
<h4 id="org7856d2c"><span class="section-number-4">1.2.6</span> Buddy System</h4>
<div class="outline-text-4" id="text-1-2-6">
</div>
<div id="outline-container-orgf97ed82" class="outline-5">
<h5 id="orgf97ed82"><span class="section-number-5">1.2.6.1</span> Buddy system 的基本原理</h5>
<div class="outline-text-5" id="text-1-2-6-1">
<ol class="org-ol">
<li>buddy system 用来快速分配连续的 page frame</li>

<li>它的主要目的是减少外部碎片</li>

<li>每个 zone 都有一个 buddy system, 管理着这个 zone 所有的 page frame
(或者说 page struct)</li>

<li><p>
buddy system 将它管理的所有 page 分为 MAX_ORDER (0 ~ 10 共 11 ) 个
free_area, 每个 area 维护着一个链表, 链表中的每一项代表着 "连续的
2^n 个 page" 构成的 block,并且这个 block 的第一个 page 的 pfn 是
2^n 对齐的. 所以 buddy system 能分配的最大连续内存是 4M
</p>


<div id="org2dc4910" class="figure">
<p><img src="../extra/kernel_buddy_system.png" alt="kernel_buddy_system.png" />
</p>
</div></li>

<li>当需要分配连续 2^n 个 page 时, buddy system 会:

<ol class="org-ol">
<li>查看对应 area n 是否有空闲的 block</li>

<li>如果有则使用这个空闲的 block</li>

<li>否则, 查看 area n+1 是否有空闲的 block

<ol class="org-ol">
<li>如果有, 则将这个空闲 block 拆为两个 2^n 大小 的 block, 返回一个, 另一个加入到 area n.</li>

<li>如果 area n+1 也没有空闲的 block, 则查看 area n+2 &#x2026; 以此类推</li>
</ol></li>
</ol></li>

<li>当释放一个 block 时, 把这个 block 插入到相应的 area, 然后看这个
block 能否与前后的 block 合并, 合并的条件是:

<ol class="org-ol">
<li>两个 block 大小相等</li>

<li>两个 block 物理连续</li>

<li>第一个 block 的第一个 page 的 pfn 相对于合并后的 area n 是 2^n 对齐的</li>
</ol></li>
</ol>
</div>
</div>

<div id="outline-container-orgc658276" class="outline-5">
<h5 id="orgc658276"><span class="section-number-5">1.2.6.2</span> 相关数据结构</h5>
<div class="outline-text-5" id="text-1-2-6-2">
</div>
<ol class="org-ol">
<li><a id="orga084ee6"></a>zone<br />
<div class="outline-text-6" id="text-1-2-6-2-1">
<p>
struct zone 维护了许多和 buddy system 相关的信息
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">zone</span> <span style="color: #757575;">{</span>
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span>     <span style="color: #268bd2;">free_pages</span>;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">MAX_ORDER &#20026; 11, free_area[i] &#20195;&#34920;&#30340;&#26159;&#22823;&#23567;&#20026; 2^i &#30340; block &#30340;&#38598;&#21512;</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">free_area</span>  <span style="color: #268bd2;">free_area</span>[MAX_ORDER];

    <span style="color: #586e75;">// </span><span style="color: #586e75;">zone_mem_map &#26159; mem_map &#20013;&#19982; zone &#23545;&#24212;&#30340;&#30340;&#37096;&#20998;</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">page</span>      *<span style="color: #268bd2;">zone_mem_map</span>;
<span style="color: #757575;">}</span>
</pre>
</div>
</div>
</li>

<li><a id="orga8a5304"></a>free_area<br />
<div class="outline-text-6" id="text-1-2-6-2-2">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">free_area</span> <span style="color: #757575;">{</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">free_list &#26159;&#19968;&#20010;&#30001; page &#26500;&#25104;&#30340; list, list &#20013;&#30340; page &#26159;&#22823;&#23567;&#20026; 2^n</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#30340; block &#30340;&#31532;&#19968;&#20010; page</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">list_head</span>    <span style="color: #268bd2;">free_list</span>;

    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span>       <span style="color: #268bd2;">nr_free</span>;
<span style="color: #757575;">}</span>
</pre>
</div>
</div>
</li>

<li><a id="org0f0f335"></a>page<br />
<div class="outline-text-6" id="text-1-2-6-2-3">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">page</span> <span style="color: #757575;">{</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#19982; free_area &#20013;&#30340; free_list &#23545;&#24212;</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">list_head</span> <span style="color: #268bd2;">lru</span>;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">buddy system &#20013; block &#30340;&#31532;&#19968;&#20010; page &#36890;&#36807; private &#20445;&#23384;&#30528; block</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#23545;&#24212;&#30340; order.</span>
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span> <span style="color: #268bd2;">private</span>;
<span style="color: #757575;">}</span>
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org2784a05" class="outline-5">
<h5 id="org2784a05"><span class="section-number-5">1.2.6.3</span> Allocating a block</h5>
<div class="outline-text-5" id="text-1-2-6-3">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">page</span> *<span style="color: #268bd2;">__rmqueue</span><span style="color: #757575;">(</span><span style="color: #859900;">struct</span> <span style="color: #b58900;">zone</span> *<span style="color: #268bd2;">zone</span><span style="color: #757575;">,</span> <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">order</span><span style="color: #757575;">)</span>:
  <span style="color: #859900;">for</span> <span style="color: #757575;">(</span>current_order = order; current_order &lt; MAX_ORDER; ++current_order<span style="color: #757575;">)</span>:
    area = zone-&gt;free_area + current_order;
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>list_empty<span style="color: #757575;">(</span>&amp;area-&gt;free_list<span style="color: #757575;">))</span>
      <span style="color: #859900;">continue</span>;

    page = list_entry<span style="color: #757575;">(</span>area-&gt;free_list.next<span style="color: #757575;">,</span> <span style="color: #859900;">struct</span> <span style="color: #b58900;">page</span><span style="color: #757575;">,</span> lru<span style="color: #757575;">)</span>;
    list_del<span style="color: #757575;">(</span>&amp;page-&gt;lru<span style="color: #757575;">)</span>;
    <span style="color: #268bd2;">rmv_page_order</span><span style="color: #757575;">(</span><span style="color: #b58900;">page</span><span style="color: #757575;">)</span>;
    area-&gt;nr_free--;
    zone-&gt;free_pages -= 1UL &lt;&lt; order;
    <span style="color: #859900;">return</span> expand<span style="color: #757575;">(</span>zone<span style="color: #757575;">,</span> page<span style="color: #757575;">,</span> order<span style="color: #757575;">,</span> current_order<span style="color: #757575;">,</span> area<span style="color: #757575;">)</span>;


<span style="color: #859900;">static</span> <span style="color: #859900;">inline</span> <span style="color: #859900;">struct</span> <span style="color: #b58900;">page</span> *
<span style="color: #268bd2;">expand</span><span style="color: #757575;">(</span><span style="color: #859900;">struct</span> <span style="color: #b58900;">zone</span> *<span style="color: #268bd2;">zone</span><span style="color: #757575;">,</span> <span style="color: #859900;">struct</span> <span style="color: #b58900;">page</span> *<span style="color: #268bd2;">page</span><span style="color: #757575;">,</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">low</span><span style="color: #757575;">,</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">high</span><span style="color: #757575;">,</span> <span style="color: #859900;">struct</span> <span style="color: #b58900;">free_area</span> *<span style="color: #268bd2;">area</span><span style="color: #757575;">)</span>:
  <span style="color: #586e75;">// </span><span style="color: #586e75;">low &#34920;&#31034;&#26368;&#21021;&#30340;&#21407;&#22987; order, high &#25351;&#26368;&#32456;&#23454;&#38469;&#30340; order. expand &#30340;&#20316;&#29992;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#26159;&#23558; order &#20026; high &#30340; block &#25286;&#20998;, &#23558;&#22810;&#20313;&#30340;&#37096;&#20998;&#21512;&#24182;&#21040;&#20854;&#23427;&#30340; area &#20013;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#19979;&#38754;&#20551;&#35774; low = 0, high = 2, &#21363;&#35201;&#20998;&#37197; 1 &#20010; page, &#26368;&#32456;&#22312; free_area[2] &#20013;&#25214;&#21040;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#19968;&#20010; 4-page &#30340; block, expand &#30340;&#32467;&#26524;&#24212;&#35813;&#26159;:</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">1. &#25226;&#19968;&#20010; 1 page &#30340; block &#25554;&#20837; free_area[0]</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">2. &#25226;&#19968;&#20010; 2 page &#30340; block &#25554;&#20837; free_area[1]</span>

  <span style="color: #586e75;">// </span><span style="color: #586e75;">size = 1&lt;&lt;2 = 4, &#34920;&#31034;&#26368;&#21021;&#19968;&#20849;&#20998;&#37197;&#20102; 4 &#20010; page</span>
  <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span> size = 1 &lt;&lt; high;
  <span style="color: #859900;">while</span> <span style="color: #757575;">(</span>high &gt; low<span style="color: #757575;">)</span>:
    <span style="color: #586e75;">// </span><span style="color: #586e75;">area &#21021;&#22987;&#20026; area[2]</span>
    area--;
    high--;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#24490;&#29615;&#20004;&#27425;, &#31532;&#19968;&#27425; size &#20026; 2, &#21017; page[2] &#20195;&#34920;&#30340; block</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">(page[2],page[3]) &#34987;&#25554;&#20837;&#21040; area[1], &#31532;&#20108;&#27425; size &#20026; 1, &#21017;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">page[1] &#20195;&#34920;&#30340; block &#34987;&#25554;&#20837;&#21040; area[0]</span>
    size &gt;&gt;= 1;
    list_add<span style="color: #757575;">(</span>&amp;page[size].lru<span style="color: #757575;">,</span> &amp;area-&gt;free_list<span style="color: #757575;">)</span>;
    area-&gt;nr_free++;
    set_page_order<span style="color: #757575;">(</span>&amp;page[size]<span style="color: #757575;">,</span> high<span style="color: #757575;">)</span>;
      page-&gt;private = order;
  <span style="color: #859900;">return</span> page;

</pre>
</div>
</div>
</div>

<div id="outline-container-orga234561" class="outline-5">
<h5 id="orga234561"><span class="section-number-5">1.2.6.4</span> Freeing a block</h5>
<div class="outline-text-5" id="text-1-2-6-4">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #b58900;">void</span> <span style="color: #268bd2;">__free_pages_bulk</span> <span style="color: #757575;">(</span><span style="color: #859900;">struct</span> <span style="color: #b58900;">page</span> *<span style="color: #268bd2;">page</span><span style="color: #757575;">,</span> <span style="color: #859900;">struct</span> <span style="color: #b58900;">page</span> *<span style="color: #268bd2;">base</span><span style="color: #757575;">,</span><span style="color: #859900;">struct</span> <span style="color: #b58900;">zone</span> *<span style="color: #268bd2;">zone</span><span style="color: #757575;">,</span> <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">order</span><span style="color: #757575;">)</span>:
  <span style="color: #586e75;">// </span><span style="color: #586e75;">page &#26159;&#35201;&#37322;&#25918;&#30340; block &#30340;&#31532;&#19968;&#20010; page</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">base &#26159; zone &#30340; zone_mem_map</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">zone &#26159; block &#25152;&#23646;&#30340; zone</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">order &#26159; block &#30340; order</span>
  <span style="color: #586e75;">//</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20551;&#35774;&#35201;&#37322;&#25918;&#30340; block &#30340; order &#20026; 2, page_index &#20026; 8 (8 &#26159; 2^2 &#23545;&#40784;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#30340;), &#19988; page &#19982;&#21518;&#38754;&#19968;&#20010; block &#33021;&#21512;&#24182;&#20026;&#19968;&#20010; order &#20026; 3 &#30340; block, &#21518;&#38754;&#19968;&#20010; block</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#30340; page_index &#24212;&#35813;&#26159; 12</span>
  page_idx = page - base;
  zone-&gt;free_pages += 1&lt;&lt;order;
  <span style="color: #859900;">while</span> <span style="color: #757575;">(</span>order &lt; MAX_ORDER-1<span style="color: #757575;">)</span>:
    <span style="color: #859900;">struct</span> page *buddy;
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">buddy_idx</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">iter 1: buddy_index = 8 ^ 1&lt;&lt;2 = 12, ^ &#25805;&#20316;&#20250;&#25226; page_index +/-</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#19968;&#20010; 2^order &#22823;&#23567;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">iter 2: buddy_index = 8 ^ 1&lt;&lt;3 = 0, &#33509; page 0 &#20195;&#34920;&#19968;&#20010;&#31354;&#38386;&#30340; 3 &#38454; block, &#21017;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#36824;&#21487;&#20197;&#36827;&#19968;&#27493;&#21512;&#24182;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">iter 3: buddy_index = 0 ^ 1&lt;&lt;4 = 16, ...</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#36825;&#37324;&#30340;&#24322;&#25110;&#25805;&#20316;&#21644;&#23545;&#40784;&#30340;&#35201;&#27714;&#26377;&#20851;: &#24403;&#21069; block &#32943;&#23450;&#26159; 2^order &#23545;&#40784;&#30340;, &#22914;&#26524;&#21644;&#21518;&#38754;&#30340; block &#21512;&#24182;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#38656;&#35201;&#20445;&#35777;&#24403;&#21069; block &#20063;&#26159; 2^(order+1) &#23545;&#40784;&#30340;, &#22914;&#26524;&#21644;&#21069;&#19968;&#20010; block &#21512;&#24182;, &#38656;&#35201;&#20445;&#35777;&#21069;&#19968;&#20010; block &#26159;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">2^(order+1) &#23545;&#40784;&#30340;.</span>
    <span style="color: #586e75;">//</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#29992;&#35821;&#35328;&#25551;&#36848;&#36825;&#20010;&#21462; buddy_idx &#30340;&#25805;&#20316;:</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">1. page_index &#30340;&#20302; order &#20301;&#24517;&#28982; 0</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">2. &#33509; page_index &#30340;&#20302; order+1 &#20301;&#20063;&#26159; 0, &#21017;&#23427;&#24050;&#32463;&#26159; 2^(order+1) &#23545;&#40784;&#20102;,</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#25226; page_index &#21152;&#19978; 2^order &#24471;&#21040; buddy_idx</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">3. &#33509; page_index &#30340;&#20302; order+1 &#20301;&#26159; 1, &#21017;&#23427;&#26412;&#36523;&#26080;&#27861;&#19982; 2^(order+1)&#23545;&#40784;,</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#25226; page_index &#20943;&#21435; 2^order &#24471;&#20110; buddy_idx, &#21487;&#20197;&#30830;&#23450;&#36825;&#20010; buddy_idx</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#24517;&#28982;&#26159; 2^(order+1) &#23545;&#40784;&#30340;</span>
    <span style="color: #586e75;">//</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#19968;&#20010;&#24322;&#25110;&#25805;&#20316;&#23601;&#21487;&#20197;&#35299;&#20915;&#36825;&#20010;&#38382;&#39064;...</span>

    buddy_idx = <span style="color: #757575;">(</span>page_idx ^ <span style="color: #757575;">(</span>1 &lt;&lt; order<span style="color: #757575;">))</span>;
    buddy = base + buddy_idx;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">page_is_buddy &#34920;&#31034; page &#26159;&#21542;&#26159;&#19968;&#20010;&#31354;&#38386; block &#30340;&#36215;&#22987; page</span>
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>page_is_buddy<span style="color: #757575;">(</span>buddy<span style="color: #757575;">,</span> order<span style="color: #757575;">))</span>:
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#23558; buddy &#20174;&#21407;&#26469;&#30340; area &#21024;&#38500;</span>
      list_del<span style="color: #757575;">(</span>&amp;buddy-&gt;lru<span style="color: #757575;">)</span>;
      area = zone-&gt;free_area + order;
      area-&gt;nr_free--;
      <span style="color: #586e75;">// </span><span style="color: #586e75;">iter1: page_index = 8 &amp; 12 = 8</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">iter2: page_index = 8 &amp; 0 = 0</span>
      page_idx &amp;= buddy_idx;
      order++;
  <span style="color: #586e75;">// </span><span style="color: #586e75;">coalesced &#21644; order &#26159;&#26368;&#32456;&#21512;&#24182;&#30340;&#32467;&#26524;</span>
  coalesced = base + page_idx;
  <span style="color: #268bd2;">set_page_order</span><span style="color: #757575;">(</span><span style="color: #b58900;">coalesced</span><span style="color: #757575;">,</span> <span style="color: #b58900;">order</span><span style="color: #757575;">)</span>;
  list_add<span style="color: #757575;">(</span>&amp;coalesced-&gt;lru<span style="color: #757575;">,</span> &amp;zone-&gt;free_area[order].free_list<span style="color: #757575;">)</span>;
  zone-&gt;free_area[order].nr_free++;
</pre>
</div>
</div>
</div>

<div id="outline-container-org8bc63f4" class="outline-5">
<h5 id="org8bc63f4"><span class="section-number-5">1.2.6.5</span> Buddy system 初始化</h5>
<div class="outline-text-5" id="text-1-2-6-5">
</div>
<ol class="org-ol">
<li><a id="org92c1d2b"></a>初始化所有的 free_area 为空<br />
<div class="outline-text-6" id="text-1-2-6-5-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">setup_arch</span>:
  paging_init
    zone_sizes_init
      free_area_init
        free_area_init_node
          <span style="color: #b58900;">free_area_init_core</span>
            <span style="color: #268bd2;">zone_init_free_lists</span>
              <span style="color: #859900;">for</span> <span style="color: #757575;">(</span>order = 0; order &lt; MAX_ORDER ; order++<span style="color: #757575;">)</span>:
                INIT_LIST_HEAD<span style="color: #757575;">(</span>&amp;zone-&gt;free_area[order].free_list<span style="color: #757575;">)</span>;
                zone-&gt;free_area[order].nr_free = 0;
</pre>
</div>
</div>
</li>

<li><a id="orgd8fe41a"></a>释放 bootmem 到 buddy system<br />
<div class="outline-text-6" id="text-1-2-6-5-2">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">start_kernel</span>:
  mm_init
    mem_init
      free_all_bootmem
        <span style="color: #b58900;">free_all_bootmem_core</span>
          <span style="color: #268bd2;">__free_pages</span>
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-orgb60fdc8" class="outline-4">
<h4 id="orgb60fdc8"><span class="section-number-4">1.2.7</span> Slab Allocator</h4>
<div class="outline-text-4" id="text-1-2-7">
</div>
<div id="outline-container-orgfb41889" class="outline-5">
<h5 id="orgfb41889"><span class="section-number-5">1.2.7.1</span> Slab 基本原理</h5>
<div class="outline-text-5" id="text-1-2-7-1">
<ol class="org-ol">
<li>Buddy System 以 page 为单位来分配内存, 如果用 Buddy System 来分配一个只需要几十 KB 的 buffer 的话, 使用 Buddy System 会造成严重的内部碎片.</li>

<li>kernel 会频繁的分配和释放某些相同的数据结构, 例如 task_struct,
mm_struct 等, 通过维护一个针对这些常用数据结构的对象缓存, 可以大大提高分配与释放的效率 (当然会占用更多的内存), 并避免多次的初始化.</li>

<li>通过 Slab Colouring 组织不同 Slab 中对象的地址, 尽量使得这些对象在使用时能分布在不同的硬件 cache line 上.</li>

<li>除了缓存 task_struct 等这种数据结构, 大小为 32B, 64B, &#x2026; 128KB 的一些通用内存区域 (kmalloc) 也会通过 Slab 缓存起来.</li>
</ol>
</div>
</div>

<div id="outline-container-org50f8677" class="outline-5">
<h5 id="org50f8677"><span class="section-number-5">1.2.7.2</span> 相关数据结构</h5>
<div class="outline-text-5" id="text-1-2-7-2">
</div>
<ol class="org-ol">
<li><a id="orgd5e0b11"></a>kmem_cache_t<br />
<div class="outline-text-6" id="text-1-2-7-2-1">
<p>
kmem_cache_t (或 struct kmem_cache_s) 是 Slab 最上层的结构, 代表一种对象的缓存, 例如 task_struct, mm_struct 各自会有一个对应的 kmem_cache_t,
另外, /proc/slabinfo 中每一行都对应着一个 kmem_cache_t
</p>


<div id="org5548b9a" class="figure">
<p><img src="../extra/kernel_slab.png" alt="kernel_slab.png" />
</p>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">kmem_cache_s</span> <span style="color: #757575;">{</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">free objects &#30340;&#26368;&#22823;&#25968;&#30446;, &#21363; cache &#22810;&#23569;&#20010; free objects</span>
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">int</span>        <span style="color: #268bd2;">limit</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#21333;&#20010;&#23545;&#35937;&#30340;&#22823;&#23567;, &#23427;&#30340;&#20540;&#21487;&#33021;&#20250;&#22823;&#20110;&#23545;&#35937;&#30495;&#27491;&#30340;&#22823;&#23567;, &#22240;&#20026;&#38656;&#35201;&#32771;&#34385;&#23545;&#40784;</span>
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">int</span>        <span style="color: #268bd2;">objsize</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#27599;&#20010; slab &#26377;&#22810;&#23569;&#20010;&#23545;&#35937;</span>
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">int</span>        <span style="color: #268bd2;">num</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#27599;&#20010; slab &#38656;&#35201;&#21344;&#29992; 2^gfporder &#20010; page</span>
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">int</span>        <span style="color: #268bd2;">gfporder</span>;
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">int</span>        <span style="color: #268bd2;">gfpflags</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">slab colouring &#30456;&#20851;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">colour &#26159;&#36825;&#20010; cache &#30340; slab &#33021;&#20351;&#29992;&#30340; colour &#30340;&#33539;&#22260; (0~colour)</span>
    <span style="color: #586e75;">//</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">colour_off &#26159; colour &#23545;&#24212;&#30340;&#20559;&#31227;&#37327; (&#33509;&#26576;&#20010; slab &#30340; colour &#20026; i,</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#21017;&#36825;&#20010; slab &#24320;&#22836;&#30340;&#20559;&#31227;&#37327;&#20026; i*colour_off), &#20855;&#20307;&#21442;&#32771; kmem_cache_alloc,</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#19968;&#33324; colour_off &#20026; cache line &#30340;&#22823;&#23567;, &#20363;&#22914; 32B</span>
    <span style="color: #b58900;">size_t</span>          <span style="color: #268bd2;">colour</span>;
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">int</span>        <span style="color: #268bd2;">colour_off</span>;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">slab_size &#26159;&#25351; slab &#20013; slab descriptor &#19982; kmem_bufctl_t &#25968;&#32452;&#30340;&#22823;&#23567;&#20043;&#21644;</span>
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">int</span>        <span style="color: #268bd2;">slab_size</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">ctor &#19982; dtor</span>
    <span style="color: #b58900;">void</span> <span style="color: #757575;">(</span>*<span style="color: #268bd2;">ctor</span><span style="color: #757575;">)(</span><span style="color: #b58900;">void</span> *<span style="color: #757575;">,</span> <span style="color: #b58900;">kmem_cache_t</span> *<span style="color: #757575;">,</span> <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span><span style="color: #757575;">)</span>;
    <span style="color: #b58900;">void</span> <span style="color: #757575;">(</span>*<span style="color: #268bd2;">dtor</span><span style="color: #757575;">)(</span><span style="color: #b58900;">void</span> *<span style="color: #757575;">,</span> <span style="color: #b58900;">kmem_cache_t</span> *<span style="color: #757575;">,</span> <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span><span style="color: #757575;">)</span>;
    <span style="color: #859900;">const</span> <span style="color: #b58900;">char</span>      *<span style="color: #268bd2;">name</span>;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">slabs_partial &#20013;&#21516;&#26102;&#26377; free &#19982; nonfree &#30340; object</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">list_head</span>    <span style="color: #268bd2;">slabs_partial</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">slabs_full &#20013;&#25152;&#26377; object &#37117;&#26159; nonfree</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">list_head</span>    <span style="color: #268bd2;">slabs_full</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">slabs_free &#20013;&#25152;&#26377; object &#37117;&#26159; free</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">list_head</span>    <span style="color: #268bd2;">slabs_free</span>;

<span style="color: #757575;">}</span>
</pre>
</div>
</div>
</li>

<li><a id="org4c3fcb7"></a>slab<br />
<div class="outline-text-6" id="text-1-2-7-2-2">
<p>
slab 代表了一些 object 的集合, 它也代表一个或多个 (gfporder 有关) page.
</p>


<div id="orgca6309c" class="figure">
<p><img src="../extra/kernel_slab_object.png" alt="kernel_slab_object.png" />
</p>
</div>


<p>
上面图展示了 slab descriptor, kmem_bufctl_t 数组及 slab 的 objects 的布局
</p>

<p>
确切的说这只是 slab 结构中的 "slab with internal descriptor" 一种 (IN_SLAB), 即 slab descriptor 与 object 是放在同一个 page. 如果 object 很大,
例如几 K, 则会使用另一布局 "slab with external descriptor" (OFF_SLAB),
此处暂不讨论.
</p>

<p>
其中 free 及 kmem_bufctl_t 数组中的箭头指向相应的 Free Object, 实际上这个箭头是通过 free 和 kmem_bufctl_t 下标推算出来的 (slabp-&gt;s_mem +
slabp-&gt;free*cachep-&gt;objsize) &#x2026; 并不是直接的指针, 具体见
<a href="#orgb8e466e">kmem_cache_alloc</a>
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">slab</span> <span style="color: #757575;">{</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">slab &#25152;&#23646;&#30340; kmem_cache_t &#30340; slabs_partial, slabs_full,</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">slabs_free &#20013;&#30340;&#26576;&#19968;&#20010;</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">list_head</span>    <span style="color: #268bd2;">list</span>;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">page + colouroff = s_mem</span>
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span>       <span style="color: #268bd2;">colouroff</span>;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">slab &#31649;&#29702;&#30340; objects &#30340;&#39318;&#22320;&#22336;</span>
    <span style="color: #b58900;">void</span>            *<span style="color: #268bd2;">s_mem</span>;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">slab &#20013; nonfree &#30340; object &#20010;&#25968;, &#33509; inuse == kmem_cache_t.num,</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#34920;&#31034;&#36825;&#20010; slab &#24050;&#32463;&#27809;&#26377; free &#30340; object</span>
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">int</span>        <span style="color: #268bd2;">inuse</span>;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#19968;&#20010; slab &#21253;&#21547;&#22810;&#20010; object, &#23427;&#30340; free &#26159;&#25351;&#36825;&#20123; object &#20013;&#31532;&#19968;&#20010;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">free &#30340; object &#30340;&#19979;&#26631;(kmem_cache_t &#23454;&#38469;&#19978;&#23601;&#26159;&#19968;&#20010; short, &#23427;&#23601;&#26159;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#19968;&#20010;&#25968;&#32452;&#30340;&#19979;&#26631;)</span>
    <span style="color: #b58900;">kmem_bufctl_t</span>       <span style="color: #268bd2;">free</span>;
<span style="color: #757575;">}</span>
</pre>
</div>
</div>
</li>

<li><a id="org5caccf3"></a>kmem_bufctl_t 数组及 slab objects<br />
<div class="outline-text-6" id="text-1-2-7-2-3">
<p>
kmem_bufctl_t 实际就是一个数组下标, 本身是 short 类型.
</p>

<p>
在 slab 开头紧接着 Slab descriptor 的位置是一个数组, 这个数组的大小取决于每个 slab 有多少个 object (即 kmem_cache_t 的 num).
</p>

<p>
这个数组与数组后面的 slab objects 区域是对应的, x[i] 指示的是下一个
free 的 object 在数组中的下标, 通过这个数组, 可以建立一个 slab 中 free
objects 的链表.
</p>

<p>
slab-&gt;free 及 kmem_bufctl_t 的使用见 <a href="#orgb8e466e">kmem_cache_alloc</a>
</p>
</div>
</li>

<li><a id="org6dc2b01"></a>总结<br />
<div class="outline-text-6" id="text-1-2-7-2-4">
<p>
Slab 分为 cache, slab, object 三个层次.
</p>

<ol class="org-ol">
<li>每类对象对应一个 cache</li>

<li>每个 cache 有多个 slab, 这些 slab 根据每个 slab 中 free object 的个数分布在 slabs_partial, slabs_full, slabs_free 三条 slab 链表中.</li>

<li>每个 slab 通过一个或多个连续的 page 保存着多个 object 及 slab
descriptor 本身以及一个 kmem_bufctl_t 数组, 这个数组用来维护 slab
内部的 free objects 链表</li>
</ol>
</div>
</li>
</ol>
</div>

<div id="outline-container-org6efb5af" class="outline-5">
<h5 id="org6efb5af"><span class="section-number-5">1.2.7.3</span> Allocating a Slab Object</h5>
<div class="outline-text-5" id="text-1-2-7-3">
</div>
<ol class="org-ol">
<li><a id="orgb8e466e"></a>kmem_cache_alloc<br />
<div class="outline-text-6" id="text-1-2-7-3-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #b58900;">void</span> * <span style="color: #268bd2;">kmem_cache_alloc</span> <span style="color: #757575;">(</span><span style="color: #b58900;">kmem_cache_t</span> *<span style="color: #268bd2;">cachep</span><span style="color: #757575;">,</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">flags</span><span style="color: #757575;">)</span>:
  <span style="color: #586e75;">// </span><span style="color: #586e75;">kmem_cache_alloc &#26102;&#20250;&#19968;&#27425;&#20998;&#37197; batchcount &#20010; object &#21040;&#21478;&#19968;&#20010; cache</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">(ac_data), &#32780;&#19981;&#26159;&#20165;&#20998;&#37197;&#19968;&#20010; object, &#25152;&#20197; kmem_cache_alloc &#20250;&#20808;&#26816;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#26597; ac_data &#20013;&#26159;&#21542;&#26377; object</span>
  ac = ac_data<span style="color: #757575;">(</span>cachep<span style="color: #757575;">)</span>;
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>likely<span style="color: #757575;">(</span>ac-&gt;avail<span style="color: #757575;">))</span>:
    objp = ac_entry<span style="color: #757575;">(</span>ac<span style="color: #757575;">)</span>[--ac-&gt;avail];
  <span style="color: #859900;">else</span>:

    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#35843;&#29992; cache_alloc_refill &#26469; fill ac_data</span>
    objp = cache_alloc_refill<span style="color: #757575;">(</span>cachep<span style="color: #757575;">,</span> flags<span style="color: #757575;">)</span>;
      <span style="color: #859900;">while</span> <span style="color: #757575;">(</span>batchcount &gt; 0<span style="color: #757575;">)</span>:
        <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20808;&#23581;&#35797;&#20174; slabs_partial &#20998;&#37197;, &#33509; slabs_partial &#38142;&#34920;&#20026;&#31354;</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">(slabs_partial.next == slabs_partial), &#21017;&#23581;&#35797;&#20174; slabs_free &#20998;&#37197;</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">&#33509; slabs_free &#20063;&#20026;&#31354;, &#36339;&#21040; must_grow, &#20197;&#20998;&#37197;&#19968;&#20010;&#26032;&#30340; slab</span>
        entry = l3-&gt;slabs_partial.next;
        <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>entry == &amp;l3-&gt;slabs_partial<span style="color: #757575;">)</span>:
          entry = l3-&gt;slabs_free.next;
        <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>entry == &amp;l3-&gt;slabs_free<span style="color: #757575;">)</span>:
          cache_grow<span style="color: #757575;">(</span>cachep<span style="color: #757575;">,</span> flags<span style="color: #757575;">,</span> -1<span style="color: #757575;">)</span>;
          <span style="color: #859900;">goto</span> <span style="color: #268bd2; font-weight: bold;">must_grow</span>;

        <span style="color: #586e75;">// </span><span style="color: #586e75;">&#36825;&#37324;&#25214;&#21040;&#19968;&#20010; slabs &#38142;&#34920;</span>
        slabp = list_entry<span style="color: #757575;">(</span>entry<span style="color: #757575;">,</span> <span style="color: #859900;">struct</span> <span style="color: #b58900;">slab</span><span style="color: #757575;">,</span> list<span style="color: #757575;">)</span>;
        <span style="color: #859900;">while</span> <span style="color: #757575;">(</span>slabp-&gt;inuse &lt; cachep-&gt;num &amp;&amp; batchcount--<span style="color: #757575;">)</span>:
          <span style="color: #586e75;">// </span><span style="color: #586e75;">alloc &#30340; object &#26368;&#32456;&#20250;&#20445;&#23384;&#22312; ac_data &#20013;, slab-&gt;free &#26159;</span>
          <span style="color: #586e75;">// </span><span style="color: #586e75;">slab &#20013;&#31532;&#19968;&#20010; free &#30340; object &#30340;&#19979;&#26631;, s_mem &#26159; slab &#20013;</span>
          <span style="color: #586e75;">// </span><span style="color: #586e75;">object &#37096;&#20998;&#30340;&#39318;&#22320;&#22336;</span>
          ac_entry<span style="color: #757575;">(</span>ac<span style="color: #757575;">)</span>[ac-&gt;avail++] = slabp-&gt;s_mem + slabp-&gt;free*cachep-&gt;objsize;
          slabp-&gt;inuse++;
          <span style="color: #586e75;">// </span><span style="color: #586e75;">&#36890;&#36807; kmem_bufctl_t &#25968;&#32452;&#25214;&#21040; slab &#20013;&#19979;&#19968;&#20010; free &#30340; object</span>
          next = slab_bufctl<span style="color: #757575;">(</span>slabp<span style="color: #757575;">)</span>[slabp-&gt;free];
          slabp-&gt;free = next;

         <span style="color: #586e75;">// </span><span style="color: #586e75;">&#35843;&#25972; slab &#36807;&#23545;&#24212;&#30340; slab &#38142;&#34920;</span>
          list_del<span style="color: #757575;">(</span>&amp;slabp-&gt;list<span style="color: #757575;">)</span>;
          <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>slabp-&gt;free == BUFCTL_END<span style="color: #757575;">)</span>:
            list_add<span style="color: #757575;">(</span>&amp;slabp-&gt;list<span style="color: #757575;">,</span> &amp;l3-&gt;slabs_full<span style="color: #757575;">)</span>;
          <span style="color: #859900;">else</span>:
            list_add<span style="color: #757575;">(</span>&amp;slabp-&gt;list<span style="color: #757575;">,</span> &amp;l3-&gt;slabs_partial<span style="color: #757575;">)</span>;

          <span style="color: #586e75;">// </span><span style="color: #586e75;">fall through to must_grow</span>

    <span style="color: #268bd2; font-weight: bold;">must_grow</span>:
      <span style="color: #586e75;">// </span><span style="color: #586e75;">ac-&gt;avail &#20026; 0, &#34920;&#31034;&#27809;&#26377;&#20998;&#37197;&#20219;&#20309;&#19968;&#20010; object, &#21017;&#38656;&#35201;&#20998;&#37197;&#19968;&#20010;&#26032;&#30340; slab</span>
      <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>unlikely<span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>ac-&gt;avail<span style="color: #757575;">))</span>:
        x = cache_grow<span style="color: #757575;">(</span>cachep<span style="color: #757575;">,</span> flags<span style="color: #757575;">,</span> -1<span style="color: #757575;">)</span>;
      <span style="color: #859900;">return</span> ac_entry<span style="color: #757575;">(</span>ac<span style="color: #757575;">)</span>[--ac-&gt;avail];
</pre>
</div>
</div>
</li>

<li><a id="org793eaf6"></a>cache_grow<br />
<div class="outline-text-6" id="text-1-2-7-3-2">
<p>
当 cache 没有任何 free 的 slab 时, 通过 cache_grow 分配一个 slab
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b58900;">void</span> <span style="color: #268bd2;">cache_grow</span> <span style="color: #757575;">(</span><span style="color: #b58900;">kmem_cache_t</span> * <span style="color: #268bd2;">cachep</span><span style="color: #757575;">)</span>:
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#35745;&#31639; slab &#30340; colour</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">colour_next &#34920;&#31034;&#26032;&#20998;&#37197;&#30340; slab &#24212;&#35813;&#20351;&#29992;&#30340; colour</span>
  offset = cachep-&gt;colour_next;
  <span style="color: #586e75;">// </span><span style="color: #586e75;">colour_next++, &#33509;&#36229;&#36807;&#20102; cachep-&gt;colour &#25351;&#23450;&#30340; colour &#26368;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#22823;&#20540;, &#21017;&#22238;&#32469;&#21040; 0</span>
  cachep-&gt;colour_next++;
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>cachep-&gt;colour_next &gt;= cachep-&gt;colour<span style="color: #757575;">)</span>:
    cachep-&gt;colour_next = 0;

  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#26368;&#32456;&#30340; offset &#20026; colour * cachep-&gt;colour_off</span>
  offset *= cachep-&gt;colour_off;

  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20998;&#37197; page</span>
  objp = kmem_getpages<span style="color: #757575;">(</span>cachep<span style="color: #757575;">,</span> flags<span style="color: #757575;">,</span> nodeid<span style="color: #757575;">)</span>
    page = alloc_pages<span style="color: #757575;">(</span>flags<span style="color: #757575;">,</span> cachep-&gt;gfporder<span style="color: #757575;">)</span>;

  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#25353; slab &#30340;&#26684;&#24335;&#21021;&#22987;&#21270;&#36825;&#20010; page (&#23454;&#38469;&#19978;&#23601;&#26159;&#29983;&#25104; slab descriptor)</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20854;&#20013; offset &#26159;&#25351;&#26681;&#25454; slab colouring &#30340;&#32467;&#26524;, slab &#30340;&#31532;&#19968;&#20010;&#23545;&#35937;&#30340;&#36215;&#22987;&#20301;&#32622;</span>
  slabp = alloc_slabmgmt<span style="color: #757575;">(</span>cachep<span style="color: #757575;">,</span> objp<span style="color: #757575;">,</span> offset<span style="color: #757575;">,</span> local_flags<span style="color: #757575;">)</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">slab &#24320;&#22836;&#30340; offset &#20010;&#23383;&#33410;&#34987;&#36339;&#36807;</span>
    slabp = objp+offset;
    slabp-&gt;inuse = 0;

    offset += cachep-&gt;slab_size;
    slabp-&gt;colouroff = offset;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">s_mem &#21363; slab &#20013;&#31532;&#19968;&#20010; object &#30340;&#22320;&#22336;</span>
    slabp-&gt;s_mem = objp+offset;

  <span style="color: #586e75;">// </span><span style="color: #586e75;">set_slab_attr &#23558;&#25152;&#26377; page &#37117;&#21644; cachep &#21450; slabp "&#20851;&#32852;" &#36215;&#26469;,</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#25152;&#35859;&#30340;"&#20851;&#32852;", &#26159;&#25351;&#36890;&#36807; page, &#21487;&#20197;&#25214;&#21040;&#23427;&#23646;&#20110;&#21738;&#20010; cache &#21450;&#21738;&#20010; slab,</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#36825;&#20123;&#20449;&#24687;&#26159;&#24517;&#35201;&#30340;, &#20197; kmem_cache_free &#20026;&#20363;, object &#23545;&#24212;&#30340; cache &#22312; kmem_cache_free</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#30340;&#31532;&#19968;&#20010;&#21442;&#25968;&#20013;, &#20294;&#23427;&#25152;&#35859;&#30340; slab &#24517;&#39035;&#36890;&#36807; set_slab_attr &#24314;&#31435;&#30340;&#20851;&#32852;&#25165;&#33021;&#25214;&#21040;,</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#21478;&#22806;, kfree &#26102;&#21482;&#25552;&#20379;&#20102;&#19968;&#20010; object &#21442;&#25968;, &#36830; cache &#37117;&#27809;&#26377;, &#26356;&#38656;&#35201; set_slab_attr</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#24314;&#31435;&#30340;&#20851;&#32852;.</span>
  <span style="color: #586e75;">//</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">set_slab_attr &#22914;&#20309;&#24314;&#31435; objp &#19982; cachep &#21450; slabp &#30340;&#20851;&#32852;? &#36890;&#36807; page-&gt;lru.prev &#21450;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">page-&gt;lru.next.</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#22240;&#20026;&#27492;&#26102; page &#19981;&#23646;&#20110; buddy &#25110; PFRA &#31649;&#29702;, &#25152;&#20197;&#20854; lru &#23383;&#27573;&#26159;&#21487;&#20197;&#33258;&#30001;&#20351;&#29992;&#30340;</span>
  <span style="color: #268bd2;">set_slab_attr</span><span style="color: #757575;">(</span><span style="color: #b58900;">cachep</span><span style="color: #757575;">,</span> <span style="color: #b58900;">slabp</span><span style="color: #757575;">,</span> <span style="color: #b58900;">objp</span><span style="color: #757575;">)</span>;
    i = 1 &lt;&lt; cachep-&gt;gfporder;
    page = virt_to_page<span style="color: #757575;">(</span>objp<span style="color: #757575;">)</span>;
    <span style="color: #859900;">do</span>:
      SET_PAGE_CACHE<span style="color: #757575;">(</span>page<span style="color: #757575;">,</span> cachep<span style="color: #757575;">)</span>;
        page-&gt;lru.next = cachep;
      <span style="color: #268bd2;">SET_PAGE_SLAB</span><span style="color: #757575;">(</span><span style="color: #b58900;">page</span><span style="color: #757575;">,</span> <span style="color: #b58900;">slabp</span><span style="color: #757575;">)</span>;
        page-&gt;lru.prev = slabp;
      page++;
     <span style="color: #859900;">while</span> <span style="color: #757575;">(</span>--i<span style="color: #757575;">)</span>;

  <span style="color: #268bd2;">cache_init_objs</span><span style="color: #757575;">(</span><span style="color: #b58900;">cachep</span><span style="color: #757575;">,</span> <span style="color: #b58900;">slabp</span><span style="color: #757575;">,</span> <span style="color: #b58900;">ctor_flags</span><span style="color: #757575;">)</span>;
    <span style="color: #859900;">for</span> <span style="color: #757575;">(</span>i = 0; i &lt; cachep-&gt;num; i++<span style="color: #757575;">)</span>:
      <span style="color: #b58900;">void</span>* objp = slabp-&gt;s_mem+cachep-&gt;objsize*i;
      <span style="color: #586e75;">// </span><span style="color: #586e75;">ctor &#26159;&#22312;&#20998;&#37197; slab &#26102;&#23601;&#34987;&#35843;&#29992;&#20102;, &#32780;&#19981;&#26159;&#22312;&#20998;&#37197; object &#26102;</span>
      <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>cachep-&gt;ctor<span style="color: #757575;">)</span>:
        cachep-&gt;ctor<span style="color: #757575;">(</span>objp<span style="color: #757575;">,</span> cachep<span style="color: #757575;">,</span> ctor_flags<span style="color: #757575;">)</span>;
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#21021;&#22987;&#21270; kmem_bufctl_t &#20013;&#25968;&#25454;&#20026; x[i] = i+1</span>
      <span style="color: #268bd2;">slab_bufctl</span><span style="color: #757575;">(</span><span style="color: #b58900;">slabp</span><span style="color: #757575;">)</span>[i] = i+1;
      <span style="color: #586e75;">// </span><span style="color: #586e75;">slab &#31532;&#19968;&#20010; free &#30340; object &#30340;&#19979;&#26631;&#21021;&#22987;&#26159; 0</span>
      slabp-&gt;free = 0;

  list_add_tail<span style="color: #757575;">(</span>&amp;slabp-&gt;list<span style="color: #757575;">,</span> &amp;<span style="color: #757575;">(</span>list3_data<span style="color: #757575;">(</span>cachep<span style="color: #757575;">)</span>-&gt;slabs_free<span style="color: #757575;">))</span>;
  <span style="color: #268bd2;">list3_data</span><span style="color: #757575;">(</span><span style="color: #b58900;">cachep</span><span style="color: #757575;">)</span>-&gt;free_objects += cachep-&gt;num;
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-orgca14029" class="outline-5">
<h5 id="orgca14029"><span class="section-number-5">1.2.7.4</span> Freeing a Slab Object</h5>
<div class="outline-text-5" id="text-1-2-7-4">
</div>
<ol class="org-ol">
<li><a id="orgd9c2ee4"></a>kmem_cache_free<br /></li>
</ol>
</div>

<div id="outline-container-org6bf042a" class="outline-5">
<h5 id="org6bf042a"><span class="section-number-5">1.2.7.5</span> kmalloc</h5>
<div class="outline-text-5" id="text-1-2-7-5">
<p>
kmalloc 建立在 slab 基础上, 除了通过 kmem_cache_create 创建的 specific
cache 外, slab 内建了几个 generic cache, 又来支持 kmalloc. 通过一个
cache_sizes 数组, slab 维护了 object size 分别为 32, 64, &#x2026; 128K 的几个 cache. kmalloc 时会根据 kmalloc 的需要的内存大小选择一个大小最接近的 cache 去分配
</p>
</div>

<ol class="org-ol">
<li><a id="org8543dee"></a>kmalloc<br />
<div class="outline-text-6" id="text-1-2-7-5-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #859900;">static</span> <span style="color: #859900;">inline</span> <span style="color: #b58900;">void</span> *<span style="color: #268bd2;">kmalloc</span><span style="color: #757575;">(</span><span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">size</span><span style="color: #757575;">,</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">flags</span><span style="color: #757575;">)</span>:
  <span style="color: #859900;">return</span> __kmalloc <span style="color: #757575;">(</span><span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">size</span><span style="color: #757575;">,</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">flags</span><span style="color: #757575;">)</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">cache_sizes</span> *<span style="color: #268bd2;">csizep</span> = malloc_sizes;
      <span style="color: #859900;">for</span> <span style="color: #757575;">(</span>; csizep-&gt;cs_size; csizep++<span style="color: #757575;">)</span>:
        <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>size &gt; csizep-&gt;cs_size<span style="color: #757575;">)</span>:
         <span style="color: #859900;">continue</span>;
    <span style="color: #859900;">return</span> __cache_alloc<span style="color: #757575;">(</span>csizep-&gt;cs_cachep<span style="color: #757575;">,</span> flags<span style="color: #757575;">)</span>;
</pre>
</div>

<p>
需要注意的是, __cache_alloc 时最终会通过 set_slab_attr 将 kmalloc 返回的 object 所在的 page 与相关的 cache 和 slab 关联起来, 后面在 kfree 时需要这些关联的 cache 和 slab.
</p>
</div>
</li>

<li><a id="org8b4815a"></a>kfree<br />
<div class="outline-text-6" id="text-1-2-7-5-2">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #b58900;">void</span> <span style="color: #268bd2;">kfree</span> <span style="color: #757575;">(</span><span style="color: #859900;">const</span> <span style="color: #b58900;">void</span> *<span style="color: #268bd2;">objp</span><span style="color: #757575;">)</span>:
  cache = GET_PAGE_CACHE<span style="color: #757575;">(</span>virt_to_page<span style="color: #757575;">(</span>objp<span style="color: #757575;">))</span>;
    cache = pg-&gt;lru.next;
  <span style="color: #268bd2;">__cache_free</span><span style="color: #757575;">(</span><span style="color: #b58900;">cache</span><span style="color: #757575;">,</span> <span style="color: #757575;">(</span><span style="color: #b58900;">void</span>*<span style="color: #757575;">)</span>objp<span style="color: #757575;">)</span>;
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org567846a" class="outline-5">
<h5 id="org567846a"><span class="section-number-5">1.2.7.6</span> Slab Colouring</h5>
<div class="outline-text-5" id="text-1-2-7-6">
<p>
如 <a href="#org793eaf6">cache_grow</a> 所示, 在分配 slab 时会在 slab 开头插入一段空白, 空白的大小由 cache 的 colour, colour_next 及 colour_offset 决定.
</p>


<div id="org4729432" class="figure">
<p><img src="../extra/kernel_slab_colouring.png" alt="kernel_slab_colouring.png" />
</p>
</div>

<p>
上图第一部分 col*aln 的部分即是插入的一段空白, 其中 col 即 cache_grow
时使用的 cache-&gt;colour_next, aln(align) 即 cache_grow 时使用的
cache-&gt;colour_offset (即 cache line size, 32B), 从 cache_grow 已经看到,
cache-&gt;colour_next 在每次分配 slab 时加 1, 直到达到 cache-&gt;colour 这个最大值时回绕到 0, 现在的问题是, cache-&gt;colour 这个最大值是如何确定的?
显然这个值大了会浪费空间, 小了又起不到多少作用&#x2026;
</p>

<p>
每个 slab 的大小是 page size 对齐的, 但 object 的大小是任意的, 假设这种情况:
</p>

<p>
slab 大小为 4K (占用一个 page), 假设 object 大小为 300B, slab
descriptor 大小为 20B, 不考虑 object 对齐的情况下, 一个 slab 能容纳的
object 数为 (4096-20)/300 = 13, 则不考虑 colouring 的情况下, slab 的布局大约 (没有考虑 object align) 是:
</p>

<ol class="org-ol">
<li>20 B 的 slab descriptor</li>
<li>26 B 的 kmem_bufctl_t 数组 (13 个 object)</li>
<li>13 * 300 = 3900 B 的 objects</li>
<li>还剩余 150 B</li>
</ol>

<p>
剩余的 150B 是浪费的, 因为它无法容纳一个 object, 但 slab 可以利用这块空闲空间做 slab colouring:
</p>

<p>
因为 150 / 32 = 4.6, 所以 cache-&gt;colour = 5, cache-&gt;colour_offset =
32, 初始 cache-&gt;colour_next = 0, 假设后面连续分配了几个 slab:
</p>

<ol class="org-ol">
<li>slab(0) 的 offset 为 0</li>
<li>slab(1) 32</li>
<li>slab(2) 64</li>
<li>slab(3) 96</li>
<li>slab(4) 128</li>
<li>slab(5) 又回绕到 0</li>
</ol>

<p>
可见 slab(0) 到 slab(4) 的 offset 依次相差一个 cache line 的大小. 相对而言这些 slab 中的对象被 cache 到同一条 cache line 的可能性会小一些.
</p>
</div>
</div>

<div id="outline-container-org0b41e39" class="outline-5">
<h5 id="org0b41e39"><span class="section-number-5">1.2.7.7</span> Appendix</h5>
<div class="outline-text-5" id="text-1-2-7-7">
</div>
<ol class="org-ol">
<li><a id="orga110e18"></a>cache 的 gfporder 如何确定<br />
<div class="outline-text-6" id="text-1-2-7-7-1">
<p>
cache 的 gfporder 决定了一个 slab 占用多少个 page (参考 cache_grow 的代码), 那么 cache 的 gfporder 是如何确定的?
</p>

<p>
总的来说, gfporder 的选择需要权衡以下几个指标:
</p>

<ol class="org-ol">
<li>object 的大小</li>
<li>page 的大小</li>
<li>对齐</li>
<li>浪费的空间的大小</li>
</ol>

<p>
具体参考 cache_estimate
</p>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-orgf89e667" class="outline-4">
<h4 id="orgf89e667"><span class="section-number-4">1.2.8</span> vmalloc</h4>
<div class="outline-text-4" id="text-1-2-8">
</div>
<div id="outline-container-org10469f0" class="outline-5">
<h5 id="org10469f0"><span class="section-number-5">1.2.8.1</span> vm_struct</h5>
<div class="outline-text-5" id="text-1-2-8-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">vm_struct</span> <span style="color: #757575;">{</span>
    <span style="color: #b58900;">void</span>            *<span style="color: #268bd2;">addr</span>;
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span>       <span style="color: #268bd2;">size</span>;
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span>       <span style="color: #268bd2;">flags</span>;
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">page</span>     **<span style="color: #268bd2;">pages</span>;
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">int</span>        <span style="color: #268bd2;">nr_pages</span>;
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span>       <span style="color: #268bd2;">phys_addr</span>;
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">vm_struct</span>    *<span style="color: #268bd2;">next</span>;
<span style="color: #757575;">}</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-org28f7575" class="outline-5">
<h5 id="org28f7575"><span class="section-number-5">1.2.8.2</span> vmalloc</h5>
<div class="outline-text-5" id="text-1-2-8-2">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #b58900;">void</span> *<span style="color: #268bd2;">vmalloc</span><span style="color: #757575;">(</span><span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span> <span style="color: #268bd2;">size</span><span style="color: #757575;">)</span>:
  <span style="color: #586e75;">// </span><span style="color: #586e75;">__GFP_HIGHMEM</span>
  <span style="color: #859900;">return</span> __vmalloc<span style="color: #757575;">(</span>size<span style="color: #757575;">,</span> GFP_KERNEL | __GFP_HIGHMEM<span style="color: #757575;">,</span> PAGE_KERNEL<span style="color: #757575;">)</span>;
    size = PAGE_ALIGN<span style="color: #757575;">(</span>size<span style="color: #757575;">)</span>;
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#25214;&#19968;&#22359;&#34394;&#25311;&#22320;&#22336;&#31354;&#38388;</span>
  <span style="color: #859900;">struct</span> <span style="color: #b58900;">vm_struct</span>* <span style="color: #268bd2;">area</span> = get_vm_area<span style="color: #757575;">(</span>size<span style="color: #757575;">,</span> VM_ALLOC<span style="color: #757575;">)</span>;
  nr_pages = size &gt;&gt; PAGE_SHIFT;
  array_size = <span style="color: #757575;">(</span>nr_pages * <span style="color: #859900;">sizeof</span><span style="color: #757575;">(</span><span style="color: #859900;">struct</span> <span style="color: #b58900;">page</span> *<span style="color: #757575;">))</span>;

  <span style="color: #586e75;">// </span><span style="color: #586e75;">1. &#20998;&#37197; area-&gt;pages &#25968;&#32452;</span>
  pages = kmalloc<span style="color: #757575;">(</span>array_size<span style="color: #757575;">,</span> <span style="color: #757575;">(</span>gfp_mask &amp; ~__GFP_HIGHMEM<span style="color: #757575;">))</span>;
  area-&gt;pages = pages;

  <span style="color: #586e75;">// </span><span style="color: #586e75;">2. &#20998;&#37197; page</span>
  <span style="color: #859900;">for</span> <span style="color: #757575;">(</span>i = 0; i &lt; area-&gt;nr_pages; i++<span style="color: #757575;">)</span>:
    area-&gt;pages[i] = alloc_page<span style="color: #757575;">(</span>gfp_mask<span style="color: #757575;">)</span>;

  <span style="color: #586e75;">// </span><span style="color: #586e75;">3. &#23558; page &#26144;&#23556;&#21040; area-&gt;addr</span>
  <span style="color: #268bd2;">map_vm_area</span><span style="color: #757575;">(</span><span style="color: #b58900;">area</span><span style="color: #757575;">,</span> <span style="color: #b58900;">prot</span><span style="color: #757575;">,</span> &amp;pages<span style="color: #757575;">)</span>
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="orgf9f7ed2"></a>get_vm_area<br />
<div class="outline-text-6" id="text-1-2-8-2-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">vm_struct</span> *<span style="color: #268bd2;">get_vm_area</span><span style="color: #757575;">(</span><span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span> <span style="color: #268bd2;">size</span><span style="color: #757575;">,</span> <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span> <span style="color: #268bd2;">flags</span><span style="color: #757575;">)</span>:
  <span style="color: #859900;">return</span> __get_vm_area<span style="color: #757575;">(</span>size<span style="color: #757575;">,</span> flags<span style="color: #757575;">,</span> VMALLOC_START<span style="color: #757575;">,</span> VMALLOC_END<span style="color: #757575;">)</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20174; VMALLOC_START .. VMALLOC_END &#36825;&#22359;&#21306;&#22495;&#25214;&#19968;&#20010; size &#22823;&#23567;&#30340;&#34394;&#25311;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#22320;&#22336;&#31354;&#38388;</span>
    area = kmalloc<span style="color: #757575;">(</span><span style="color: #859900;">sizeof</span><span style="color: #757575;">(</span>*area<span style="color: #757575;">),</span> GFP_KERNEL<span style="color: #757575;">)</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">vmalloc &#21306;&#22495;&#20013;&#30456;&#37051;&#30340; area &#26377;&#19968;&#20010; guard page</span>
    size += PAGE_SIZE;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">vmlist &#26159;&#19968;&#20010; vm_struct &#30340;&#38142;&#34920;, &#36825;&#20123; vm_struct &#30340; (addr, size)</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20195;&#34920;&#30340;&#34394;&#25311;&#22320;&#22336;&#31354;&#38388;&#26159;&#19981;&#37325;&#21472;&#30340;, &#36825;&#20010;&#38142;&#34920;&#20013;&#30340; vm_struct &#30340;&#39034;&#24207;&#23427;&#20204;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#23545;&#24212;&#30340;&#22320;&#22336;&#31354;&#38388;&#30340;&#20808;&#21518;&#39034;&#24207;&#26159;&#19968;&#33268;&#30340;.</span>
    <span style="color: #586e75;">//</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#19979;&#38754;&#30340;&#20195;&#30721;&#26159;&#25195;&#25551;&#36825;&#20010;&#38142;&#34920;, &#30475;&#26159;&#21542;&#23384;&#22312;&#20004;&#20010; vm_struct: &#23427;&#20204;&#20013;&#38388;&#26377;&#36275;&#22815;&#22823;&#30340;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#38388;&#38548;&#23481;&#32435;&#19968;&#20010;&#26032;&#30340; vm_struct</span>
    addr = start;
    <span style="color: #859900;">for</span> <span style="color: #757575;">(</span>p = &amp;vmlist; <span style="color: #757575;">(</span>tmp = *p<span style="color: #757575;">)</span> != <span style="color: #268bd2; font-weight: bold;">NULL</span> ;p = &amp;tmp-&gt;next<span style="color: #757575;">)</span>:
      <span style="color: #586e75;">// </span><span style="color: #586e75;">addr &#34920;&#31034;"&#21069;&#19968;&#20010;" vm_struct &#30340;&#32467;&#23614;, size &#34920;&#31034;&#38656;&#35201;&#30340;&#38388;&#38548;&#22823;&#23567;,</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#33509; size+addr &lt;= tmp-&gt;addr, &#21017;&#34920;&#31034; (addr, addr+size) &#36825;&#27573;&#21306;&#22495;</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#26159;&#21487;&#29992;&#30340;.</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#26174;&#28982;&#36825;&#37324;&#26159;&#29992;&#30340; first-fit &#31639;&#27861;</span>
      <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>size + addr &lt;= <span style="color: #757575;">(</span><span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span><span style="color: #757575;">)</span>tmp-&gt;addr<span style="color: #757575;">)</span>:
        <span style="color: #859900;">goto</span> <span style="color: #268bd2; font-weight: bold;">found</span>
      <span style="color: #859900;">else</span>:
        <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20174;&#19979;&#19968;&#20010; vm_struct &#30340;&#32467;&#23614;&#24320;&#22987;&#32487;&#32493;&#26597;&#25214;</span>
        addr = tmp-&gt;size + tmp-&gt;addr;
      <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>addr &gt; end - size<span style="color: #757575;">)</span>:
        <span style="color: #586e75;">// </span><span style="color: #586e75;">&#27809;&#25214;&#21040;</span>
        <span style="color: #859900;">goto</span> <span style="color: #268bd2; font-weight: bold;">out</span>;

    <span style="color: #268bd2; font-weight: bold;">found</span>:
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#23558;&#26032;&#20998;&#37197;&#30340; area &#25554;&#20837;&#21040;&#21069;&#21518;&#20004;&#20010; vm_struct &#20043;&#38388;</span>
      area-&gt;next = *p;
      *p = area;

      area-&gt;addr = <span style="color: #757575;">(</span><span style="color: #b58900;">void</span> *<span style="color: #757575;">)</span>addr;
      area-&gt;size = size;
      area-&gt;pages = <span style="color: #268bd2; font-weight: bold;">NULL</span>;
      area-&gt;nr_pages = 0;
      area-&gt;phys_addr = 0;
      <span style="color: #859900;">return</span> area;
</pre>
</div>

<p>
ps. 关于 get_vm_area, 参考 android binder 的 部分
</p>
</div>
</li>

<li><a id="orgb4ddfb3"></a>map_vm_area<br /></li>

<li><a id="org22bb695"></a>总结<br />
<div class="outline-text-6" id="text-1-2-8-2-3">
<ol class="org-ol">
<li>vmalloc 用一个简单 vm_struct 链表通过 first_fit 方法来管理虚拟地址空间的分配</li>

<li>除了分配虚拟地址空间, vmalloc 还会自己分配 page 并设置 page table,
并且与 kmap 一样, vmalloc 也是操作的 swapper_pg_dir</li>
</ol>
</div>
</li>
</ol>
</div>

<div id="outline-container-org7854f38" class="outline-5">
<h5 id="org7854f38"><span class="section-number-5">1.2.8.3</span> vfree</h5>
<div class="outline-text-5" id="text-1-2-8-3">
<p>
与 vmalloc 相反的动作:
</p>

<ol class="org-ol">
<li>根据 address 找到 vm_struct</li>

<li>从 vmlist 链表中删除这个 vm_struct</li>

<li>kfree vm_struct-&gt;pages 数组</li>

<li>__free_pages 释放 vm_struct-&gt;pages 中的 page</li>

<li>修改 page table (PTE 清 0)</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org28f6186" class="outline-4">
<h4 id="org28f6186"><span class="section-number-4">1.2.9</span> Bootmem Allocator</h4>
</div>
</div>

<div id="outline-container-orgd5bb960" class="outline-3">
<h3 id="orgd5bb960"><span class="section-number-3">1.3</span> 进程地址空间</h3>
<div class="outline-text-3" id="text-1-3">
<p>
进程地址空间 (process address space), 是指 0~3G 这部分 user mode 可以直接访问的虚拟地址空间,
这部分空间被划分为许多不相交的 memory region, 通过 memory region 和
page fault, 能实现 demanding page, COW, swap 等功能.
</p>

<p>
另外, memory region 也是主要的 user mode 与 kernel 之间关于 memory 的接口, 可以实现 sharing, locking 等功能
</p>
</div>

<div id="outline-container-orgdee8521" class="outline-4">
<h4 id="orgdee8521"><span class="section-number-4">1.3.1</span> mm_struct</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
mm_struct 中和 memory region 相关的字段主要有:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">mm_struct</span> <span style="color: #757575;">{</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#25152;&#26377;&#30340; memory region (vm_area_struct) &#36890;&#36807; mmap &#36825;&#20010;&#38142;&#34920;&#32452;&#32455;&#36215;&#26469;,</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#24182;&#19988;&#26159;&#25353;&#29031;&#22320;&#22336;&#36882;&#22686;&#30340;&#39034;&#24207;, &#26041;&#20415;&#36941;&#21382;&#25152;&#26377;&#30340; vma, &#20294;&#36825;&#37324;&#24182;&#19981;&#26159;&#33021;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">list_head &#26500;&#36896;&#30340;&#38142;&#34920;, &#32780;&#19988;&#29992;&#26222;&#36890;&#30340;&#38142;&#34920;&#26041;&#24335;&#26500;&#25104;&#19968;&#20010;&#21333;&#21521;&#38142;&#34920;</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">vm_area_struct</span> * <span style="color: #268bd2;">mmap</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#38500;&#20102; mmap &#36825;&#20010;&#38142;&#34920;, &#25152;&#26377;&#30340; vm_area_struct &#36824;&#36890;&#36807; rb-tree &#32452;&#32455;&#36215;&#26469;,</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#26041;&#20415;&#36890;&#36807;&#34394;&#25311;&#22320;&#20301;&#25214;&#21040;&#23545;&#24212;&#30340; vm_area_struct</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">rb_root</span> <span style="color: #268bd2;">mm_rb</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#26368;&#36817;&#20351;&#29992;&#30340; vm_area_struct &#20445;&#23384;&#22312; mmap_cache &#20013;</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">vm_area_struct</span> * <span style="color: #268bd2;">mmap_cache</span>;
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span> <span style="color: #268bd2;">mmap_base</span>;
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span> <span style="color: #268bd2;">free_area_cache</span>;

    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span> <span style="color: #268bd2;">start_code</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">end_code</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">start_data</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">end_data</span>;
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span> <span style="color: #268bd2;">start_brk</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">brk</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">start_stack</span>;
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span> <span style="color: #268bd2;">arg_start</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">arg_end</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">env_start</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">env_end</span>;
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span> <span style="color: #268bd2;">rss</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">anon_rss</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">total_vm</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">locked_vm</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">shared_vm</span>;
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span> <span style="color: #268bd2;">exec_vm</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">stack_vm</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">reserved_vm</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">def_flags</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">nr_ptes</span>;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">...</span>
<span style="color: #757575;">}</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-org5795af7" class="outline-4">
<h4 id="org5795af7"><span class="section-number-4">1.3.2</span> Memory Region</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
memroy region 主要由 mmap 系统调用来管理
</p>
</div>

<div id="outline-container-org66bf480" class="outline-5">
<h5 id="org66bf480"><span class="section-number-5">1.3.2.1</span> 数据结构</h5>
<div class="outline-text-5" id="text-1-3-2-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">vm_area_struct</span> <span style="color: #757575;">{</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#25351;&#21521; mm_struct</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">mm_struct</span> * <span style="color: #268bd2;">vm_mm</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">memory region &#30340;&#36215;&#22987;&#34394;&#25311;&#22320;&#22336;</span>
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span> <span style="color: #268bd2;">vm_start</span>;
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span> <span style="color: #268bd2;">vm_end</span>;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">mm_struct &#20013; mmap &#38142;&#34920;&#36890;&#36807; vm_next &#36830;&#25509;&#36215;&#26469;</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">vm_area_struct</span> *<span style="color: #268bd2;">vm_next</span>;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#36825;&#20010; memory region &#23545;&#24212;&#30340;&#34394;&#25311;&#22320;&#22336;&#33539;&#22260;&#20869;&#30340;&#25152;&#26377; pte &#30340;&#26435;&#38480;&#37096;&#20998;&#21644;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">vm_page_prot &#26159;&#19968;&#33268;&#30340;, page fault &#26102;&#20998;&#37197; pte &#26102;&#20250;&#32771;&#34385;&#36825;&#20010;&#20540;</span>
    <span style="color: #b58900;">pgprot_t</span> <span style="color: #268bd2;">vm_page_prot</span>;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">vm_area_struct &#30340; flag, &#21644;&#26435;&#38480;&#26816;&#26597;&#20197;&#21450; vm_area_struct &#30340;&#20854;&#23427;&#21151;&#33021;&#26377;&#20851;</span>
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span> <span style="color: #268bd2;">vm_flags</span>;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#19982; mm_struct &#20013;&#30340; mm_rb &#19968;&#36215;&#26500;&#25104; rb-tree</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">rb_node</span> <span style="color: #268bd2;">vm_rb</span>;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#21644; anonymous vma &#30340; reversed map &#26377;&#20851;</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">list_head</span> <span style="color: #268bd2;">anon_vma_node</span>;
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">anon_vma</span> *<span style="color: #268bd2;">anon_vma</span>;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#19981;&#21516;&#31867;&#22411;&#30340; vma (anonymous, file mapped) &#26377;&#19981;&#21516;&#30340; vm_ops, &#27604;&#36739;&#37325;&#35201;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#30340;&#26159; vm_ops-&gt;nopage, &#20915;&#23450;&#20102; page fault &#26102;&#22914;&#20309;&#20998;&#37197;&#29289;&#29702;&#39029;</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">vm_operations_struct</span> * <span style="color: #268bd2;">vm_ops</span>;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#33509; vma &#26159; file mapped, &#21017; vm_pgoff &#26159;&#25351; vma &#26144;&#23556;&#30340;&#21306;&#22495;&#23545;&#24212; file &#30340;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#36215;&#22987;&#20559;&#31227;&#37327; (mmap &#31995;&#32479;&#35843;&#29992;&#30340;&#26368;&#21518;&#19968;&#20010; off &#21442;&#25968;)</span>
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span> <span style="color: #268bd2;">vm_pgoff</span>;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#33509; vma &#26159; file mmaped, vm_file &#25351;&#23545;&#24212;&#30340; file</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">file</span> * <span style="color: #268bd2;">vm_file</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">...</span>
<span style="color: #757575;">}</span>;
</pre>
</div>


<div id="org99058e1" class="figure">
<p><img src="../extra/kernel_address_space_vma.png" alt="kernel_address_space_vma.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgf3daefa" class="outline-5">
<h5 id="orgf3daefa"><span class="section-number-5">1.3.2.2</span> vm_flags</h5>
<div class="outline-text-5" id="text-1-3-2-2">
<p>
和 "memory" 相关的 flags 有许多, 例如:
</p>

<ol class="org-ol">
<li><p>
PTE 中的 flags
</p>

<p>
Read/Write, Present, User/Supervisor 等, CPU 会直接使用这个 flag
</p></li>

<li><p>
page descriptor 中的 flags
</p>

<p>
参考 <a href="#org237ce19">Page Descriptor</a>, 主要是和 PFRA 有关, 例如 PG_referenced,
PG_lru, PG_active 等, CPU 并不会直接使用这个 flag
</p></li>
</ol>

<p>
除了以上两种, 还有一种 flag 是 vm_area_struct 的 vm_flags, 这个 flag
也不会被 CPU 直接使用, 而且它的功能很多
</p>
</div>

<ol class="org-ol">
<li><a id="org9bd9822"></a>Access Right 相关<br />
<div class="outline-text-6" id="text-1-3-2-2-1">
<ul class="org-ul">
<li>VM_READ</li>
<li>VM_WRITE</li>
<li>VM_EXEC</li>
</ul>

<p>
Access right 分为三种: 读, 写, 执行, 一般情况下, vma 的 access right
与对应的 PTE 的 flag 是一致的, 但有例外:
</p>

<ol class="org-ol">
<li>x86 中 PTE 中关于 access right 只有一个 bit: Read/Write, 但 vma 的三种权限需要三个 bit 才可以完整表示, 所以 linux 使用了如下的规则:

<ol class="org-ol">
<li>PTE 的 Read/Write 为 Read, 则表示 vma 有 VM_READ 和 VM_EXEC</li>

<li>PTE 的 Read/Write 为 Write, 则表示 vma 有 VM_READ, VM_WRITE 和 VM_EXEC</li>
</ol></li>

<li>为了支持 COW, vma 的 access right 与对应的 PTE 的 access right 是不一致的, 具体参考 page fault</li>
</ol>

<p>
mprotect 系统调用可以修改这些 flag
</p>
</div>
</li>

<li><a id="org108f2dc"></a>和栈有关<br />
<div class="outline-text-6" id="text-1-3-2-2-2">
<ul class="org-ul">
<li>VM_GROWSDOWN</li>
<li>VM_GROWSUP</li>
</ul>
</div>
</li>

<li><a id="org61f1a68"></a>和 PFRA 有关<br />
<div class="outline-text-6" id="text-1-3-2-2-3">
<ul class="org-ul">
<li>VM_LOCKED</li>
<li>VM_RESERVED</li>
</ul>

<p>
mlock 相关的系统调用可以修改这些 flag
</p>
</div>
</li>

<li><a id="org71658c2"></a>和 IO 预读有关<br />
<div class="outline-text-6" id="text-1-3-2-2-4">
<ul class="org-ul">
<li>VM_SEQ_READ</li>
<li>VM_RAND_READ</li>
</ul>

<p>
madvise 系统调用可以修改这些 flag
</p>
</div>
</li>

<li><a id="orgc83f9ee"></a>其它<br />
<div class="outline-text-6" id="text-1-3-2-2-5">
<ul class="org-ul">
<li>VM_DONTCOPY</li>
</ul>

<p>
madvise 系统调用可以修改这些 flag
</p>
</div>
</li>
</ol>
</div>

<div id="outline-container-org65f2361" class="outline-5">
<h5 id="org65f2361"><span class="section-number-5">1.3.2.3</span> find_vma</h5>
<div class="outline-text-5" id="text-1-3-2-3">
<p>
find_vma 是使用 mm_rb 和 vm_rb 这棵 RB tree 来查找相应的 vma
</p>
</div>
</div>

<div id="outline-container-org9e36f34" class="outline-5">
<h5 id="org9e36f34"><span class="section-number-5">1.3.2.4</span> get_unmapped_area</h5>
<div class="outline-text-5" id="text-1-3-2-4">
<p>
get_unmapped_area 决定了 mmap 时分配的区域的位置, 实际上, 存在两种不同的 get_unmapped_area 实现, 导致两种完全不同的 layout
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">get_unmapped_area</span>:
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#23545;&#20110; MAP_FIXED, &#30452;&#25509;&#36820;&#22238; addr</span>
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>flags &amp; MAP_FIXED<span style="color: #757575;">)</span>:
    <span style="color: #859900;">return</span> addr
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#26681;&#25454; arch_pick_mmap_layout &#30340;&#32467;&#26524;, &#21487;&#33021;&#35843;&#29992;&#21040; arch_get_unmapped_area</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#25110; arch_get_unmapped_area_topdown        </span>
  current-&gt;mm-&gt;get_unmapped_area<span style="color: #757575;">(</span>file<span style="color: #757575;">,</span> addr<span style="color: #757575;">,</span> len<span style="color: #757575;">,</span> pgoff<span style="color: #757575;">,</span> flags<span style="color: #757575;">)</span>;

</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org8b5b4e2"></a>arch_get_unmapped_area<br />
<div class="outline-text-6" id="text-1-3-2-4-1">
<p>
arch_get_unmapped_area 是从 TASK_UNMAPPED_BASE (1G) 处开始, 从低到高选择一块可用的区域, 这种方式适用于 stack 需要 "无限" 增长的情况: the
"classic" layout
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2;">arch_get_unmapped_area</span><span style="color: #757575;">()</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#33509; mmap &#26102;&#25351;&#23450;&#20102; addr &#19981;&#20026;&#38646;, &#19988;&#35813; [addr, addr+size] &#21018;&#22909;&#26159;&#21487;&#29992;&#30340;,</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#21017;&#30452;&#25509;&#36820;&#22238;        </span>
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>addr<span style="color: #757575;">)</span>:
    addr = PAGE_ALIGN<span style="color: #757575;">(</span>addr<span style="color: #757575;">)</span>;
  vma = find_vma<span style="color: #757575;">(</span>mm<span style="color: #757575;">,</span> addr<span style="color: #757575;">)</span>;
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>TASK_SIZE - len &gt;= addr &amp;&amp; <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>vma || addr + len &lt;= vma-&gt;vm_start<span style="color: #757575;">))</span>:
    <span style="color: #859900;">return</span> addr;
  <span style="color: #859900;">else</span>:
    <span style="color: #586e75;">// </span><span style="color: #586e75;">addr &#19981;&#21487;&#29992;, &#20174; mm-&gt;free_area_cache &#36825;&#20010; addr &#24320;&#22987;&#26597;&#25214;&#19968;&#20010;&#21487;&#29992;&#30340;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#21306;&#38388;, mm-&gt;free_area_cache &#21021;&#22987;&#20540;&#20026; TASK_UNMAPPED_BASE, &#20854;&#20540;&#20026;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">3G/3 = 1G, &#25152;&#20197; mmap &#19981;&#25351;&#23450; addr &#26102;&#33021;&#25343;&#21040;&#30340;&#22320;&#22336;&#37117;&#26159;&#20301;&#20110; 1G</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">(0x4000 0000)&#20197;&#21518;      </span>
    start_addr = addr = mm-&gt;free_area_cache;
    <span style="color: #268bd2; font-weight: bold;">full_search</span>:
    <span style="color: #859900;">for</span> <span style="color: #757575;">(</span>vma = find_vma<span style="color: #757575;">(</span>mm<span style="color: #757575;">,</span> addr<span style="color: #757575;">)</span>; ; vma = vma-&gt;vm_next<span style="color: #757575;">)</span>:
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#22238;&#32469;&#21040; TASK_UNMAPPED_BASE &#37325;&#26032;&#24320;&#22987;&#26597;&#25214;      </span>
      <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>TASK_SIZE - len &lt; addr<span style="color: #757575;">)</span>:
          <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>start_addr != TASK_UNMAPPED_BASE<span style="color: #757575;">)</span>:
            start_addr = addr = TASK_UNMAPPED_BASE;
          <span style="color: #859900;">goto</span> <span style="color: #268bd2; font-weight: bold;">full_search</span>;
      <span style="color: #859900;">else</span>:
        <span style="color: #859900;">return</span> -ENOMEM;
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#25214;&#21040;&#30446;&#26631;, &#26356;&#26032; mm-&gt;free_area_cache &#20197;&#20415;&#21518;&#32493; mmap &#20174;&#36825;&#20010;&#20301;&#32622;&#24320;</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#22987;&#26597;&#25214;        </span>
      <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>vma || addr + len &lt;= vma-&gt;vm_start<span style="color: #757575;">)</span>:
        mm-&gt;free_area_cache = addr + len;
      <span style="color: #859900;">return</span> addr;
      addr = vma-&gt;vm_end;

</pre>
</div>

<p>
一段 mmap(1G) 的代码运行时的 layout 为:
</p>

<pre class="example" id="org60a280f">
0000000008048000      4K r-x-- a.out
0000000008049000      4K rw--- a.out
000000000804a000    132K rw---   [ anon ]  &lt;--- heap
0000000055555000    136K r-x-- ld-2.23.so
0000000055577000      4K r---- ld-2.23.so
0000000055578000      4K rw--- ld-2.23.so
0000000055579000     12K r----   [ anon ]
000000005557c000      8K r-x--   [ anon ]
000000005557e000      4K rw---   [ anon ]
00000000555b0000   1720K r-x-- libc-2.23.so
000000005575e000      4K ----- libc-2.23.so
000000005575f000      8K r---- libc-2.23.so
0000000055761000      4K rw--- libc-2.23.so 
0000000055762000 1048592K rw---   [ anon ]  &lt;--- mmap 
00000000fffdc000    136K rw---   [ stack ]
</pre>


<div id="org8add7bc" class="figure">
<p><img src="../extra/kernel_mmap_layout_classic.png" alt="kernel_mmap_layout_classic.png" />
</p>
</div>
</div>
</li>

<li><a id="orge4a5c93"></a>arch_get_unmapped_area_topdown<br />
<div class="outline-text-6" id="text-1-3-2-4-2">
<p>
arch_get_unmapped_area_topdown 是从 stack 的 low-limit (base) 处开始从高到低来查找可用区域, 适用于 stack 大小固定的 layout: the "flexible"
layout.
</p>

<p>
正常情况下 stack 都不是 ulimited, 所以都是使用的这个方法
</p>

<p>
同样的一段 mmap(1G) 的代码运行进的 layout 为:
</p>

<pre class="example" id="org5e719fc">
0000000008048000      4K r-x-- a.out
0000000008049000      4K rw--- a.out
000000000804a000    132K rw---   [ anon ]  &lt;--- heap
00000000b7ded000 1048580K rw---   [ anon ] &lt;--- mmap
00000000f7dee000   1720K r-x-- libc-2.23.so
00000000f7f9c000      4K ----- libc-2.23.so
00000000f7f9d000      8K r---- libc-2.23.so
00000000f7f9f000      4K rw--- libc-2.23.so
00000000f7fa0000     12K rw---   [ anon ]
00000000f7fd4000      4K rw---   [ anon ]
00000000f7fd5000     12K r----   [ anon ]
00000000f7fd8000      8K r-x--   [ anon ]
00000000f7fda000    136K r-x-- ld-2.23.so
00000000f7ffc000      4K r---- ld-2.23.so
00000000f7ffd000      4K rw--- ld-2.23.so
00000000fffdc000    136K rw---   [ stack ]
</pre>


<div id="org410c2b3" class="figure">
<p><img src="../extra/kernel_mmap_layout_flexible.png" alt="kernel_mmap_layout_flexible.png" />
</p>
</div>
</div>
</li>

<li><a id="orge0f8d28"></a>arch_pick_mmap_layout<br />
<div class="outline-text-6" id="text-1-3-2-4-3">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">arch_pick_mmap_layout</span>:
  <span style="color: #586e75;">// </span><span style="color: #586e75;">Fall back to the standard layout if the personality bit is set, or</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">if the expected stack growth is unlimited:</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#33509; RLIMIT_STACK &#20026; unlimited, &#21017;&#36873;&#25321; arch_get_unmapped_area &#20174;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">TASK_UNMAPPED_BASE &#24320;&#22987;&#20174;&#20302;&#21040;&#39640;&#20998;&#37197;.</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#21542;&#21017;, &#20351;&#29992; arch_get_unmapped_area_topdown &#20174; stack &#30340; base &#22788;&#20174;&#39640;&#21040;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20302;&#20998;&#37197;  </span>
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>sysctl_legacy_va_layout || <span style="color: #757575;">(</span>current-&gt;personality &amp; ADDR_COMPAT_LAYOUT<span style="color: #757575;">)</span> ||
        current-&gt;signal-&gt;rlim[RLIMIT_STACK].rlim_cur == RLIM_INFINITY<span style="color: #757575;">)</span>:
    mm-&gt;mmap_base = TASK_UNMAPPED_BASE;
    mm-&gt;get_unmapped_area = arch_get_unmapped_area;
    mm-&gt;unmap_area = arch_unmap_area;
    <span style="color: #859900;">else</span>:
      mm-&gt;mmap_base = mmap_base<span style="color: #757575;">(</span>mm<span style="color: #757575;">)</span>;
      mm-&gt;get_unmapped_area = arch_get_unmapped_area_topdown;
      mm-&gt;unmap_area = arch_unmap_area_topdown;
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org3ef7e07" class="outline-5">
<h5 id="org3ef7e07"><span class="section-number-5">1.3.2.5</span> sys_mmap</h5>
<div class="outline-text-5" id="text-1-3-2-5">
<p>
mmap 系统调用用来建立 memory region
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">do_mmap</span>:
  <span style="color: #268bd2;">do_mmap_pgoff</span><span style="color: #757575;">(</span><span style="color: #b58900;">file</span><span style="color: #757575;">,</span> <span style="color: #b58900;">addr</span><span style="color: #757575;">,</span> <span style="color: #b58900;">len</span><span style="color: #757575;">,</span> <span style="color: #b58900;">prot</span><span style="color: #757575;">,</span> <span style="color: #b58900;">flag</span><span style="color: #757575;">,</span> offset &gt;&gt; PAGE_SHIFT<span style="color: #757575;">)</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#22312;&#34394;&#25311;&#22320;&#22336;&#31354;&#38388;&#19978;&#20998;&#37197;&#19968;&#22359;&#21512;&#36866;&#30340;&#21306;&#22495;</span>
    addr = get_unmapped_area<span style="color: #757575;">(</span>file<span style="color: #757575;">,</span> addr<span style="color: #757575;">,</span> len<span style="color: #757575;">,</span> pgoff<span style="color: #757575;">,</span> flags<span style="color: #757575;">)</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#23558; mmap &#30340;&#19968;&#20123;&#21442;&#25968; (prot, flags) &#36716;&#25442;&#20026; vm_flags</span>
    vm_flags = calc_vm_prot_bits<span style="color: #757575;">(</span>prot<span style="color: #757575;">)</span> | calc_vm_flag_bits<span style="color: #757575;">(</span>flags<span style="color: #757575;">)</span>
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>flags &amp; MAP_LOCKED<span style="color: #757575;">)</span>:
      vm_flags |= VM_LOCKED;

    inode = file ? file-&gt;f_dentry-&gt;d_inode : <span style="color: #268bd2; font-weight: bold;">NULL</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">file mapped</span>
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>file<span style="color: #757575;">)</span>:
      <span style="color: #859900;">switch</span> <span style="color: #757575;">(</span>flags &amp; MAP_TYPE<span style="color: #757575;">)</span>:
        <span style="color: #859900;">case</span> MAP_SHARED:
          <span style="color: #859900;">if</span> <span style="color: #757575;">((</span>prot&amp;PROT_WRITE<span style="color: #757575;">)</span> &amp;&amp; <span style="color: #b58900; font-weight: bold;">!</span><span style="color: #757575;">(</span>file-&gt;f_mode&amp;FMODE_WRITE<span style="color: #757575;">))</span>:
            <span style="color: #859900;">return</span> -EACCES;
          vm_flags |= VM_SHARED | VM_MAYSHARE;
          <span style="color: #586e75;">/* </span><span style="color: #586e75;">fall through</span><span style="color: #586e75;"> */</span>
        <span style="color: #859900;">case</span> MAP_PRIVATE:
          <span style="color: #586e75;">// </span><span style="color: #586e75;">&#23545;&#20110; MAP_PRIVATE, &#24182;&#19981;&#38656;&#35201;&#26816;&#26597;&#26159;&#21542;&#25991;&#20214;&#38656;&#35201; write &#26435;&#38480;, &#22240;&#20026;</span>
          <span style="color: #586e75;">// </span><span style="color: #586e75;">MAP_PRIVATE &#24182;&#19981;&#38656;&#35201;&#30495;&#27491;"&#20889;"&#21040;&#25991;&#20214;&#20013;</span>
          <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span><span style="color: #757575;">(</span>file-&gt;f_mode &amp; FMODE_READ<span style="color: #757575;">))</span>:
            <span style="color: #859900;">return</span> -EACCES;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">find_vma_prepare &#30340;&#20316;&#29992;&#26159;&#25214;&#21040; addr &#21069;&#38754;&#30340; vma, &#25918;&#22312; prev &#20013;(&#21644;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">vma_merge &#26377;&#20851;), &#20197;&#21450; addr &#20043;&#21518;&#30340; vma, &#36890;&#36807;&#36820;&#22238;&#20540;&#36820;&#22238;</span>
    <span style="color: #268bd2; font-weight: bold;">munmap_back</span>:
    vma = find_vma_prepare<span style="color: #757575;">(</span>mm<span style="color: #757575;">,</span> addr<span style="color: #757575;">,</span> &amp;prev<span style="color: #757575;">,</span> &amp;rb_link<span style="color: #757575;">,</span> &amp;rb_parent<span style="color: #757575;">)</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#22914;&#26524;&#21457;&#29616;&#24050;&#32463;&#23384;&#22312;&#30340;&#19968;&#20010; vma &#19982;&#35201;&#20998;&#37197;&#30340; [addr, addr+len] &#26377;&#37325;&#21512;,</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#21017;&#20808;&#23581;&#35797; unmap &#25481;&#20043;&#21069;&#30340; vma, &#36825;&#20010;&#34892;&#20026;&#21442;&#32771; mmap &#20013;&#20851;&#20110; MAP_FIXED</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#30340;&#35828;&#26126;. &#23454;&#29616;&#19978;, MAP_FIXED &#30340;&#38656;&#27714;&#23548;&#33268; get_unmapped_area &#24182;&#19981;&#33021;&#20445;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#35777;&#36820;&#22238;&#30340;[addr, addr+len] &#19968;&#23450;&#26159;"&#31354;&#38386;"&#30340;&#21306;&#38388; (&#21442;&#32771; get_unmapped_area)</span>
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>vma &amp;&amp; vma-&gt;vm_start &lt; addr + len<span style="color: #757575;">)</span>:
        do_munmap<span style="color: #757575;">(</span>mm<span style="color: #757575;">,</span> addr<span style="color: #757575;">,</span> len<span style="color: #757575;">)</span>
    <span style="color: #859900;">goto</span> <span style="color: #268bd2; font-weight: bold;">munmap_back</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#30495;&#27491;&#20998;&#37197;&#19968;&#20010; vma</span>
    vma = kmem_cache_alloc<span style="color: #757575;">(</span>vm_area_cachep<span style="color: #757575;">,</span> SLAB_KERNEL<span style="color: #757575;">)</span>;
    vma-&gt;vm_mm = mm;
    vma-&gt;vm_start = addr;
    vma-&gt;vm_end = addr + len;
    vma-&gt;vm_flags = vm_flags;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">protection_map &#23436;&#25104; vm_flags &#19982; PTE flags &#30340;&#26144;&#23556;, &#26144;&#23556;&#30340;&#35268;&#21017;&#21442;&#32771;&#21069;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#38754;&#30340;&#25551;&#36848; [[*Access Right &#30456;&#20851;][Access Right &#30456;&#20851;]]</span>
    vma-&gt;vm_page_prot = protection_map[vm_flags &amp; 0x0f];
    vma-&gt;vm_pgoff = pgoff;
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>file<span style="color: #757575;">)</span>:
      vma-&gt;vm_file = file;
      file-&gt;f_op-&gt;mmap<span style="color: #757575;">(</span>file<span style="color: #757575;">,</span> vma<span style="color: #757575;">)</span>;
    <span style="color: #859900;">else</span> <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>vm_flags &amp; VM_SHARED<span style="color: #757575;">)</span>:
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20026;&#20102;&#25903;&#25345; anonymous shared mapping (&#21363; mmap &#26102;&#25351;&#23450;&#20102; MAP_ANONYMOUS|MAP_SHARED)</span>
      shmem_zero_setup<span style="color: #757575;">(</span>vma<span style="color: #757575;">)</span>;
        file = shmem_file_setup<span style="color: #757575;">(</span><span style="color: #2aa198;">"dev/zero"</span><span style="color: #757575;">,</span> size<span style="color: #757575;">,</span> vma-&gt;vm_flags<span style="color: #757575;">)</span>;
        vma-&gt;vm_file = file;
        vma-&gt;vm_ops = &amp;shmem_vm_ops;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#19982;&#21069;&#21518;&#30340; vma &#36827;&#34892; merge</span>
    <span style="color: #268bd2;">vma_merge</span><span style="color: #757575;">(</span><span style="color: #b58900;">mm</span><span style="color: #757575;">,</span> <span style="color: #b58900;">prev</span><span style="color: #757575;">,</span> <span style="color: #b58900;">addr</span><span style="color: #757575;">,</span> ...<span style="color: #757575;">)</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#28155;&#21152;&#21040; mm_struct-&gt;mmap &#38142;&#34920;&#21450; mm_struct-&gt;mm_rb &#26641;&#20013;</span>
    <span style="color: #268bd2;">vma_link</span><span style="color: #757575;">(</span><span style="color: #b58900;">mm</span><span style="color: #757575;">,</span> <span style="color: #b58900;">vma</span><span style="color: #757575;">,</span> <span style="color: #b58900;">prev</span><span style="color: #757575;">,</span> <span style="color: #b58900;">rb_link</span><span style="color: #757575;">,</span> <span style="color: #b58900;">rb_parent</span><span style="color: #757575;">)</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#23545;&#20110; VM_LOCKED, &#30452;&#25509;&#20998;&#37197; page (&#36890;&#36807; handle_mm_fault)</span>
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>vm_flags &amp; VM_LOCKED<span style="color: #757575;">)</span>:
      make_pages_present<span style="color: #757575;">(</span>addr<span style="color: #757575;">,</span> addr + len<span style="color: #757575;">)</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#23545;&#20110; MAP_POPULATE, &#21516;&#26679;&#39044;&#20808;&#20998;&#37197; page (&#36890;&#36807; vm_ops-&gt;populate)</span>
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>flags &amp; MAP_POPULATE<span style="color: #757575;">)</span>:
        sys_remap_file_pages<span style="color: #757575;">(</span>addr<span style="color: #757575;">,</span> len<span style="color: #757575;">,</span> 0<span style="color: #757575;">,</span> pgoff<span style="color: #757575;">,</span> flags &amp; MAP_NONBLOCK<span style="color: #757575;">)</span>;
    <span style="color: #859900;">return</span> addr;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org5c6a68b" class="outline-4">
<h4 id="org5c6a68b"><span class="section-number-4">1.3.3</span> Page Fault</h4>
<div class="outline-text-4" id="text-1-3-3">
</div>
<div id="outline-container-org609d808" class="outline-5">
<h5 id="org609d808"><span class="section-number-5">1.3.3.1</span> Overview</h5>
<div class="outline-text-5" id="text-1-3-3-1">

<div id="orga65e889" class="figure">
<p><img src="../extra/kernel_page_fault.png" alt="kernel_page_fault.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org89d2bf2" class="outline-5">
<h5 id="org89d2bf2"><span class="section-number-5">1.3.3.2</span> error code</h5>
<div class="outline-text-5" id="text-1-3-3-2">
<p>
page fault 发生时, 硬件负责调用 do_page_fault 并提供一个 error code, 表示 page fault 的原因, error code 一共 5 bit, 从高到低依次是:
</p>

<ul class="org-ul">
<li><p>
present
</p>

<p>
若 present 为 0, 表示 page 没有 present 导致 page fault, 否则 page
present, 但 page 权限导致了 fault
</p></li>

<li><p>
write
</p>

<p>
若 write 为 0, 表示 page read 导致的 page fault, 否则, 表示 page
write 导致的 page fault
</p></li>

<li><p>
user
</p>

<p>
若 user 为 0, 表示发生在 kernel mode, 否则, 表示发生成 user mode
</p></li>

<li>reserved write</li>

<li>instruction fetch</li>
</ul>

<p>
最重要的低 3 bit, 例如:
</p>

<p>
当 !(error_code &amp; 5) 时, 表示 !(user|present), 则发生在 kernel mode,
而且 page 没有 present, 即 vmalloc_fault
</p>
</div>
</div>

<div id="outline-container-orgb56fbb9" class="outline-5">
<h5 id="orgb56fbb9"><span class="section-number-5">1.3.3.3</span> do_page_fault</h5>
<div class="outline-text-5" id="text-1-3-3-3">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2;">do_page_fault</span><span style="color: #757575;">(</span><span style="color: #859900;">struct</span> <span style="color: #b58900;">pt_regs</span> *<span style="color: #268bd2;">regs</span><span style="color: #757575;">,</span> <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span> <span style="color: #268bd2;">error_code</span><span style="color: #757575;">)</span>:
  <span style="color: #859900;">__asm__</span><span style="color: #757575;">(</span><span style="color: #2aa198;">"movl %%cr2,%0"</span>:<span style="color: #2aa198;">"=r"</span> <span style="color: #757575;">(</span>address<span style="color: #757575;">))</span>;
  tsk = current;
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>unlikely<span style="color: #757575;">(</span>address &gt;= TASK_SIZE<span style="color: #757575;">))</span>:
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span><span style="color: #757575;">(</span>error_code &amp; 5<span style="color: #757575;">))</span>:
      <span style="color: #859900;">goto</span> <span style="color: #268bd2; font-weight: bold;">vmalloc_fault</span>;
  <span style="color: #586e75;">// </span><span style="color: #586e75;">find_vma &#26159;&#22312;&#23547;&#25214;&#19968;&#20010; address &#20043;&#21518;&#31163; address &#26368;&#36817;&#30340; vma, &#32780;&#19981;&#19968;&#23450;&#26159;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">"&#21253;&#21547;" address &#30340; vma, &#20855;&#20307;&#30340;&#35828;, find_vma &#26159; `Look up the first VMA</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">which satisfies addr &lt; vm_end, NULL if none`.</span>
  <span style="color: #586e75;">// </span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20043;&#25152;&#20197;&#36825;&#26679;&#26159;&#20026;&#20102;&#22788;&#29702; expand_stack &#30340;&#24773;&#20917;  </span>

  vma = find_vma<span style="color: #757575;">(</span>mm<span style="color: #757575;">,</span> address<span style="color: #757575;">)</span>;
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>vma<span style="color: #757575;">)</span>:
    <span style="color: #859900;">goto</span> <span style="color: #268bd2; font-weight: bold;">bad_area</span>;
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>vma-&gt;vm_start &lt;= address<span style="color: #757575;">)</span>:
    <span style="color: #859900;">goto</span> <span style="color: #268bd2; font-weight: bold;">good_area</span>;
  <span style="color: #586e75;">// </span><span style="color: #586e75;">address &#22312; vma &#20043;&#21069;, &#33509; vma &#26159; growsdown, &#21017;&#21487;&#33021;&#26159;&#22312; push stack, &#21542;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#21017;, &#30452;&#25509; segment fault</span>
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span><span style="color: #757575;">(</span>vma-&gt;vm_flags &amp; VM_GROWSDOWN<span style="color: #757575;">))</span>:
    <span style="color: #859900;">goto</span> <span style="color: #268bd2; font-weight: bold;">bad_area</span>;
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>error_code &amp; 4<span style="color: #757575;">)</span>:
    <span style="color: #586e75;">/*</span>
<span style="color: #586e75;">     * accessing the stack below %esp is always a bug.</span>
<span style="color: #586e75;">     * The "+ 32" is there due to some instructions (like</span>
<span style="color: #586e75;">     * pusha) doing post-decrement on the stack and that</span>
<span style="color: #586e75;">     * doesn't show up until later..</span>
<span style="color: #586e75;">     */</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#36825;&#20010;&#21028;&#26029;&#23548;&#33268;&#26222;&#36890;&#30340;&#36890;&#36807; MAP_GROWSDOWN &#26144;&#23556;&#30340; VMA &#24182;&#19981;&#33021;&#20687; stack</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#37027;&#26679;&#25903;&#25345; auto expand</span>
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>address + 32 &lt; regs-&gt;esp<span style="color: #757575;">)</span>
        <span style="color: #859900;">goto</span> <span style="color: #268bd2; font-weight: bold;">bad_area</span>;

  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>expand_stack<span style="color: #757575;">(</span>vma<span style="color: #757575;">,</span> address<span style="color: #757575;">))</span>:
    <span style="color: #859900;">goto</span> <span style="color: #268bd2; font-weight: bold;">bad_area</span>;

  <span style="color: #268bd2; font-weight: bold;">good_area</span>:
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#26816;&#26597; error_code &#20013;&#30340; write &#21644; present &#20301;</span>
  <span style="color: #859900;">switch</span> <span style="color: #757575;">(</span>error_code &amp; 3<span style="color: #757575;">)</span>:
    <span style="color: #859900;">default</span>:
      <span style="color: #586e75;">// </span><span style="color: #586e75;">write, present</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#33509; vma &#21487;&#20889;, &#19988; page present, &#20294; PTE &#19981;&#21487;&#20889;, &#21017;&#20195;&#34920;&#36825;&#26159;&#19968;&#27425; COW</span>
    <span style="color: #859900;">case</span> 2:
      <span style="color: #586e75;">// </span><span style="color: #586e75;">write, not present</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">vma &#21487;&#20889;, &#20294; page not present, &#20195;&#34920;&#36825;&#26159;&#19968;&#20010; demanding page</span>
      <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span><span style="color: #757575;">(</span>vma-&gt;vm_flags &amp; VM_WRITE<span style="color: #757575;">))</span>:
          <span style="color: #859900;">goto</span> <span style="color: #268bd2; font-weight: bold;">bad_area</span>;
      write++;
      <span style="color: #859900;">break</span>;
    <span style="color: #859900;">case</span> 1:
      <span style="color: #586e75;">// </span><span style="color: #586e75;">read, present</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">page present &#20294;&#19981;&#33021; read? SEGV</span>
      <span style="color: #859900;">goto</span> <span style="color: #268bd2; font-weight: bold;">bad_area</span>;
    <span style="color: #859900;">case</span> 0:
      <span style="color: #586e75;">// </span><span style="color: #586e75;">read, not present</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">vma &#21487;&#35835;, &#20294; page not present, &#20195;&#34920;&#19968;&#27425; demanding page</span>
      <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span><span style="color: #757575;">(</span>vma-&gt;vm_flags &amp; <span style="color: #757575;">(</span>VM_READ | VM_EXEC<span style="color: #757575;">)))</span>:
        <span style="color: #859900;">goto</span> <span style="color: #268bd2; font-weight: bold;">bad_area</span>;

  <span style="color: #268bd2; font-weight: bold;">good_area</span>:
  ret = handle_mm_fault<span style="color: #757575;">(</span>mm<span style="color: #757575;">,</span> vma<span style="color: #757575;">,</span> address<span style="color: #757575;">,</span> write<span style="color: #757575;">)</span>;
    pte = pte_alloc_map<span style="color: #757575;">(</span>mm<span style="color: #757575;">,</span> pmd<span style="color: #757575;">,</span> address<span style="color: #757575;">)</span>;
    <span style="color: #268bd2;">handle_pte_fault</span><span style="color: #757575;">(</span><span style="color: #b58900;">mm</span><span style="color: #757575;">,</span> <span style="color: #b58900;">vma</span><span style="color: #757575;">,</span> <span style="color: #b58900;">address</span><span style="color: #757575;">,</span> <span style="color: #b58900;">write_access</span><span style="color: #757575;">,</span> <span style="color: #b58900;">pte</span><span style="color: #757575;">,</span> <span style="color: #b58900;">pmd</span><span style="color: #757575;">)</span>;
      <span style="color: #586e75;">// </span><span style="color: #586e75;">PTE not present, &#33509; PTE &#20026; 0, &#21017;&#34920;&#31034; demanding page, &#21542;&#21017; PTE &#30340;</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20540;&#20026; swap identifier, &#34920;&#31034; swap</span>
      <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>pte_present<span style="color: #757575;">(</span>entry<span style="color: #757575;">))</span>:
        <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>pte_none<span style="color: #757575;">(</span>entry<span style="color: #757575;">))</span>:
          <span style="color: #859900;">return</span> do_no_page<span style="color: #757575;">(</span>mm<span style="color: #757575;">,</span> vma<span style="color: #757575;">,</span> address<span style="color: #757575;">,</span> write_access<span style="color: #757575;">,</span> pte<span style="color: #757575;">,</span> pmd<span style="color: #757575;">)</span>;
        <span style="color: #859900;">else</span>:
          <span style="color: #859900;">return</span> do_swap_page<span style="color: #757575;">(</span>mm<span style="color: #757575;">,</span> vma<span style="color: #757575;">,</span> address<span style="color: #757575;">,</span> pte<span style="color: #757575;">,</span> pmd<span style="color: #757575;">,</span> entry<span style="color: #757575;">,</span> write_access<span style="color: #757575;">)</span>;
      <span style="color: #859900;">else</span>:
        <span style="color: #586e75;">// </span><span style="color: #586e75;">PTE present, &#20294; PTE &#19981;&#21487;&#20889;, &#32780; VMA &#21487;&#20889;, &#34920;&#31034; COW</span>
        <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>write_access<span style="color: #757575;">)</span>:
          <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>pte_write<span style="color: #757575;">(</span>entry<span style="color: #757575;">))</span>:
            <span style="color: #859900;">return</span> do_wp_page<span style="color: #757575;">(</span>mm<span style="color: #757575;">,</span> vma<span style="color: #757575;">,</span> address<span style="color: #757575;">,</span> pte<span style="color: #757575;">,</span> pmd<span style="color: #757575;">,</span> entry<span style="color: #757575;">)</span>;

  <span style="color: #859900;">switch</span> ret:
    <span style="color: #859900;">case</span> VM_FAULT_MINOR:
      tsk-&gt;min_flt++;
      <span style="color: #859900;">break</span>;
    <span style="color: #859900;">case</span> VM_FAULT_MAJOR:
      tsk-&gt;maj_flt++;
      <span style="color: #859900;">break</span>;
    <span style="color: #859900;">case</span> VM_FAULT_SIGBUS:
      <span style="color: #859900;">goto</span> <span style="color: #268bd2; font-weight: bold;">do_sigbus</span>;
    <span style="color: #859900;">case</span> VM_FAULT_OOM:
      <span style="color: #859900;">goto</span> <span style="color: #268bd2; font-weight: bold;">out_of_memory</span>;
        <span style="color: #268bd2;">do_exit</span><span style="color: #757575;">(</span><span style="color: #b58900;">SIGKILL</span><span style="color: #757575;">)</span>;
    <span style="color: #859900;">default</span>:
      <span style="color: #268bd2;">BUG</span><span style="color: #757575;">()</span>;

</pre>
</div>
</div>
</div>

<div id="outline-container-orgea449ea" class="outline-5">
<h5 id="orgea449ea"><span class="section-number-5">1.3.3.4</span> vmalloc_fault</h5>
<div class="outline-text-5" id="text-1-3-3-4">
<p>
vmalloc_fault 的功能是把 swapper_pg_dir 中对应的 PTE 同步到 current
task 的页表, 参考 <a href="#org02d3c0d">动态映射的部分 (ZONE_HIGHMEM)</a>
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">vmalloc_fault</span>:
  <span style="color: #b58900;">int</span> <span style="color: #268bd2;">index</span> = pgd_index<span style="color: #757575;">(</span>address<span style="color: #757575;">)</span>;
  <span style="color: #859900;">asm</span><span style="color: #757575;">(</span><span style="color: #2aa198;">"movl %%cr3,%0"</span>:<span style="color: #2aa198;">"=r"</span> <span style="color: #757575;">(</span>pgd_paddr<span style="color: #757575;">))</span>;
  <span style="color: #586e75;">// </span><span style="color: #586e75;">pgd &#26159;&#24403;&#21069;&#36827;&#31243;&#30340; page directory &#20013;&#23545;&#24212;&#30340;&#22320;&#20301;</span>
  pgd = index + <span style="color: #757575;">(</span><span style="color: #b58900;">pgd_t</span> *<span style="color: #757575;">)</span><span style="color: #268bd2;">__va</span><span style="color: #757575;">(</span><span style="color: #b58900;">pgd_paddr</span><span style="color: #757575;">)</span>;
  <span style="color: #586e75;">// </span><span style="color: #586e75;">init_mm.pgd &#21363; swapper_pg_dir</span>
  pgd_k = init_mm.pgd + index;
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#36825;&#37324;&#24182;&#27809;&#26377;&#21333;&#29420;&#35774;&#32622; PTE, &#32780;&#26159;&#30452;&#25509;&#35774;&#32622;&#20102; pgd</span>
  <span style="color: #268bd2;">set_pgd</span><span style="color: #757575;">(</span><span style="color: #b58900;">pgd</span><span style="color: #757575;">,</span> *pgd_k<span style="color: #757575;">)</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-org5717042" class="outline-5">
<h5 id="org5717042"><span class="section-number-5">1.3.3.5</span> expand_stack</h5>
<div class="outline-text-5" id="text-1-3-3-5">
</div>
<ol class="org-ol">
<li><a id="orgd315fd2"></a>expand_stack<br />
<div class="outline-text-6" id="text-1-3-3-5-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">expand_stack</span>:
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>address &lt; vma-&gt;vm_start<span style="color: #757575;">)</span>:
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span> size<span style="color: #757575;">,</span> grow;

    size = vma-&gt;vm_end - address;
    grow = <span style="color: #757575;">(</span>vma-&gt;vm_start - address<span style="color: #757575;">)</span> &gt;&gt; PAGE_SHIFT;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">acct_stack_growth &#20250;&#21435;&#26816;&#26597; rlim[RLIMIT_STACK] &#30830;&#20445; stack &#22823;&#23567;&#27809;&#26377;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#36229;&#36807; ulimit &#35774;&#23450;&#30340;&#20540;</span>
    error = acct_stack_growth<span style="color: #757575;">(</span>vma<span style="color: #757575;">,</span> size<span style="color: #757575;">,</span> grow<span style="color: #757575;">)</span>;
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>error<span style="color: #757575;">)</span>:
        vma-&gt;vm_start = address;
        vma-&gt;vm_pgoff -= grow;

</pre>
</div>
</div>
</li>

<li><a id="org9fcb0c0"></a>一段利用 expand_stack (或者 MAP_GROWSDOWN) 的代码<br />
<div class="outline-text-6" id="text-1-3-3-5-2">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;sys/mman.h&gt;</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #757575;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span><span style="color: #757575;">,</span> <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span>[]<span style="color: #757575;">)</span> <span style="color: #757575;">{</span>
    <span style="color: #b58900;">char</span> * <span style="color: #268bd2;">buf</span> = <span style="color: #757575;">(</span><span style="color: #b58900;">char</span> *<span style="color: #757575;">)</span> mmap<span style="color: #757575;">(</span>0<span style="color: #757575;">,</span> 40960<span style="color: #757575;">,</span> PROT_READ|PROT_WRITE<span style="color: #757575;">,</span> MAP_PRIVATE|MAP_ANONYMOUS|MAP_GROWSDOWN<span style="color: #757575;">,</span> 0<span style="color: #757575;">,</span> 0<span style="color: #757575;">)</span>;

    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">__sp</span> = <span style="color: #757575;">(</span><span style="color: #b58900;">int</span><span style="color: #757575;">)</span>buf;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20462;&#25913; sp &#30340;&#20540;&#20197;&#32469;&#36807; kernel &#23545; expand_stack &#30340;&#26816;&#26597;</span>
    <span style="color: #859900;">__asm__</span><span style="color: #757575;">(</span>
        <span style="color: #2aa198;">"mov  %0, %%esp\n\t"</span>                    \
        :
        :<span style="color: #2aa198;">"r"</span> <span style="color: #757575;">(</span>__sp<span style="color: #757575;">))</span>;

    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#36825;&#37324;&#27809;&#26377;&#25253;&#38169;, &#35828;&#26126; expand_stack &#25104;&#21151;&#20102;</span>
    buf[-1] = 1;

    <span style="color: #859900;">return</span> 0;
<span style="color: #757575;">}</span>
</pre>
</div>

<p>
实际上, expand_stack 的功能是应该避免使用的, 因为它可能会导致某些 vma
被意外的修改 <a href="http://lwn.net/Articles/294001/">MAP_GROWSUP &amp; MAP_GROWSDOWN removal</a>
</p>
</div>
</li>

<li><a id="orge6e3fc8"></a>pthread 与 stack<br />
<div class="outline-text-6" id="text-1-3-3-5-3">
<p>
pthread_create 在生成新的 stack 时也并没有使用 expand_stack 功能
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">pthread_create</span>:
  <span style="color: #b58900;">void</span>* <span style="color: #268bd2;">child_stack</span> = <span style="color: #268bd2; font-weight: bold;">NULL</span>;
  __allocate_thread<span style="color: #757575;">(</span>&amp;thread_attr<span style="color: #757575;">,</span> &amp;thread<span style="color: #757575;">,</span> &amp;child_stack<span style="color: #757575;">)</span>;
    attr-&gt;stack_base = __create_thread_mapped_space<span style="color: #757575;">(</span>mmap_size<span style="color: #757575;">,</span> attr-&gt;guard_size<span style="color: #757575;">)</span>;
      <span style="color: #b58900;">int</span> <span style="color: #268bd2;">prot</span> = PROT_READ | PROT_WRITE;
      <span style="color: #b58900;">int</span> <span style="color: #268bd2;">flags</span> = MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE;
      <span style="color: #859900;">return</span> mmap<span style="color: #757575;">(</span><span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #757575;">,</span> mmap_size<span style="color: #757575;">,</span> prot<span style="color: #757575;">,</span> flags<span style="color: #757575;">,</span> -1<span style="color: #757575;">,</span> 0<span style="color: #757575;">)</span>;
    stack_top = reinterpret_cast&lt;uint8_t*&gt;<span style="color: #757575;">(</span>attr-&gt;stack_base<span style="color: #757575;">)</span> + mmap_size;
    *child_stack = stack_top;
  <span style="color: #b58900;">int</span> <span style="color: #268bd2;">flags</span> = CLONE_VM | CLONE_FS | CLONE_FILES |
      CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM |
      CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID;
  <span style="color: #268bd2;">clone</span><span style="color: #757575;">(</span><span style="color: #b58900;">__pthread_start</span><span style="color: #757575;">,</span> <span style="color: #b58900;">child_stack</span><span style="color: #757575;">,</span> <span style="color: #b58900;">flags</span><span style="color: #757575;">,</span> <span style="color: #b58900;">thread</span><span style="color: #757575;">,</span> &amp;<span style="color: #757575;">(</span>thread-&gt;tid<span style="color: #757575;">),</span> <span style="color: #b58900;">tls</span><span style="color: #757575;">,</span> &amp;<span style="color: #757575;">(</span>thread-&gt;tid<span style="color: #757575;">))</span>;
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-orgf79adff" class="outline-5">
<h5 id="orgf79adff"><span class="section-number-5">1.3.3.6</span> do_no_page</h5>
<div class="outline-text-5" id="text-1-3-3-6">
<p>
Demanding page
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">do_no_page</span>:
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>vma-&gt;vm_ops || <span style="color: #b58900; font-weight: bold;">!</span>vma-&gt;vm_ops-&gt;nopage<span style="color: #757575;">)</span>:
    <span style="color: #586e75;">// </span><span style="color: #586e75;">do_anonymous_page &#23545;&#24212; private anonymous mapping  (MAP_PRIVATE|MAP_ANONYMOUS)</span>
    <span style="color: #859900;">return</span> do_anonymous_page<span style="color: #757575;">(</span>mm<span style="color: #757575;">,</span> vma<span style="color: #757575;">,</span> page_table<span style="color: #757575;">,</span> pmd<span style="color: #757575;">,</span> write_access<span style="color: #757575;">,</span> address<span style="color: #757575;">)</span>;
  <span style="color: #859900;">else</span>:
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#38500;&#20102; driver &#33258;&#24049;&#23454;&#29616; mmap, &#33267;&#23569;&#36824;&#26377;&#20004;&#31181;&#24773;&#20917;&#19979; vm_ops-&gt;nopage &#20250;&#26377;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20540;:</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">1. file mapping, vm_ops-&gt;nopage &#25351;&#21521; filemap_nopage</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">2. shared anonymous mapping, vm_ops-&gt;nopage &#25351;&#21521; shmem_nopage</span>
    new_page = vma-&gt;vm_ops-&gt;nopage<span style="color: #757575;">(</span>vma<span style="color: #757575;">,</span> address &amp; PAGE_MASK<span style="color: #757575;">,</span> &amp;ret<span style="color: #757575;">)</span>;

  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#38500;&#20102; fork &#22806;, private file mapping &#26159; COW &#30340;&#21478;&#19968;&#31181;&#24773;&#20917;, &#34429;&#28982;&#24403;&#21069;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">page fault &#30340;&#21407;&#22240;&#26159; "pte not present", &#20294;&#22240;&#20026; write_access &#20026; true,</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#34920;&#31034; page fault &#30340;&#21407;&#22240;&#26159; write, &#25152;&#20197;&#36825;&#37324;&#25552;&#21069;&#20570; "early COW break", &#22914;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#26524;&#36825;&#37324;&#19981;&#20570;, &#26412;&#27425; page fault &#36820;&#22238;&#21518;&#39532;&#19978;&#20063;&#24517;&#23450;&#20250;&#22240;&#20026; COW &#23548;&#33268;&#21478;&#19968;&#27425;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">page fault</span>
  <span style="color: #586e75;">//</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#22914;&#26524;&#36825;&#37324;&#19981;&#20570; "early COW break", &#21017; do_no_page &#21518;&#38754;&#24182;&#19981;&#33021;&#31616;&#21333;&#30340;&#36890;&#36807;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">mk_pte(new_page, vma-&gt;vm_page_prot) &#26469;&#35774;&#32622; PTE, &#32780;&#26159;&#35201;&#25353;&#29031; COW &#30340;&#35201;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#27714;&#26469;&#35774;&#32622; PTE</span>
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>write_access &amp;&amp; <span style="color: #b58900; font-weight: bold;">!</span><span style="color: #757575;">(</span>vma-&gt;vm_flags &amp; VM_SHARED<span style="color: #757575;">))</span>:
    <span style="color: #859900;">struct</span> page *page;

    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>unlikely<span style="color: #757575;">(</span>anon_vma_prepare<span style="color: #757575;">(</span>vma<span style="color: #757575;">)))</span>
        <span style="color: #859900;">goto</span> <span style="color: #268bd2; font-weight: bold;">oom</span>;
    page = alloc_page_vma<span style="color: #757575;">(</span>GFP_HIGHUSER<span style="color: #757575;">,</span> vma<span style="color: #757575;">,</span> address<span style="color: #757575;">)</span>;
    <span style="color: #268bd2;">copy_user_highpage</span><span style="color: #757575;">(</span><span style="color: #b58900;">page</span><span style="color: #757575;">,</span> <span style="color: #b58900;">new_page</span><span style="color: #757575;">,</span> <span style="color: #b58900;">address</span><span style="color: #757575;">)</span>;
    <span style="color: #268bd2;">page_cache_release</span><span style="color: #757575;">(</span><span style="color: #b58900;">new_page</span><span style="color: #757575;">)</span>;
    new_page = page;
    anon = 1;

  entry = mk_pte<span style="color: #757575;">(</span>new_page<span style="color: #757575;">,</span> vma-&gt;vm_page_prot<span style="color: #757575;">)</span>;
  <span style="color: #268bd2;">set_pte</span><span style="color: #757575;">(</span><span style="color: #b58900;">page_table</span><span style="color: #757575;">,</span> <span style="color: #b58900;">entry</span><span style="color: #757575;">)</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-orge00c5ed" class="outline-5">
<h5 id="orge00c5ed"><span class="section-number-5">1.3.3.7</span> do_swap_page</h5>
<div class="outline-text-5" id="text-1-3-3-7">
<p>
参考 <a href="#org9023385">Swap In</a>
</p>
</div>
</div>

<div id="outline-container-org02aa070" class="outline-5">
<h5 id="org02aa070"><span class="section-number-5">1.3.3.8</span> do_wp_page</h5>
<div class="outline-text-5" id="text-1-3-3-8">
<p>
COW, 参考 <a href="#orga5f43ed">Copy On Write</a>
</p>
</div>
</div>

<div id="outline-container-orgf48ac39" class="outline-5">
<h5 id="orgf48ac39"><span class="section-number-5">1.3.3.9</span> 关于 SIGBUS</h5>
<div class="outline-text-5" id="text-1-3-3-9">
<p>
一般情况下, handle_mm_fault 返回 VM_FAULT_MAJOR 或 VM_FAULT_MAJOR, 但也有可能返回 VM_FAULT_OOM 或 VM_FAULT_SIGBUS.
</p>

<p>
其中对于 VM_FAULT_SIGBUS, 除了和硬件相关的错误, 最常见的一种情况是这样的:
</p>

<div class="org-src-container">
<pre class="src src-c">handle_pte_fault
  <span style="color: #b58900;">do_file_page</span>
    <span style="color: #268bd2;">vma</span>-&gt;vm_ops-&gt;populate
      filemap_populate
        <span style="color: #586e75;">// </span><span style="color: #586e75;">pgoff + len &gt; size? &#21487;&#33021; file &#34987; truncate &#20102;</span>
        <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>pgoff + <span style="color: #757575;">(</span>len &gt;&gt; PAGE_CACHE_SHIFT<span style="color: #757575;">)</span> &gt; size<span style="color: #757575;">)</span>:
          <span style="color: #859900;">return</span> -EINVAL;
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>err == -ENOMEM<span style="color: #757575;">)</span>:
    <span style="color: #859900;">return</span> VM_FAULT_OOM;
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>err<span style="color: #757575;">)</span>:
    <span style="color: #586e75;">// </span><span style="color: #586e75;">filemap_populate &#36820;&#22238;&#38750; ENOMEM, &#20363;&#22914; EINVAL, &#23548;&#33268;&#36825;&#37324;&#20250;&#36820;&#22238; SIGBUS</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">...</span>
    <span style="color: #859900;">return</span> VM_FAULT_SIGBUS;
  <span style="color: #859900;">return</span> VM_FAULT_MAJOR;
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org4a10846" class="outline-4">
<h4 id="org4a10846"><span class="section-number-4">1.3.4</span> Creating Process Address Space</h4>
<div class="outline-text-4" id="text-1-3-4">
</div>
<div id="outline-container-org9cc32fa" class="outline-5">
<h5 id="org9cc32fa"><span class="section-number-5">1.3.4.1</span> fork</h5>
<div class="outline-text-5" id="text-1-3-4-1">
<p>
一般情况下 fork 时的 copy_mm 是创建 process address space 的主要入口,
参考 <a href="#org144d084">Process page table 初始化</a>
</p>
</div>
</div>

<div id="outline-container-org50a1e48" class="outline-5">
<h5 id="org50a1e48"><span class="section-number-5">1.3.4.2</span> exec</h5>
<div class="outline-text-5" id="text-1-3-4-2">
<p>
参考 <a href="program_exzecution.html#orgc929912">do_execve</a>
</p>
</div>
</div>
</div>

<div id="outline-container-orgc30e680" class="outline-4">
<h4 id="orgc30e680"><span class="section-number-4">1.3.5</span> Managing the Heap</h4>
<div class="outline-text-4" id="text-1-3-5">
<p>
Managing the heap, linux 下主要是依靠 brk 系统调用
</p>
</div>

<div id="outline-container-org54e5958" class="outline-5">
<h5 id="org54e5958"><span class="section-number-5">1.3.5.1</span> brk</h5>
<div class="outline-text-5" id="text-1-3-5-1">
<p>
libc 有两个和 brk 相关的函数:
</p>

<ol class="org-ol">
<li>brk</li>

<li>sbrk</li>
</ol>

<p>
在 linux 里都是通过 sys_brk 实现的.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2;">sys_brk</span><span style="color: #757575;">(</span><span style="color: #b58900;">brk</span><span style="color: #757575;">)</span>:
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#33509; brk &#23567;&#20110;&#24403;&#21069;&#30340; end_code, &#30452;&#25509;&#36820;&#22238;&#24403;&#21069;&#30340; brk, &#33267;&#20110;&#20026;&#21861;&#26159;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">end_code&#32780;&#19981;&#26159; start_brk ... &#25105;&#26159;&#24819;&#19981;&#36890;&#30340;, &#22240;&#20026;&#20869;&#23384;&#24067;&#23616;&#19978;&#22522;&#26412;&#26159;</span>
  <span style="color: #586e75;">// </span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">[start_code, end_code] [start_data, end_data] [start_brk, brk].</span>
  <span style="color: #586e75;">// </span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">kernel 3.18 &#24182;&#19981;&#26159;&#21644; end_code &#27604;&#36739;, &#32780;&#26159;&#21644; start_brk &#25110; end_data &#27604;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#36739; (&#21462;&#20915;&#20110; brk &#26159;&#21542;&#26377; randomize &#30340;&#37197;&#32622;), &#25152;&#20197;&#25105;&#35748;&#20026;&#36825;&#21487;&#33021;&#26159; kernel</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">2.6.11  &#30340; bug...</span>
  <span style="color: #586e75;">// </span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20294;&#36825;&#19968;&#34892;&#20195;&#30721;&#23548;&#33268; sys_brk &#21487;&#20197;&#25903;&#25345; libc &#30340; sbrk(0)    </span>

  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>brk &lt; mm-&gt;end_code<span style="color: #757575;">)</span>:
    <span style="color: #859900;">goto</span> <span style="color: #268bd2; font-weight: bold;">out</span>;

  newbrk = PAGE_ALIGN<span style="color: #757575;">(</span>brk<span style="color: #757575;">)</span>;
  oldbrk = PAGE_ALIGN<span style="color: #757575;">(</span>mm-&gt;brk<span style="color: #757575;">)</span>;
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>oldbrk == newbrk<span style="color: #757575;">)</span>:
    <span style="color: #859900;">goto</span> <span style="color: #268bd2; font-weight: bold;">set_brk</span>;

  <span style="color: #586e75;">// </span><span style="color: #586e75;">shrink brk &#24517;&#28982;&#20250;&#25104;&#21151;</span>
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>brk &lt;= mm-&gt;brk<span style="color: #757575;">)</span>:
    do_munmap<span style="color: #757575;">(</span>mm<span style="color: #757575;">,</span> newbrk<span style="color: #757575;">,</span> oldbrk-newbrk<span style="color: #757575;">)</span>
    <span style="color: #859900;">goto</span> <span style="color: #268bd2; font-weight: bold;">out</span>;

  <span style="color: #586e75;">// </span><span style="color: #586e75;">brk &#21463; RLIMIT_DATA &#30340;&#38480;&#21046;</span>
  rlim = current-&gt;signal-&gt;rlim[RLIMIT_DATA].rlim_cur;
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>rlim &lt; RLIM_INFINITY &amp;&amp; brk - mm-&gt;start_data &gt; rlim<span style="color: #757575;">)</span>:
    <span style="color: #859900;">goto</span> <span style="color: #268bd2; font-weight: bold;">out</span>;

  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#33509;&#22312;&#24403;&#21069; brk &#22522;&#30784;&#19978;&#23581;&#35797;&#21521;&#21518;&#36890;&#36807; mmap &#25193;&#23637;&#21040;&#26032;&#30340; brk &#26102;&#21457;&#29616;&#24050;&#32463;&#23384;&#22312;&#21478;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#19968;&#20010; mmap &#23548;&#33268;&#26080;&#27861;&#25193;&#23637;, &#21017;&#30452;&#25509;&#25253;&#38169;  </span>
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>find_vma_intersection<span style="color: #757575;">(</span>mm<span style="color: #757575;">,</span> oldbrk<span style="color: #757575;">,</span> newbrk+PAGE_SIZE<span style="color: #757575;">))</span>:
    <span style="color: #859900;">goto</span> <span style="color: #268bd2; font-weight: bold;">out</span>;

  <span style="color: #586e75;">// </span><span style="color: #586e75;">do_brk &#19982; do_mmap &#24046;&#19981;&#22810;</span>
  <span style="color: #268bd2;">do_brk</span><span style="color: #757575;">(</span><span style="color: #b58900;">oldbrk</span><span style="color: #757575;">,</span> newbrk-oldbrk<span style="color: #757575;">)</span>

out:
  <span style="color: #586e75;">// </span><span style="color: #586e75;">sys_brk &#20250;&#36820;&#22238;&#24403;&#21069;&#30340; brk</span>
  retval = mm-&gt;brk;
</pre>
</div>

<p>
heap 为何会与其它的vma 产生 intersection?  参考 <a href="#org9e36f34">get_unmapped_area</a>
</p>
</div>
</div>

<div id="outline-container-orgdae908f" class="outline-5">
<h5 id="orgdae908f"><span class="section-number-5">1.3.5.2</span> 关于 malloc</h5>
<div class="outline-text-5" id="text-1-3-5-2">
<p>
malloc 涉及到底层内存分配时, 如果发现 heap 需要扩展, 则会使用如下的逻辑:
</p>

<ol class="org-ol">
<li>优先使用 MORECORE 来扩展, MORECORE 是 libc 中对 "sbrk-style system
routine" 的称呼, 一般来说 MORECORE 就是 sbrk, 但也允许用其它方式来模拟 sbrk 的过程</li>

<li>若 MORECORE 失败, 例如 sbrk 因为 vma intersection 的原因无法扩展,
则 libc 会尝试 MMAP 来扩展 heap.</li>

<li>若一次 malloc 的大小超过 DEFAULT_MMAP_THRESHOLD (256K), 则会直接使用
MMAP 来分配</li>
</ol>

<p>
以上是 malloc 的逻辑.
</p>

<p>
除此之外, libc 还支持 mspace<sub>malloc, free, realloc, &#x2026;</sub>, mspace_xxx
支持用户自己通过 create_space 创建一块内存池, 后续的 mspace_xxx 都会操作这块 mspace, 而不再与 heap 打交道.
</p>

<p>
例如, dalvik 把对象都分配在 Dalvik/ART heap 上, Dalvik/ART heap 实际上就是一个 mspace, Dalvik/ART 最终是依靠 mspace_malloc 来分配 java 对象的
</p>
</div>
</div>
</div>

<div id="outline-container-org296b1aa" class="outline-4">
<h4 id="org296b1aa"><span class="section-number-4">1.3.6</span> API</h4>
<div class="outline-text-4" id="text-1-3-6">
<p>
和进程地址空间相关的 API, 除了 mmap, 还有以下几个:
</p>
</div>

<div id="outline-container-org91c7a7d" class="outline-5">
<h5 id="org91c7a7d"><span class="section-number-5">1.3.6.1</span> madvise</h5>
<div class="outline-text-5" id="text-1-3-6-1">
<p>
madvise 的主要设置几类的 advice:
</p>

<ol class="org-ol">
<li><p>
和 IO 预读有关  
</p>

<ol class="org-ol">
<li>MADV_NORMAL</li>

<li>MADV_RANDOM</li>

<li>MADV_SEQUENTIAL</li>
</ol>

<p>
这几个 advice 与 vma 的 flags 对应
</p></li>

<li>和 vma 的 VM_DONTCOPY flag 对应

<ol class="org-ol">
<li>MADV_DONTFORK</li>

<li>MADV_DOFORK</li>
</ol></li>

<li>和 coredump 有关

<ol class="org-ol">
<li>MADV_DONTDUMP</li>

<li>MADV_DODUMP</li>
</ol></li>

<li><p>
和 PFRA 有关
</p>

<ol class="org-ol">
<li>MADV_WILLNEED</li>

<li>MADV_DONTNEED</li>
</ol>

<p>
应用的一些 memory trim 的过程通过会通过设置 MADV_DONTNEED 使 kernel
回收不需要的内存以达到 trim 的目的.
</p></li>
</ol>
</div>
</div>

<div id="outline-container-orge25603c" class="outline-5">
<h5 id="orge25603c"><span class="section-number-5">1.3.6.2</span> mprotect</h5>
<div class="outline-text-5" id="text-1-3-6-2">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2;">sys_mprotect</span> <span style="color: #757575;">(</span><span style="color: #b58900;">start</span><span style="color: #757575;">,</span> <span style="color: #b58900;">len</span><span style="color: #757575;">,</span> <span style="color: #b58900;">prot</span><span style="color: #757575;">)</span>:
  <span style="color: #586e75;">// </span><span style="color: #586e75;">start &#38656;&#35201;&#19982; 4K &#23545;&#40784;</span>
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>start &amp; ~PAGE_MASK<span style="color: #757575;">)</span>:
    <span style="color: #859900;">return</span> -EINVAL;
  <span style="color: #586e75;">// </span><span style="color: #586e75;">len &#20063;&#38656;&#35201;&#19982; 4K &#23545;&#40784;</span>
  len = PAGE_ALIGN<span style="color: #757575;">(</span>len<span style="color: #757575;">)</span>;
  end = start + len;

  vm_flags = calc_vm_prot_bits<span style="color: #757575;">(</span>prot<span style="color: #757575;">)</span>;
  vma = find_vma_prev<span style="color: #757575;">(</span>current-&gt;mm<span style="color: #757575;">,</span> start<span style="color: #757575;">,</span> &amp;prev<span style="color: #757575;">)</span>;
  <span style="color: #859900;">for</span> <span style="color: #757575;">(</span>nstart = start ; ; <span style="color: #757575;">)</span>:
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#26032;&#30340; vma flag</span>
    newflags = vm_flags | <span style="color: #757575;">(</span>vma-&gt;vm_flags &amp; ~<span style="color: #757575;">(</span>VM_READ | VM_WRITE | VM_EXEC<span style="color: #757575;">))</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">mprotect &#30340; (start, len) &#21487;&#33021;&#36328;&#36807;&#22810;&#20010; vma, &#25152;&#20197;&#36825;&#37324;&#38656;&#35201;&#22312;&#19968;&#20010;&#24490;&#29615;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#37324;&#21435;&#22788;&#29702;&#25152;&#26377;&#28041;&#21450;&#30340; vma    </span>
    tmp = vma-&gt;vm_end;
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>tmp &gt; end<span style="color: #757575;">)</span>:
      tmp = end;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">mprotect_fixup &#38656;&#35201;&#23436;&#25104;&#20197;&#19979;&#20219;&#21153;:</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">1. &#35774;&#32622; vma &#30340; flags</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">2. &#35774;&#32622;&#30456;&#24212;&#30340; page &#30340; flag</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">3. &#23545; vma &#36827;&#34892;&#21512;&#24182;&#25110;&#25286;&#20998;    </span>
    <span style="color: #268bd2;">mprotect_fixup</span><span style="color: #757575;">(</span><span style="color: #b58900;">vma</span><span style="color: #757575;">,</span> &amp;prev<span style="color: #757575;">,</span> <span style="color: #b58900;">nstart</span><span style="color: #757575;">,</span> <span style="color: #b58900;">tmp</span><span style="color: #757575;">,</span> <span style="color: #b58900;">newflags</span><span style="color: #757575;">)</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20934;&#22791;&#22788;&#29702;&#19979;&#19968;&#20010; vma, &#36825;&#37324;&#30340; prev &#20195;&#34920;&#24403;&#21069;&#24050;&#32463;&#22788;&#29702;&#36807;&#30340; vma    </span>
    nstart = tmp;
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>nstart &lt; prev-&gt;vm_end<span style="color: #757575;">)</span>
      nstart = prev-&gt;vm_end;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#25152;&#26377; vma &#37117;&#22788;&#29702;&#23436;&#27605;, &#36820;&#22238;</span>
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>nstart &gt;= end<span style="color: #757575;">)</span>:
      <span style="color: #859900;">goto</span> <span style="color: #268bd2; font-weight: bold;">out</span>;
    vma = prev-&gt;vm_next;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2;">mprotect_fixup</span><span style="color: #757575;">(</span><span style="color: #b58900;">vma</span><span style="color: #757575;">,</span> &amp;prev<span style="color: #757575;">,</span> <span style="color: #b58900;">nstart</span><span style="color: #757575;">,</span> <span style="color: #b58900;">tmp</span><span style="color: #757575;">,</span> <span style="color: #b58900;">newflags</span><span style="color: #757575;">)</span>:
  <span style="color: #586e75;">// </span><span style="color: #586e75;">vma &#26159;&#24403;&#38656;&#35201;&#22788;&#29702;&#30340; vma, (nstart, tmp) &#34920;&#31034;&#22320;&#22336;&#33539;&#22260;, newflags &#34920;&#31034;&#26032;&#30340; flag</span>
  oldflags = vma-&gt;vm_flags;
  nrpages = <span style="color: #757575;">(</span>end - start<span style="color: #757575;">)</span> &gt;&gt; PAGE_SHIFT;
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#24403;&#21069; vma &#19981;&#38656;&#35201;&#25913;&#21464;, &#36890;&#36807;&#23558; pprev &#35774;&#32622;&#20026; vma &#20351;&#24471;&#21518;&#38754;&#32487;&#32493;&#22788;&#29702; vma-&gt;next</span>
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>newflags == oldflags<span style="color: #757575;">)</span>:
    *pprev = vma;
    <span style="color: #859900;">return</span> 0;
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#26681;&#25454; newflags &#35745;&#31639; PTE &#23545;&#24212;&#30340;&#26435;&#38480;&#20301;    </span>
  newprot = protection_map[newflags &amp; 0xf];
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#39318;&#20808;, &#23581;&#35797;&#19982;&#21069;&#21518; vma &#21512;&#24182;  </span>
  pgoff = vma-&gt;vm_pgoff + <span style="color: #757575;">((</span>start - vma-&gt;vm_start<span style="color: #757575;">)</span> &gt;&gt; PAGE_SHIFT<span style="color: #757575;">)</span>;
  *pprev = vma_merge<span style="color: #757575;">(</span>mm<span style="color: #757575;">,</span> *pprev<span style="color: #757575;">,</span> start<span style="color: #757575;">,</span> end<span style="color: #757575;">,</span> newflags<span style="color: #757575;">,</span> vma-&gt;anon_vma<span style="color: #757575;">,</span> vma-&gt;vm_file<span style="color: #757575;">,</span> pgoff<span style="color: #757575;">,</span> vma_policy<span style="color: #757575;">(</span>vma<span style="color: #757575;">))</span>;

  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#25286;&#20998; vma, &#22240;&#20026; (start, end) &#24182;&#19981;&#23545;&#24212;&#25972;&#20010; vma  </span>
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>start != vma-&gt;vm_start<span style="color: #757575;">)</span>:
    split_vma<span style="color: #757575;">(</span>mm<span style="color: #757575;">,</span> vma<span style="color: #757575;">,</span> start<span style="color: #757575;">,</span> 1<span style="color: #757575;">)</span>;

  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>end != vma-&gt;vm_end<span style="color: #757575;">)</span>:
    split_vma<span style="color: #757575;">(</span>mm<span style="color: #757575;">,</span> vma<span style="color: #757575;">,</span> end<span style="color: #757575;">,</span> 0<span style="color: #757575;">)</span>;

  *pprev = vma;

  vma-&gt;vm_flags = newflags;
  vma-&gt;vm_page_prot = newprot;
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20462;&#25913; PTE &#30340; &#26435;&#38480;&#20301;</span>
  <span style="color: #268bd2;">change_protection</span><span style="color: #757575;">(</span><span style="color: #b58900;">vma</span><span style="color: #757575;">,</span> <span style="color: #b58900;">start</span><span style="color: #757575;">,</span> <span style="color: #b58900;">end</span><span style="color: #757575;">,</span> <span style="color: #b58900;">newprot</span><span style="color: #757575;">)</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-org3272251" class="outline-5">
<h5 id="org3272251"><span class="section-number-5">1.3.6.3</span> mlock</h5>
</div>

<div id="outline-container-orgd3b360f" class="outline-5">
<h5 id="orgd3b360f"><span class="section-number-5">1.3.6.4</span> mlockall</h5>
</div>

<div id="outline-container-org802ab92" class="outline-5">
<h5 id="org802ab92"><span class="section-number-5">1.3.6.5</span> prctl</h5>
</div>
</div>
</div>

<div id="outline-container-org7dbe60e" class="outline-3">
<h3 id="org7dbe60e"><span class="section-number-3">1.4</span> 页面回收</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-orgf064367" class="outline-4">
<h4 id="orgf064367"><span class="section-number-4">1.4.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
页面回收算法 (Page Frame Reclaiming Algorithm, PFRA) 的目标是选择一个 none-free page
frame 交还给 buddy system 以实现 page 的回收.
</p>

<p>
page frame, 根据它们的内容和用法, 分为以下几类:
</p>

<ol class="org-ol">
<li><p>
Unreclaimalbe
</p>

<p>
不可回收的 page, 具体包括:
</p>

<ol class="org-ol">
<li><p>
free pages
</p>

<p>
本身已经受 buddy system 管理的 page
</p></li>

<li>PG_reserved</li>

<li>PG_slab</li>

<li>PG_locked</li>

<li>VM_LOCKED (mlock)</li>
</ol></li>

<li>Swappable

<ol class="org-ol">
<li>Anonymous mapped pages of user space</li>

<li>tmpfs</li>
</ol></li>

<li>Syncable

<ol class="org-ol">
<li>File mapped pages of user space (page cache, 包括 device file 的
buffer pages)</li>

<li>inode cache, &#x2026;</li>
</ol></li>

<li>Discardable

<ol class="org-ol">
<li>空闲的 slab</li>

<li>空闲的 dentry cache</li>

<li>&#x2026;</li>
</ol></li>
</ol>

<p>
PFRA 可以回收的 page frame 是 2,3,4 类, 这几类也可以按另一种标准分为:
</p>

<ol class="org-ol">
<li><p>
user mode address space
</p>

<p>
user mode 可以使用的 page, 即 page-&gt;_mapcount &gt;= 0 的部分, 包括
anonymous 和一部分映射到 user mode 的 page cache
</p></li>

<li><p>
page cache
</p>

<p>
还有大多数 page cache 没有映射到 user mode
</p></li>

<li><p>
disk cache
</p>

<p>
inode cache
</p></li>

<li><p>
memory cache
</p>

<p>
slab
</p></li>
</ol>

<p>
PFRA 在选择 victim page 时, 需要综合考虑以下几点:
</p>

<ol class="org-ol">
<li>考虑优先选择哪类 page frame: swappable, syncable, discardable &#x2026;</li>

<li>考虑根据 page 的 aging (LRU) 选择一个 page</li>

<li>考虑 page 的某些状态, 例如, 对于 syncable page, non-dirty 比 dirty
page 应该优先</li>
</ol>
</div>
</div>

<div id="outline-container-org6b99493" class="outline-4">
<h4 id="org6b99493"><span class="section-number-4">1.4.2</span> 反向映射</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
反向映射 (reversed mapping) 是指: 通过 PFRA 算法选择了一个 victim page
后, 如果这个 page 属于 file mapped page, 除了将这个 page 交还给 buddy
system 变成 free page 外, 还需要将引用这个 victim page 的所有 PTE 重置为 0, 如果这个 page 属于 anonymous page, 则需要将 PTE 置为 swap
identifier. 问题是, 如何根据 victim page 找到所有指向它的 PTE?
</p>

<p>
最简单的方法也许可以这样: 在 page descriptor 中维护一个 list_head, 所有相关的 PTE 都保存在这个 list 中.
</p>

<p>
对每个 page descriptor 都维护一个 list 可以代价太高, linux 的作法是对
page descriptor 做某种聚合: 一类 page descriptor 相关的 PTE 用同一个数据结构来描述.
</p>
</div>

<div id="outline-container-orga3eabd1" class="outline-5">
<h5 id="orga3eabd1"><span class="section-number-5">1.4.2.1</span> Anonymous Pages</h5>
<div class="outline-text-5" id="text-1-4-2-1">
<p>
对于 anonymous page, linux 使用的方法和前面描述的 "最简单方法" 类似:
page descriptor 中有一个称为 anon_vma 的 list_head. 但 list 中的成员并不是 PTE, 而是 vm_area_struct.
</p>
</div>

<ol class="org-ol">
<li><a id="org256e7bd"></a>Overview<br />
<div class="outline-text-6" id="text-1-4-2-1-1">
<p>
Anonymous pages 可能会有多个 PTE 指向的它, 最常见的情形是 fork: fork
时的复制了一块 vma, 则在父子进程中这块 vma 对应的 PTE 指向相同的
anonymous page.
</p>

<p>
随着不断的 fork, 最初的 vma 在不同的进程会有多份拷贝, linux 的作法是
</p>

<ol class="org-ol">
<li>将所有这些 vma 的拷贝放在一个 list 中</li>

<li>将这些 vma 引用的所有 page (包括后续 COW 分配的新 page) 聚合在一起:
这些 page 的 anon_vma 指向同一个 list_head, 这个 list_head 指向前面提到的 list</li>

<li>当 linux 要释放某个 victim page 时, 通过 page-&gt;anon_vma 找到所有相关的 vma, 根据 (vma-&gt;vm_mm-&gt;pgd, vma-&gt;vm_start, page-&gt;index) 可以找到对应的 PTE</li>
</ol>


<p>
相关的数据结构:
</p>

<ol class="org-ol">
<li>page-&gt;anon_vma</li>

<li>page-&gt;mapping</li>

<li>page-&gt;index</li>

<li>vm_area_struct-&gt;anon_vma</li>

<li>vm_area_struct-&gt;vm_start</li>

<li>vm_area_struct-&gt;vm_mm-&gt;pgd</li>
</ol>



<div id="org1d5c25b" class="figure">
<p><img src="../extra/kernel_rmap_anonymous.png" alt="kernel_rmap_anonymous.png" />
</p>
</div>
</div>
</li>

<li><a id="org94f44b4"></a>when Demanding Page<br />
<div class="outline-text-6" id="text-1-4-2-1-2">
<p>
Demanding page 时将 page 的 anon_vma 指向 vma-&gt;anon_vma, 若有需要, 会分配 anon_vma, 初始化 list_head.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">handle_pte_fault</span>:
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>pte_present<span style="color: #757575;">(</span>entry<span style="color: #757575;">))</span>:
    do_no_page<span style="color: #757575;">()</span>;
      <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>vma-&gt;vm_ops || <span style="color: #b58900; font-weight: bold;">!</span>vma-&gt;vm_ops-&gt;nopage<span style="color: #757575;">)</span>:
        do_anonymous_page<span style="color: #757575;">(</span>mm<span style="color: #757575;">,</span> vma<span style="color: #757575;">,</span> page_table<span style="color: #757575;">,</span> pmd<span style="color: #757575;">,</span> write_access<span style="color: #757575;">,</span> address<span style="color: #757575;">)</span>;
          <span style="color: #586e75;">// </span><span style="color: #586e75;">1. get anon_vma from vma-&gt;anon_vma &#25110; allocate one anon_vma</span>
          <span style="color: #268bd2;">anon_vma_prepare</span><span style="color: #757575;">(</span><span style="color: #b58900;">vma</span><span style="color: #757575;">)</span>
            <span style="color: #859900;">struct</span> <span style="color: #b58900;">anon_vma</span> *<span style="color: #268bd2;">anon_vma</span> = vma-&gt;anon_vma;
            <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>unlikely<span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>anon_vma<span style="color: #757575;">))</span>:
              anon_vma = anon_vma_alloc<span style="color: #757575;">()</span>;
              vma-&gt;anon_vma = anon_vma;
          <span style="color: #586e75;">// </span><span style="color: #586e75;">2. allocate page, &#24182;&#19988;&#20250; zeroed</span>
          page = alloc_zeroed_user_highpage<span style="color: #757575;">(</span>vma<span style="color: #757575;">,</span> addr<span style="color: #757575;">)</span>;
          <span style="color: #586e75;">// </span><span style="color: #586e75;">3. set page-&gt;anon_vma</span>
          <span style="color: #268bd2;">page_add_anon_rmap</span><span style="color: #757575;">(</span><span style="color: #b58900;">page</span><span style="color: #757575;">,</span> <span style="color: #b58900;">vma</span><span style="color: #757575;">,</span> <span style="color: #b58900;">addr</span><span style="color: #757575;">)</span>;
            <span style="color: #586e75;">// </span><span style="color: #586e75;">&#24403; page &#26159; anonymous page (&#32780;&#38750; file mapped page) &#26102;,</span>
            <span style="color: #586e75;">// </span><span style="color: #586e75;">page-&gt;index &#26159;&#25351; page &#30456;&#23545;&#20110; vma &#36215;&#22987;&#22320;&#22336;&#20559;&#31227;&#22810;&#23569;&#20010; page</span>
            <span style="color: #586e75;">// </span><span style="color: #586e75;">shift, page-&gt;mapping &#25351;&#21521; anon_vma. &#21518;&#38754;&#36890;&#36807;&#36825;&#20004;&#20010;&#20540;,&#21487;</span>
            <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20197;&#25214;&#21040; page &#23545;&#24212;&#30340; pte</span>
            page-&gt;index = index;
            page-&gt;mapping = <span style="color: #757575;">(</span><span style="color: #859900;">struct</span> <span style="color: #b58900;">address_space</span> *<span style="color: #757575;">)</span> anon_vma;
          <span style="color: #586e75;">// </span><span style="color: #586e75;">4. set pte</span>
          <span style="color: #268bd2;">set_pte</span><span style="color: #757575;">(</span><span style="color: #b58900;">page_table</span><span style="color: #757575;">,</span> <span style="color: #b58900;">entry</span><span style="color: #757575;">)</span>;
</pre>
</div>
</div>
</li>

<li><a id="org6b55017"></a>When Fork<br />
<div class="outline-text-6" id="text-1-4-2-1-3">
<p>
fork 时会将新的 vma 加到 anon_vma 指示的 list 中
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">do_fork</span>:
  <span style="color: #268bd2;">copy_process</span><span style="color: #757575;">()</span>
    <span style="color: #268bd2;">copy_mm</span><span style="color: #757575;">()</span>
      <span style="color: #268bd2;">dup_mmap</span><span style="color: #757575;">(</span><span style="color: #b58900;">mm</span><span style="color: #757575;">,</span> <span style="color: #b58900;">oldmm</span><span style="color: #757575;">)</span>;
        <span style="color: #586e75;">// </span><span style="color: #586e75;">for each vma</span>
        <span style="color: #859900;">for</span> <span style="color: #757575;">(</span>mpnt = current-&gt;mm-&gt;mmap ; mpnt ; mpnt = mpnt-&gt;vm_next<span style="color: #757575;">)</span>:
          new_vma = kmem_cache_alloc<span style="color: #757575;">(</span>vm_area_cachep<span style="color: #757575;">,</span> SLAB_KERNEL<span style="color: #757575;">)</span>;
          <span style="color: #586e75;">// </span><span style="color: #586e75;">copy the vma, so as to vma-&gt;anon_vma</span>
          *new_vma = *mpnt;
          <span style="color: #586e75;">// </span><span style="color: #586e75;">add to forked vma to anon_vma list</span>
          <span style="color: #268bd2;">anon_vma_link</span><span style="color: #757575;">(</span><span style="color: #b58900;">new_vma</span><span style="color: #757575;">)</span>;
            <span style="color: #859900;">struct</span> <span style="color: #b58900;">anon_vma</span> *<span style="color: #268bd2;">anon_vma</span> = vma-&gt;anon_vma;
            list_add<span style="color: #757575;">(</span>&amp;vma-&gt;anon_vma_node<span style="color: #757575;">,</span> &amp;anon_vma-&gt;head<span style="color: #757575;">)</span>;
</pre>
</div>
</div>
</li>

<li><a id="orgfa9390f"></a>When Copy on Write<br />
<div class="outline-text-6" id="text-1-4-2-1-4">
<p>
除了 demanding page, COW 时也会将 page 的 anon_vma 指向 vma-&gt;anon_vma
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">handle_pte_fault</span>:
  <span style="color: #268bd2;">do_wp_page</span><span style="color: #757575;">(</span><span style="color: #b58900;">mm</span><span style="color: #757575;">,</span> <span style="color: #b58900;">vma</span><span style="color: #757575;">,</span> <span style="color: #b58900;">address</span><span style="color: #757575;">,</span> <span style="color: #b58900;">pte</span><span style="color: #757575;">,</span> <span style="color: #b58900;">pmd</span><span style="color: #757575;">,</span> <span style="color: #b58900;">entry</span><span style="color: #757575;">)</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#36825;&#37324;&#24182;&#19981;&#20250;&#20998;&#37197;&#26032;&#30340; anon_vma, &#22240;&#20026;&#24403;&#21069; vma &#26159;&#20043;&#21069; fork &#26102;&#22797;&#21046;&#32780;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#26469;&#30340;, vma-&gt;anon_vma &#19982; parent process &#20013; vma-&gt;anon_vma &#30456;&#21516;</span>
    <span style="color: #268bd2;">anon_vma_prepare</span><span style="color: #757575;">(</span><span style="color: #b58900;">vma</span><span style="color: #757575;">)</span>
    <span style="color: #268bd2;">alloc_zeroed_user_highpage</span><span style="color: #757575;">(</span><span style="color: #b58900;">vma</span><span style="color: #757575;">,</span> <span style="color: #b58900;">address</span><span style="color: #757575;">)</span>;
    <span style="color: #268bd2;">page_add_anon_rmap</span><span style="color: #757575;">(</span><span style="color: #b58900;">new_page</span><span style="color: #757575;">,</span> <span style="color: #b58900;">vma</span><span style="color: #757575;">,</span> <span style="color: #b58900;">address</span><span style="color: #757575;">)</span>;
</pre>
</div>

<p>
基本上 do_wp_page 和 do_anonymous_page 差不多, 比较奇怪的是 COW 新分配的 new_page 的 anon_vma 被设置为 old_page 的 anon_vma, 即如果将来要回收这个 new_page, 扫描其 anon_vma 时会遍历到那些 "旧的" vma, 显然这些旧的 vma 的 pte 并不会指向这个 new_page: 它们都是指向 old_page 的.
</p>

<p>
感觉 new_page 不应该使用 old_page 的 anon_vma 而应该新分配一个
anon_vma? 由于 page 的 anon_vma 与 vma-&gt;anon_vma 必须是一致的, 则新进程的 vma 的 anon_vma 也需要设为新的 anon_vma, 考虑下面这种情况:
</p>

<ol class="org-ol">
<li>A fork B, vma_A-&gt;anon_vma 链表中有两项 (vma_A,vma_B)</li>

<li>B COW 一个 new_page, 假设新生成一个 anon_vma 为 vma_B-&gt;anon_vma</li>

<li>B fork C, vma_B-&gt;anon_vma 链表会有两项 (vma_B, vma_C),
vma_A-&gt;anon_vma 还有原来的两项 (vma_A, vma_B)</li>

<li>如果此时回收 vma<sub>A,B,C</sub> 中某一个公共的 page, 则只会扫描到
vma<sub>A,B</sub> (实际需要扫描到 vma<sub>A,B,C</sub>), 因为这个 page 的 anon_vma
是指向 vma_A-&gt;anon_vma 的. 如果此时要回收 new_page, 则 vma<sub>B,C</sub> 会扫描到, 这倒是正常的</li>
</ol>

<p>
为了应对 4 中的异常情况, 需要 B COW new_page 时将 new_page 的 anon_vma
指向最初 vma_A-&gt;anon_vma 且不修改 vma_B-&gt;anon_vma. 这也就是最初描述的:
"将这些 vma 引用的所有 page (包括后续 COW 分配的新 page) 聚合在一起"的原因. anon_vma 是一个比 "实际" 范围更大的并集.
</p>
</div>
</li>
</ol>
</div>

<div id="outline-container-org10c696a" class="outline-5">
<h5 id="org10c696a"><span class="section-number-5">1.4.2.2</span> file mapped pages</h5>
<div class="outline-text-5" id="text-1-4-2-2">
<p>
基于 anon_vma 链表的 reversed mapping 不适用于 file mapping pages.
</p>

<p>
由于前面提到的基于 anon_vma 的一个主要性质是 "同一个 vma 所有的 page
聚合在一起", 而 file mapping 可以有重叠, 这会导致所有重叠的 vma 的所有
page 都会聚合在一起, 导致 anon_vma 链接会是一个巨大的并集, 扫描效率会很差.
</p>

<p>
因为, file mapped pages 使用了另一种聚合的方法: 基于 address_space 上的 PST (Priority Search Tree) 树的聚合方式.
</p>

<p>
针对每个文件(或 address_space) 有一棵 PST 树, 树上的节点是映射了这个文件的 vma, 通过 PST 树可以做到:
</p>

<p>
给定一段 interval (start, end), 能很快的查找到所有包含这段 interval 的
VMA
</p>
</div>
</div>

<div id="outline-container-orgd1804e4" class="outline-5">
<h5 id="orgd1804e4"><span class="section-number-5">1.4.2.3</span> try_to_unmap</h5>
</div>
</div>

<div id="outline-container-org253fb07" class="outline-4">
<h4 id="org253fb07"><span class="section-number-4">1.4.3</span> PFRA 的实现</h4>
<div class="outline-text-4" id="text-1-4-3">

<div id="orge3d0953" class="figure">
<p><img src="../extra/kernel_pfra.png" alt="kernel_pfra.png" />
</p>
</div>
</div>


<div id="outline-container-org42053a5" class="outline-5">
<h5 id="org42053a5"><span class="section-number-5">1.4.3.1</span> LRU</h5>
<div class="outline-text-5" id="text-1-4-3-1">
<p>
PFRA 能回收的 page frame 中, user mode address space 占了绝大部分.
Linux 使用 LRU 机制来决定这部分 page 中哪些会被回收.
</p>
</div>

<ol class="org-ol">
<li><a id="org15da87a"></a>相关数据结构<br />
<div class="outline-text-6" id="text-1-4-3-1-1">
<ol class="org-ol">
<li><p>
zone
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">zone</span> <span style="color: #757575;">{</span>
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">list_head</span>       <span style="color: #268bd2;">active_list</span>;
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">list_head</span>       <span style="color: #268bd2;">inactive_list</span>;
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span>          <span style="color: #268bd2;">nr_scan_active</span>;
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span>          <span style="color: #268bd2;">nr_scan_inactive</span>;
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span>          <span style="color: #268bd2;">nr_active</span>;
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span>          <span style="color: #268bd2;">nr_inactive</span>;
    <span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">long</span>          <span style="color: #268bd2;">pages_scanned</span>;
<span style="color: #757575;">}</span>
</pre>
</div></li>

<li><p>
page
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #859900;">struct</span> <span style="color: #b58900;">page</span> <span style="color: #757575;">{</span>
    <span style="color: #b58900;">page_flags_t</span> <span style="color: #268bd2;">flags</span>;
    <span style="color: #859900;">struct</span> <span style="color: #b58900;">list_head</span> <span style="color: #268bd2;">lru</span>;
<span style="color: #757575;">}</span>
</pre>
</div></li>

<li><p>
page flags
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2;">#define</span> <span style="color: #268bd2;">PG_lru</span>           5
<span style="color: #268bd2;">#define</span> <span style="color: #268bd2;">PG_referenced</span>        2
<span style="color: #268bd2;">#define</span> <span style="color: #268bd2;">PG_active</span>        6
</pre>
</div></li>
</ol>
</div>
</li>

<li><a id="orgeb28a39"></a>Overview<br />
<div class="outline-text-6" id="text-1-4-3-1-2">
<p>
zone 中已经分配的 page 中的一部分 (user mode address space 及 page
cache) 被组织在两个不相关的链表中: active_list 和 inactive_list
</p>

<p>
当 page 被 "访问" 时, PFRA 会将 page 移动到 active_list, 当 page 一段时间没有被 "访问" 时, PFRA 会将它移到到 inactive_list, 当需要进行
reclaim 时, PFRA 会从 inactive_list 中找一个 victim.
</p>

<p>
所有被 active_list 和 inactive_list 管理的 page 的 PG_lru flag 会置位,
同时, 如果 page 属于 active_list, 则它的 PG_active 也会置位.
</p>

<p>
另外, 还存在一个 PG_referenced flag, 当 page 被访问时, 并不是直接将它放在 active_list, 而是先检查 PG_referenced, 如果已经置位, 则 clear
PG_referenced, 同时将 page 放到 active_list, 否则, 仅仅将 PG_referenced
置位, 而不放在 active_list 中. 通过 PG_referenced, 实现了某种缓冲的效果.
</p>

<p>
下图展示了 PG_active, PG_referenced 的转换.
</p>


<div id="org8b3f05e" class="figure">
<p><img src="../extra/kernel_pfra_lru.png" alt="kernel_pfra_lru.png" />
</p>
</div>

<p>
图中提到的几个函数:
</p>

<ol class="org-ol">
<li>lru_cache_add</li>

<li>lru_cache_add_active</li>

<li>mark_page_accessed</li>

<li>page_referenced</li>

<li>refill_inactive_zone</li>
</ol>

<p>
是实现 active_list 与 inactive_list 转换的关键.
</p>
</div>
</li>

<li><a id="orge260a52"></a>lru_cache_add / lru_cache_add_active<br />
<div class="outline-text-6" id="text-1-4-3-1-3">
<p>
这两个函数决定了 zone 中已分配的 page 中哪些是受 LRU 管理的, 简单的说:
</p>

<ol class="org-ol">
<li>通过 page fault 分配的 user mode address space 会通过
lru_cache_add_active 加入到 active_list</li>

<li>新分配的 page cache 会通过 lru_cache_add 加入到 inactive_list</li>
</ol>
</div>
</li>

<li><a id="orga21845e"></a>mark_page_accessed<br />
<div class="outline-text-6" id="text-1-4-3-1-4">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2;">mark_page_accessed</span><span style="color: #757575;">(</span><span style="color: #859900;">struct</span> <span style="color: #b58900;">page</span> *<span style="color: #268bd2;">page</span><span style="color: #757575;">)</span>:
  <span style="color: #586e75;">// </span><span style="color: #586e75;">1. page &#22312; inactive_list &#19988; PG_referenced == 1, &#21017;&#31227;&#21160; page &#21040;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">active_list &#24182; clear PG_referenced</span>
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>PageActive<span style="color: #757575;">(</span>page<span style="color: #757575;">)</span> &amp;&amp; PageReferenced<span style="color: #757575;">(</span>page<span style="color: #757575;">)</span> &amp;&amp; PageLRU<span style="color: #757575;">(</span>page<span style="color: #757575;">))</span>:
    activate_page<span style="color: #757575;">(</span>page<span style="color: #757575;">)</span>;
      <span style="color: #268bd2;">del_page_from_inactive_list</span><span style="color: #757575;">(</span><span style="color: #b58900;">zone</span><span style="color: #757575;">,</span> <span style="color: #b58900;">page</span><span style="color: #757575;">)</span>;
      <span style="color: #268bd2;">SetPageActive</span><span style="color: #757575;">(</span><span style="color: #b58900;">page</span><span style="color: #757575;">)</span>;
      <span style="color: #268bd2;">add_page_to_active_list</span><span style="color: #757575;">(</span><span style="color: #b58900;">zone</span><span style="color: #757575;">,</span> <span style="color: #b58900;">page</span><span style="color: #757575;">)</span>;
    <span style="color: #268bd2;">ClearPageReferenced</span><span style="color: #757575;">(</span><span style="color: #b58900;">page</span><span style="color: #757575;">)</span>;
  <span style="color: #859900;">else</span> <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>PageReferenced<span style="color: #757575;">(</span>page<span style="color: #757575;">))</span>:
    SetPageReferenced<span style="color: #757575;">(</span>page<span style="color: #757575;">)</span>;
</pre>
</div>

<p>
mark_page_accessed 在下面这些情况下被执行:
</p>

<ul class="org-ul">
<li>do_anonymous_page</li>

<li>filemap_nopage</li>

<li>do_generic_file_read</li>

<li>do_swap_page</li>
</ul>

<p>
可见, PFRA 并没有办法做到每次 page 被 "访问" 时都更新 PG_referenced,
例如当 user mode 正常访问了某个地址时 (不涉及到 page fault) kernel 并没有办法跟踪这次动作来更新 PG_referenced.
</p>
</div>
</li>

<li><a id="orgf4ba24b"></a>page_referenced<br />
<div class="outline-text-6" id="text-1-4-3-1-5">
<p>
PFRA 扫描时 (refill_inactive_zone) 会用 page_referenced 检查并清除
PG_referenced 和 PTE 的 Accessed flag.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b58900;">int</span> <span style="color: #268bd2;">page_referenced</span><span style="color: #757575;">(</span><span style="color: #859900;">struct</span> <span style="color: #b58900;">page</span> *<span style="color: #268bd2;">page</span><span style="color: #757575;">)</span>:
  <span style="color: #586e75;">// </span><span style="color: #586e75;">1. PG_referenced</span>
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>TestClearPageReferenced<span style="color: #757575;">(</span>page<span style="color: #757575;">))</span>:
    referenced++;
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>page_mapped<span style="color: #757575;">(</span>page<span style="color: #757575;">)</span> &amp;&amp; page-&gt;mapping<span style="color: #757575;">)</span>:
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>PageAnon<span style="color: #757575;">(</span>page<span style="color: #757575;">))</span>:
      <span style="color: #586e75;">// </span><span style="color: #586e75;">2. &#36890;&#36807; reversed mapping &#25214;&#21040;&#25152;&#26377;&#30340; pte, &#26597;&#30475;&#24182;&#28165;&#38500; PTE &#30340;</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">Accessed flag CPU &#27599;&#27425;&#22312;&#35775;&#38382;&#20869;&#23384;&#26102;&#37117;&#38656;&#35201;&#20808;&#26597;&#25214;&#21040;&#23545;&#24212;&#30340; PTE,</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#36825;&#26102; CPU &#20250;&#36127;&#36131;&#23558; PTE &#30340; accessed flag &#32622;&#20301;, &#20294; CPU &#19981;&#20250;&#23558;&#23427;&#22797;&#20301;, PFRA &#38656;&#35201;&#36127;&#36131;</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#22312; page_referenced &#20013;&#23558;&#20854;&#22797;&#20301;</span>
      referenced += page_referenced_anon<span style="color: #757575;">(</span>page<span style="color: #757575;">,</span> ignore_token<span style="color: #757575;">)</span>;
    <span style="color: #859900;">else</span>:
      <span style="color: #586e75;">// </span><span style="color: #586e75;">3. &#19982; page_referenced_anon &#31867;&#20284;</span>
      referenced += page_referenced_file<span style="color: #757575;">(</span>page<span style="color: #757575;">,</span> ignore_token<span style="color: #757575;">)</span>;
  <span style="color: #859900;">return</span> referenced
</pre>
</div>

<p>
若 page_referenced 返回值不为 0, 说明最近 (自上次 page_referenced 调用以来) 该 page 被 reference 过
</p>
</div>
</li>

<li><a id="org94aec20"></a>refill_inactive_zone<br />
<div class="outline-text-6" id="text-1-4-3-1-6">
<p>
refill_inactive_zone 是唯一可以将 active_list 中的 page 移动到
inactive_list 的函数, 由于后面 shrink_list 时只会从 inactive_list 中找
victim, 所以 refill_inactive_zone 是 PFRA 中第一个关键的函数.
</p>
</div>

<ol class="org-ol">
<li><a id="orgbc9f64b"></a>Swap Tendency<br />
<div class="outline-text-7" id="text-1-4-3-1-6-1">
<p>
PFRA 计算了一个 swap tendency 来决定是否会把 active_list 中的 page 移动到 inactive_list 中.
</p>

<p>
Swap tendency 的计算方法为:
</p>

<blockquote>
<p>
swap_tendency = maped_ratio / 2 + distress + swappiness
</p>
</blockquote>

<p>
其中:
</p>

<ol class="org-ol">
<li>mapped_ratio 是 user mode address space 占所有内存的比例 (anonymous
<ul class="org-ul">
<li>file mapped), mapped_ratio 越大, 基本表示空闲的 (没有被 user mode
映射) page cache 占用的内存越少</li>
</ul></li>

<li>distress 对应 PFRA 扫描时使用的 prio, PFRA 工作的紧急程度, prio 为 0
时, 表示最紧急, distress 为 100, prio 为 12, 表示不紧急, distress
为 0</li>

<li>swappiness 对应于 /proc/sys/vm/swappiness, 表示是否优先回收 user
mode address space, swappiness 值越小越避免回收 user mode address
space</li>
</ol>

<p>
Swap tendency 的值 &gt;= 100 时, user mode 的 page 才可能被移动到
inactive_list 进而被回收, 所以 swappiness 的值实际的意义是 "PFRA 面临多大压力时才可以回收 user mode address space"
</p>

<p>
实际上, swap tendency 与 swappiness 的名字是有些歧义的, swap tendency
和 swappiness 代表的 user mode address space 是否被回收, user mode
address space 不仅仅包含和 swap 相关的部分 (anonymous) 还包括 file
mapped, 后者和 swap 并没有什么关系
</p>
</div>
</li>

<li><a id="orgdd92f53"></a>refill_inactive_zone<br />
<div class="outline-text-7" id="text-1-4-3-1-6-2">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">refill_inactive_zone</span>:
  <span style="color: #586e75;">// </span><span style="color: #586e75;">sc-&gt;nr_to_scan &#34920;&#31034;&#26368;&#22810; move &#22810;&#23569;&#20010; page &#21040; inactive_list, &#36825;&#30340;&#20540;</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#26368;&#22823;&#20026; 32 (SWAP_CLUSTER_MAX)</span>
  <span style="color: #b58900;">int</span> <span style="color: #268bd2;">nr_pages</span> = sc-&gt;nr_to_scan;
  <span style="color: #586e75;">// </span><span style="color: #586e75;">1. &#20174; active list &#36873;&#25321;&#19968;&#23450;&#25968;&#30446;&#30340; page &#21040;&#20020;&#26102;&#30340; l_hold</span>
  <span style="color: #859900;">while</span> <span style="color: #757575;">(</span>pgscanned &lt; nr_pages &amp;&amp; <span style="color: #b58900; font-weight: bold;">!</span>list_empty<span style="color: #757575;">(</span>&amp;zone-&gt;active_list<span style="color: #757575;">))</span>:
    <span style="color: #586e75;">// </span><span style="color: #586e75;">lru_to_page &#26159;&#21462; lru &#38142;&#34920;&#20013;&#26368;&#21518;&#19968;&#20010; page</span>
    page = lru_to_page<span style="color: #757575;">(</span>&amp;zone-&gt;active_list<span style="color: #757575;">)</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#23558; page &#20174; active_list &#31227;&#38500;</span>
    list_del<span style="color: #757575;">(</span>&amp;page-&gt;lru<span style="color: #757575;">)</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">&#23558; page &#25554;&#20837;&#21040;&#20020;&#26102;&#30340; l_hold &#38142;&#34920;</span>
    list_add<span style="color: #757575;">(</span>&amp;page-&gt;lru<span style="color: #757575;">,</span> &amp;l_hold<span style="color: #757575;">)</span>;
    pgscanned++;

  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#26681;&#25454; PFRA &#30340; priority &#35745;&#31639; distress &#20540;</span>
  distress = 100 &gt;&gt; zone-&gt;prev_priority;
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#35745;&#31639; mapped_ratio</span>
  mapped_ratio = <span style="color: #757575;">(</span>sc-&gt;nr_mapped * 100<span style="color: #757575;">)</span> / total_memory;
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#35745;&#31639; swap_tendency</span>
  swap_tendency = mapped_ratio / 2 + distress + vm_swappiness;
  <span style="color: #586e75;">//</span>
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>swap_tendency &gt;= 100<span style="color: #757575;">)</span>:
    reclaim_mapped = 1;

  <span style="color: #586e75;">// </span><span style="color: #586e75;">2. &#36941;&#21382; l_hold</span>
  <span style="color: #859900;">while</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>list_empty<span style="color: #757575;">(</span>&amp;l_hold<span style="color: #757575;">))</span>:
    page = lru_to_page<span style="color: #757575;">(</span>&amp;l_hold<span style="color: #757575;">)</span>;
    list_del<span style="color: #757575;">(</span>&amp;page-&gt;lru<span style="color: #757575;">)</span>;
    <span style="color: #586e75;">// </span><span style="color: #586e75;">page_mapped &#34920;&#31034; page &#23646;&#20110; user mode, &#21487;&#33021;&#26159; anonymous &#20063;&#21487;&#33021;&#26159;</span>
    <span style="color: #586e75;">// </span><span style="color: #586e75;">file mmaped</span>
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>page_mapped<span style="color: #757575;">(</span>page<span style="color: #757575;">))</span>:
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#33509; reclaim_mapped &#20026; 0, &#21017;&#25152;&#26377; l_hold &#20013;&#30340; page &#26368;&#32456;&#37117;&#20250;&#34987;&#25918;</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#22238; active_list, &#26412;&#27425; refill_inactive_zone &#30456;&#24403;&#20110;&#31354;&#25805;&#20316;, &#21518;&#32493;&#37325;</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#22797;&#30340; refill_inactive_zone &#25805;&#20316;&#30001;&#20110; priority &#21464;&#23567;&#20250;&#23548;&#33268;</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">distress &#21464;&#22823;,&#26368;&#32456;&#20250;&#23548;&#33268; reclaim_mapped &#20026; 1.</span>
      <span style="color: #586e75;">//</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#33509; reclaim_mapped &#20026; 1, &#34920;&#31034; user mode &#21487;&#20197;&#34987; swap, &#20294;&#20063;&#26377;&#20363;&#22806;:</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">1. &#33509;&#27492;&#26102; page &#26159; anonymous &#20294;&#27809;&#26377; swap space, &#21017;&#36824;&#26159;&#20250;&#34987;&#25918;&#22238;</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">active_list.</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">2. &#33509; page_referenced &#20026;&#30495;, &#20063;&#20250;&#34987;&#25918;&#22238; active_list &#19981;&#20250;&#34987;&#22238;&#25910;</span>
      <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>reclaim_mapped || <span style="color: #757575;">(</span>total_swap_pages == 0 &amp;&amp; PageAnon<span style="color: #757575;">(</span>page<span style="color: #757575;">))</span> ||
          page_referenced<span style="color: #757575;">(</span>page<span style="color: #757575;">,</span> 0<span style="color: #757575;">,</span> sc-&gt;priority &lt;= 0<span style="color: #757575;">))</span>:
        list_add<span style="color: #757575;">(</span>&amp;page-&gt;lru<span style="color: #757575;">,</span> &amp;l_active<span style="color: #757575;">)</span>;
        <span style="color: #859900;">continue</span>;
    list_add<span style="color: #757575;">(</span>&amp;page-&gt;lru<span style="color: #757575;">,</span> &amp;l_inactive<span style="color: #757575;">)</span>;

  <span style="color: #586e75;">// </span><span style="color: #586e75;">3. &#23558; l_inactive &#20013;&#30340; page &#31227;&#21160;&#21040; inactive_list</span>
  <span style="color: #859900;">while</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>list_empty<span style="color: #757575;">(</span>&amp;l_inactive<span style="color: #757575;">))</span>:
    page = lru_to_page<span style="color: #757575;">(</span>&amp;l_inactive<span style="color: #757575;">)</span>;
    list_move<span style="color: #757575;">(</span>&amp;page-&gt;lru<span style="color: #757575;">,</span> &amp;zone-&gt;inactive_list<span style="color: #757575;">)</span>;

  <span style="color: #586e75;">// </span><span style="color: #586e75;">4. &#23558; l_active &#20013;&#30340; page &#31227;&#21160;&#21040; active_list</span>
  <span style="color: #859900;">while</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>list_empty<span style="color: #757575;">(</span>&amp;l_active<span style="color: #757575;">))</span>:
    page = lru_to_page<span style="color: #757575;">(</span>&amp;l_active<span style="color: #757575;">)</span>;
    list_move<span style="color: #757575;">(</span>&amp;page-&gt;lru<span style="color: #757575;">,</span> &amp;zone-&gt;active_list<span style="color: #757575;">)</span>;
</pre>
</div>
</div>
</li>

<li><a id="org522799b"></a>通过 refill_inactive_zone 更新 LRU list<br />
<div class="outline-text-7" id="text-1-4-3-1-6-3">
<p>
refill_inactive_zone 的作用, 除了从 active_list 移动一些 page 到
inactive_list 外, 还起到维护 LRU 的作用.
</p>

<p>
当一个 page 被 reference 时, 相关代码并不会修改 (或者根本无法修改, 比如 PTE accessed flag 导致的 reference) 它们在 LRU list 中的位置, 但进行 refill_inactive_zone 时, 第一次循环会从 active_list `末尾` 取一定数量的 page, 第四次循环时又会将不符合条件的 page (例如 page_referenced
或因为 swap tendency 的原因) 放回 active_list `开头`. 通过这种方式, 实现了 LRU 的更新.
</p>
</div>
</li>
</ol>
</li>
</ol>
</div>

<div id="outline-container-orge62842a" class="outline-5">
<h5 id="orge62842a"><span class="section-number-5">1.4.3.2</span> Low on Memory Reclaiming: try_to_free_pages</h5>
<div class="outline-text-5" id="text-1-4-3-2">
</div>
<ol class="org-ol">
<li><a id="org019fe9e"></a>Overview<br />
<div class="outline-text-6" id="text-1-4-3-2-1">
<p>
try_to_free_pages 是 `low on memory` page reclaim 主要的入口, 它会重复的调用 shrink_caches 和 shrink_slab, 并且每次循环使用更高的优先级 (12
-&gt; 0), 直到释放了 32 个 page 为止, 若 13 次循环后还是没有成功, 返回 0,
上层调用者 (例如 __alloc_pages) 会调用 out_of_memory
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">try_to_free_pages</span>:
  <span style="color: #859900;">for</span> <span style="color: #757575;">(</span>priority = DEF_PRIORITY; priority &gt;= 0; priority--<span style="color: #757575;">)</span>:
    sc.nr_reclaimed = 0;
    sc.priority = priority;
    <span style="color: #268bd2;">shrink_caches</span><span style="color: #757575;">(</span><span style="color: #b58900;">zones</span><span style="color: #757575;">,</span> &amp;sc<span style="color: #757575;">)</span>;
      <span style="color: #268bd2;">shrink_zone</span><span style="color: #757575;">(</span><span style="color: #b58900;">zone</span><span style="color: #757575;">)</span>
        <span style="color: #268bd2;">refill_inactive_zone</span><span style="color: #757575;">(</span><span style="color: #b58900;">zone</span><span style="color: #757575;">,</span> <span style="color: #b58900;">sc</span><span style="color: #757575;">)</span>;
        <span style="color: #268bd2;">shrink_cache</span><span style="color: #757575;">(</span><span style="color: #b58900;">zone</span><span style="color: #757575;">,</span> <span style="color: #b58900;">sc</span><span style="color: #757575;">)</span>;
          shrink_list<span style="color: #757575;">(</span>&amp;page_list<span style="color: #757575;">,</span> sc<span style="color: #757575;">)</span>
    <span style="color: #268bd2;">shrink_slab</span><span style="color: #757575;">(</span>sc.nr_scanned<span style="color: #757575;">,</span> <span style="color: #b58900;">gfp_mask</span><span style="color: #757575;">,</span> <span style="color: #b58900;">lru_pages</span><span style="color: #757575;">)</span>;
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>sc.nr_reclaimed &gt;= SWAP_CLUSTER_MAX<span style="color: #757575;">)</span>:
      <span style="color: #859900;">return</span> 1
  <span style="color: #859900;">return</span> 0
</pre>
</div>
</div>
</li>

<li><a id="orgca3c01a"></a>shrink_list<br />
<div class="outline-text-6" id="text-1-4-3-2-2">
<p>
shrink_list 是整个 PFRA 最主要的函数之一, 它的主要工作:
</p>

<ol class="org-ol">
<li>如果是 anonymous page, 通过 add_to_swap, 将其加入 swap cache 中</li>

<li>try_to_unmap, 通过 reversed mapping 修改 PTE 为空或 swap identifier</li>

<li>如果 try_to_unmap 失败 (例如 page 对应的某个 PTE 所在的 vma 是
VM_LOCKED), 则直接返回</li>

<li>若 try_to_unmap 成功, 则

<ol class="org-ol">
<li>若 PageDirty, 则 pageout, 调用 page-&gt;mapping-&gt;writepage</li>

<li>通过 __remove_from_page_cache 将 page 从 page cache 中删除</li>

<li>__pagevec_release_nonlru, 最终会调用 free_pages_bulk 将 page 交还
buddy</li>
</ol></li>
</ol>
</div>
</li>

<li><a id="org5afc75e"></a>shrink_slab<br />
<ol class="org-ol">
<li><a id="org72ced5c"></a>shrink_dcache_memory<br /></li>

<li><a id="org5d3f55a"></a>shrink_icache_memory<br /></li>
</ol>
</li>
</ol>
</div>

<div id="outline-container-orge893daa" class="outline-5">
<h5 id="orge893daa"><span class="section-number-5">1.4.3.3</span> Periodic Reclaiming: kswapd</h5>
<div class="outline-text-5" id="text-1-4-3-3">
<p>
除了 try_to_free_pages, PFRA 还会通过 kswapd 进行 periodic reclaiming.
</p>

<p>
如前面 <a href="#orge6bbf99">alloc_pages</a> 所述, alloc_pages 时如果发现所有 zone 的可用内存都低于 zone-&gt;page_low, 则会通过 wakeup_kswapd 唤醒 kswapd.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">kswapd</span>:
  <span style="color: #859900;">for</span> <span style="color: #757575;">(</span>;;<span style="color: #757575;">)</span>:
    prepare_to_wait<span style="color: #757575;">(</span>&amp;pgdat-&gt;kswapd_wait<span style="color: #757575;">,</span> &amp;wait<span style="color: #757575;">,</span> TASK_INTERRUPTIBLE<span style="color: #757575;">)</span>;
    <span style="color: #268bd2;">balance_pgdat</span><span style="color: #757575;">(</span><span style="color: #b58900;">pgdat</span><span style="color: #757575;">,</span> 0<span style="color: #757575;">,</span> <span style="color: #b58900;">order</span><span style="color: #757575;">)</span>;
      <span style="color: #268bd2;">shrink_zone</span><span style="color: #757575;">()</span>
      <span style="color: #268bd2;">shrink_slab</span><span style="color: #757575;">()</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org1b8ca8d" class="outline-5">
<h5 id="org1b8ca8d"><span class="section-number-5">1.4.3.4</span> Swapping</h5>
<div class="outline-text-5" id="text-1-4-3-4">
</div>
<ol class="org-ol">
<li><a id="org6d407fc"></a>Swap Area<br />
<div class="outline-text-6" id="text-1-4-3-4-1">
<p>
Swap area 即 swap file 或 swap device, linux 可以支持多个 swap area.
</p>

<p>
swap area 的作用类似于一个文件系统: swap area 被分割为大小为 4K 的
page slot. 当 PFRA 需要 swap out 时, 会通过 swap area 分配一个 page
slot, 这个 page slot index 及 swap area 的编号合成一个 swap
identifier, page 的 PTE 会被修改为这个 swap identifier.
</p>


<div id="orgfd21c3e" class="figure">
<p><img src="../extra/kernel_pfra_swap_identifier.png" alt="kernel_pfra_swap_identifier.png" />
</p>
</div>

<p>
当后面进程需要访问这个 PTE 时, page fault handler 通过 PTE 的值 (实际就是 swap identifier) 能知道这个 page 已经被 swap out, 它会通过
do_swap_page (swap identifier) 从 swap area 重新加载这个 page
</p>

<p>
PFRA 与 swap area 的主要接口:
</p>

<ol class="org-ol">
<li>swap_readpage</li>

<li>swap_writepage</li>

<li>get_swap_page</li>

<li>swap_free</li>
</ol>
</div>
</li>

<li><a id="org471a656"></a>Swap Cache<br />
<div class="outline-text-6" id="text-1-4-3-4-2">
<p>
在 shrink_list 时, 通过 add_to_swap 并不是直接将 page 写入 swap area,
而是先将 page 加入 swap cache 中, 然后再写入 swap area. Swap cache 主要是为了解决同步的问题:
</p>

<p>
如果 page 被 swap out, 其 PTE 已经被修改为 swap identifier, 但 page
A 正在被写入 swap area 的同时某个进程 A 又需要访问这个 page 怎么办? 由于
swap cache 暂存着这个正在写入 swap area 的 page, page fault 可以从
swap cache 中找到这个 page 给进程 A 使用.
</p>

<p>
Swap cache 本质是是一个 page cache:
</p>

<ol class="org-ol">
<li>它对应的 address_space 是 swapper_space</li>

<li>查找 radix_tree 时使用的索引是 swap identifier</li>
</ol>

<p>
shrink_list 将 page swap out 时相当于把 page 加入 swap area 的 page
cache, shrink_list 后续的代码只需要把 swapper_space 做为普通的 page
cache 处理即可, 例如在 pageout 时调用 aosp-&gt;writepage
</p>
</div>
</li>

<li><a id="org1a1ab95"></a>Swap Out<br />
<div class="outline-text-6" id="text-1-4-3-4-3">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">shrink_list</span>:
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#22914;&#26524; page &#26159; anonymous &#19988;&#20043;&#21069;&#24182;&#27809;&#26377;&#21152;&#20837; swap cache,</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#21017;&#21152;&#20837; swap cache</span>
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>PageAnon<span style="color: #757575;">(</span>page<span style="color: #757575;">)</span> &amp;&amp; <span style="color: #b58900; font-weight: bold;">!</span>PageSwapCache<span style="color: #757575;">(</span>page<span style="color: #757575;">))</span>:
    add_to_swap<span style="color: #757575;">(</span>page<span style="color: #757575;">)</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#22312; swap area &#19978;&#20998;&#37197;&#19968;&#20010; page slot, &#20854;&#20013; entry-&gt;val &#26159;&#36820;&#22238;</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#30340; swap identifier</span>
      entry = get_swap_page<span style="color: #757575;">()</span>;
      <span style="color: #586e75;">// </span><span style="color: #586e75;">&#21152;&#20837; swap cache &#24182;&#26631;&#35760;&#20026; dirty, &#20197;&#20415;&#21518;&#32493;&#30340; pageout &#20250;&#23558;&#23427;&#20889;&#22238;</span>
      <span style="color: #586e75;">// </span><span style="color: #586e75;">swap area</span>
      <span style="color: #268bd2;">__add_to_swap_cache</span><span style="color: #757575;">(</span><span style="color: #b58900;">page</span><span style="color: #757575;">,</span> <span style="color: #b58900;">entry</span><span style="color: #757575;">,</span> GFP_ATOMIC|__GFP_NOWARN<span style="color: #757575;">)</span>;
        <span style="color: #586e75;">// </span><span style="color: #586e75;">&#23558; page &#21152;&#20837; swapper_space &#25351;&#23450;&#30340; page cache, &#20351;&#29992;&#30340; index &#20026;</span>
        <span style="color: #586e75;">// </span><span style="color: #586e75;">get_swap_page &#36820;&#22238;&#30340; swap identifier</span>
        radix_tree_insert<span style="color: #757575;">(</span>&amp;swapper_space.page_tree<span style="color: #757575;">,</span> entry.val<span style="color: #757575;">,</span> page<span style="color: #757575;">)</span>;
        <span style="color: #268bd2;">SetPageLocked</span><span style="color: #757575;">(</span><span style="color: #b58900;">page</span><span style="color: #757575;">)</span>;
        <span style="color: #268bd2;">SetPageSwapCache</span><span style="color: #757575;">(</span><span style="color: #b58900;">page</span><span style="color: #757575;">)</span>;
        page-&gt;private = entry.val;
      <span style="color: #268bd2;">SetPageDirty</span><span style="color: #757575;">(</span><span style="color: #b58900;">page</span><span style="color: #757575;">)</span>;

  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#23545;&#20110; anonymous page , page_mapping &#36820;&#22238;&#20540;&#20026; swapper_space</span>
  mapping = page_mapping<span style="color: #757575;">(</span>page<span style="color: #757575;">)</span>;
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20462;&#25913;&#30456;&#20851;&#30340; PTE</span>
  <span style="color: #268bd2;">try_to_unmap</span><span style="color: #757575;">(</span><span style="color: #b58900;">page</span><span style="color: #757575;">)</span>
    <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>PageAnon<span style="color: #757575;">(</span>page<span style="color: #757575;">))</span>:
      try_to_unmap_anon<span style="color: #757575;">(</span>page<span style="color: #757575;">)</span>;
        try_to_unmap_one
          <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>PageAnon<span style="color: #757575;">(</span>page<span style="color: #757575;">))</span>:
            <span style="color: #586e75;">// </span><span style="color: #586e75;">&#23545;&#20110; anonymous page, PTE &#34987;&#20462;&#25913;&#20026; swap identifier</span>
            swp_entry_t entry = <span style="color: #757575;">{</span> .val = page-&gt;private <span style="color: #757575;">}</span>;
            <span style="color: #268bd2;">set_pte</span><span style="color: #757575;">(</span><span style="color: #b58900;">pte</span><span style="color: #757575;">,</span> <span style="color: #b58900;">swp_entry_to_pte</span><span style="color: #757575;">(</span><span style="color: #268bd2;">entry</span><span style="color: #757575;">))</span>;
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#23545;&#20110; anonymous page, page &#24517;&#28982;&#20026; dirty (&#21442;&#32771; add_to_swap)</span>
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>PageDirty<span style="color: #757575;">(</span>page<span style="color: #757575;">))</span>:
    pageout<span style="color: #757575;">(</span>page<span style="color: #757575;">,</span> mapping<span style="color: #757575;">)</span>
      mapping-&gt;a_ops-&gt;writepage<span style="color: #757575;">(</span>page<span style="color: #757575;">,</span> &amp;wbc<span style="color: #757575;">)</span>
        <span style="color: #268bd2;">swap_writepage</span><span style="color: #757575;">()</span>

  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span>PageSwapCache<span style="color: #757575;">(</span>page<span style="color: #757575;">))</span>:
    __delete_from_swap_cache<span style="color: #757575;">(</span>page<span style="color: #757575;">)</span>;
</pre>
</div>
</div>
</li>

<li><a id="org9023385"></a>Swap In<br />
<div class="outline-text-6" id="text-1-4-3-4-4">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">do_swap_page</span>:
  <span style="color: #b58900;">swp_entry_t</span> <span style="color: #268bd2;">entry</span> = pte_to_swp_entry<span style="color: #757575;">(</span>orig_pte<span style="color: #757575;">)</span>;
  page = lookup_swap_cache<span style="color: #757575;">(</span>entry<span style="color: #757575;">)</span>;
  <span style="color: #859900;">if</span> <span style="color: #757575;">(</span><span style="color: #b58900; font-weight: bold;">!</span>page<span style="color: #757575;">)</span>:
    page = read_swap_cache_async<span style="color: #757575;">(</span>entry<span style="color: #757575;">,</span> vma<span style="color: #757575;">,</span> address<span style="color: #757575;">)</span>;
      new_page = alloc_page_vma<span style="color: #757575;">(</span>GFP_HIGHUSER<span style="color: #757575;">,</span> vma<span style="color: #757575;">,</span> addr<span style="color: #757575;">)</span>;
      <span style="color: #268bd2;">add_to_swap_cache</span><span style="color: #757575;">(</span><span style="color: #b58900;">new_page</span><span style="color: #757575;">,</span> <span style="color: #b58900;">entry</span><span style="color: #757575;">)</span>;
      <span style="color: #268bd2;">lru_cache_add_active</span><span style="color: #757575;">(</span><span style="color: #b58900;">new_page</span><span style="color: #757575;">)</span>;
      swap_readpage<span style="color: #757575;">(</span><span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #757575;">,</span> new_page<span style="color: #757575;">)</span>;
      <span style="color: #859900;">return</span> new_page;
    ret = VM_FAULT_MAJOR;
  <span style="color: #586e75;">// </span><span style="color: #586e75;">&#20462;&#25913; PTE</span>
  pte = mk_pte<span style="color: #757575;">(</span>page<span style="color: #757575;">,</span> vma-&gt;vm_page_prot<span style="color: #757575;">)</span>;
  <span style="color: #268bd2;">set_pte</span><span style="color: #757575;">(</span><span style="color: #b58900;">page_table</span><span style="color: #757575;">,</span> <span style="color: #b58900;">pte</span><span style="color: #757575;">)</span>;
  <span style="color: #268bd2;">page_add_anon_rmap</span><span style="color: #757575;">(</span><span style="color: #b58900;">page</span><span style="color: #757575;">,</span> <span style="color: #b58900;">vma</span><span style="color: #757575;">,</span> <span style="color: #b58900;">address</span><span style="color: #757575;">)</span>;
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org7d6bdbb" class="outline-5">
<h5 id="org7d6bdbb"><span class="section-number-5">1.4.3.5</span> Out Of Memory</h5>
<div class="outline-text-5" id="text-1-4-3-5">
<p>
当内存特别紧张时 __alloc_pages 最后会调用 out_of_memory 来杀死某个进程来释放内存.
</p>

<p>
out_of_memory 的功能称为 oom killer, 它主要的功能是通过
select_bad_process 选择一个 victim, 选择的标准是:
</p>

<ol class="org-ol">
<li>victim 应该占用很多内存, 以便 kill 它会释放很多内存</li>

<li>victim 不应该是一个已经长时间运行的进程</li>

<li>victim 应该有较低的静态优先级</li>

<li>victim 不应该是 root 进程或 kernel thread (swapper, init, &#x2026;)</li>
</ol>
</div>

<ol class="org-ol">
<li><a id="org8da2e23"></a>badness<br />
<div class="outline-text-6" id="text-1-4-3-5-1">
</div>

<ol class="org-ol">
<li><a id="org1b90e1a"></a>oom_adjust<br /></li>
</ol>
</li>
</ol>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
即使是 32 位 CPU, 其段寄存器也是 16 位
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
地址映射是否存在以及 page 权限是否一致
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
但也有例外, 比如通过 CLONE_VM 创建的进程
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <div class="footpara"><p class="footpara">
通过 page entry 的 User/Supervisor flag 来限制访问, 但这里有一个例外: vsyscall page 位于 3G 以上 (0xffffe000), 但通过设置 page entry
的 user flag 允许 user mode 访问, 具体参考 
</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5">5</a></sup> <div class="footpara"><p class="footpara">
swapper (或 idle 进程, init_task, 0 号进程) 是一个例外: 它会使用 swapper_pg_dir 做为 page table
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">

<p class="author">Author: sunway (sunwayforever@gmail.com)<br />
Date: 2016-06-14 二 00:00<br />
Last updated: 2022-01-19 三 13:25</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。
<br />

<div id="disqus_thread"></div>
<script>

(function() { // DON'T EDIT BELOW THIS LINE
         var d = document, s = d.createElement('script');
         s.src = '//sunwayforever-github-io.disqus.com/embed.js';
         s.setAttribute('data-timestamp', +new Date());
         (d.head || d.body).appendChild(s);
         })();
</script>
</div>
</body>
</html>
