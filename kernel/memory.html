<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-01-26 Wed 20:09 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Linux Kernel: Memory</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wei Sun (孙伟)" />
<link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
<link rel = "icon" href = "/icon.png"  type = "image/x-icon">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">Linux Kernel: Memory</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org311d983">1. Linux Kernel: Memory</a>
<ul>
<li><a href="#org5683e60">1.1. 内存定址</a>
<ul>
<li><a href="#org09b9ac6">1.1.1. 分段</a></li>
<li><a href="#org65bf59c">1.1.2. 分页</a></li>
</ul>
</li>
<li><a href="#org3ccd20f">1.2. 内存管理</a>
<ul>
<li><a href="#org903b5d7">1.2.1. Page Descriptor</a></li>
<li><a href="#org35cc50e">1.2.2. Memory Zones</a></li>
<li><a href="#orgcd851a6">1.2.3. Zone Allocator</a></li>
<li><a href="#org3959c62">1.2.4. Physical Mapping</a></li>
<li><a href="#org7531025">1.2.5. Mapping High memory</a></li>
<li><a href="#org5a406c8">1.2.6. Buddy System</a></li>
<li><a href="#org394f816">1.2.7. Slab Allocator</a></li>
<li><a href="#orgfa76e67">1.2.8. vmalloc</a></li>
<li><a href="#org5db649a">1.2.9. Bootmem Allocator</a></li>
</ul>
</li>
<li><a href="#orgd29711c">1.3. 进程地址空间</a>
<ul>
<li><a href="#orgb4655c2">1.3.1. mm_struct</a></li>
<li><a href="#orgf5a10c1">1.3.2. Memory Region</a></li>
<li><a href="#org60f8369">1.3.3. Page Fault</a></li>
<li><a href="#org0cc98d1">1.3.4. Creating Process Address Space</a></li>
<li><a href="#org0ce7ec9">1.3.5. Managing the Heap</a></li>
<li><a href="#org2f5d038">1.3.6. API</a></li>
</ul>
</li>
<li><a href="#org0d2bfaf">1.4. 页面回收</a>
<ul>
<li><a href="#orgafdab97">1.4.1. Overview</a></li>
<li><a href="#org8b59652">1.4.2. 反向映射</a></li>
<li><a href="#org25ed659">1.4.3. PFRA 的实现</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org311d983" class="outline-2">
<h2 id="org311d983"><span class="section-number-2">1</span> Linux Kernel: Memory</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org5683e60" class="outline-3">
<h3 id="org5683e60"><span class="section-number-3">1.1</span> 内存定址</h3>
<div class="outline-text-3" id="text-1-1">
<p>
内存定址 (memory addressing) 是指如何实现虚拟地址与物理地址的转换. 
</p>
</div>

<div id="outline-container-org09b9ac6" class="outline-4">
<h4 id="org09b9ac6"><span class="section-number-4">1.1.1</span> 分段</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
分段 (segmentation) 是早期 x86 采用的内存定址方式
</p>
</div>

<div id="outline-container-org85e024f" class="outline-5">
<h5 id="org85e024f"><span class="section-number-5">1.1.1.1</span> 实模式</h5>
<div class="outline-text-5" id="text-1-1-1-1">
<p>
实模式 (real mode) 下, 各个段寄存器保存的是段基址
</p>
</div>
</div>

<div id="outline-container-org3c811a0" class="outline-5">
<h5 id="org3c811a0"><span class="section-number-5">1.1.1.2</span> 保护模式</h5>
<div class="outline-text-5" id="text-1-1-1-2">
<p>
在保护模式 (protected mode) 下, 各个段寄存器中保存的不再是段的基址: 每个段寄存器共 16
位<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> , 其中高 13 位是一个索引, 指向 GDT (Global Descriptor Table)
或 LDT (Local Descriptor Table) 表中的某一项 segment descriptor.
</p>

<p>
对于 cs 寄存器, 它的低两位称为 CPL (Current Privilege Level), cs 的
CPL 位始终与 CPU 当时的 privilege level (ring) 是一致的(参考 ). 若当前处于 kernel mode, 则 CPU 为 ring 0, cs 的 CPL 也为 0, 若
当前处于 user mode, 则 CPU 的 ring 和 cs 的 CPL 都为 3
</p>

<p>
保护模式与实模式的切换是通过 cr0 寄存器来完成, 显然这个切换模式的指令
在保护模式下必须在 ring 0 时才能进行
</p>
</div>
</div>

<div id="outline-container-orgfab6db7" class="outline-5">
<h5 id="orgfab6db7"><span class="section-number-5">1.1.1.3</span> 段描述符</h5>
<div class="outline-text-5" id="text-1-1-1-3">
<p>
每个段描述符 (segment descriptor) 大小为 8 bytes, 它主要的结构:
</p>

<ol class="org-ol">
<li><p>
base
</p>

<p>
32 bit 的段基址
</p></li>

<li><p>
limit
</p>

<p>
20 bit 的 limit
</p></li>

<li><p>
G
</p>

<p>
1 bit 的 granularity 标记, 若 clear, 则上面的 limit 单位为 byte, limit 最大
可以表示 1MB, 若 set, 则 limit 单位为 4K, limit 最大表示 4G
</p></li>

<li><p>
DPL
</p>

<p>
2 bit 的 descriptor privilege level, 它的作用在后面的 <a href="#orgb25f052">memory 的保护</a>
部分会描述
</p></li>
</ol>

<p>
对 linux 来说, 所有的 segment descriptor:
</p>

<ol class="org-ol">
<li>base 都是 0</li>

<li>G 都置位</li>

<li>limit 都为 0xfffff</li>
</ol>

<p>
所以 logical address (最原始的地址) 与 linear address (被 segment unit
映射过的地址) 是一样的, 所以对 linux 来说, 使用 segmentation 主要的用
处是实现 segmentation protection
</p>
</div>
</div>

<div id="outline-container-org00a19bf" class="outline-5">
<h5 id="org00a19bf"><span class="section-number-5">1.1.1.4</span> 基于分段的保护</h5>
<div class="outline-text-5" id="text-1-1-1-4">
<p>
基于分段的保护 (segmentation protection), 主要是指基于 CPL, DPL 的保护,
主要有几方面:
</p>
</div>

<div id="outline-container-orgb25f052" class="outline-6">
<h6 id="orgb25f052"><span class="section-number-6">1.1.1.4.1</span> memory 的保护</h6>
<div class="outline-text-6" id="text-1-1-1-4-1">
<p>
由于 linux 主要依赖 paging 来保护内存, 所以 segmentation 对内存的保护
不好体现. 假设存在某种依赖 segmentation 保护内存的 OS, 它的 gtd 表中有
几个 segment descriptor, 其中 segment A 通过 base+limit 指定了一个内存
区域是设计给 user space 使用的 (DPL = 3), segment B 指定了另一个内存区
域给 kernel 使用 (DPL = 0)
</p>

<p>
假设 user space 的进程想非法访问 segment B 指定的那块内存区域, 则它可
能会通过 mov 指令修改 ss 或 ds 的值, 使 ss 或 ds 指定 segment B, 但由
于 segmentation protection 的存在, 这个指令并不能成功: CPU 会在执行 mov
时会检测于 cs 的 CPL (3) 大于 segment B 的 DPL (0), 从而触发 exception.
</p>

<p>
似乎有一个问题: user space 直接在 GDT 里加一项 DPL 为 3 的 segment
descriptor 不就可以通过个 segment 访问任意内存了么? GDT 所在的内存区域
显然不是 ring 3 可以访问的&#x2026;
</p>
</div>
</div>

<div id="outline-container-orgf2b659b" class="outline-6">
<h6 id="orgf2b659b"><span class="section-number-6">1.1.1.4.2</span> 指令的保护</h6>
<div class="outline-text-6" id="text-1-1-1-4-2">
<p>
有些指令限制了只有 ring 0 才可以使用, 或者限制了只有 ring 0 才能在某些
指令中使用特定的操作数.
</p>

<p>
例如, cr0 寄存器的值关系到是否开启 segmentation 和 paging, 以及实模式
与保护模式的切换, 所以 mov 指令想修改 cr0 时需要是 ring 0 才行.
</p>
</div>
</div>

<div id="outline-container-org9f3b02d" class="outline-6">
<h6 id="org9f3b02d"><span class="section-number-6">1.1.1.4.3</span> interrupt 处理</h6>
<div class="outline-text-6" id="text-1-1-1-4-3">
<p>
interrupt, trap, syscall 都是通过同一个 idt (中断向量表) 处理的, 例如
page fault 这个 interrupt 在 idt_table 中对应的 index 为 14, 那么 ring
3 是否可以通过 int 14 来模拟一个 page fault?
</p>

<p>
显然不可以, CPU 在执行 int 指令时, 会检查 CPL 与 interrupt descriptor
的 DPL 是否一致. 实际上, 在 idt_table 中, 只有 system gate
(set_system_gate, 0x80) 和 system interrupt gate
(set_system_intr_gate, 0x3) 两项可以被 ring 3 的 int 指令调用
</p>

<p>
因为 int 指令可以指定任意 idt index, 所以每个 int 指令都需要去检查 CPL
与 DPL. 但 int 通常都是用来实现 syscall 的, x86 又提供两个不需要检查
DPL 的 `int 0x80` 指令: sysenter, syscall (参考 )
</p>
</div>
</div>

<div id="outline-container-orgec7e569" class="outline-6">
<h6 id="orgec7e569"><span class="section-number-6">1.1.1.4.4</span> See also</h6>
<div class="outline-text-6" id="text-1-1-1-4-4">
<p>
<a href="http://duartes.org/gustavo/blog/post/cpu-rings-privilege-and-protection/">CPU-rings-privilege-and-protection</a>
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org65bf59c" class="outline-4">
<h4 id="org65bf59c"><span class="section-number-4">1.1.2</span> 分页</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
分页 (paging) 是另一种内存定址的方式, 由于它功能更强, 已经代替了上面提
到的分段的方式, 但如前面 <a href="#org3c811a0">保护模式</a> 所述, linux 还是会使用分段提供的保护
模式等和安全相关的功能. 但是不会使用分段机制提供的地址翻译相关的功能
(例如所有段描述符中的 base 都为 0)
</p>
</div>

<div id="outline-container-orga7109be" class="outline-5">
<h5 id="orga7109be"><span class="section-number-5">1.1.2.1</span> Overview</h5>
<div class="outline-text-5" id="text-1-1-2-1">
<p>
Paging unit 的作用:
</p>

<ol class="org-ol">
<li>将 linear address 映射为 physical address</li>

<li>检查是否有权限访问 linear address<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup></li>
</ol>

<p>
paging unit 将物理内存划分为连续的定长 (一般为 4K) 的 page frame (或者
叫 physical page). page frame 就是一块固定大小的连续物理内存.
</p>

<p>
与 page frame 对应的是 page 结构体 (struct page), struct page 是一个结
构体, 与 page frame (已分配的) 有一一对应关系. struct page 本身, 做为
一个变量, 必定是保存在某个 page frame 中, 但这个 page frame 与 struct
page "管理" 的那个 page frame 并没有任何关系
</p>
</div>
</div>

<div id="outline-container-org5bcb177" class="outline-5">
<h5 id="org5bcb177"><span class="section-number-5">1.1.2.2</span> Paging</h5>
<div class="outline-text-5" id="text-1-1-2-2">
<p>
i386 使用 cr3 保存 Page Directory Table 的物理地址.
</p>

<p>
i386 的 linear address 为 32 位, page frame 大小为 4K (12 位).
</p>

<p>
32 位的 linear address 的高 10 位做为 page directory 中的 index, 因为
page directory 本身占用一个 page frame (4K), 每个 page directory entry
占用 4B (32 位物理地址), 所以一个 page directory 刚好能存放 1024
(2^10) 个 PTE. 这里 page directory 划分为 10 位, 根本的原
因是 4K 的 page frame, 每个 entry 大小为 32 位, 最多只能容纳 2^10 个
entry
</p>

<p>
后 10 位做为 page table 中的 index
</p>

<p>
使用前 20 定位到 page table 中的某一个 page frame 的地址后, 加上剩下的
12 位就是最终的物理地址.
</p>


<div id="org3557e61" class="figure">
<p><img src="../extra/kernel_paging.png" alt="kernel_paging.png" />
</p>
</div>

<p>
由于 page frame 的地址是 4K 对齐的, 所以 page directory entry 和 page
table entry 只需要 20 位就可以表示, 但 page directory entry 和 page
table entry 都是用 32 位表示, 所以它们的低 12 位实际是空闲的, 可以用来
表示一些和 page frame 相关的的额外信息, 比如权限. 这 12 位空闲比特构成
了 page directory/table entry 的 flag
</p>
</div>
</div>

<div id="outline-container-orgfe532e0" class="outline-5">
<h5 id="orgfe532e0"><span class="section-number-5">1.1.2.3</span> page directory/table entry 的 flag</h5>
<div class="outline-text-5" id="text-1-1-2-3">
<ol class="org-ol">
<li><p>
Present
</p>

<p>
表示 page entry 是否映射了一个 page frame. 若进行地址转换
时解析到某个 entry 的 Present 为 0, 则会触发 Page Fault.
</p></li>

<li><p>
Accessed
</p>

<p>
Paging unit 每次进行地址转换时都会将涉及到的 page frame 的 Accessed
置位. kernel 会读取这些标记, 比如选择 page frame 进行 swapped out
的动作时. 另外, CPU 只负责置位, 不会主动对它们复位, kernel 会负责进
行复位
</p></li>

<li><p>
Dirty
</p>

<p>
与 Accessed 类似, 但只针对 PTE. CPU 每次对 page frame 的写
操作都会将相应的 PTE 的 Dirty 置位
</p></li>

<li><p>
Read/Write
</p>

<p>
是否可读或可读写. 若 flag 为 0, 表示可读, flag 为 1, 表示可读写
</p></li>

<li><p>
User/Supervisor
</p>

<p>
privilege level require to access the page frame, 若 flag 为 0, 则
类似于 DPL 为 0, 若 flag 为 1, 则相当于 DPL 为 3
</p></li>
</ol>
</div>
</div>

<div id="outline-container-orgf1bb79a" class="outline-5">
<h5 id="orgf1bb79a"><span class="section-number-5">1.1.2.4</span> Process page table 初始化</h5>
<div class="outline-text-5" id="text-1-1-2-4">
<p>
一般情况下每个进程有不同的页表, 即 PGD (Page Global Directory) 不
同<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup>, 这个页表的 0~0xc0000000(3GB) 的部分是 user space 可以访问的,
0xc0000000~0xffffffff 是只有 kernel 可以访问<sup><a id="fnr.4" class="footref" href="#fn.4">4</a></sup>
</p>

<p>
进程页表是 fork 时分配的, 并且会复制父进程的页表
</p>
</div>

<div id="outline-container-org56e9420" class="outline-6">
<h6 id="org56e9420"><span class="section-number-6">1.1.2.4.1</span> do_fork</h6>
<div class="outline-text-6" id="text-1-1-2-4-1">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">do_fork</span>:
  <span style="font-weight: bold;">copy_process</span>()
    <span style="font-weight: bold;">copy_mm</span>()
      <span style="font-weight: bold;">if</span> (clone_flags &amp; CLONE_VM):
        tsk-&gt;mm = oldmm;
        <span style="font-weight: bold;">return</span>
      mm = allocate_mm();
      <span style="font-weight: bold;">memcpy</span>(mm, oldmm, <span style="font-weight: bold;">sizeof</span>(*mm));
      <span style="font-weight: bold;">mm_init</span>()
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">1. &#20998;&#37197; pgd</span>
        <span style="font-weight: bold;">mm_alloc_pgd</span>()
      <span style="font-weight: bold;">dup_mmap</span>(mm, oldmm);
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">2. &#22797;&#21046;&#29238;&#36827;&#31243;&#39029;&#34920;</span>
        <span style="font-weight: bold;">copy_page_range</span>(mm, current-&gt;mm, tmp);
          copy_pud_range
            copy_pmd_range
              copy_pte_range
                <span style="font-weight: bold; text-decoration: underline;">copy_one_pte</span>
      <span style="font-weight: bold; font-style: italic;">tsk</span>-&gt;mm = mm;
</pre>
</div>

<p>
需要注意的是, dump_mmap 复制由 vma 控制的区域的页表项, 即 3G 以下的部
分, 3G 以上的部分的复制由 mm_alloc_pgd 间接完成 <a href="#org17212f2">Kernel page table 与
process page table 的同步</a>
</p>
</div>
</div>

<div id="outline-container-org6492f04" class="outline-6">
<h6 id="org6492f04"><span class="section-number-6">1.1.2.4.2</span> Copy On Write</h6>
<div class="outline-text-6" id="text-1-1-2-4-2">
<p>
copy_one_pte 只是复制 PTE: 新旧两个 pte 值相同, 指向同一
个 page frame, copy_one_pte 会处理 COW 的情况
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">copy_one_pte</span>:
  <span style="font-weight: bold;">if</span> ((vm_flags &amp; (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE):
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#29238;&#36827;&#31243;&#30340; pte &#37117;&#35774;&#20026;&#21482;&#35835;&#24182;&#22797;&#21046;&#21040;&#23376;&#36827;&#31243;&#30340;&#39029;&#34920;, &#21518;&#32493;&#20219;&#20309;&#19968;&#26041;&#20462;&#25913;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#30456;&#24212;&#30340; page frame, &#37117;&#20250;&#35302;&#21457; page fault</span>
      ptep_set_wrprotect(src_pte);

<span style="font-weight: bold; text-decoration: underline;">do_page_fault</span>:
  vma = find_vma(mm, address);
  <span style="font-weight: bold;">switch</span> (error_code &amp; 3) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">3 &#34920;&#31034;&#20889;&#25805;&#20316;, &#19988; pte &#26159; present</span>
    <span style="font-weight: bold;">case</span> 3:
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#34920;&#31034; fault address &#23545;&#24212;&#30340; vma &#26377;&#20889;&#26435;&#38480;</span>
        <span style="font-weight: bold;">if</span> (vma-&gt;vm_flags &amp; VM_WRITE):
          write = 1;
        <span style="font-weight: bold;">break</span>
  handle_mm_fault(mm, vma, address, write)
    <span style="font-weight: bold;">if</span> (write_access &amp;&amp; pte_present(entry)):
      <span style="font-weight: bold;">if</span> (!pte_write(entry)):
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">wp &#25351; write-protected</span>
        do_wp_page(mm, vma, address, pte, pmd, entry);
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#33509; page count &#20026; 1,  &#23558; pte &#35774;&#20026;&#20889;&#21487;, &#20197;&#20415;&#20849;&#20139; pte &#30340;&#26368;&#21518;&#19968;&#20010;&#36827;&#31243;&#19981;&#20250;&#20877; page fault</span>
          reuse = can_share_swap_page(old_page)
          <span style="font-weight: bold;">if</span> reuse:
            pte_mkwrite(pte);
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20998;&#37197;&#19968;&#20010;&#26032;&#30340; page &#24182;&#22797;&#21046;&#26087;&#30340; page</span>
          new_page = alloc_page_vma(GFP_HIGHUSER, vma, address);
          copy_user_highpage(new_page, old_page, address);
          break_cow(vma, new_page, address, page_table);
          entry = maybe_mkwrite(pte_mkdirty(mk_pte(new_page, vma-&gt;vm_page_prot)),
                                vma);
          ptep_establish(vma, address, page_table, entry);
            <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35774;&#32622;&#26032;&#30340;&#39029;&#34920;</span>
            set_pte_atomic(__ptep, __entry);
</pre>
</div>

<p>
父子两个进程的页表的 pte 都设为只读, 后续任何一方修改相应的 page
frame, 都会触发 page fault, 从而分配新的 page frame
</p>
</div>
</div>
</div>

<div id="outline-container-org0eb3652" class="outline-5">
<h5 id="org0eb3652"><span class="section-number-5">1.1.2.5</span> Kernel page table 初始化</h5>
<div class="outline-text-5" id="text-1-1-2-5">
<p>
kernel page table 是 kernel 使用的 page table, 这个 table 的地址保存在
swapper_pg_dir (linear address) 中.
</p>

<p>
kernel 页表的布局大约是这样的:
</p>

<div class="org-src-container">
<pre class="src src-ditaa">
0                              3G      3G+896M                            4095M 4G
+------------------------------+-----------+-----------+-------------+-------+--+
|                              | physical  |  vmalloc  | perm kmaps  | fixed |  |
+------------------------------+-----------+-----------+-------------+-------+--+
                                  896M         ~124M         4M        ~100 K

</pre>
</div>


<div id="org6497a92" class="figure">
<p><img src="../extra/kernel_address_space.png" alt="kernel_address_space.png" />
</p>
</div>
</div>

<div id="outline-container-orgcd63098" class="outline-6">
<h6 id="orgcd63098"><span class="section-number-6">1.1.2.5.1</span> pagetable_init</h6>
<div class="outline-text-6" id="text-1-1-2-5-1">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">paging_init</span>:
  <span style="font-weight: bold;">pagetable_init</span>();
  <span style="font-weight: bold;">load_cr3</span>(swapper_pg_dir);
    <span style="font-weight: bold;">asm</span> <span style="font-weight: bold;">volatile</span>(<span style="font-style: italic;">"movl %0,%%cr3"</span>: :<span style="font-style: italic;">"r"</span> (__pa(pgdir)))
  <span style="font-weight: bold;">kmap_init</span>();

<span style="font-weight: bold; text-decoration: underline;">pagetable_init</span>:
  <span style="font-weight: bold; text-decoration: underline;">pgd_t</span> *<span style="font-weight: bold; font-style: italic;">pgd_base</span> = swapper_pg_dir;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">1. &#21069; 896M &#29289;&#29702;&#20869;&#23384;&#30452;&#25509;&#26144;&#23556;&#20110; 3G~3G+896M &#30340;&#34394;&#25311;&#22320;&#22336;</span>
  <span style="font-weight: bold;">kernel_physical_mapping_init</span>(pgd_base);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">2. fixed_addresses &#37096;&#20998;&#30340;&#26144;&#23556;, &#36825;&#37096;&#20998;&#26144;&#23556;&#30340;&#34394;&#25311;&#22320;&#22336;&#33539;&#22260;&#26159; 4095M &#20043;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21069;&#30340;&#20960;&#21313;&#20010; page, &#36825;&#37324;&#30340; vaddr &#23454;&#38469;&#23601;&#26159; 4095M, &#36825;&#37324;&#30475;&#36215;&#26469;&#25351;&#23450;&#30340;&#26159;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19968;&#20010;&#32467;&#26463;&#22320;&#22336;&#32780;&#38750;&#36215;&#22987;&#22320;&#22336;? &#23454;&#38469;&#19978;, &#21518;&#38754;&#30340; page_table_range_init &#35201;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26681;&#25454; vaddr &#25805;&#20316;&#30456;&#24212;&#30340; PGD entry, 4092M~4096M &#33539;&#22260;&#37117;&#33853;&#22312;&#21516;&#19968;&#20010; PGD</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">entry &#19978;</span>
  vaddr = __fix_to_virt(__end_of_fixed_addresses - 1) &amp; PMD_MASK;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">pagetable_init &#21482;&#36127;&#36131;&#21021;&#22987;&#21270;&#30456;&#24212;&#30340; page table: page table &#20013; PTE &#30340;&#20540;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#30001;&#21518;&#32493;&#30340; set_fixmap &#21450; kmap_atomic &#35774;&#32622;</span>
  <span style="font-weight: bold;">page_table_range_init</span>(vaddr, 0, pgd_base);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">3. KMAP &#37096;&#20998;&#30340;&#26144;&#23556;</span>
  <span style="font-weight: bold;">permanent_kmaps_init</span>(pgd_base);
</pre>
</div>
</div>
</div>

<div id="outline-container-org7a4ef95" class="outline-6">
<h6 id="org7a4ef95"><span class="section-number-6">1.1.2.5.2</span> kernel_physical_mapping_init</h6>
<div class="outline-text-6" id="text-1-1-2-5-2">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">kernel_physical_mapping_init</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">PAGE_OFFSET &#20026; 0xc0000000 pgd_index &#20026; 0xc0000000 &#23545;&#24212;&#30340; pgd &#20013;&#30340;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#32034;&#24341;, &#21363; 768</span>
  pgd_idx = pgd_index(PAGE_OFFSET);
  pgd = pgd_base + pgd_idx;
  pfn = 0;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">PTRS_PER_PGD &#20026; 1024</span>
  <span style="font-weight: bold;">for</span> (; pgd_idx &lt; PTRS_PER_PGD; pgd++, pgd_idx++):
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20197; 32 bit paging (10-10-12 &#20004;&#32423;&#26144;&#23556;) &#20026;&#20363;, pmd &#19982; pgd &#26159;&#19968;&#26679;&#30340;,</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19988; PTRS_PER_PMD &#20026; 1 , &#25152;&#20197;&#21518;&#38754;&#20004;&#34892;&#20195;&#30721;&#21487;&#20197;&#24573;&#30053;</span>
    <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">pmd = one_md_table_init(pgd);</span><span style="font-weight: bold; font-style: italic;"> */</span>
    <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">for (pmd_idx = 0; pmd_idx &lt; PTRS_PER_PMD &amp;&amp; pfn &lt; max_low_pfn; pmd++, pmd_idx++):</span><span style="font-weight: bold; font-style: italic;"> */</span>

    pte = one_page_table_init(pgd);
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20998;&#37197;&#19968;&#20010; page table, &#24182;&#25554;&#20837;&#21040; PMD (&#23545;&#20110; 32 bit, &#23454;&#38469;&#23601;&#26159;&#25554;&#20837;&#21040; PGD) &#20013;&#30456;&#24212;&#30340;&#20301;&#32622;</span>
      <span style="font-weight: bold; text-decoration: underline;">pte_t</span> *<span style="font-weight: bold; font-style: italic;">page_table</span> = (<span style="font-weight: bold; text-decoration: underline;">pte_t</span> *) <span style="font-weight: bold;">alloc_bootmem_low_pages</span>(PAGE_SIZE);
      <span style="font-weight: bold;">set_pmd</span>(pmd, __pmd(<span style="font-weight: bold; text-decoration: underline;">__pa</span>(<span style="font-weight: bold; font-style: italic;">page_table</span>) | _PAGE_TABLE));
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545; page table &#20013;&#27599;&#19968;&#39033;&#35774;&#32622;&#19968;&#20010; pte, PTRS_PER_PTE &#20026; 1024</span>
    <span style="font-weight: bold;">for</span> (pte_ofs = 0; pte_ofs &lt; PTRS_PER_PTE &amp;&amp; pfn &lt; max_low_pfn; pte++, pfn++, pte_ofs++):
      set_pte(pte, pfn_pte(pfn, PAGE_KERNEL));
                     <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">pfn &#26159; page frame number, pfn &#24038;&#31227; 12 &#20301;&#21363;&#26159;&#23427;</span>
                     <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#24212;&#30340; page frame &#30340;&#29289;&#29702;&#22320;&#22336;</span>
                     <span style="font-weight: bold;">__pte</span>(((pfn) &lt;&lt; PAGE_SHIFT) | pgprot_val(prot))

</pre>
</div>
</div>
</div>

<div id="outline-container-orge564710" class="outline-6">
<h6 id="orge564710"><span class="section-number-6">1.1.2.5.3</span> page_table_range_init</h6>
<div class="outline-text-6" id="text-1-1-2-5-3">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">page_table_range_init</span>(vaddr, end, pgd_base);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">page_table_range_init &#21482;&#36127;&#36131;&#21021;&#22987;&#21270; PGD &#20013;&#30456;&#24212;&#30340; page table, &#33267;&#20110;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">page table &#20013; PTE &#30340;&#36171;&#20540;&#23427;&#24182;&#19981;&#22788;&#29702;</span>
  pgd_idx = pgd_index(vaddr);
  pgd = pgd_base + pgd_idx;
  <span style="font-weight: bold;">for</span> ( ; (pgd_idx &lt; PTRS_PER_PGD) &amp;&amp; (vaddr != end); pgd++, pgd_idx++):
    one_page_table_init(pgd);
    vaddr += 1&lt;&lt;22
</pre>
</div>
</div>
</div>

<div id="outline-container-org2358b45" class="outline-6">
<h6 id="org2358b45"><span class="section-number-6">1.1.2.5.4</span> permanent_kmaps_init</h6>
<div class="outline-text-6" id="text-1-1-2-5-4">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">permanent_kmaps_init</span>(pgd_base):
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">permanent_kmaps &#30340;&#34394;&#25311;&#22320;&#22336;&#33539;&#22260;&#26159; fixed_addresses &#21069;&#30340; 4MB &#30340;&#33539;&#22260;,</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25152;&#20197; PKMAP_BASE &#22823;&#32422;&#26159; 4090M &#24038;&#21491;</span>
  vaddr = PKMAP_BASE;
  <span style="font-weight: bold;">page_table_range_init</span>(vaddr, vaddr + PAGE_SIZE*LAST_PKMAP, pgd_base);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org17212f2" class="outline-5">
<h5 id="org17212f2"><span class="section-number-5">1.1.2.6</span> Kernel page table 与 process page table 的同步</h5>
<div class="outline-text-5" id="text-1-1-2-6">
<p>
kernel page table (swapper_pg_dir) 大部分情况<sup><a id="fnr.5" class="footref" href="#fn.5">5</a></sup>只是 process page table
的参考, 而不会被直接使用 (load 到 cr3). 在中断或 syscall 时, kernel
contrl path 都是使用被中断打断或发起 syscall 的进程的 process page table.
</p>

<p>
这是因为 syscall 时 kernel 通常需要访问进程自己的内存, 以 read 为例,
kernel 需要将读到的数据写入到进程自己的地址空间的某个 buffer 中去, 因
为 kernel 需要同时能访问到 process 和 kernel 的页表, 所以实现的方法是:
发起 syscall 时 kernel 使用 process page table, 并且保证 process page
table 的 3G 以上的部分与 kernel page table 是一致的, 如何做到一致?
</p>
</div>

<div id="outline-container-orgdaa8ad8" class="outline-6">
<h6 id="orgdaa8ad8"><span class="section-number-6">1.1.2.6.1</span> 固定映射的部分 (ZONE_DMA+ZONE_NORMAL)</h6>
<div class="outline-text-6" id="text-1-1-2-6-1">
<p>
<a href="#org56e9420">do_fork</a> 时已经提到了 mm_alloc_pgd, 但这个函数并不是简单的分配一个 pgd:
</p>

<p>
mm_alloc_pgd 是通过 slab 去分配 pgd 的, 而 slab 支持在分配某个 object
时指定一个 ctor, 分配完这个 object 后 slab 会自动执行这个 ctor.
</p>

<p>
pgtable_cache_init 时指定了一个叫做 pgd_ctor 的函数:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">pgd_ctor</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">USER_PTRS_PER_PGD &#34920;&#31034; PGD &#34920;&#20013;&#30340; 1024 &#20010;&#34920;&#39033;&#26377;&#22810;&#23569;&#26144;&#23556;&#30340; 3G &#20197;&#19979;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23454;&#38469;&#19978;&#22312; 32 &#20301;&#31995;&#32479;&#19978;&#36825;&#20010;&#20540;&#20026; 768 (1024 * 3 /4)</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25152;&#20197;&#19979;&#38754;&#20004;&#34892;&#30340;&#20316;&#29992;&#26159;:</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">1. &#23558; pgd &#21069; 3g &#30340;&#37096;&#20998;&#32622; 0</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">2. &#23558; pgd &#21518; 1g &#30340;&#37096;&#20998;&#29992; swapper_pg_dir &#21518; 1g &#30340;&#25968;&#25454;&#35206;&#30422;</span>
  <span style="font-weight: bold;">memcpy</span>((<span style="font-weight: bold; text-decoration: underline;">pgd_t</span> *)pgd + USER_PTRS_PER_PGD,
       swapper_pg_dir + USER_PTRS_PER_PGD,
       (PTRS_PER_PGD - USER_PTRS_PER_PGD) * <span style="font-weight: bold;">sizeof</span>(<span style="font-weight: bold; text-decoration: underline;">pgd_t</span>));
  <span style="font-weight: bold;">memset</span>(pgd, 0, <span style="font-weight: bold; text-decoration: underline;">USER_PTRS_PER_PGD</span>*<span style="font-weight: bold;">sizeof</span>(<span style="font-weight: bold; text-decoration: underline;">pgd_t</span>));
</pre>
</div>

<p>
通过 pgd_ctor, 可以确保每个 process page table 3G~4G 的部分与
swapper_pg_dir 是一致的
</p>
</div>
</div>

<div id="outline-container-org55e30db" class="outline-6">
<h6 id="org55e30db"><span class="section-number-6">1.1.2.6.2</span> 动态映射的部分 (ZONE_HIGHMEM)</h6>
<div class="outline-text-6" id="text-1-1-2-6-2">
<p>
但 swapper_pg_dir 后面 1g 的部分并不是一直固定不变的, 3G~3G+896M 的部
分是固定映射, 不会改变, 但 896M 之后的部分 (ZONE_HIGHMEM), 是通过 kmap
和 vmalloc 动态映射的, 前面通过 pgd_ctor 一次性的复制无法应对 kmap,
vmalloc 这种情况.
</p>

<p>
理论上, kmap/vmalloc 需要同时修改 kernel page table 和所有的 process
page table, 但实际上, kernel 采用了一种 lazy 的处理方式:
</p>

<p>
kmap/vmalloc 时 kernel 只修改 swapper_pg_dir, 当用户进程进入到 kernel
并需要访问这个区域上, 会发生 page fault, 因为 pgd entry 或 pt entry 为
null. 这时 do_page_fault 会检查 fault address 是否位于 swapper_pg_dir
的 kmap/vmalloc 区域 (vmalloc_fault), 如果是, 则根据 swapper_pg_dir 修改
process page table.
</p>

<p>
当 vfree 时, swapper_pg_dir 中相应的 PTE 被置 null, 这样
后续通过 process page table 访问之前那个 kmap/vmalloc 区域时, 会再次发
生 page fault, 但此时就不是 vmalloc_fault 了
</p>

<p>
参考 <a href="#org7567fa7">vmalloc_fault</a>
</p>
</div>
</div>
</div>

<div id="outline-container-org248dff4" class="outline-5">
<h5 id="org248dff4"><span class="section-number-5">1.1.2.7</span> 页表的切换</h5>
</div>
</div>
</div>

<div id="outline-container-org3ccd20f" class="outline-3">
<h3 id="org3ccd20f"><span class="section-number-3">1.2</span> 内存管理</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-org903b5d7" class="outline-4">
<h4 id="org903b5d7"><span class="section-number-4">1.2.1</span> Page Descriptor</h4>
<div class="outline-text-4" id="text-1-2-1">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">page</span> {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">PG_dirty, PG_private, PG_uptodate &#31561;&#21478;&#22806;, page &#25152;&#23646;&#30340; zone &#20449;&#24687;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25918;&#21253;&#21547;&#22312; flag &#20013; (memmap_init_zone)</span>
    <span style="font-weight: bold; text-decoration: underline;">page_flags_t</span> <span style="font-weight: bold; font-style: italic;">flags</span>;
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">private</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">page &#19982; inode &#30340; page cache &#20851;&#32852;</span>
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">address_space</span> *<span style="font-weight: bold; font-style: italic;">mapping</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">page &#22312; mapping &#20013;&#30340; index</span>
    <span style="font-weight: bold; text-decoration: underline;">pgoff_t</span> <span style="font-weight: bold; font-style: italic;">index</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">lru &#26681;&#25454; page &#30340;&#29366;&#24577;&#21644;&#29992;&#27861;&#26377;&#22810;&#31181;&#29992;&#36884;:</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">1. &#24403; page free &#26102;, &#21644; buddy system &#26377;&#20851; (zone-&gt;free_area)</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">2. &#24403; page &#29992;&#20570; slab &#30456;&#20851;&#26102;, &#21644; slab &#26377;&#20851;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">3. &#24403; page &#27491;&#22312;&#34987; user mode &#25110; page cache &#20351;&#29992;&#26102;,</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21644; PFRA &#26377;&#20851; (zone-&gt;active_list, zone-&gt;inactive_list)</span>
    <span style="font-weight: bold; font-style: italic;">//</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">lru &#30340;&#21517;&#23383;&#21462;&#30340;&#26159;&#31532;&#19977;&#31181;&#24773;&#20917;</span>
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">list_head</span> <span style="font-weight: bold; font-style: italic;">lru</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">...</span>
}
</pre>
</div>

<p>
每个 page 结构体的大小为 32 字节, 而且每个 page 结构体与 4K 的 page
frame 有一一对应关系.
</p>
</div>

<div id="outline-container-org9821ebe" class="outline-5">
<h5 id="org9821ebe"><span class="section-number-5">1.2.1.1</span> mem_map</h5>
<div class="outline-text-5" id="text-1-2-1-1">
<p>
paging_init 时会针对每一个 page frame 都生成一个 page struct, 并会把这
些 page struct 按 pfn 的顺序依次保存在 mem_map 数组中. 具体代码在
memmap_init_zone 中.
</p>

<p>
由于每个 page struct 大小为 32B, 所以 mem_map 本身会占用的物理内存大小
不到总内存的 1% (32/4K)
</p>

<p>
由于 mem_map 数组的存在, pfn_to_page 与 page_to_pfn 的实现就非常直接了.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">pfn_to_page</span>:
  mem_map + (pfn)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">page_to_pfn</span>:
  (page) - mem_map
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org35cc50e" class="outline-4">
<h4 id="org35cc50e"><span class="section-number-4">1.2.2</span> Memory Zones</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
kernel 将所有物理内存分为三个 zone:
</p>

<ol class="org-ol">
<li><p>
ZONE_DMA
</p>

<p>
管理低于 16M 的 page frame
</p></li>

<li><p>
ZONE_NORMAL
</p>

<p>
管理 16M ~ 896M 的 page frame
</p></li>

<li><p>
ZONE_HIGHMEM
</p>

<p>
896M 以上的 page frame
</p></li>
</ol>

<p>
由于硬件的限制, 旧式 ISA 设备的 DMA 只能使用 ZONE_DMA 中的 page frame.
</p>

<p>
ZONE_DMA 和 ZONE_NORMAL 中的 page frame 可以被 physical mapping
</p>

<p>
ZONE_HIGHMEM 中的 page frame 无法被 physical mapping (<a href="#org7531025">Mapping High
memory</a> )
</p>

<ol class="org-ol">
<li><p>
Non-contiguous Mapping
</p>

<p>
vmalloc
</p></li>

<li><p>
Permanent Kmap
</p>

<p>
kmap
</p></li>

<li>Fixed Mapping

<ol class="org-ol">
<li>kmap_atomic</li>
<li>set_fixmap</li>
</ol></li>
</ol>
</div>
</div>

<div id="outline-container-orgcd851a6" class="outline-4">
<h4 id="orgcd851a6"><span class="section-number-4">1.2.3</span> Zone Allocator</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
所有的 page frame 最终都是通过 zone allocator 来分配, 通过 zone
allocator 可以分配多个物理连续的 page frame. zone allocator 可以根据情
况 (GFP Mask 及各个 zone 剩余内存的情况) 选择在哪个 zone 中分配, 最后,
各个 zone 自己的 buddy allocator 会负责最终的分配.
</p>

<p>
分配 page frame 实际就是分配一个可用的 page struct, 因为 page struct
与 page frame 是一一对应的, 而且可能通过 pfn_to_page, page_to_pfn 方便
的转换.
</p>

<p>
分配只是分配一个可用的 page struct, 一般这个 page struct 需要通过映射
后才能使用, 根据 page struct 所属的 zone, 需要使用不同的映射方法来完成
映射.
</p>
</div>

<div id="outline-container-org7da2df3" class="outline-5">
<h5 id="org7da2df3"><span class="section-number-5">1.2.3.1</span> 相关的分配函数</h5>
<div class="outline-text-5" id="text-1-2-3-1">
</div>
<div id="outline-container-org9c39e92" class="outline-6">
<h6 id="org9c39e92"><span class="section-number-6">1.2.3.1.1</span> alloc_pages(gfp_mask, order)</h6>
<div class="outline-text-6" id="text-1-2-3-1-1">
<p>
分配 2^order 个连续的 page frame, 返回第个 page struct 的地址.
gfp_mask 中的 gfp 代表 "get_free_page". Zone allocator 会根据 gfp_mask
选择合适的 zone 来分配
</p>

<p>
alloc_pages 主要逻辑:
</p>

<ol class="org-ol">
<li>判断各个 zone 内存的使用情况</li>

<li>根据各个 zone 的内存情况及 gfp_mask 选择合适的 zone 去分配内存

<ol class="org-ol">
<li>选择一个可用内存大于 zone-&gt;pages_low 的 zone 去分配, pages_low
的值是 pages_min * 5 / 4</li>

<li>若所有 zone 的可用内存都小于 zone-&gt;pages_low, 则唤醒 kswapd 异步的回收内存</li>

<li>选择一个可用内存大于 zone-&gt;pages_min 的 zone 去分配, pages_min 的
值和 /proc/sys/vm/min_free_kbytes 有关</li>

<li>若所有 zone 的可用内存都小于 zone-&gt;pages_min, 则通过 try_to_free_pages 同步回收内存</li>
</ol></li>

<li>若所有 zone 都无法分配内存

<ol class="org-ol">
<li>out_of_memory 会通过 oom killer 杀掉某个 victim 进程以释放内存</li>
</ol></li>
</ol>

<p>
具体参考 <a href="#org0d2bfaf">页面回收</a>
</p>
</div>
</div>

<div id="outline-container-orgd81c9a5" class="outline-6">
<h6 id="orgd81c9a5"><span class="section-number-6">1.2.3.1.2</span> alloc_page(gfp_mask)</h6>
<div class="outline-text-6" id="text-1-2-3-1-2">
<p>
即 alloc_page(gfp_mask, 0)
</p>
</div>
</div>

<div id="outline-container-org1aa5046" class="outline-6">
<h6 id="org1aa5046"><span class="section-number-6">1.2.3.1.3</span> __get_free_pages(gfp_mask, order)</h6>
<div class="outline-text-6" id="text-1-2-3-1-3">
<p>
与 alloc_pages 类似, 但它将第一个 page struct 映射为线性地址后返回
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">__get_free_pages</span>:
  page = alloc_pages(gfp_mask, order);
  <span style="font-weight: bold;">if</span> (!page):
    <span style="font-weight: bold;">return</span> 0;
  <span style="font-weight: bold;">return</span>  page_address(page);
    <span style="font-weight: bold;">if</span> (!PageHighMem(page))
      <span style="font-weight: bold;">return</span> lowmem_page_address(page);
        <span style="font-weight: bold;">__va</span>(<span style="font-weight: bold; text-decoration: underline;">page_to_pfn</span>(<span style="font-weight: bold; font-style: italic;">page</span>) &lt;&lt; PAGE_SHIFT);
    <span style="font-weight: bold;">else</span>:
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26816;&#26597; page_address_map, &#30001;&#20110; page_address_map &#21482;&#19982; kmap &#26377;&#20851;,</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25152;&#20197;&#22312; __get_free_pages &#26102;, page &#24182;&#27809;&#26377;&#20107;&#20808;&#36890;&#36807; kmap &#22312;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">page_address_map &#26377;&#35760;&#24405;, &#25152;&#20197;&#36825;&#37324;&#24517;&#28982;&#20250;&#25214;&#19981;&#21040;, &#23548;&#33268;&#36820;&#22238;&#32447;&#24615;&#22320;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22336;&#20026; NULL, &#25152;&#20197; __get_free_pages &#19981;&#24212;&#35813;&#20351;&#29992; __GFP_HIGHMEM &#26469;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20998;&#37197;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org5abca89" class="outline-6">
<h6 id="org5abca89"><span class="section-number-6">1.2.3.1.4</span> __get_free_page(gfp_mask)</h6>
</div>
</div>

<div id="outline-container-org2604ea7" class="outline-5">
<h5 id="org2604ea7"><span class="section-number-5">1.2.3.2</span> GFP Mask</h5>
<div class="outline-text-5" id="text-1-2-3-2">
<ol class="org-ol">
<li><p>
__GFP_DMA
</p>

<p>
必须从 ZONE_DMA 分配
</p></li>

<li><p>
__GFP_HIGH
</p>

<p>
允许使用 zone 的 reserved page frames
</p></li>

<li><p>
__GFP_HIGHMEM
</p>

<p>
可以从 ZONE_HIGHMEM 分配
</p></li>

<li><p>
__GFP_WAIT
</p>

<p>
允许分配动作被阻塞以便等待释放内存
</p></li>

<li><p>
__GFP_IO
</p>

<p>
允许做 IO 以释放内存
</p></li>

<li><p>
GFP_KERNEL / GFP_USER
</p>

<p>
__GFP_WAIT | __GFP_IO | __GFP_F'S
</p>

<p>
即:
</p>

<ul class="org-ul">
<li>可以阻塞</li>
<li>可以做 IO 以释放内存</li>
<li>不可以使用 ZONE_HIGHMEM</li>
</ul></li>

<li><p>
GFP_HIGHUSER
</p>

<p>
GFP_USER | __GFP_HIGHMEM
</p></li>

<li><p>
GFP_ATOMIC
</p>

<p>
__GFP_HIGH
</p></li>
</ol>

<p>
在这些 GFP mask 中, __GFP_DMA 和 __GFP_HIGHMEM 会影响分配内存时选择
zone 的顺序:
</p>

<ol class="org-ol">
<li>若指定了 __GFP_DMA, 则只能从 ZONE_DMA 中分配</li>

<li>若指定了 __GFP_HIGHMEM, 则选择 zone 的顺序为 ZONE_HIGHMEM,
ZONE_NORMAL, ZONE_DMA</li>

<li>若没有指定 __GFP_HIGHMEM, 则选择的顺序为 ZONE_NORMAL, ZONE_DMA</li>
</ol>
</div>
</div>
</div>


<div id="outline-container-org3959c62" class="outline-4">
<h4 id="org3959c62"><span class="section-number-4">1.2.4</span> Physical Mapping</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
ZONE_DMA 和 ZONE_NORMAL 中的 page frame 可以通过 physical mapping 直接
映射, 所谓 physical mapping, 是指 0~896M 范围的物理内存直接映射到
3G~3G+896M 的线性地址空间. 前面 <a href="#org17212f2">Kernel page table 与 process page
table 的同步</a> 及 <a href="#org7a4ef95">kernel_physical_mapping_init</a> 已经提到了这部分 mapping
建立的过程.
</p>

<p>
由于这部分映射是线性的, 所以可以方便的进行物理地址与线性地址的转换
</p>
</div>

<div id="outline-container-org4b232d3" class="outline-5">
<h5 id="org4b232d3"><span class="section-number-5">1.2.4.1</span> _va</h5>
<div class="outline-text-5" id="text-1-2-4-1">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">#define</span> <span style="font-weight: bold;">__va</span>(<span style="font-weight: bold; font-style: italic;">x</span>)                 ((<span style="font-weight: bold; text-decoration: underline;">void</span> *)((<span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span>)(x)+PAGE_OFFSET))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd903e87" class="outline-5">
<h5 id="orgd903e87"><span class="section-number-5">1.2.4.2</span> _pa</h5>
<div class="outline-text-5" id="text-1-2-4-2">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">#define</span> <span style="font-weight: bold;">__pa</span>(<span style="font-weight: bold; font-style: italic;">x</span>)                 ((<span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span>)(x)-PAGE_OFFSET)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org7531025" class="outline-4">
<h4 id="org7531025"><span class="section-number-4">1.2.5</span> Mapping High memory</h4>
<div class="outline-text-4" id="text-1-2-5">
<p>
 ZONE_HIGHMEM 中的 page frame 无法被 physical mapping, 必须通过
以下几种途径之一映射过才能访问:
</p>

<ol class="org-ol">
<li><p>
Non-contiguous Mapping
</p>

<p>
vmalloc
</p></li>

<li><p>
Permanent Kmap
</p>

<p>
kmap_high
</p></li>

<li>Fixed Mapping

<ol class="org-ol">
<li>kmap_atomic</li>
<li>set_fixmap</li>
</ol></li>
</ol>
</div>

<div id="outline-container-org0f73a5a" class="outline-5">
<h5 id="org0f73a5a"><span class="section-number-5">1.2.5.1</span> Permanent Kmap</h5>
<div class="outline-text-5" id="text-1-2-5-1">
<p>
Permanent Kmap 维护 kernel page map 中一段 page table 的映射,
LAST_PKMAP 决定了这段映射大小: 一般 LAST_PKMAP 为 1024, 则 Permanent
Kmap 刚好维护一个 PGD entry, 即 4M 虚拟地址范围
</p>

<p>
Permanent Kmap 内部维护一个数组 pkmap_count[LAST_PKMAP], 分配映射, 释
放映射, 查找映射都是通过对这个数组的线程查找完成的.
</p>

<ol class="org-ol">
<li><p>
分配: kmap
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">kmap</span>:
  <span style="font-weight: bold;">if</span> (!PageHighMem(page)):
    <span style="font-weight: bold;">return</span> page_address(page);
  <span style="font-weight: bold;">return</span> kmap_high(page);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26597;&#25214;, &#30475;&#36825;&#20010; page &#20043;&#21069;&#26159;&#21542;&#24050;&#32463;&#26144;&#23556;&#36807;</span>
    vaddr = (<span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span>)<span style="font-weight: bold;">page_address</span>(page);
    <span style="font-weight: bold;">if</span> (!vaddr)
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#30495;&#27491;&#30340;&#20998;&#37197;&#21160;&#20316;, &#26597;&#25214; pkmap_count &#20013;&#26576;&#19968;&#20010;&#31354;&#30340; slot</span>
      vaddr = map_new_virtual(page);
    <span style="font-weight: bold; text-decoration: underline;">pkmap_count</span>[PKMAP_NR(vaddr)]++;
    <span style="font-weight: bold;">return</span> vaddr

map_new_virtual:
 <span style="font-weight: bold;">for</span> (;;):
   <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25551;&#36848; pkmap_count &#20013;&#25152;&#26377;&#30340;&#39033;, &#25214;&#19968;&#20010; pkmap_count[x] &#20026; 0 &#30340;</span>
   last_pkmap_nr = (last_pkmap_nr + 1) &amp; LAST_PKMAP_MASK;
   <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">...</span>

  vaddr = PKMAP_ADDR(last_pkmap_nr);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">permanent_kmaps_init &#26102;&#23558; pkmap_page_table &#35774;&#32622;&#20102;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">swapper_pg_dir &#20013;&#23545;&#24212;&#30340;&#37096;&#20998;, &#25152;&#20197; kmap &#20462;&#25913;&#30340;&#26159; swapper_pg_dir         </span>
  set_pte(&amp;(pkmap_page_table[last_pkmap_nr]), mk_pte(page, kmap_prot));
  <span style="font-weight: bold; text-decoration: underline;">pkmap_count</span>[last_pkmap_nr] = 1;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">set_page_address &#20250;&#20462;&#25913; page_address_map &#36825;&#20010; list, &#35760;&#24405; page &#19982;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">vaddr &#30340;&#26144;&#23556;&#20851;&#31995;, &#21518;&#38754; page_address &#20250;&#20351;&#29992;&#23427;</span>
  <span style="font-weight: bold;">set_page_address</span>(page, (<span style="font-weight: bold; text-decoration: underline;">void</span> *)vaddr);
  <span style="font-weight: bold;">return</span> vaddr;
</pre>
</div></li>

<li><p>
释放: kunmap
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">kunmap</span>:
  <span style="font-weight: bold;">if</span> (!PageHighMem(page)):
    <span style="font-weight: bold;">return</span>;
  <span style="font-weight: bold;">kunmap_high</span>(page);
    vaddr = (<span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span>)<span style="font-weight: bold;">page_address</span>(page);
    nr = PKMAP_NR(vaddr);
    --pkmap_count[nr]
</pre>
</div></li>

<li><p>
查找: page_address
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">page_address</span>:
  <span style="font-weight: bold;">if</span> (!PageHighMem(page))
    <span style="font-weight: bold;">return</span> lowmem_page_address(page);
  <span style="font-weight: bold;">if</span> (!list_empty(&amp;pas-&gt;lh)):
    <span style="font-weight: bold;">struct</span> page_address_map *pam;
    <span style="font-weight: bold;">list_for_each_entry</span>(pam, &amp;pas-&gt;lh, list):
      <span style="font-weight: bold;">if</span> (pam-&gt;page == page):
        ret = pam-&gt;virtual;
        <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">done</span>;
</pre>
</div>

<p>
Permanent Kmap 支持通过 page 查找其线性地址, 主要的依靠
page_address_map, 之前 map_new_virtual 时会使用这个
page_address_map 记录 page 与 vaddr 的映射关系.
</p>

<p>
除了 Permanent Kmap 和 Physical Mapping, 其它的映射方式 (vmalloc,
fix mapping) 无法根据 page 直接查找到其 vaddr (当然通过遍历还是可以
查到的&#x2026;)
</p></li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org5a406c8" class="outline-4">
<h4 id="org5a406c8"><span class="section-number-4">1.2.6</span> Buddy System</h4>
<div class="outline-text-4" id="text-1-2-6">
</div>
<div id="outline-container-org07aae19" class="outline-5">
<h5 id="org07aae19"><span class="section-number-5">1.2.6.1</span> Buddy system 的基本原理</h5>
<div class="outline-text-5" id="text-1-2-6-1">
<ol class="org-ol">
<li>buddy system 用来快速分配连续的 page frame</li>

<li>它的主要目的是减少外部碎片</li>

<li>每个 zone 都有一个 buddy system, 管理着这个 zone 所有的 page frame
(或者说 page struct)</li>

<li><p>
buddy system 将它管理的所有 page 分为 MAX_ORDER (0 ~ 10 共 11 ) 个
free_area, 每个 area 维护着一个链表, 链表中的每一项代表着 "连续的
2^n 个 page" 构成的 block,并且这个 block 的第一个 page 的 pfn 是
2^n 对齐的. 所以 buddy system 能分配的最大连续内存是 4M
</p>


<div id="orgc06d32e" class="figure">
<p><img src="../extra/kernel_buddy_system.png" alt="kernel_buddy_system.png" />
</p>
</div></li>

<li>当需要分配连续 2^n 个 page 时, buddy system 会:

<ol class="org-ol">
<li>查看对应 area n 是否有空闲的 block</li>

<li>如果有则使用这个空闲的 block</li>

<li>否则, 查看 area n+1 是否有空闲的 block

<ol class="org-ol">
<li>如果有, 则将这个空闲 block 拆为两个 2^n 大小 的 block, 返回一
个, 另一个加入到 area n.</li>

<li>如果 area n+1 也没有空闲的 block, 则查看 area n+2 &#x2026; 以此类推</li>
</ol></li>
</ol></li>

<li>当释放一个 block 时, 把这个 block 插入到相应的 area, 然后看这个
block 能否与前后的 block 合并, 合并的条件是:

<ol class="org-ol">
<li>两个 block 大小相等</li>

<li>两个 block 物理连续</li>

<li>第一个 block 的第一个 page 的 pfn 相对于合并后的 area n 是 2^n 对齐
的</li>
</ol></li>
</ol>
</div>
</div>

<div id="outline-container-orgf9d688f" class="outline-5">
<h5 id="orgf9d688f"><span class="section-number-5">1.2.6.2</span> 相关数据结构</h5>
<div class="outline-text-5" id="text-1-2-6-2">
</div>
<div id="outline-container-orgd82f745" class="outline-6">
<h6 id="orgd82f745"><span class="section-number-6">1.2.6.2.1</span> zone</h6>
<div class="outline-text-6" id="text-1-2-6-2-1">
<p>
struct zone 维护了许多和 buddy system 相关的信息
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">zone</span> {
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span>     <span style="font-weight: bold; font-style: italic;">free_pages</span>;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">MAX_ORDER &#20026; 11, free_area[i] &#20195;&#34920;&#30340;&#26159;&#22823;&#23567;&#20026; 2^i &#30340; block &#30340;&#38598;&#21512;</span>
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">free_area</span>  <span style="font-weight: bold; font-style: italic;">free_area</span>[MAX_ORDER];

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">zone_mem_map &#26159; mem_map &#20013;&#19982; zone &#23545;&#24212;&#30340;&#30340;&#37096;&#20998;</span>
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">page</span>      *<span style="font-weight: bold; font-style: italic;">zone_mem_map</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org4637a6e" class="outline-6">
<h6 id="org4637a6e"><span class="section-number-6">1.2.6.2.2</span> free_area</h6>
<div class="outline-text-6" id="text-1-2-6-2-2">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">free_area</span> {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">free_list &#26159;&#19968;&#20010;&#30001; page &#26500;&#25104;&#30340; list, list &#20013;&#30340; page &#26159;&#22823;&#23567;&#20026; 2^n</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#30340; block &#30340;&#31532;&#19968;&#20010; page</span>
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">list_head</span>    <span style="font-weight: bold; font-style: italic;">free_list</span>;

    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span>               <span style="font-weight: bold; font-style: italic;">nr_free</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orga68149d" class="outline-6">
<h6 id="orga68149d"><span class="section-number-6">1.2.6.2.3</span> page</h6>
<div class="outline-text-6" id="text-1-2-6-2-3">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">page</span> {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19982; free_area &#20013;&#30340; free_list &#23545;&#24212;</span>
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">list_head</span> <span style="font-weight: bold; font-style: italic;">lru</span>;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">buddy system &#20013; block &#30340;&#31532;&#19968;&#20010; page &#36890;&#36807; private &#20445;&#23384;&#30528; block</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#24212;&#30340; order.</span>
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">private</span>;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org9f2f43a" class="outline-5">
<h5 id="org9f2f43a"><span class="section-number-5">1.2.6.3</span> Allocating a block</h5>
<div class="outline-text-5" id="text-1-2-6-3">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">page</span> *<span style="font-weight: bold;">__rmqueue</span>(<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">zone</span> *<span style="font-weight: bold; font-style: italic;">zone</span>, <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">order</span>):
  <span style="font-weight: bold;">for</span> (current_order = order; current_order &lt; MAX_ORDER; ++current_order):
    area = zone-&gt;free_area + current_order;
    <span style="font-weight: bold;">if</span> (list_empty(&amp;area-&gt;free_list))
      <span style="font-weight: bold;">continue</span>;

    page = list_entry(area-&gt;free_list.next, <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">page</span>, lru);
    list_del(&amp;page-&gt;lru);
    <span style="font-weight: bold;">rmv_page_order</span>(<span style="font-weight: bold; text-decoration: underline;">page</span>);
    area-&gt;nr_free--;
    zone-&gt;free_pages -= 1UL &lt;&lt; order;
    <span style="font-weight: bold;">return</span> expand(zone, page, order, current_order, area);


<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">inline</span> <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">page</span> *
<span style="font-weight: bold;">expand</span>(<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">zone</span> *<span style="font-weight: bold; font-style: italic;">zone</span>, <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">page</span> *<span style="font-weight: bold; font-style: italic;">page</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">low</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">high</span>, <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">free_area</span> *<span style="font-weight: bold; font-style: italic;">area</span>):
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">low &#34920;&#31034;&#26368;&#21021;&#30340;&#21407;&#22987; order, high &#25351;&#26368;&#32456;&#23454;&#38469;&#30340; order. expand &#30340;&#20316;&#29992;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26159;&#23558; order &#20026; high &#30340; block &#25286;&#20998;, &#23558;&#22810;&#20313;&#30340;&#37096;&#20998;&#21512;&#24182;&#21040;&#20854;&#23427;&#30340; area &#20013;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19979;&#38754;&#20551;&#35774; low = 0, high = 2, &#21363;&#35201;&#20998;&#37197; 1 &#20010; page, &#26368;&#32456;&#22312; free_area[2] &#20013;&#25214;&#21040;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19968;&#20010; 4-page &#30340; block, expand &#30340;&#32467;&#26524;&#24212;&#35813;&#26159;:</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">1. &#25226;&#19968;&#20010; 1 page &#30340; block &#25554;&#20837; free_area[0]</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">2. &#25226;&#19968;&#20010; 2 page &#30340; block &#25554;&#20837; free_area[1]</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">size = 1&lt;&lt;2 = 4, &#34920;&#31034;&#26368;&#21021;&#19968;&#20849;&#20998;&#37197;&#20102; 4 &#20010; page</span>
  <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> size = 1 &lt;&lt; high;
  <span style="font-weight: bold;">while</span> (high &gt; low):
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">area &#21021;&#22987;&#20026; area[2]</span>
    area--;
    high--;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24490;&#29615;&#20004;&#27425;, &#31532;&#19968;&#27425; size &#20026; 2, &#21017; page[2] &#20195;&#34920;&#30340; block</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">(page[2],page[3]) &#34987;&#25554;&#20837;&#21040; area[1], &#31532;&#20108;&#27425; size &#20026; 1, &#21017;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">page[1] &#20195;&#34920;&#30340; block &#34987;&#25554;&#20837;&#21040; area[0]</span>
    size &gt;&gt;= 1;
    list_add(&amp;page[size].lru, &amp;area-&gt;free_list);
    area-&gt;nr_free++;
    set_page_order(&amp;page[size], high);
      page-&gt;private = order;
  <span style="font-weight: bold;">return</span> page;

</pre>
</div>
</div>
</div>

<div id="outline-container-org3980995" class="outline-5">
<h5 id="org3980995"><span class="section-number-5">1.2.6.4</span> Freeing a block</h5>
<div class="outline-text-5" id="text-1-2-6-4">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">__free_pages_bulk</span> (<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">page</span> *<span style="font-weight: bold; font-style: italic;">page</span>, <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">page</span> *<span style="font-weight: bold; font-style: italic;">base</span>,<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">zone</span> *<span style="font-weight: bold; font-style: italic;">zone</span>, <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">order</span>):
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">page &#26159;&#35201;&#37322;&#25918;&#30340; block &#30340;&#31532;&#19968;&#20010; page</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">base &#26159; zone &#30340; zone_mem_map</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">zone &#26159; block &#25152;&#23646;&#30340; zone</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">order &#26159; block &#30340; order</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20551;&#35774;&#35201;&#37322;&#25918;&#30340; block &#30340; order &#20026; 2, page_index &#20026; 8 (8 &#26159; 2^2 &#23545;&#40784;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#30340;), &#19988; page &#19982;&#21518;&#38754;&#19968;&#20010; block &#33021;&#21512;&#24182;&#20026;&#19968;&#20010; order &#20026; 3 &#30340; block, &#21518;&#38754;&#19968;&#20010; block</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#30340; page_index &#24212;&#35813;&#26159; 12</span>
  page_idx = page - base;
  zone-&gt;free_pages += 1&lt;&lt;order;
  <span style="font-weight: bold;">while</span> (order &lt; MAX_ORDER-1):
    <span style="font-weight: bold;">struct</span> page *buddy;
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">buddy_idx</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">iter 1: buddy_index = 8 ^ 1&lt;&lt;2 = 12, ^ &#25805;&#20316;&#20250;&#25226; page_index +/-</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19968;&#20010; 2^order &#22823;&#23567;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">iter 2: buddy_index = 8 ^ 1&lt;&lt;3 = 0, &#33509; page 0 &#20195;&#34920;&#19968;&#20010;&#31354;&#38386;&#30340; 3 &#38454; block, &#21017;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36824;&#21487;&#20197;&#36827;&#19968;&#27493;&#21512;&#24182;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">iter 3: buddy_index = 0 ^ 1&lt;&lt;4 = 16, ...</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#30340;&#24322;&#25110;&#25805;&#20316;&#21644;&#23545;&#40784;&#30340;&#35201;&#27714;&#26377;&#20851;: &#24403;&#21069; block &#32943;&#23450;&#26159; 2^order &#23545;&#40784;&#30340;, &#22914;&#26524;&#21644;&#21518;&#38754;&#30340; block &#21512;&#24182;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#38656;&#35201;&#20445;&#35777;&#24403;&#21069; block &#20063;&#26159; 2^(order+1) &#23545;&#40784;&#30340;, &#22914;&#26524;&#21644;&#21069;&#19968;&#20010; block &#21512;&#24182;, &#38656;&#35201;&#20445;&#35777;&#21069;&#19968;&#20010; block &#26159;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">2^(order+1) &#23545;&#40784;&#30340;.</span>
    <span style="font-weight: bold; font-style: italic;">//</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#29992;&#35821;&#35328;&#25551;&#36848;&#36825;&#20010;&#21462; buddy_idx &#30340;&#25805;&#20316;:</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">1. page_index &#30340;&#20302; order &#20301;&#24517;&#28982; 0</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">2. &#33509; page_index &#30340;&#20302; order+1 &#20301;&#20063;&#26159; 0, &#21017;&#23427;&#24050;&#32463;&#26159; 2^(order+1) &#23545;&#40784;&#20102;,</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25226; page_index &#21152;&#19978; 2^order &#24471;&#21040; buddy_idx</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">3. &#33509; page_index &#30340;&#20302; order+1 &#20301;&#26159; 1, &#21017;&#23427;&#26412;&#36523;&#26080;&#27861;&#19982; 2^(order+1)&#23545;&#40784;,</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25226; page_index &#20943;&#21435; 2^order &#24471;&#20110; buddy_idx, &#21487;&#20197;&#30830;&#23450;&#36825;&#20010; buddy_idx</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24517;&#28982;&#26159; 2^(order+1) &#23545;&#40784;&#30340;</span>
    <span style="font-weight: bold; font-style: italic;">//</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19968;&#20010;&#24322;&#25110;&#25805;&#20316;&#23601;&#21487;&#20197;&#35299;&#20915;&#36825;&#20010;&#38382;&#39064;...</span>

    buddy_idx = (page_idx ^ (1 &lt;&lt; order));
    buddy = base + buddy_idx;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">page_is_buddy &#34920;&#31034; page &#26159;&#21542;&#26159;&#19968;&#20010;&#31354;&#38386; block &#30340;&#36215;&#22987; page</span>
    <span style="font-weight: bold;">if</span> (page_is_buddy(buddy, order)):
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558; buddy &#20174;&#21407;&#26469;&#30340; area &#21024;&#38500;</span>
      list_del(&amp;buddy-&gt;lru);
      area = zone-&gt;free_area + order;
      area-&gt;nr_free--;
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">iter1: page_index = 8 &amp; 12 = 8</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">iter2: page_index = 8 &amp; 0 = 0</span>
      page_idx &amp;= buddy_idx;
      order++;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">coalesced &#21644; order &#26159;&#26368;&#32456;&#21512;&#24182;&#30340;&#32467;&#26524;</span>
  coalesced = base + page_idx;
  <span style="font-weight: bold;">set_page_order</span>(coalesced, order);
  list_add(&amp;coalesced-&gt;lru, &amp;zone-&gt;free_area[order].free_list);
  zone-&gt;free_area[order].nr_free++;
</pre>
</div>
</div>
</div>

<div id="outline-container-org28aedd3" class="outline-5">
<h5 id="org28aedd3"><span class="section-number-5">1.2.6.5</span> Buddy system 初始化</h5>
<div class="outline-text-5" id="text-1-2-6-5">
</div>
<div id="outline-container-org459aaf8" class="outline-6">
<h6 id="org459aaf8"><span class="section-number-6">1.2.6.5.1</span> 初始化所有的 free_area 为空</h6>
<div class="outline-text-6" id="text-1-2-6-5-1">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">setup_arch</span>:
  paging_init
    zone_sizes_init
      free_area_init
        free_area_init_node
          <span style="font-weight: bold; text-decoration: underline;">free_area_init_core</span>
            <span style="font-weight: bold;">zone_init_free_lists</span>
              <span style="font-weight: bold;">for</span> (order = 0; order &lt; MAX_ORDER ; order++):
                INIT_LIST_HEAD(&amp;zone-&gt;free_area[order].free_list);
                zone-&gt;free_area[order].nr_free = 0;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf39febf" class="outline-6">
<h6 id="orgf39febf"><span class="section-number-6">1.2.6.5.2</span> 释放 bootmem 到 buddy system</h6>
<div class="outline-text-6" id="text-1-2-6-5-2">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">start_kernel</span>:
  mm_init
    mem_init
      free_all_bootmem
        <span style="font-weight: bold; text-decoration: underline;">free_all_bootmem_core</span>
          <span style="font-weight: bold; font-style: italic;">__free_pages</span>
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org394f816" class="outline-4">
<h4 id="org394f816"><span class="section-number-4">1.2.7</span> Slab Allocator</h4>
<div class="outline-text-4" id="text-1-2-7">
</div>
<div id="outline-container-orgcfe4084" class="outline-5">
<h5 id="orgcfe4084"><span class="section-number-5">1.2.7.1</span> Slab 基本原理</h5>
<div class="outline-text-5" id="text-1-2-7-1">
<ol class="org-ol">
<li>Buddy System 以 page 为单位来分配内存, 如果用 Buddy System 来分配一
个只需要几十 KB 的 buffer 的话, 使用 Buddy System 会造成严重的内部
碎片.</li>

<li>kernel 会频繁的分配和释放某些相同的数据结构, 例如 task_struct,
mm_struct 等, 通过维护一个针对这些常用数据结构的对象缓存, 可以大大
提高分配与释放的效率 (当然会占用更多的内存), 并避免多次的初始化.</li>

<li>通过 Slab Colouring 组织不同 Slab 中对象的地址, 尽量使得这些对象在
使用时能分布在不同的硬件 cache line 上.</li>

<li>除了缓存 task_struct 等这种数据结构, 大小为 32B, 64B, &#x2026; 128KB 的
一些通用内存区域 (kmalloc) 也会通过 Slab 缓存起来.</li>
</ol>
</div>
</div>

<div id="outline-container-org0a522a1" class="outline-5">
<h5 id="org0a522a1"><span class="section-number-5">1.2.7.2</span> 相关数据结构</h5>
<div class="outline-text-5" id="text-1-2-7-2">
</div>
<div id="outline-container-orgbec0a6c" class="outline-6">
<h6 id="orgbec0a6c"><span class="section-number-6">1.2.7.2.1</span> kmem_cache_t</h6>
<div class="outline-text-6" id="text-1-2-7-2-1">
<p>
kmem_cache_t (或 struct kmem_cache_s) 是 Slab 最上层的结构, 代表一种对
象的缓存, 例如 task_struct, mm_struct 各自会有一个对应的 kmem_cache_t,
另外, /proc/slabinfo 中每一行都对应着一个 kmem_cache_t
</p>


<div id="orgcc3a2a4" class="figure">
<p><img src="../extra/kernel_slab.png" alt="kernel_slab.png" />
</p>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">kmem_cache_s</span> {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">free objects &#30340;&#26368;&#22823;&#25968;&#30446;, &#21363; cache &#22810;&#23569;&#20010; free objects</span>
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">int</span>                <span style="font-weight: bold; font-style: italic;">limit</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21333;&#20010;&#23545;&#35937;&#30340;&#22823;&#23567;, &#23427;&#30340;&#20540;&#21487;&#33021;&#20250;&#22823;&#20110;&#23545;&#35937;&#30495;&#27491;&#30340;&#22823;&#23567;, &#22240;&#20026;&#38656;&#35201;&#32771;&#34385;&#23545;&#40784;</span>
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">int</span>                <span style="font-weight: bold; font-style: italic;">objsize</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27599;&#20010; slab &#26377;&#22810;&#23569;&#20010;&#23545;&#35937;</span>
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">int</span>                <span style="font-weight: bold; font-style: italic;">num</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27599;&#20010; slab &#38656;&#35201;&#21344;&#29992; 2^gfporder &#20010; page</span>
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">int</span>                <span style="font-weight: bold; font-style: italic;">gfporder</span>;
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">int</span>                <span style="font-weight: bold; font-style: italic;">gfpflags</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">slab colouring &#30456;&#20851;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">colour &#26159;&#36825;&#20010; cache &#30340; slab &#33021;&#20351;&#29992;&#30340; colour &#30340;&#33539;&#22260; (0~colour)</span>
    <span style="font-weight: bold; font-style: italic;">//</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">colour_off &#26159; colour &#23545;&#24212;&#30340;&#20559;&#31227;&#37327; (&#33509;&#26576;&#20010; slab &#30340; colour &#20026; i,</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21017;&#36825;&#20010; slab &#24320;&#22836;&#30340;&#20559;&#31227;&#37327;&#20026; i*colour_off), &#20855;&#20307;&#21442;&#32771; kmem_cache_alloc,</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19968;&#33324; colour_off &#20026; cache line &#30340;&#22823;&#23567;, &#20363;&#22914; 32B</span>
    <span style="font-weight: bold; text-decoration: underline;">size_t</span>                      <span style="font-weight: bold; font-style: italic;">colour</span>;
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">int</span>                <span style="font-weight: bold; font-style: italic;">colour_off</span>;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">slab_size &#26159;&#25351; slab &#20013; slab descriptor &#19982; kmem_bufctl_t &#25968;&#32452;&#30340;&#22823;&#23567;&#20043;&#21644;</span>
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">int</span>                <span style="font-weight: bold; font-style: italic;">slab_size</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">ctor &#19982; dtor</span>
    <span style="font-weight: bold; text-decoration: underline;">void</span> (*<span style="font-weight: bold;">ctor</span>)(<span style="font-weight: bold; text-decoration: underline;">void</span> *, <span style="font-weight: bold; text-decoration: underline;">kmem_cache_t</span> *, <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span>);
    <span style="font-weight: bold; text-decoration: underline;">void</span> (*<span style="font-weight: bold;">dtor</span>)(<span style="font-weight: bold; text-decoration: underline;">void</span> *, <span style="font-weight: bold; text-decoration: underline;">kmem_cache_t</span> *, <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span>);
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>          *<span style="font-weight: bold; font-style: italic;">name</span>;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">slabs_partial &#20013;&#21516;&#26102;&#26377; free &#19982; nonfree &#30340; object</span>
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">list_head</span>    <span style="font-weight: bold; font-style: italic;">slabs_partial</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">slabs_full &#20013;&#25152;&#26377; object &#37117;&#26159; nonfree</span>
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">list_head</span>    <span style="font-weight: bold; font-style: italic;">slabs_full</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">slabs_free &#20013;&#25152;&#26377; object &#37117;&#26159; free</span>
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">list_head</span>    <span style="font-weight: bold; font-style: italic;">slabs_free</span>;

}
</pre>
</div>
</div>
</div>

<div id="outline-container-org1e484c6" class="outline-6">
<h6 id="org1e484c6"><span class="section-number-6">1.2.7.2.2</span> slab</h6>
<div class="outline-text-6" id="text-1-2-7-2-2">
<p>
slab 代表了一些 object 的集合, 它也代表一个或多个 (gfporder 有关) page.
</p>


<div id="org255cefc" class="figure">
<p><img src="../extra/kernel_slab_object.png" alt="kernel_slab_object.png" />
</p>
</div>


<p>
上面图展示了 slab descriptor, kmem_bufctl_t 数组及 slab 的 objects 的
布局
</p>

<p>
确切的说这只是 slab 结构中的 "slab with internal descriptor" 一
种 (IN_SLAB), 即 slab descriptor 与 object 是放在同一个 page. 如果 object 很大,
例如几 K, 则会使用另一布局 "slab with external descriptor" (OFF_SLAB),
此处暂不讨论.
</p>

<p>
其中 free 及 kmem_bufctl_t 数组中的箭头指向相应的 Free Object, 实际上
这个箭头是通过 free 和 kmem_bufctl_t 下标推算出来的 (slabp-&gt;s_mem +
slabp-&gt;free*cachep-&gt;objsize) &#x2026; 并不是直接的指针, 具体见
<a href="#org42e6e46">kmem_cache_alloc</a>
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">slab</span> {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">slab &#25152;&#23646;&#30340; kmem_cache_t &#30340; slabs_partial, slabs_full,</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">slabs_free &#20013;&#30340;&#26576;&#19968;&#20010;</span>
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">list_head</span>    <span style="font-weight: bold; font-style: italic;">list</span>;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">page + colouroff = s_mem</span>
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span>               <span style="font-weight: bold; font-style: italic;">colouroff</span>;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">slab &#31649;&#29702;&#30340; objects &#30340;&#39318;&#22320;&#22336;</span>
    <span style="font-weight: bold; text-decoration: underline;">void</span>                        *<span style="font-weight: bold; font-style: italic;">s_mem</span>;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">slab &#20013; nonfree &#30340; object &#20010;&#25968;, &#33509; inuse == kmem_cache_t.num,</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#34920;&#31034;&#36825;&#20010; slab &#24050;&#32463;&#27809;&#26377; free &#30340; object</span>
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">int</span>                <span style="font-weight: bold; font-style: italic;">inuse</span>;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19968;&#20010; slab &#21253;&#21547;&#22810;&#20010; object, &#23427;&#30340; free &#26159;&#25351;&#36825;&#20123; object &#20013;&#31532;&#19968;&#20010;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">free &#30340; object &#30340;&#19979;&#26631;(kmem_cache_t &#23454;&#38469;&#19978;&#23601;&#26159;&#19968;&#20010; short, &#23427;&#23601;&#26159;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19968;&#20010;&#25968;&#32452;&#30340;&#19979;&#26631;)</span>
    <span style="font-weight: bold; text-decoration: underline;">kmem_bufctl_t</span>               <span style="font-weight: bold; font-style: italic;">free</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org1954cff" class="outline-6">
<h6 id="org1954cff"><span class="section-number-6">1.2.7.2.3</span> kmem_bufctl_t 数组及 slab objects</h6>
<div class="outline-text-6" id="text-1-2-7-2-3">
<p>
kmem_bufctl_t 实际就是一个数组下标, 本身是 short 类型.
</p>

<p>
在 slab 开头紧接着 Slab descriptor 的位置是一个数组, 这个数组的大小取
决于每个 slab 有多少个 object (即 kmem_cache_t 的 num).
</p>

<p>
这个数组与数组后面的 slab objects 区域是对应的, x[i] 指示的是下一个
free 的 object 在数组中的下标, 通过这个数组, 可以建立一个 slab 中 free
objects 的链表.
</p>

<p>
slab-&gt;free 及 kmem_bufctl_t 的使用见 <a href="#org42e6e46">kmem_cache_alloc</a>
</p>
</div>
</div>

<div id="outline-container-orgaf822e1" class="outline-6">
<h6 id="orgaf822e1"><span class="section-number-6">1.2.7.2.4</span> 总结</h6>
<div class="outline-text-6" id="text-1-2-7-2-4">
<p>
Slab 分为 cache, slab, object 三个层次.
</p>

<ol class="org-ol">
<li>每类对象对应一个 cache</li>

<li>每个 cache 有多个 slab, 这些 slab 根据每个 slab 中 free object 的个
数分布在 slabs_partial, slabs_full, slabs_free 三条 slab 链表中.</li>

<li>每个 slab 通过一个或多个连续的 page 保存着多个 object 及 slab
descriptor 本身以及一个 kmem_bufctl_t 数组, 这个数组用来维护 slab
内部的 free objects 链表</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-orgd0baee1" class="outline-5">
<h5 id="orgd0baee1"><span class="section-number-5">1.2.7.3</span> Allocating a Slab Object</h5>
<div class="outline-text-5" id="text-1-2-7-3">
</div>
<div id="outline-container-org42e6e46" class="outline-6">
<h6 id="org42e6e46"><span class="section-number-6">1.2.7.3.1</span> kmem_cache_alloc</h6>
<div class="outline-text-6" id="text-1-2-7-3-1">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">void</span> * <span style="font-weight: bold;">kmem_cache_alloc</span> (<span style="font-weight: bold; text-decoration: underline;">kmem_cache_t</span> *<span style="font-weight: bold; font-style: italic;">cachep</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">flags</span>):
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">kmem_cache_alloc &#26102;&#20250;&#19968;&#27425;&#20998;&#37197; batchcount &#20010; object &#21040;&#21478;&#19968;&#20010; cache</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">(ac_data), &#32780;&#19981;&#26159;&#20165;&#20998;&#37197;&#19968;&#20010; object, &#25152;&#20197; kmem_cache_alloc &#20250;&#20808;&#26816;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26597; ac_data &#20013;&#26159;&#21542;&#26377; object</span>
  ac = ac_data(cachep);
  <span style="font-weight: bold;">if</span> (likely(ac-&gt;avail)):
    objp = ac_entry(ac)[--ac-&gt;avail];
  <span style="font-weight: bold;">else</span>:

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35843;&#29992; cache_alloc_refill &#26469; fill ac_data</span>
    objp = cache_alloc_refill(cachep, flags);
      <span style="font-weight: bold;">while</span> (batchcount &gt; 0):
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20808;&#23581;&#35797;&#20174; slabs_partial &#20998;&#37197;, &#33509; slabs_partial &#38142;&#34920;&#20026;&#31354;</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">(slabs_partial.next == slabs_partial), &#21017;&#23581;&#35797;&#20174; slabs_free &#20998;&#37197;</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#33509; slabs_free &#20063;&#20026;&#31354;, &#36339;&#21040; must_grow, &#20197;&#20998;&#37197;&#19968;&#20010;&#26032;&#30340; slab</span>
        entry = l3-&gt;slabs_partial.next;
        <span style="font-weight: bold;">if</span> (entry == &amp;l3-&gt;slabs_partial):
          entry = l3-&gt;slabs_free.next;
        <span style="font-weight: bold;">if</span> (entry == &amp;l3-&gt;slabs_free):
          cache_grow(cachep, flags, -1);
          <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">must_grow</span>;

        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#25214;&#21040;&#19968;&#20010; slabs &#38142;&#34920;</span>
        slabp = list_entry(entry, <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">slab</span>, list);
        <span style="font-weight: bold;">while</span> (slabp-&gt;inuse &lt; cachep-&gt;num &amp;&amp; batchcount--):
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">alloc &#30340; object &#26368;&#32456;&#20250;&#20445;&#23384;&#22312; ac_data &#20013;, slab-&gt;free &#26159;</span>
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">slab &#20013;&#31532;&#19968;&#20010; free &#30340; object &#30340;&#19979;&#26631;, s_mem &#26159; slab &#20013;</span>
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">object &#37096;&#20998;&#30340;&#39318;&#22320;&#22336;</span>
          ac_entry(ac)[ac-&gt;avail++] = slabp-&gt;s_mem + slabp-&gt;free*cachep-&gt;objsize;
          slabp-&gt;inuse++;
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36890;&#36807; kmem_bufctl_t &#25968;&#32452;&#25214;&#21040; slab &#20013;&#19979;&#19968;&#20010; free &#30340; object</span>
          next = slab_bufctl(slabp)[slabp-&gt;free];
          slabp-&gt;free = next;

         <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35843;&#25972; slab &#36807;&#23545;&#24212;&#30340; slab &#38142;&#34920;</span>
          list_del(&amp;slabp-&gt;list);
          <span style="font-weight: bold;">if</span> (slabp-&gt;free == BUFCTL_END):
            list_add(&amp;slabp-&gt;list, &amp;l3-&gt;slabs_full);
          <span style="font-weight: bold;">else</span>:
            list_add(&amp;slabp-&gt;list, &amp;l3-&gt;slabs_partial);

          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">fall through to must_grow</span>

    <span style="font-weight: bold; text-decoration: underline;">must_grow</span>:
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">ac-&gt;avail &#20026; 0, &#34920;&#31034;&#27809;&#26377;&#20998;&#37197;&#20219;&#20309;&#19968;&#20010; object, &#21017;&#38656;&#35201;&#20998;&#37197;&#19968;&#20010;&#26032;&#30340; slab</span>
      <span style="font-weight: bold;">if</span> (unlikely(!ac-&gt;avail)):
        x = cache_grow(cachep, flags, -1);
      <span style="font-weight: bold;">return</span> ac_entry(ac)[--ac-&gt;avail];
</pre>
</div>
</div>
</div>

<div id="outline-container-org24dac74" class="outline-6">
<h6 id="org24dac74"><span class="section-number-6">1.2.7.3.2</span> cache_grow</h6>
<div class="outline-text-6" id="text-1-2-7-3-2">
<p>
当 cache 没有任何 free 的 slab 时, 通过 cache_grow 分配一个 slab
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">cache_grow</span> (<span style="font-weight: bold; text-decoration: underline;">kmem_cache_t</span> * <span style="font-weight: bold; font-style: italic;">cachep</span>):
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35745;&#31639; slab &#30340; colour</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">colour_next &#34920;&#31034;&#26032;&#20998;&#37197;&#30340; slab &#24212;&#35813;&#20351;&#29992;&#30340; colour</span>
  offset = cachep-&gt;colour_next;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">colour_next++, &#33509;&#36229;&#36807;&#20102; cachep-&gt;colour &#25351;&#23450;&#30340; colour &#26368;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22823;&#20540;, &#21017;&#22238;&#32469;&#21040; 0</span>
  cachep-&gt;colour_next++;
  <span style="font-weight: bold;">if</span> (cachep-&gt;colour_next &gt;= cachep-&gt;colour):
    cachep-&gt;colour_next = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26368;&#32456;&#30340; offset &#20026; colour * cachep-&gt;colour_off</span>
  offset *= cachep-&gt;colour_off;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20998;&#37197; page</span>
  objp = kmem_getpages(cachep, flags, nodeid)
    page = alloc_pages(flags, cachep-&gt;gfporder);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25353; slab &#30340;&#26684;&#24335;&#21021;&#22987;&#21270;&#36825;&#20010; page (&#23454;&#38469;&#19978;&#23601;&#26159;&#29983;&#25104; slab descriptor)</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20854;&#20013; offset &#26159;&#25351;&#26681;&#25454; slab colouring &#30340;&#32467;&#26524;, slab &#30340;&#31532;&#19968;&#20010;&#23545;&#35937;&#30340;&#36215;&#22987;&#20301;&#32622;</span>
  slabp = alloc_slabmgmt(cachep, objp, offset, local_flags)
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">slab &#24320;&#22836;&#30340; offset &#20010;&#23383;&#33410;&#34987;&#36339;&#36807;</span>
    slabp = objp+offset;
    slabp-&gt;inuse = 0;

    offset += cachep-&gt;slab_size;
    slabp-&gt;colouroff = offset;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">s_mem &#21363; slab &#20013;&#31532;&#19968;&#20010; object &#30340;&#22320;&#22336;</span>
    slabp-&gt;s_mem = objp+offset;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">set_slab_attr &#23558;&#25152;&#26377; page &#37117;&#21644; cachep &#21450; slabp "&#20851;&#32852;" &#36215;&#26469;,</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25152;&#35859;&#30340;"&#20851;&#32852;", &#26159;&#25351;&#36890;&#36807; page, &#21487;&#20197;&#25214;&#21040;&#23427;&#23646;&#20110;&#21738;&#20010; cache &#21450;&#21738;&#20010; slab,</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20123;&#20449;&#24687;&#26159;&#24517;&#35201;&#30340;, &#20197; kmem_cache_free &#20026;&#20363;, object &#23545;&#24212;&#30340; cache &#22312; kmem_cache_free</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#30340;&#31532;&#19968;&#20010;&#21442;&#25968;&#20013;, &#20294;&#23427;&#25152;&#35859;&#30340; slab &#24517;&#39035;&#36890;&#36807; set_slab_attr &#24314;&#31435;&#30340;&#20851;&#32852;&#25165;&#33021;&#25214;&#21040;,</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21478;&#22806;, kfree &#26102;&#21482;&#25552;&#20379;&#20102;&#19968;&#20010; object &#21442;&#25968;, &#36830; cache &#37117;&#27809;&#26377;, &#26356;&#38656;&#35201; set_slab_attr</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24314;&#31435;&#30340;&#20851;&#32852;.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">set_slab_attr &#22914;&#20309;&#24314;&#31435; objp &#19982; cachep &#21450; slabp &#30340;&#20851;&#32852;? &#36890;&#36807; page-&gt;lru.prev &#21450;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">page-&gt;lru.next.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22240;&#20026;&#27492;&#26102; page &#19981;&#23646;&#20110; buddy &#25110; PFRA &#31649;&#29702;, &#25152;&#20197;&#20854; lru &#23383;&#27573;&#26159;&#21487;&#20197;&#33258;&#30001;&#20351;&#29992;&#30340;</span>
  <span style="font-weight: bold;">set_slab_attr</span>(cachep, slabp, objp);
    i = 1 &lt;&lt; cachep-&gt;gfporder;
    page = virt_to_page(objp);
    <span style="font-weight: bold;">do</span>:
      SET_PAGE_CACHE(page, cachep);
        page-&gt;lru.next = cachep;
      <span style="font-weight: bold;">SET_PAGE_SLAB</span>(page, slabp);
        page-&gt;lru.prev = slabp;
      page++;
     <span style="font-weight: bold;">while</span> (--i);

  <span style="font-weight: bold;">cache_init_objs</span>(cachep, slabp, ctor_flags);
    <span style="font-weight: bold;">for</span> (i = 0; i &lt; cachep-&gt;num; i++):
      <span style="font-weight: bold; text-decoration: underline;">void</span>* objp = slabp-&gt;s_mem+cachep-&gt;objsize*i;
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">ctor &#26159;&#22312;&#20998;&#37197; slab &#26102;&#23601;&#34987;&#35843;&#29992;&#20102;, &#32780;&#19981;&#26159;&#22312;&#20998;&#37197; object &#26102;</span>
      <span style="font-weight: bold;">if</span> (cachep-&gt;ctor):
        cachep-&gt;ctor(objp, cachep, ctor_flags);
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21021;&#22987;&#21270; kmem_bufctl_t &#20013;&#25968;&#25454;&#20026; x[i] = i+1</span>
      <span style="font-weight: bold;">slab_bufctl</span>(slabp)[i] = i+1;
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">slab &#31532;&#19968;&#20010; free &#30340; object &#30340;&#19979;&#26631;&#21021;&#22987;&#26159; 0</span>
      slabp-&gt;free = 0;

  list_add_tail(&amp;slabp-&gt;list, &amp;(list3_data(cachep)-&gt;slabs_free));
  <span style="font-weight: bold;">list3_data</span>(cachep)-&gt;free_objects += cachep-&gt;num;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orge56f9a2" class="outline-5">
<h5 id="orge56f9a2"><span class="section-number-5">1.2.7.4</span> Freeing a Slab Object</h5>
<div class="outline-text-5" id="text-1-2-7-4">
</div>
<div id="outline-container-orgcf44f5d" class="outline-6">
<h6 id="orgcf44f5d"><span class="section-number-6">1.2.7.4.1</span> kmem_cache_free</h6>
</div>
</div>

<div id="outline-container-org27c979f" class="outline-5">
<h5 id="org27c979f"><span class="section-number-5">1.2.7.5</span> kmalloc</h5>
<div class="outline-text-5" id="text-1-2-7-5">
<p>
kmalloc 建立在 slab 基础上, 除了通过 kmem_cache_create 创建的 specific
cache 外, slab 内建了几个 generic cache, 又来支持 kmalloc. 通过一个
cache_sizes 数组, slab 维护了 object size 分别为 32, 64, &#x2026; 128K 的几
个 cache. kmalloc 时会根据 kmalloc 的需要的内存大小选择一个大小最接近
的 cache 去分配
</p>
</div>

<div id="outline-container-orgd1e97bf" class="outline-6">
<h6 id="orgd1e97bf"><span class="section-number-6">1.2.7.5.1</span> kmalloc</h6>
<div class="outline-text-6" id="text-1-2-7-5-1">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">static</span> <span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">void</span> *<span style="font-weight: bold;">kmalloc</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">size</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">flags</span>):
  <span style="font-weight: bold;">return</span> __kmalloc (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">size</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">flags</span>)
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">cache_sizes</span> *<span style="font-weight: bold; font-style: italic;">csizep</span> = malloc_sizes;
      <span style="font-weight: bold;">for</span> (; csizep-&gt;cs_size; csizep++):
        <span style="font-weight: bold;">if</span> (size &gt; csizep-&gt;cs_size):
         <span style="font-weight: bold;">continue</span>;
    <span style="font-weight: bold;">return</span> __cache_alloc(csizep-&gt;cs_cachep, flags);
</pre>
</div>

<p>
需要注意的是, __cache_alloc 时最终会通过 set_slab_attr 将 kmalloc 返回
的 object 所在的 page 与相关的 cache 和 slab 关联起来, 后面在 kfree 时
需要这些关联的 cache 和 slab.
</p>
</div>
</div>

<div id="outline-container-orgea2b36c" class="outline-6">
<h6 id="orgea2b36c"><span class="section-number-6">1.2.7.5.2</span> kfree</h6>
<div class="outline-text-6" id="text-1-2-7-5-2">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">kfree</span> (<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">void</span> *<span style="font-weight: bold; font-style: italic;">objp</span>):
  cache = GET_PAGE_CACHE(virt_to_page(objp));
    cache = pg-&gt;lru.next;
  <span style="font-weight: bold;">__cache_free</span>(cache, (<span style="font-weight: bold; text-decoration: underline;">void</span>*)objp);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org4b3d0c4" class="outline-5">
<h5 id="org4b3d0c4"><span class="section-number-5">1.2.7.6</span> Slab Colouring</h5>
<div class="outline-text-5" id="text-1-2-7-6">
<p>
如 <a href="#org24dac74">cache_grow</a> 所示, 在分配 slab 时会在 slab 开头插入一段空白, 空白的大
小由 cache 的 colour, colour_next 及 colour_offset 决定.
</p>


<div id="org07e6afe" class="figure">
<p><img src="../extra/kernel_slab_colouring.png" alt="kernel_slab_colouring.png" />
</p>
</div>

<p>
上图第一部分 col*aln 的部分即是插入的一段空白, 其中 col 即 cache_grow
时使用的 cache-&gt;colour_next, aln(align) 即 cache_grow 时使用的
cache-&gt;colour_offset (即 cache line size, 32B), 从 cache_grow 已经看到,
cache-&gt;colour_next 在每次分配 slab 时加 1, 直到达到 cache-&gt;colour 这个
最大值时回绕到 0, 现在的问题是, cache-&gt;colour 这个最大值是如何确定的?
显然这个值大了会浪费空间, 小了又起不到多少作用&#x2026;
</p>

<p>
每个 slab 的大小是 page size 对齐的, 但 object 的大小是任意的, 假设这
种情况:
</p>

<p>
slab 大小为 4K (占用一个 page), 假设 object 大小为 300B, slab
descriptor 大小为 20B, 不考虑 object 对齐的情况下, 一个 slab 能容纳的
object 数为 (4096-20)/300 = 13, 则不考虑 colouring 的情况下, slab 的布
局大约 (没有考虑 object align) 是:
</p>

<ol class="org-ol">
<li>20 B 的 slab descriptor</li>
<li>26 B 的 kmem_bufctl_t 数组 (13 个 object)</li>
<li>13 * 300 = 3900 B 的 objects</li>
<li>还剩余 150 B</li>
</ol>

<p>
剩余的 150B 是浪费的, 因为它无法容纳一个 object, 但 slab 可以利用这块
空闲空间做 slab colouring:
</p>

<p>
因为 150 / 32 = 4.6, 所以 cache-&gt;colour = 5, cache-&gt;colour_offset =
32, 初始 cache-&gt;colour_next = 0, 假设后面连续分配了几个 slab:
</p>

<ol class="org-ol">
<li>slab(0) 的 offset 为 0</li>
<li>slab(1) 32</li>
<li>slab(2) 64</li>
<li>slab(3) 96</li>
<li>slab(4) 128</li>
<li>slab(5) 又回绕到 0</li>
</ol>

<p>
可见 slab(0) 到 slab(4) 的 offset 依次相差一个 cache line 的大小. 相对
而言这些 slab 中的对象被 cache 到同一条 cache line 的可能性会小一些.
</p>
</div>
</div>

<div id="outline-container-org1f82802" class="outline-5">
<h5 id="org1f82802"><span class="section-number-5">1.2.7.7</span> Appendix</h5>
<div class="outline-text-5" id="text-1-2-7-7">
</div>
<div id="outline-container-orgaaeec6b" class="outline-6">
<h6 id="orgaaeec6b"><span class="section-number-6">1.2.7.7.1</span> cache 的 gfporder 如何确定</h6>
<div class="outline-text-6" id="text-1-2-7-7-1">
<p>
cache 的 gfporder 决定了一个 slab 占用多少个 page (参考 cache_grow 的代
码), 那么 cache 的 gfporder 是如何确定的?
</p>

<p>
总的来说, gfporder 的选择需要权衡以下几个指标:
</p>

<ol class="org-ol">
<li>object 的大小</li>
<li>page 的大小</li>
<li>对齐</li>
<li>浪费的空间的大小</li>
</ol>

<p>
具体参考 cache_estimate
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgfa76e67" class="outline-4">
<h4 id="orgfa76e67"><span class="section-number-4">1.2.8</span> vmalloc</h4>
<div class="outline-text-4" id="text-1-2-8">
</div>
<div id="outline-container-org5cc929e" class="outline-5">
<h5 id="org5cc929e"><span class="section-number-5">1.2.8.1</span> vm_struct</h5>
<div class="outline-text-5" id="text-1-2-8-1">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">vm_struct</span> {
    <span style="font-weight: bold; text-decoration: underline;">void</span>                        *<span style="font-weight: bold; font-style: italic;">addr</span>;
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span>               <span style="font-weight: bold; font-style: italic;">size</span>;
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span>               <span style="font-weight: bold; font-style: italic;">flags</span>;
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">page</span>         **<span style="font-weight: bold; font-style: italic;">pages</span>;
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">int</span>                <span style="font-weight: bold; font-style: italic;">nr_pages</span>;
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span>               <span style="font-weight: bold; font-style: italic;">phys_addr</span>;
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">vm_struct</span>    *<span style="font-weight: bold; font-style: italic;">next</span>;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-org3a890c3" class="outline-5">
<h5 id="org3a890c3"><span class="section-number-5">1.2.8.2</span> vmalloc</h5>
<div class="outline-text-5" id="text-1-2-8-2">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">void</span> *<span style="font-weight: bold;">vmalloc</span>(<span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">size</span>):
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">__GFP_HIGHMEM</span>
  <span style="font-weight: bold;">return</span> __vmalloc(size, GFP_KERNEL | __GFP_HIGHMEM, PAGE_KERNEL);
    size = PAGE_ALIGN(size);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25214;&#19968;&#22359;&#34394;&#25311;&#22320;&#22336;&#31354;&#38388;</span>
  <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">vm_struct</span>* <span style="font-weight: bold; font-style: italic;">area</span> = get_vm_area(size, VM_ALLOC);
  nr_pages = size &gt;&gt; PAGE_SHIFT;
  array_size = (nr_pages * <span style="font-weight: bold;">sizeof</span>(<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">page</span> *));

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">1. &#20998;&#37197; area-&gt;pages &#25968;&#32452;</span>
  pages = kmalloc(array_size, (gfp_mask &amp; ~__GFP_HIGHMEM));
  area-&gt;pages = pages;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">2. &#20998;&#37197; page</span>
  <span style="font-weight: bold;">for</span> (i = 0; i &lt; area-&gt;nr_pages; i++):
    area-&gt;pages[i] = alloc_page(gfp_mask);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">3. &#23558; page &#26144;&#23556;&#21040; area-&gt;addr</span>
  <span style="font-weight: bold;">map_vm_area</span>(area, prot, &amp;pages)
</pre>
</div>
</div>

<div id="outline-container-orgfb009eb" class="outline-6">
<h6 id="orgfb009eb"><span class="section-number-6">1.2.8.2.1</span> get_vm_area</h6>
<div class="outline-text-6" id="text-1-2-8-2-1">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">vm_struct</span> *<span style="font-weight: bold;">get_vm_area</span>(<span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">size</span>, <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">flags</span>):
  <span style="font-weight: bold;">return</span> __get_vm_area(size, flags, VMALLOC_START, VMALLOC_END);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20174; VMALLOC_START .. VMALLOC_END &#36825;&#22359;&#21306;&#22495;&#25214;&#19968;&#20010; size &#22823;&#23567;&#30340;&#34394;&#25311;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22320;&#22336;&#31354;&#38388;</span>
    area = kmalloc(<span style="font-weight: bold;">sizeof</span>(*area), GFP_KERNEL);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">vmalloc &#21306;&#22495;&#20013;&#30456;&#37051;&#30340; area &#26377;&#19968;&#20010; guard page</span>
    size += PAGE_SIZE;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">vmlist &#26159;&#19968;&#20010; vm_struct &#30340;&#38142;&#34920;, &#36825;&#20123; vm_struct &#30340; (addr, size)</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20195;&#34920;&#30340;&#34394;&#25311;&#22320;&#22336;&#31354;&#38388;&#26159;&#19981;&#37325;&#21472;&#30340;, &#36825;&#20010;&#38142;&#34920;&#20013;&#30340; vm_struct &#30340;&#39034;&#24207;&#23427;&#20204;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#24212;&#30340;&#22320;&#22336;&#31354;&#38388;&#30340;&#20808;&#21518;&#39034;&#24207;&#26159;&#19968;&#33268;&#30340;.</span>
    <span style="font-weight: bold; font-style: italic;">//</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19979;&#38754;&#30340;&#20195;&#30721;&#26159;&#25195;&#25551;&#36825;&#20010;&#38142;&#34920;, &#30475;&#26159;&#21542;&#23384;&#22312;&#20004;&#20010; vm_struct: &#23427;&#20204;&#20013;&#38388;&#26377;&#36275;&#22815;&#22823;&#30340;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#38388;&#38548;&#23481;&#32435;&#19968;&#20010;&#26032;&#30340; vm_struct</span>
    addr = start;
    <span style="font-weight: bold;">for</span> (p = &amp;vmlist; (tmp = *p) != <span style="font-weight: bold; text-decoration: underline;">NULL</span> ;p = &amp;tmp-&gt;next):
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">addr &#34920;&#31034;"&#21069;&#19968;&#20010;" vm_struct &#30340;&#32467;&#23614;, size &#34920;&#31034;&#38656;&#35201;&#30340;&#38388;&#38548;&#22823;&#23567;,</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#33509; size+addr &lt;= tmp-&gt;addr, &#21017;&#34920;&#31034; (addr, addr+size) &#36825;&#27573;&#21306;&#22495;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26159;&#21487;&#29992;&#30340;.</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26174;&#28982;&#36825;&#37324;&#26159;&#29992;&#30340; first-fit &#31639;&#27861;</span>
      <span style="font-weight: bold;">if</span> (size + addr &lt;= (<span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span>)tmp-&gt;addr):
        <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">found</span>
      <span style="font-weight: bold;">else</span>:
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20174;&#19979;&#19968;&#20010; vm_struct &#30340;&#32467;&#23614;&#24320;&#22987;&#32487;&#32493;&#26597;&#25214;</span>
        addr = tmp-&gt;size + tmp-&gt;addr;
      <span style="font-weight: bold;">if</span> (addr &gt; end - size):
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27809;&#25214;&#21040;</span>
        <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">out</span>;

    <span style="font-weight: bold; text-decoration: underline;">found</span>:
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;&#26032;&#20998;&#37197;&#30340; area &#25554;&#20837;&#21040;&#21069;&#21518;&#20004;&#20010; vm_struct &#20043;&#38388;</span>
      area-&gt;next = *p;
      *p = area;

      area-&gt;addr = (<span style="font-weight: bold; text-decoration: underline;">void</span> *)addr;
      area-&gt;size = size;
      area-&gt;pages = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
      area-&gt;nr_pages = 0;
      area-&gt;phys_addr = 0;
      <span style="font-weight: bold;">return</span> area;
</pre>
</div>

<p>
ps. 关于 get_vm_area, 参考 android binder 的 部分
</p>
</div>
</div>

<div id="outline-container-orgd2d37c8" class="outline-6">
<h6 id="orgd2d37c8"><span class="section-number-6">1.2.8.2.2</span> map_vm_area</h6>
</div>

<div id="outline-container-orgbfb5b69" class="outline-6">
<h6 id="orgbfb5b69"><span class="section-number-6">1.2.8.2.3</span> 总结</h6>
<div class="outline-text-6" id="text-1-2-8-2-3">
<ol class="org-ol">
<li>vmalloc 用一个简单 vm_struct 链表通过 first_fit 方法来管理虚拟地址
空间的分配</li>

<li>除了分配虚拟地址空间, vmalloc 还会自己分配 page 并设置 page table,
并且与 kmap 一样, vmalloc 也是操作的 swapper_pg_dir</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org845ccf5" class="outline-5">
<h5 id="org845ccf5"><span class="section-number-5">1.2.8.3</span> vfree</h5>
<div class="outline-text-5" id="text-1-2-8-3">
<p>
与 vmalloc 相反的动作:
</p>

<ol class="org-ol">
<li>根据 address 找到 vm_struct</li>

<li>从 vmlist 链表中删除这个 vm_struct</li>

<li>kfree vm_struct-&gt;pages 数组</li>

<li>__free_pages 释放 vm_struct-&gt;pages 中的 page</li>

<li>修改 page table (PTE 清 0)</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org5db649a" class="outline-4">
<h4 id="org5db649a"><span class="section-number-4">1.2.9</span> Bootmem Allocator</h4>
</div>
</div>

<div id="outline-container-orgd29711c" class="outline-3">
<h3 id="orgd29711c"><span class="section-number-3">1.3</span> 进程地址空间</h3>
<div class="outline-text-3" id="text-1-3">
<p>
进程地址空间 (process address space), 是指 0~3G 这部分 user mode 可以直接访问的虚拟地址空间,
这部分空间被划分为许多不相交的 memory region, 通过 memory region 和
page fault, 能实现 demanding page, COW, swap 等功能.
</p>

<p>
另外, memory region 也是主要的 user mode 与 kernel 之间关于 memory 的
接口, 可以实现 sharing, locking 等功能
</p>
</div>

<div id="outline-container-orgb4655c2" class="outline-4">
<h4 id="orgb4655c2"><span class="section-number-4">1.3.1</span> mm_struct</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
mm_struct 中和 memory region 相关的字段主要有:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">mm_struct</span> {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25152;&#26377;&#30340; memory region (vm_area_struct) &#36890;&#36807; mmap &#36825;&#20010;&#38142;&#34920;&#32452;&#32455;&#36215;&#26469;,</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24182;&#19988;&#26159;&#25353;&#29031;&#22320;&#22336;&#36882;&#22686;&#30340;&#39034;&#24207;, &#26041;&#20415;&#36941;&#21382;&#25152;&#26377;&#30340; vma, &#20294;&#36825;&#37324;&#24182;&#19981;&#26159;&#33021;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">list_head &#26500;&#36896;&#30340;&#38142;&#34920;, &#32780;&#19988;&#29992;&#26222;&#36890;&#30340;&#38142;&#34920;&#26041;&#24335;&#26500;&#25104;&#19968;&#20010;&#21333;&#21521;&#38142;&#34920;</span>
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">vm_area_struct</span> * <span style="font-weight: bold; font-style: italic;">mmap</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#38500;&#20102; mmap &#36825;&#20010;&#38142;&#34920;, &#25152;&#26377;&#30340; vm_area_struct &#36824;&#36890;&#36807; rb-tree &#32452;&#32455;&#36215;&#26469;,</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26041;&#20415;&#36890;&#36807;&#34394;&#25311;&#22320;&#20301;&#25214;&#21040;&#23545;&#24212;&#30340; vm_area_struct</span>
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">rb_root</span> <span style="font-weight: bold; font-style: italic;">mm_rb</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26368;&#36817;&#20351;&#29992;&#30340; vm_area_struct &#20445;&#23384;&#22312; mmap_cache &#20013;</span>
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">vm_area_struct</span> * <span style="font-weight: bold; font-style: italic;">mmap_cache</span>;
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">mmap_base</span>;
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">free_area_cache</span>;

    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">start_code</span>, <span style="font-weight: bold; font-style: italic;">end_code</span>, <span style="font-weight: bold; font-style: italic;">start_data</span>, <span style="font-weight: bold; font-style: italic;">end_data</span>;
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">start_brk</span>, <span style="font-weight: bold; font-style: italic;">brk</span>, <span style="font-weight: bold; font-style: italic;">start_stack</span>;
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">arg_start</span>, <span style="font-weight: bold; font-style: italic;">arg_end</span>, <span style="font-weight: bold; font-style: italic;">env_start</span>, <span style="font-weight: bold; font-style: italic;">env_end</span>;
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">rss</span>, <span style="font-weight: bold; font-style: italic;">anon_rss</span>, <span style="font-weight: bold; font-style: italic;">total_vm</span>, <span style="font-weight: bold; font-style: italic;">locked_vm</span>, <span style="font-weight: bold; font-style: italic;">shared_vm</span>;
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">exec_vm</span>, <span style="font-weight: bold; font-style: italic;">stack_vm</span>, <span style="font-weight: bold; font-style: italic;">reserved_vm</span>, <span style="font-weight: bold; font-style: italic;">def_flags</span>, <span style="font-weight: bold; font-style: italic;">nr_ptes</span>;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">...</span>
};
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf5a10c1" class="outline-4">
<h4 id="orgf5a10c1"><span class="section-number-4">1.3.2</span> Memory Region</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
memroy region 主要由 mmap 系统调用来管理
</p>
</div>

<div id="outline-container-org5bd5f98" class="outline-5">
<h5 id="org5bd5f98"><span class="section-number-5">1.3.2.1</span> 数据结构</h5>
<div class="outline-text-5" id="text-1-3-2-1">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">vm_area_struct</span> {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25351;&#21521; mm_struct</span>
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">mm_struct</span> * <span style="font-weight: bold; font-style: italic;">vm_mm</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">memory region &#30340;&#36215;&#22987;&#34394;&#25311;&#22320;&#22336;</span>
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">vm_start</span>;
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">vm_end</span>;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">mm_struct &#20013; mmap &#38142;&#34920;&#36890;&#36807; vm_next &#36830;&#25509;&#36215;&#26469;</span>
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">vm_area_struct</span> *<span style="font-weight: bold; font-style: italic;">vm_next</span>;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010; memory region &#23545;&#24212;&#30340;&#34394;&#25311;&#22320;&#22336;&#33539;&#22260;&#20869;&#30340;&#25152;&#26377; pte &#30340;&#26435;&#38480;&#37096;&#20998;&#21644;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">vm_page_prot &#26159;&#19968;&#33268;&#30340;, page fault &#26102;&#20998;&#37197; pte &#26102;&#20250;&#32771;&#34385;&#36825;&#20010;&#20540;</span>
    <span style="font-weight: bold; text-decoration: underline;">pgprot_t</span> <span style="font-weight: bold; font-style: italic;">vm_page_prot</span>;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">vm_area_struct &#30340; flag, &#21644;&#26435;&#38480;&#26816;&#26597;&#20197;&#21450; vm_area_struct &#30340;&#20854;&#23427;&#21151;&#33021;&#26377;&#20851;</span>
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">vm_flags</span>;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19982; mm_struct &#20013;&#30340; mm_rb &#19968;&#36215;&#26500;&#25104; rb-tree</span>
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">rb_node</span> <span style="font-weight: bold; font-style: italic;">vm_rb</span>;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21644; anonymous vma &#30340; reversed map &#26377;&#20851;</span>
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">list_head</span> <span style="font-weight: bold; font-style: italic;">anon_vma_node</span>;
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">anon_vma</span> *<span style="font-weight: bold; font-style: italic;">anon_vma</span>;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19981;&#21516;&#31867;&#22411;&#30340; vma (anonymous, file mapped) &#26377;&#19981;&#21516;&#30340; vm_ops, &#27604;&#36739;&#37325;&#35201;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#30340;&#26159; vm_ops-&gt;nopage, &#20915;&#23450;&#20102; page fault &#26102;&#22914;&#20309;&#20998;&#37197;&#29289;&#29702;&#39029;</span>
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">vm_operations_struct</span> * <span style="font-weight: bold; font-style: italic;">vm_ops</span>;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#33509; vma &#26159; file mapped, &#21017; vm_pgoff &#26159;&#25351; vma &#26144;&#23556;&#30340;&#21306;&#22495;&#23545;&#24212; file &#30340;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36215;&#22987;&#20559;&#31227;&#37327; (mmap &#31995;&#32479;&#35843;&#29992;&#30340;&#26368;&#21518;&#19968;&#20010; off &#21442;&#25968;)</span>
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">vm_pgoff</span>;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#33509; vma &#26159; file mmaped, vm_file &#25351;&#23545;&#24212;&#30340; file</span>
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">file</span> * <span style="font-weight: bold; font-style: italic;">vm_file</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">...</span>
};
</pre>
</div>


<div id="org7d806a4" class="figure">
<p><img src="../extra/kernel_address_space_vma.png" alt="kernel_address_space_vma.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgadd08f3" class="outline-5">
<h5 id="orgadd08f3"><span class="section-number-5">1.3.2.2</span> vm_flags</h5>
<div class="outline-text-5" id="text-1-3-2-2">
<p>
和 "memory" 相关的 flags 有许多, 例如:
</p>

<ol class="org-ol">
<li><p>
PTE 中的 flags
</p>

<p>
Read/Write, Present, User/Supervisor 等, CPU 会直接使用这个 flag
</p></li>

<li><p>
page descriptor 中的 flags
</p>

<p>
参考 <a href="#org903b5d7">Page Descriptor</a>, 主要是和 PFRA 有关, 例如 PG_referenced,
PG_lru, PG_active 等, CPU 并不会直接使用这个 flag
</p></li>
</ol>

<p>
除了以上两种, 还有一种 flag 是 vm_area_struct 的 vm_flags, 这个 flag
也不会被 CPU 直接使用, 而且它的功能很多
</p>
</div>

<div id="outline-container-orgf1d34ab" class="outline-6">
<h6 id="orgf1d34ab"><span class="section-number-6">1.3.2.2.1</span> Access Right 相关</h6>
<div class="outline-text-6" id="text-1-3-2-2-1">
<ul class="org-ul">
<li>VM_READ</li>
<li>VM_WRITE</li>
<li>VM_EXEC</li>
</ul>

<p>
Access right 分为三种: 读, 写, 执行, 一般情况下, vma 的 access right
与对应的 PTE 的 flag 是一致的, 但有例外:
</p>

<ol class="org-ol">
<li>x86 中 PTE 中关于 access right 只有一个 bit: Read/Write, 但 vma 的三
种权限需要三个 bit 才可以完整表示, 所以 linux 使用了如下的规则:

<ol class="org-ol">
<li>PTE 的 Read/Write 为 Read, 则表示 vma 有 VM_READ 和 VM_EXEC</li>

<li>PTE 的 Read/Write 为 Write, 则表示 vma 有 VM_READ, VM_WRITE 和 VM_EXEC</li>
</ol></li>

<li>为了支持 COW, vma 的 access right 与对应的 PTE 的 access right 是不
一致的, 具体参考 page fault</li>
</ol>

<p>
mprotect 系统调用可以修改这些 flag
</p>
</div>
</div>

<div id="outline-container-orgaa427cf" class="outline-6">
<h6 id="orgaa427cf"><span class="section-number-6">1.3.2.2.2</span> 和栈有关</h6>
<div class="outline-text-6" id="text-1-3-2-2-2">
<ul class="org-ul">
<li>VM_GROWSDOWN</li>
<li>VM_GROWSUP</li>
</ul>
</div>
</div>

<div id="outline-container-orgd740a9a" class="outline-6">
<h6 id="orgd740a9a"><span class="section-number-6">1.3.2.2.3</span> 和 PFRA 有关</h6>
<div class="outline-text-6" id="text-1-3-2-2-3">
<ul class="org-ul">
<li>VM_LOCKED</li>
<li>VM_RESERVED</li>
</ul>

<p>
mlock 相关的系统调用可以修改这些 flag
</p>
</div>
</div>

<div id="outline-container-orgd70a8e9" class="outline-6">
<h6 id="orgd70a8e9"><span class="section-number-6">1.3.2.2.4</span> 和 IO 预读有关</h6>
<div class="outline-text-6" id="text-1-3-2-2-4">
<ul class="org-ul">
<li>VM_SEQ_READ</li>
<li>VM_RAND_READ</li>
</ul>

<p>
madvise 系统调用可以修改这些 flag
</p>
</div>
</div>

<div id="outline-container-org87b9bf9" class="outline-6">
<h6 id="org87b9bf9"><span class="section-number-6">1.3.2.2.5</span> 其它</h6>
<div class="outline-text-6" id="text-1-3-2-2-5">
<ul class="org-ul">
<li>VM_DONTCOPY</li>
</ul>

<p>
madvise 系统调用可以修改这些 flag
</p>
</div>
</div>
</div>

<div id="outline-container-org2d3f478" class="outline-5">
<h5 id="org2d3f478"><span class="section-number-5">1.3.2.3</span> find_vma</h5>
<div class="outline-text-5" id="text-1-3-2-3">
<p>
find_vma 是使用 mm_rb 和 vm_rb 这棵 RB tree 来查找相应的 vma
</p>
</div>
</div>

<div id="outline-container-orgff3b2ce" class="outline-5">
<h5 id="orgff3b2ce"><span class="section-number-5">1.3.2.4</span> get_unmapped_area</h5>
<div class="outline-text-5" id="text-1-3-2-4">
<p>
get_unmapped_area 决定了 mmap 时分配的区域的位置, 实际上, 存在两种不同
的 get_unmapped_area 实现, 导致两种完全不同的 layout
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">get_unmapped_area</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110; MAP_FIXED, &#30452;&#25509;&#36820;&#22238; addr</span>
  <span style="font-weight: bold;">if</span> (flags &amp; MAP_FIXED):
    <span style="font-weight: bold;">return</span> addr
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26681;&#25454; arch_pick_mmap_layout &#30340;&#32467;&#26524;, &#21487;&#33021;&#35843;&#29992;&#21040; arch_get_unmapped_area</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25110; arch_get_unmapped_area_topdown        </span>
  current-&gt;mm-&gt;get_unmapped_area(file, addr, len, pgoff, flags);

</pre>
</div>
</div>

<div id="outline-container-org8de50f4" class="outline-6">
<h6 id="org8de50f4"><span class="section-number-6">1.3.2.4.1</span> arch_get_unmapped_area</h6>
<div class="outline-text-6" id="text-1-3-2-4-1">
<p>
arch_get_unmapped_area 是从 TASK_UNMAPPED_BASE (1G) 处开始, 从低到高选
择一块可用的区域, 这种方式适用于 stack 需要 "无限" 增长的情况: the
"classic" layout
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">arch_get_unmapped_area</span>()
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#33509; mmap &#26102;&#25351;&#23450;&#20102; addr &#19981;&#20026;&#38646;, &#19988;&#35813; [addr, addr+size] &#21018;&#22909;&#26159;&#21487;&#29992;&#30340;,</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21017;&#30452;&#25509;&#36820;&#22238;        </span>
  <span style="font-weight: bold;">if</span> (addr):
    addr = PAGE_ALIGN(addr);
  vma = find_vma(mm, addr);
  <span style="font-weight: bold;">if</span> (TASK_SIZE - len &gt;= addr &amp;&amp; (!vma || addr + len &lt;= vma-&gt;vm_start)):
    <span style="font-weight: bold;">return</span> addr;
  <span style="font-weight: bold;">else</span>:
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">addr &#19981;&#21487;&#29992;, &#20174; mm-&gt;free_area_cache &#36825;&#20010; addr &#24320;&#22987;&#26597;&#25214;&#19968;&#20010;&#21487;&#29992;&#30340;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21306;&#38388;, mm-&gt;free_area_cache &#21021;&#22987;&#20540;&#20026; TASK_UNMAPPED_BASE, &#20854;&#20540;&#20026;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">3G/3 = 1G, &#25152;&#20197; mmap &#19981;&#25351;&#23450; addr &#26102;&#33021;&#25343;&#21040;&#30340;&#22320;&#22336;&#37117;&#26159;&#20301;&#20110; 1G</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">(0x4000 0000)&#20197;&#21518;      </span>
    start_addr = addr = mm-&gt;free_area_cache;
    <span style="font-weight: bold; text-decoration: underline;">full_search</span>:
    <span style="font-weight: bold;">for</span> (vma = find_vma(mm, addr); ; vma = vma-&gt;vm_next):
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22238;&#32469;&#21040; TASK_UNMAPPED_BASE &#37325;&#26032;&#24320;&#22987;&#26597;&#25214;      </span>
      <span style="font-weight: bold;">if</span> (TASK_SIZE - len &lt; addr):
          <span style="font-weight: bold;">if</span> (start_addr != TASK_UNMAPPED_BASE):
            start_addr = addr = TASK_UNMAPPED_BASE;
          <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">full_search</span>;
      <span style="font-weight: bold;">else</span>:
        <span style="font-weight: bold;">return</span> -ENOMEM;
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25214;&#21040;&#30446;&#26631;, &#26356;&#26032; mm-&gt;free_area_cache &#20197;&#20415;&#21518;&#32493; mmap &#20174;&#36825;&#20010;&#20301;&#32622;&#24320;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22987;&#26597;&#25214;        </span>
      <span style="font-weight: bold;">if</span> (!vma || addr + len &lt;= vma-&gt;vm_start):
        mm-&gt;free_area_cache = addr + len;
      <span style="font-weight: bold;">return</span> addr;
      addr = vma-&gt;vm_end;

</pre>
</div>

<p>
一段 mmap(1G) 的代码运行时的 layout 为:
</p>

<pre class="example" id="orgcac8063">
0000000008048000      4K r-x-- a.out
0000000008049000      4K rw--- a.out
000000000804a000    132K rw---   [ anon ]  &lt;--- heap
0000000055555000    136K r-x-- ld-2.23.so
0000000055577000      4K r---- ld-2.23.so
0000000055578000      4K rw--- ld-2.23.so
0000000055579000     12K r----   [ anon ]
000000005557c000      8K r-x--   [ anon ]
000000005557e000      4K rw---   [ anon ]
00000000555b0000   1720K r-x-- libc-2.23.so
000000005575e000      4K ----- libc-2.23.so
000000005575f000      8K r---- libc-2.23.so
0000000055761000      4K rw--- libc-2.23.so 
0000000055762000 1048592K rw---   [ anon ]  &lt;--- mmap 
00000000fffdc000    136K rw---   [ stack ]
</pre>


<div id="org9f770e1" class="figure">
<p><img src="../extra/kernel_mmap_layout_classic.png" alt="kernel_mmap_layout_classic.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org0834cb3" class="outline-6">
<h6 id="org0834cb3"><span class="section-number-6">1.3.2.4.2</span> arch_get_unmapped_area_topdown</h6>
<div class="outline-text-6" id="text-1-3-2-4-2">
<p>
arch_get_unmapped_area_topdown 是从 stack 的 low-limit (base) 处开始从
高到低来查找可用区域, 适用于 stack 大小固定的 layout: the "flexible"
layout.
</p>

<p>
正常情况下 stack 都不是 ulimited, 所以都是使用的这个方法
</p>

<p>
同样的一段 mmap(1G) 的代码运行进的 layout 为:
</p>

<pre class="example" id="orgb6ad0ed">
0000000008048000      4K r-x-- a.out
0000000008049000      4K rw--- a.out
000000000804a000    132K rw---   [ anon ]  &lt;--- heap
00000000b7ded000 1048580K rw---   [ anon ] &lt;--- mmap
00000000f7dee000   1720K r-x-- libc-2.23.so
00000000f7f9c000      4K ----- libc-2.23.so
00000000f7f9d000      8K r---- libc-2.23.so
00000000f7f9f000      4K rw--- libc-2.23.so
00000000f7fa0000     12K rw---   [ anon ]
00000000f7fd4000      4K rw---   [ anon ]
00000000f7fd5000     12K r----   [ anon ]
00000000f7fd8000      8K r-x--   [ anon ]
00000000f7fda000    136K r-x-- ld-2.23.so
00000000f7ffc000      4K r---- ld-2.23.so
00000000f7ffd000      4K rw--- ld-2.23.so
00000000fffdc000    136K rw---   [ stack ]
</pre>


<div id="org8f4fe33" class="figure">
<p><img src="../extra/kernel_mmap_layout_flexible.png" alt="kernel_mmap_layout_flexible.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org68e46cf" class="outline-6">
<h6 id="org68e46cf"><span class="section-number-6">1.3.2.4.3</span> arch_pick_mmap_layout</h6>
<div class="outline-text-6" id="text-1-3-2-4-3">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">arch_pick_mmap_layout</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Fall back to the standard layout if the personality bit is set, or</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">if the expected stack growth is unlimited:</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#33509; RLIMIT_STACK &#20026; unlimited, &#21017;&#36873;&#25321; arch_get_unmapped_area &#20174;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">TASK_UNMAPPED_BASE &#24320;&#22987;&#20174;&#20302;&#21040;&#39640;&#20998;&#37197;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21542;&#21017;, &#20351;&#29992; arch_get_unmapped_area_topdown &#20174; stack &#30340; base &#22788;&#20174;&#39640;&#21040;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20302;&#20998;&#37197;  </span>
  <span style="font-weight: bold;">if</span> (sysctl_legacy_va_layout || (current-&gt;personality &amp; ADDR_COMPAT_LAYOUT) ||
        current-&gt;signal-&gt;rlim[RLIMIT_STACK].rlim_cur == RLIM_INFINITY):
    mm-&gt;mmap_base = TASK_UNMAPPED_BASE;
    mm-&gt;get_unmapped_area = arch_get_unmapped_area;
    mm-&gt;unmap_area = arch_unmap_area;
    <span style="font-weight: bold;">else</span>:
      mm-&gt;mmap_base = mmap_base(mm);
      mm-&gt;get_unmapped_area = arch_get_unmapped_area_topdown;
      mm-&gt;unmap_area = arch_unmap_area_topdown;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf827070" class="outline-5">
<h5 id="orgf827070"><span class="section-number-5">1.3.2.5</span> sys_mmap</h5>
<div class="outline-text-5" id="text-1-3-2-5">
<p>
mmap 系统调用用来建立 memory region
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">do_mmap</span>:
  <span style="font-weight: bold;">do_mmap_pgoff</span>(file, addr, len, prot, flag, offset &gt;&gt; PAGE_SHIFT);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22312;&#34394;&#25311;&#22320;&#22336;&#31354;&#38388;&#19978;&#20998;&#37197;&#19968;&#22359;&#21512;&#36866;&#30340;&#21306;&#22495;</span>
    addr = get_unmapped_area(file, addr, len, pgoff, flags);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558; mmap &#30340;&#19968;&#20123;&#21442;&#25968; (prot, flags) &#36716;&#25442;&#20026; vm_flags</span>
    vm_flags = calc_vm_prot_bits(prot) | calc_vm_flag_bits(flags)
    <span style="font-weight: bold;">if</span> (flags &amp; MAP_LOCKED):
      vm_flags |= VM_LOCKED;

    inode = file ? file-&gt;f_dentry-&gt;d_inode : <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">file mapped</span>
    <span style="font-weight: bold;">if</span> (file):
      <span style="font-weight: bold;">switch</span> (flags &amp; MAP_TYPE):
        <span style="font-weight: bold;">case</span> MAP_SHARED:
          <span style="font-weight: bold;">if</span> ((prot&amp;PROT_WRITE) &amp;&amp; !(file-&gt;f_mode&amp;FMODE_WRITE)):
            <span style="font-weight: bold;">return</span> -EACCES;
          vm_flags |= VM_SHARED | VM_MAYSHARE;
          <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">fall through</span><span style="font-weight: bold; font-style: italic;"> */</span>
        <span style="font-weight: bold;">case</span> MAP_PRIVATE:
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110; MAP_PRIVATE, &#24182;&#19981;&#38656;&#35201;&#26816;&#26597;&#26159;&#21542;&#25991;&#20214;&#38656;&#35201; write &#26435;&#38480;, &#22240;&#20026;</span>
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">MAP_PRIVATE &#24182;&#19981;&#38656;&#35201;&#30495;&#27491;"&#20889;"&#21040;&#25991;&#20214;&#20013;</span>
          <span style="font-weight: bold;">if</span> (!(file-&gt;f_mode &amp; FMODE_READ)):
            <span style="font-weight: bold;">return</span> -EACCES;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">find_vma_prepare &#30340;&#20316;&#29992;&#26159;&#25214;&#21040; addr &#21069;&#38754;&#30340; vma, &#25918;&#22312; prev &#20013;(&#21644;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">vma_merge &#26377;&#20851;), &#20197;&#21450; addr &#20043;&#21518;&#30340; vma, &#36890;&#36807;&#36820;&#22238;&#20540;&#36820;&#22238;</span>
    <span style="font-weight: bold; text-decoration: underline;">munmap_back</span>:
    vma = find_vma_prepare(mm, addr, &amp;prev, &amp;rb_link, &amp;rb_parent);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#21457;&#29616;&#24050;&#32463;&#23384;&#22312;&#30340;&#19968;&#20010; vma &#19982;&#35201;&#20998;&#37197;&#30340; [addr, addr+len] &#26377;&#37325;&#21512;,</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21017;&#20808;&#23581;&#35797; unmap &#25481;&#20043;&#21069;&#30340; vma, &#36825;&#20010;&#34892;&#20026;&#21442;&#32771; mmap &#20013;&#20851;&#20110; MAP_FIXED</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#30340;&#35828;&#26126;. &#23454;&#29616;&#19978;, MAP_FIXED &#30340;&#38656;&#27714;&#23548;&#33268; get_unmapped_area &#24182;&#19981;&#33021;&#20445;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35777;&#36820;&#22238;&#30340;[addr, addr+len] &#19968;&#23450;&#26159;"&#31354;&#38386;"&#30340;&#21306;&#38388; (&#21442;&#32771; get_unmapped_area)</span>
    <span style="font-weight: bold;">if</span> (vma &amp;&amp; vma-&gt;vm_start &lt; addr + len):
        do_munmap(mm, addr, len)
    <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">munmap_back</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#30495;&#27491;&#20998;&#37197;&#19968;&#20010; vma</span>
    vma = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);
    vma-&gt;vm_mm = mm;
    vma-&gt;vm_start = addr;
    vma-&gt;vm_end = addr + len;
    vma-&gt;vm_flags = vm_flags;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">protection_map &#23436;&#25104; vm_flags &#19982; PTE flags &#30340;&#26144;&#23556;, &#26144;&#23556;&#30340;&#35268;&#21017;&#21442;&#32771;&#21069;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#38754;&#30340;&#25551;&#36848; [[*Access Right &#30456;&#20851;][Access Right &#30456;&#20851;]]</span>
    vma-&gt;vm_page_prot = protection_map[vm_flags &amp; 0x0f];
    vma-&gt;vm_pgoff = pgoff;
    <span style="font-weight: bold;">if</span> (file):
      vma-&gt;vm_file = file;
      file-&gt;f_op-&gt;mmap(file, vma);
    <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (vm_flags &amp; VM_SHARED):
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20026;&#20102;&#25903;&#25345; anonymous shared mapping (&#21363; mmap &#26102;&#25351;&#23450;&#20102; MAP_ANONYMOUS|MAP_SHARED)</span>
      shmem_zero_setup(vma);
        file = shmem_file_setup(<span style="font-style: italic;">"dev/zero"</span>, size, vma-&gt;vm_flags);
        vma-&gt;vm_file = file;
        vma-&gt;vm_ops = &amp;shmem_vm_ops;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19982;&#21069;&#21518;&#30340; vma &#36827;&#34892; merge</span>
    <span style="font-weight: bold;">vma_merge</span>(mm, prev, addr, ...)
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28155;&#21152;&#21040; mm_struct-&gt;mmap &#38142;&#34920;&#21450; mm_struct-&gt;mm_rb &#26641;&#20013;</span>
    <span style="font-weight: bold;">vma_link</span>(mm, vma, prev, rb_link, rb_parent);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110; VM_LOCKED, &#30452;&#25509;&#20998;&#37197; page (&#36890;&#36807; handle_mm_fault)</span>
    <span style="font-weight: bold;">if</span> (vm_flags &amp; VM_LOCKED):
      make_pages_present(addr, addr + len);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110; MAP_POPULATE, &#21516;&#26679;&#39044;&#20808;&#20998;&#37197; page (&#36890;&#36807; vm_ops-&gt;populate)</span>
    <span style="font-weight: bold;">if</span> (flags &amp; MAP_POPULATE):
        sys_remap_file_pages(addr, len, 0, pgoff, flags &amp; MAP_NONBLOCK);
    <span style="font-weight: bold;">return</span> addr;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org60f8369" class="outline-4">
<h4 id="org60f8369"><span class="section-number-4">1.3.3</span> Page Fault</h4>
<div class="outline-text-4" id="text-1-3-3">
</div>
<div id="outline-container-org145fd3b" class="outline-5">
<h5 id="org145fd3b"><span class="section-number-5">1.3.3.1</span> Overview</h5>
<div class="outline-text-5" id="text-1-3-3-1">

<div id="org0308089" class="figure">
<p><img src="../extra/kernel_page_fault.png" alt="kernel_page_fault.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgc9ef2ad" class="outline-5">
<h5 id="orgc9ef2ad"><span class="section-number-5">1.3.3.2</span> error code</h5>
<div class="outline-text-5" id="text-1-3-3-2">
<p>
page fault 发生时, 硬件负责调用 do_page_fault 并提供一个 error code, 表
示 page fault 的原因, error code 一共 5 bit, 从高到低依次是:
</p>

<ul class="org-ul">
<li><p>
present
</p>

<p>
若 present 为 0, 表示 page 没有 present 导致 page fault, 否则 page
present, 但 page 权限导致了 fault
</p></li>

<li><p>
write
</p>

<p>
若 write 为 0, 表示 page read 导致的 page fault, 否则, 表示 page
write 导致的 page fault
</p></li>

<li><p>
user
</p>

<p>
若 user 为 0, 表示发生在 kernel mode, 否则, 表示发生成 user mode
</p></li>

<li>reserved write</li>

<li>instruction fetch</li>
</ul>

<p>
最重要的低 3 bit, 例如:
</p>

<p>
当 !(error_code &amp; 5) 时, 表示 !(user|present), 则发生在 kernel mode,
而且 page 没有 present, 即 vmalloc_fault
</p>
</div>
</div>

<div id="outline-container-org0606900" class="outline-5">
<h5 id="org0606900"><span class="section-number-5">1.3.3.3</span> do_page_fault</h5>
<div class="outline-text-5" id="text-1-3-3-3">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">do_page_fault</span>(<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">pt_regs</span> *<span style="font-weight: bold; font-style: italic;">regs</span>, <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">error_code</span>):
  <span style="font-weight: bold;">__asm__</span>(<span style="font-style: italic;">"movl %%cr2,%0"</span>:<span style="font-style: italic;">"=r"</span> (address));
  tsk = current;
  <span style="font-weight: bold;">if</span> (unlikely(address &gt;= TASK_SIZE)):
    <span style="font-weight: bold;">if</span> (!(error_code &amp; 5)):
      <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">vmalloc_fault</span>;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">find_vma &#26159;&#22312;&#23547;&#25214;&#19968;&#20010; address &#20043;&#21518;&#31163; address &#26368;&#36817;&#30340; vma, &#32780;&#19981;&#19968;&#23450;&#26159;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">"&#21253;&#21547;" address &#30340; vma, &#20855;&#20307;&#30340;&#35828;, find_vma &#26159; `Look up the first VMA</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">which satisfies addr &lt; vm_end, NULL if none`.</span>
  <span style="font-weight: bold; font-style: italic;">// </span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20043;&#25152;&#20197;&#36825;&#26679;&#26159;&#20026;&#20102;&#22788;&#29702; expand_stack &#30340;&#24773;&#20917;  </span>

  vma = find_vma(mm, address);
  <span style="font-weight: bold;">if</span> (!vma):
    <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">bad_area</span>;
  <span style="font-weight: bold;">if</span> (vma-&gt;vm_start &lt;= address):
    <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">good_area</span>;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">address &#22312; vma &#20043;&#21069;, &#33509; vma &#26159; growsdown, &#21017;&#21487;&#33021;&#26159;&#22312; push stack, &#21542;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21017;, &#30452;&#25509; segment fault</span>
  <span style="font-weight: bold;">if</span> (!(vma-&gt;vm_flags &amp; VM_GROWSDOWN)):
    <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">bad_area</span>;
  <span style="font-weight: bold;">if</span> (error_code &amp; 4):
    <span style="font-weight: bold; font-style: italic;">/*</span>
<span style="font-weight: bold; font-style: italic;">     * accessing the stack below %esp is always a bug.</span>
<span style="font-weight: bold; font-style: italic;">     * The "+ 32" is there due to some instructions (like</span>
<span style="font-weight: bold; font-style: italic;">     * pusha) doing post-decrement on the stack and that</span>
<span style="font-weight: bold; font-style: italic;">     * doesn't show up until later..</span>
<span style="font-weight: bold; font-style: italic;">     */</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#21028;&#26029;&#23548;&#33268;&#26222;&#36890;&#30340;&#36890;&#36807; MAP_GROWSDOWN &#26144;&#23556;&#30340; VMA &#24182;&#19981;&#33021;&#20687; stack</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37027;&#26679;&#25903;&#25345; auto expand</span>
    <span style="font-weight: bold;">if</span> (address + 32 &lt; regs-&gt;esp)
        <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">bad_area</span>;

  <span style="font-weight: bold;">if</span> (expand_stack(vma, address)):
    <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">bad_area</span>;

  <span style="font-weight: bold; text-decoration: underline;">good_area</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26816;&#26597; error_code &#20013;&#30340; write &#21644; present &#20301;</span>
  <span style="font-weight: bold;">switch</span> (error_code &amp; 3):
    <span style="font-weight: bold;">default</span>:
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">write, present</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#33509; vma &#21487;&#20889;, &#19988; page present, &#20294; PTE &#19981;&#21487;&#20889;, &#21017;&#20195;&#34920;&#36825;&#26159;&#19968;&#27425; COW</span>
    <span style="font-weight: bold;">case</span> 2:
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">write, not present</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">vma &#21487;&#20889;, &#20294; page not present, &#20195;&#34920;&#36825;&#26159;&#19968;&#20010; demanding page</span>
      <span style="font-weight: bold;">if</span> (!(vma-&gt;vm_flags &amp; VM_WRITE)):
          <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">bad_area</span>;
      write++;
      <span style="font-weight: bold;">break</span>;
    <span style="font-weight: bold;">case</span> 1:
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">read, present</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">page present &#20294;&#19981;&#33021; read? SEGV</span>
      <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">bad_area</span>;
    <span style="font-weight: bold;">case</span> 0:
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">read, not present</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">vma &#21487;&#35835;, &#20294; page not present, &#20195;&#34920;&#19968;&#27425; demanding page</span>
      <span style="font-weight: bold;">if</span> (!(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC))):
        <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">bad_area</span>;

  <span style="font-weight: bold; text-decoration: underline;">good_area</span>:
  ret = handle_mm_fault(mm, vma, address, write);
    pte = pte_alloc_map(mm, pmd, address);
    <span style="font-weight: bold;">handle_pte_fault</span>(mm, vma, address, write_access, pte, pmd);
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">PTE not present, &#33509; PTE &#20026; 0, &#21017;&#34920;&#31034; demanding page, &#21542;&#21017; PTE &#30340;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20540;&#20026; swap identifier, &#34920;&#31034; swap</span>
      <span style="font-weight: bold;">if</span> (!pte_present(entry)):
        <span style="font-weight: bold;">if</span> (pte_none(entry)):
          <span style="font-weight: bold;">return</span> do_no_page(mm, vma, address, write_access, pte, pmd);
        <span style="font-weight: bold;">else</span>:
          <span style="font-weight: bold;">return</span> do_swap_page(mm, vma, address, pte, pmd, entry, write_access);
      <span style="font-weight: bold;">else</span>:
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">PTE present, &#20294; PTE &#19981;&#21487;&#20889;, &#32780; VMA &#21487;&#20889;, &#34920;&#31034; COW</span>
        <span style="font-weight: bold;">if</span> (write_access):
          <span style="font-weight: bold;">if</span> (!pte_write(entry)):
            <span style="font-weight: bold;">return</span> do_wp_page(mm, vma, address, pte, pmd, entry);

  <span style="font-weight: bold;">switch</span> ret:
    <span style="font-weight: bold;">case</span> VM_FAULT_MINOR:
      tsk-&gt;min_flt++;
      <span style="font-weight: bold;">break</span>;
    <span style="font-weight: bold;">case</span> VM_FAULT_MAJOR:
      tsk-&gt;maj_flt++;
      <span style="font-weight: bold;">break</span>;
    <span style="font-weight: bold;">case</span> VM_FAULT_SIGBUS:
      <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">do_sigbus</span>;
    <span style="font-weight: bold;">case</span> VM_FAULT_OOM:
      <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">out_of_memory</span>;
        <span style="font-weight: bold;">do_exit</span>(SIGKILL);
    <span style="font-weight: bold;">default</span>:
      <span style="font-weight: bold;">BUG</span>();

</pre>
</div>
</div>
</div>

<div id="outline-container-org7567fa7" class="outline-5">
<h5 id="org7567fa7"><span class="section-number-5">1.3.3.4</span> vmalloc_fault</h5>
<div class="outline-text-5" id="text-1-3-3-4">
<p>
vmalloc_fault 的功能是把 swapper_pg_dir 中对应的 PTE 同步到 current
task 的页表, 参考 <a href="#org55e30db">动态映射的部分 (ZONE_HIGHMEM)</a>
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">vmalloc_fault</span>:
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">index</span> = pgd_index(address);
  <span style="font-weight: bold;">asm</span>(<span style="font-style: italic;">"movl %%cr3,%0"</span>:<span style="font-style: italic;">"=r"</span> (pgd_paddr));
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">pgd &#26159;&#24403;&#21069;&#36827;&#31243;&#30340; page directory &#20013;&#23545;&#24212;&#30340;&#22320;&#20301;</span>
  pgd = index + (<span style="font-weight: bold; text-decoration: underline;">pgd_t</span> *)<span style="font-weight: bold;">__va</span>(pgd_paddr);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">init_mm.pgd &#21363; swapper_pg_dir</span>
  pgd_k = init_mm.pgd + index;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#24182;&#27809;&#26377;&#21333;&#29420;&#35774;&#32622; PTE, &#32780;&#26159;&#30452;&#25509;&#35774;&#32622;&#20102; pgd</span>
  <span style="font-weight: bold;">set_pgd</span>(pgd, *pgd_k);
</pre>
</div>
</div>
</div>

<div id="outline-container-org4d69e4b" class="outline-5">
<h5 id="org4d69e4b"><span class="section-number-5">1.3.3.5</span> expand_stack</h5>
<div class="outline-text-5" id="text-1-3-3-5">
</div>
<div id="outline-container-org4b162b5" class="outline-6">
<h6 id="org4b162b5"><span class="section-number-6">1.3.3.5.1</span> expand_stack</h6>
<div class="outline-text-6" id="text-1-3-3-5-1">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">expand_stack</span>:
  <span style="font-weight: bold;">if</span> (address &lt; vma-&gt;vm_start):
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> size, grow;

    size = vma-&gt;vm_end - address;
    grow = (vma-&gt;vm_start - address) &gt;&gt; PAGE_SHIFT;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">acct_stack_growth &#20250;&#21435;&#26816;&#26597; rlim[RLIMIT_STACK] &#30830;&#20445; stack &#22823;&#23567;&#27809;&#26377;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36229;&#36807; ulimit &#35774;&#23450;&#30340;&#20540;</span>
    error = acct_stack_growth(vma, size, grow);
    <span style="font-weight: bold;">if</span> (!error):
        vma-&gt;vm_start = address;
        vma-&gt;vm_pgoff -= grow;

</pre>
</div>
</div>
</div>

<div id="outline-container-org16674ea" class="outline-6">
<h6 id="org16674ea"><span class="section-number-6">1.3.3.5.2</span> 一段利用 expand_stack (或者 MAP_GROWSDOWN) 的代码</h6>
<div class="outline-text-6" id="text-1-3-3-5-2">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;sys/mman.h&gt;</span>

<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">main</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">argc</span>, <span style="font-weight: bold; text-decoration: underline;">char</span> *<span style="font-weight: bold; font-style: italic;">argv</span>[]) {
    <span style="font-weight: bold; text-decoration: underline;">char</span> * <span style="font-weight: bold; font-style: italic;">buf</span> = (<span style="font-weight: bold; text-decoration: underline;">char</span> *) mmap(0, 40960, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_GROWSDOWN, 0, 0);

    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">__sp</span> = (<span style="font-weight: bold; text-decoration: underline;">int</span>)buf;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20462;&#25913; sp &#30340;&#20540;&#20197;&#32469;&#36807; kernel &#23545; expand_stack &#30340;&#26816;&#26597;</span>
    <span style="font-weight: bold;">__asm__</span>(
        <span style="font-style: italic;">"mov  %0, %%esp\n\t"</span>                    \
        :
        :<span style="font-style: italic;">"r"</span> (__sp));

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#27809;&#26377;&#25253;&#38169;, &#35828;&#26126; expand_stack &#25104;&#21151;&#20102;</span>
    buf[-1] = 1;

    <span style="font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
实际上, expand_stack 的功能是应该避免使用的, 因为它可能会导致某些 vma
被意外的修改 <a href="http://lwn.net/Articles/294001/">MAP_GROWSUP &amp; MAP_GROWSDOWN removal</a>
</p>
</div>
</div>

<div id="outline-container-org1f412f0" class="outline-6">
<h6 id="org1f412f0"><span class="section-number-6">1.3.3.5.3</span> pthread 与 stack</h6>
<div class="outline-text-6" id="text-1-3-3-5-3">
<p>
pthread_create 在生成新的 stack 时也并没有使用 expand_stack 功能
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">pthread_create</span>:
  <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">child_stack</span> = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  __allocate_thread(&amp;thread_attr, &amp;thread, &amp;child_stack);
    attr-&gt;stack_base = __create_thread_mapped_space(mmap_size, attr-&gt;guard_size);
      <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">prot</span> = PROT_READ | PROT_WRITE;
      <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">flags</span> = MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE;
      <span style="font-weight: bold;">return</span> mmap(<span style="font-weight: bold; text-decoration: underline;">NULL</span>, mmap_size, prot, flags, -1, 0);
    stack_top = reinterpret_cast&lt;uint8_t*&gt;(attr-&gt;stack_base) + mmap_size;
    *child_stack = stack_top;
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">flags</span> = CLONE_VM | CLONE_FS | CLONE_FILES |
      CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM |
      CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID;
  <span style="font-weight: bold;">clone</span>(__pthread_start, child_stack, flags, thread, &amp;(thread-&gt;tid), tls, &amp;(thread-&gt;tid));
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org1ede518" class="outline-5">
<h5 id="org1ede518"><span class="section-number-5">1.3.3.6</span> do_no_page</h5>
<div class="outline-text-5" id="text-1-3-3-6">
<p>
Demanding page
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">do_no_page</span>:
  <span style="font-weight: bold;">if</span> (!vma-&gt;vm_ops || !vma-&gt;vm_ops-&gt;nopage):
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">do_anonymous_page &#23545;&#24212; private anonymous mapping  (MAP_PRIVATE|MAP_ANONYMOUS)</span>
    <span style="font-weight: bold;">return</span> do_anonymous_page(mm, vma, page_table, pmd, write_access, address);
  <span style="font-weight: bold;">else</span>:
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#38500;&#20102; driver &#33258;&#24049;&#23454;&#29616; mmap, &#33267;&#23569;&#36824;&#26377;&#20004;&#31181;&#24773;&#20917;&#19979; vm_ops-&gt;nopage &#20250;&#26377;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20540;:</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">1. file mapping, vm_ops-&gt;nopage &#25351;&#21521; filemap_nopage</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">2. shared anonymous mapping, vm_ops-&gt;nopage &#25351;&#21521; shmem_nopage</span>
    new_page = vma-&gt;vm_ops-&gt;nopage(vma, address &amp; PAGE_MASK, &amp;ret);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#38500;&#20102; fork &#22806;, private file mapping &#26159; COW &#30340;&#21478;&#19968;&#31181;&#24773;&#20917;, &#34429;&#28982;&#24403;&#21069;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">page fault &#30340;&#21407;&#22240;&#26159; "pte not present", &#20294;&#22240;&#20026; write_access &#20026; true,</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#34920;&#31034; page fault &#30340;&#21407;&#22240;&#26159; write, &#25152;&#20197;&#36825;&#37324;&#25552;&#21069;&#20570; "early COW break", &#22914;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26524;&#36825;&#37324;&#19981;&#20570;, &#26412;&#27425; page fault &#36820;&#22238;&#21518;&#39532;&#19978;&#20063;&#24517;&#23450;&#20250;&#22240;&#20026; COW &#23548;&#33268;&#21478;&#19968;&#27425;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">page fault</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#36825;&#37324;&#19981;&#20570; "early COW break", &#21017; do_no_page &#21518;&#38754;&#24182;&#19981;&#33021;&#31616;&#21333;&#30340;&#36890;&#36807;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">mk_pte(new_page, vma-&gt;vm_page_prot) &#26469;&#35774;&#32622; PTE, &#32780;&#26159;&#35201;&#25353;&#29031; COW &#30340;&#35201;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27714;&#26469;&#35774;&#32622; PTE</span>
  <span style="font-weight: bold;">if</span> (write_access &amp;&amp; !(vma-&gt;vm_flags &amp; VM_SHARED)):
    <span style="font-weight: bold;">struct</span> page *page;

    <span style="font-weight: bold;">if</span> (unlikely(anon_vma_prepare(vma)))
        <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">oom</span>;
    page = alloc_page_vma(GFP_HIGHUSER, vma, address);
    <span style="font-weight: bold;">copy_user_highpage</span>(page, new_page, address);
    <span style="font-weight: bold;">page_cache_release</span>(new_page);
    new_page = page;
    anon = 1;

  entry = mk_pte(new_page, vma-&gt;vm_page_prot);
  <span style="font-weight: bold;">set_pte</span>(page_table, entry);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdcd6164" class="outline-5">
<h5 id="orgdcd6164"><span class="section-number-5">1.3.3.7</span> do_swap_page</h5>
<div class="outline-text-5" id="text-1-3-3-7">
<p>
参考 <a href="#orgdc2f5c2">Swap In</a>
</p>
</div>
</div>

<div id="outline-container-org8da53f5" class="outline-5">
<h5 id="org8da53f5"><span class="section-number-5">1.3.3.8</span> do_wp_page</h5>
<div class="outline-text-5" id="text-1-3-3-8">
<p>
COW, 参考 <a href="#org6492f04">Copy On Write</a>
</p>
</div>
</div>

<div id="outline-container-org283794f" class="outline-5">
<h5 id="org283794f"><span class="section-number-5">1.3.3.9</span> 关于 SIGBUS</h5>
<div class="outline-text-5" id="text-1-3-3-9">
<p>
一般情况下, handle_mm_fault 返回 VM_FAULT_MAJOR 或 VM_FAULT_MAJOR, 但
也有可能返回 VM_FAULT_OOM 或 VM_FAULT_SIGBUS.
</p>

<p>
其中对于 VM_FAULT_SIGBUS, 除了和硬件相关的错误, 最常见的一种情况是这样
的:
</p>

<div class="org-src-container">
<pre class="src src-c">handle_pte_fault
  <span style="font-weight: bold; text-decoration: underline;">do_file_page</span>
    <span style="font-weight: bold;">vma</span>-&gt;vm_ops-&gt;populate
      filemap_populate
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">pgoff + len &gt; size? &#21487;&#33021; file &#34987; truncate &#20102;</span>
        <span style="font-weight: bold;">if</span> (pgoff + (len &gt;&gt; PAGE_CACHE_SHIFT) &gt; size):
          <span style="font-weight: bold;">return</span> -EINVAL;
  <span style="font-weight: bold;">if</span> (err == -ENOMEM):
    <span style="font-weight: bold;">return</span> VM_FAULT_OOM;
  <span style="font-weight: bold;">if</span> (err):
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">filemap_populate &#36820;&#22238;&#38750; ENOMEM, &#20363;&#22914; EINVAL, &#23548;&#33268;&#36825;&#37324;&#20250;&#36820;&#22238; SIGBUS</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">...</span>
    <span style="font-weight: bold;">return</span> VM_FAULT_SIGBUS;
  <span style="font-weight: bold;">return</span> VM_FAULT_MAJOR;
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org0cc98d1" class="outline-4">
<h4 id="org0cc98d1"><span class="section-number-4">1.3.4</span> Creating Process Address Space</h4>
<div class="outline-text-4" id="text-1-3-4">
</div>
<div id="outline-container-org25accc1" class="outline-5">
<h5 id="org25accc1"><span class="section-number-5">1.3.4.1</span> fork</h5>
<div class="outline-text-5" id="text-1-3-4-1">
<p>
一般情况下 fork 时的 copy_mm 是创建 process address space 的主要入口,
参考 <a href="#orgf1bb79a">Process page table 初始化</a>
</p>
</div>
</div>

<div id="outline-container-org3692a37" class="outline-5">
<h5 id="org3692a37"><span class="section-number-5">1.3.4.2</span> exec</h5>
<div class="outline-text-5" id="text-1-3-4-2">
<p>
参考 <a href="program_exzecution.html#orgebad535">do_execve</a>
</p>
</div>
</div>
</div>

<div id="outline-container-org0ce7ec9" class="outline-4">
<h4 id="org0ce7ec9"><span class="section-number-4">1.3.5</span> Managing the Heap</h4>
<div class="outline-text-4" id="text-1-3-5">
<p>
Managing the heap, linux 下主要是依靠 brk 系统调用
</p>
</div>

<div id="outline-container-org36b5f8f" class="outline-5">
<h5 id="org36b5f8f"><span class="section-number-5">1.3.5.1</span> brk</h5>
<div class="outline-text-5" id="text-1-3-5-1">
<p>
libc 有两个和 brk 相关的函数:
</p>

<ol class="org-ol">
<li>brk</li>

<li>sbrk</li>
</ol>

<p>
在 linux 里都是通过 sys_brk 实现的.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">sys_brk</span>(brk):
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#33509; brk &#23567;&#20110;&#24403;&#21069;&#30340; end_code, &#30452;&#25509;&#36820;&#22238;&#24403;&#21069;&#30340; brk, &#33267;&#20110;&#20026;&#21861;&#26159;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">end_code&#32780;&#19981;&#26159; start_brk ... &#25105;&#26159;&#24819;&#19981;&#36890;&#30340;, &#22240;&#20026;&#20869;&#23384;&#24067;&#23616;&#19978;&#22522;&#26412;&#26159;</span>
  <span style="font-weight: bold; font-style: italic;">// </span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">[start_code, end_code] [start_data, end_data] [start_brk, brk].</span>
  <span style="font-weight: bold; font-style: italic;">// </span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">kernel 3.18 &#24182;&#19981;&#26159;&#21644; end_code &#27604;&#36739;, &#32780;&#26159;&#21644; start_brk &#25110; end_data &#27604;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36739; (&#21462;&#20915;&#20110; brk &#26159;&#21542;&#26377; randomize &#30340;&#37197;&#32622;), &#25152;&#20197;&#25105;&#35748;&#20026;&#36825;&#21487;&#33021;&#26159; kernel</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">2.6.11  &#30340; bug...</span>
  <span style="font-weight: bold; font-style: italic;">// </span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20294;&#36825;&#19968;&#34892;&#20195;&#30721;&#23548;&#33268; sys_brk &#21487;&#20197;&#25903;&#25345; libc &#30340; sbrk(0)    </span>

  <span style="font-weight: bold;">if</span> (brk &lt; mm-&gt;end_code):
    <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">out</span>;

  newbrk = PAGE_ALIGN(brk);
  oldbrk = PAGE_ALIGN(mm-&gt;brk);
  <span style="font-weight: bold;">if</span> (oldbrk == newbrk):
    <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">set_brk</span>;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">shrink brk &#24517;&#28982;&#20250;&#25104;&#21151;</span>
  <span style="font-weight: bold;">if</span> (brk &lt;= mm-&gt;brk):
    do_munmap(mm, newbrk, oldbrk-newbrk)
    <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">out</span>;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">brk &#21463; RLIMIT_DATA &#30340;&#38480;&#21046;</span>
  rlim = current-&gt;signal-&gt;rlim[RLIMIT_DATA].rlim_cur;
  <span style="font-weight: bold;">if</span> (rlim &lt; RLIM_INFINITY &amp;&amp; brk - mm-&gt;start_data &gt; rlim):
    <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">out</span>;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#33509;&#22312;&#24403;&#21069; brk &#22522;&#30784;&#19978;&#23581;&#35797;&#21521;&#21518;&#36890;&#36807; mmap &#25193;&#23637;&#21040;&#26032;&#30340; brk &#26102;&#21457;&#29616;&#24050;&#32463;&#23384;&#22312;&#21478;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19968;&#20010; mmap &#23548;&#33268;&#26080;&#27861;&#25193;&#23637;, &#21017;&#30452;&#25509;&#25253;&#38169;  </span>
  <span style="font-weight: bold;">if</span> (find_vma_intersection(mm, oldbrk, newbrk+PAGE_SIZE)):
    <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">out</span>;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">do_brk &#19982; do_mmap &#24046;&#19981;&#22810;</span>
  <span style="font-weight: bold;">do_brk</span>(oldbrk, newbrk-oldbrk)

out:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">sys_brk &#20250;&#36820;&#22238;&#24403;&#21069;&#30340; brk</span>
  retval = mm-&gt;brk;
</pre>
</div>

<p>
heap 为何会与其它的vma 产生 intersection?  参考 <a href="#orgff3b2ce">get_unmapped_area</a>
</p>
</div>
</div>

<div id="outline-container-org8d94bc1" class="outline-5">
<h5 id="org8d94bc1"><span class="section-number-5">1.3.5.2</span> 关于 malloc</h5>
<div class="outline-text-5" id="text-1-3-5-2">
<p>
malloc 涉及到底层内存分配时, 如果发现 heap 需要扩展, 则会使用如下的逻
辑:
</p>

<ol class="org-ol">
<li>优先使用 MORECORE 来扩展, MORECORE 是 libc 中对 "sbrk-style system
routine" 的称呼, 一般来说 MORECORE 就是 sbrk, 但也允许用其它方式来
模拟 sbrk 的过程</li>

<li>若 MORECORE 失败, 例如 sbrk 因为 vma intersection 的原因无法扩展,
则 libc 会尝试 MMAP 来扩展 heap.</li>

<li>若一次 malloc 的大小超过 DEFAULT_MMAP_THRESHOLD (256K), 则会直接使用
MMAP 来分配</li>
</ol>

<p>
以上是 malloc 的逻辑.
</p>

<p>
除此之外, libc 还支持 mspace<sub>malloc, free, realloc, &#x2026;</sub>, mspace_xxx
支持用户自己通过 create_space 创建一块内存池, 后续的 mspace_xxx 都会操
作这块 mspace, 而不再与 heap 打交道.
</p>

<p>
例如, dalvik 把对象都分配在 Dalvik/ART heap 上, Dalvik/ART heap 实际上就是
一个 mspace, Dalvik/ART 最终是依靠 mspace_malloc 来分配 java 对象的
</p>
</div>
</div>
</div>

<div id="outline-container-org2f5d038" class="outline-4">
<h4 id="org2f5d038"><span class="section-number-4">1.3.6</span> API</h4>
<div class="outline-text-4" id="text-1-3-6">
<p>
和进程地址空间相关的 API, 除了 mmap, 还有以下几个:
</p>
</div>

<div id="outline-container-org779b792" class="outline-5">
<h5 id="org779b792"><span class="section-number-5">1.3.6.1</span> madvise</h5>
<div class="outline-text-5" id="text-1-3-6-1">
<p>
madvise 的主要设置几类的 advice:
</p>

<ol class="org-ol">
<li><p>
和 IO 预读有关  
</p>

<ol class="org-ol">
<li>MADV_NORMAL</li>

<li>MADV_RANDOM</li>

<li>MADV_SEQUENTIAL</li>
</ol>

<p>
这几个 advice 与 vma 的 flags 对应
</p></li>

<li>和 vma 的 VM_DONTCOPY flag 对应

<ol class="org-ol">
<li>MADV_DONTFORK</li>

<li>MADV_DOFORK</li>
</ol></li>

<li>和 coredump 有关

<ol class="org-ol">
<li>MADV_DONTDUMP</li>

<li>MADV_DODUMP</li>
</ol></li>

<li><p>
和 PFRA 有关
</p>

<ol class="org-ol">
<li>MADV_WILLNEED</li>

<li>MADV_DONTNEED</li>
</ol>

<p>
应用的一些 memory trim 的过程通过会通过设置 MADV_DONTNEED 使 kernel
回收不需要的内存以达到 trim 的目的.
</p></li>
</ol>
</div>
</div>

<div id="outline-container-org40f0f4e" class="outline-5">
<h5 id="org40f0f4e"><span class="section-number-5">1.3.6.2</span> mprotect</h5>
<div class="outline-text-5" id="text-1-3-6-2">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">sys_mprotect</span> (start, len, prot):
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">start &#38656;&#35201;&#19982; 4K &#23545;&#40784;</span>
  <span style="font-weight: bold;">if</span> (start &amp; ~PAGE_MASK):
    <span style="font-weight: bold;">return</span> -EINVAL;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">len &#20063;&#38656;&#35201;&#19982; 4K &#23545;&#40784;</span>
  len = PAGE_ALIGN(len);
  end = start + len;

  vm_flags = calc_vm_prot_bits(prot);
  vma = find_vma_prev(current-&gt;mm, start, &amp;prev);
  <span style="font-weight: bold;">for</span> (nstart = start ; ; ):
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26032;&#30340; vma flag</span>
    newflags = vm_flags | (vma-&gt;vm_flags &amp; ~(VM_READ | VM_WRITE | VM_EXEC));
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">mprotect &#30340; (start, len) &#21487;&#33021;&#36328;&#36807;&#22810;&#20010; vma, &#25152;&#20197;&#36825;&#37324;&#38656;&#35201;&#22312;&#19968;&#20010;&#24490;&#29615;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37324;&#21435;&#22788;&#29702;&#25152;&#26377;&#28041;&#21450;&#30340; vma    </span>
    tmp = vma-&gt;vm_end;
    <span style="font-weight: bold;">if</span> (tmp &gt; end):
      tmp = end;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">mprotect_fixup &#38656;&#35201;&#23436;&#25104;&#20197;&#19979;&#20219;&#21153;:</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">1. &#35774;&#32622; vma &#30340; flags</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">2. &#35774;&#32622;&#30456;&#24212;&#30340; page &#30340; flag</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">3. &#23545; vma &#36827;&#34892;&#21512;&#24182;&#25110;&#25286;&#20998;    </span>
    <span style="font-weight: bold;">mprotect_fixup</span>(vma, &amp;prev, nstart, tmp, newflags);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20934;&#22791;&#22788;&#29702;&#19979;&#19968;&#20010; vma, &#36825;&#37324;&#30340; prev &#20195;&#34920;&#24403;&#21069;&#24050;&#32463;&#22788;&#29702;&#36807;&#30340; vma    </span>
    nstart = tmp;
    <span style="font-weight: bold;">if</span> (nstart &lt; prev-&gt;vm_end)
      nstart = prev-&gt;vm_end;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25152;&#26377; vma &#37117;&#22788;&#29702;&#23436;&#27605;, &#36820;&#22238;</span>
    <span style="font-weight: bold;">if</span> (nstart &gt;= end):
      <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">out</span>;
    vma = prev-&gt;vm_next;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">mprotect_fixup</span>(vma, &amp;prev, nstart, tmp, newflags):
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">vma &#26159;&#24403;&#38656;&#35201;&#22788;&#29702;&#30340; vma, (nstart, tmp) &#34920;&#31034;&#22320;&#22336;&#33539;&#22260;, newflags &#34920;&#31034;&#26032;&#30340; flag</span>
  oldflags = vma-&gt;vm_flags;
  nrpages = (end - start) &gt;&gt; PAGE_SHIFT;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24403;&#21069; vma &#19981;&#38656;&#35201;&#25913;&#21464;, &#36890;&#36807;&#23558; pprev &#35774;&#32622;&#20026; vma &#20351;&#24471;&#21518;&#38754;&#32487;&#32493;&#22788;&#29702; vma-&gt;next</span>
  <span style="font-weight: bold;">if</span> (newflags == oldflags):
    *pprev = vma;
    <span style="font-weight: bold;">return</span> 0;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26681;&#25454; newflags &#35745;&#31639; PTE &#23545;&#24212;&#30340;&#26435;&#38480;&#20301;    </span>
  newprot = protection_map[newflags &amp; 0xf];
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#39318;&#20808;, &#23581;&#35797;&#19982;&#21069;&#21518; vma &#21512;&#24182;  </span>
  pgoff = vma-&gt;vm_pgoff + ((start - vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT);
  *pprev = vma_merge(mm, *pprev, start, end, newflags, vma-&gt;anon_vma, vma-&gt;vm_file, pgoff, vma_policy(vma));

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25286;&#20998; vma, &#22240;&#20026; (start, end) &#24182;&#19981;&#23545;&#24212;&#25972;&#20010; vma  </span>
  <span style="font-weight: bold;">if</span> (start != vma-&gt;vm_start):
    split_vma(mm, vma, start, 1);

  <span style="font-weight: bold;">if</span> (end != vma-&gt;vm_end):
    split_vma(mm, vma, end, 0);

  *pprev = vma;

  vma-&gt;vm_flags = newflags;
  vma-&gt;vm_page_prot = newprot;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20462;&#25913; PTE &#30340; &#26435;&#38480;&#20301;</span>
  <span style="font-weight: bold;">change_protection</span>(vma, start, end, newprot);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdd8c43d" class="outline-5">
<h5 id="orgdd8c43d"><span class="section-number-5">1.3.6.3</span> mlock</h5>
</div>

<div id="outline-container-org0678cea" class="outline-5">
<h5 id="org0678cea"><span class="section-number-5">1.3.6.4</span> mlockall</h5>
</div>

<div id="outline-container-org02cf796" class="outline-5">
<h5 id="org02cf796"><span class="section-number-5">1.3.6.5</span> prctl</h5>
</div>
</div>
</div>

<div id="outline-container-org0d2bfaf" class="outline-3">
<h3 id="org0d2bfaf"><span class="section-number-3">1.4</span> 页面回收</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-orgafdab97" class="outline-4">
<h4 id="orgafdab97"><span class="section-number-4">1.4.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
页面回收算法 (Page Frame Reclaiming Algorithm, PFRA) 的目标是选择一个 none-free page
frame 交还给 buddy system 以实现 page 的回收.
</p>

<p>
page frame, 根据它们的内容和用法, 分为以下几类:
</p>

<ol class="org-ol">
<li><p>
Unreclaimalbe
</p>

<p>
不可回收的 page, 具体包括:
</p>

<ol class="org-ol">
<li><p>
free pages
</p>

<p>
本身已经受 buddy system 管理的 page
</p></li>

<li>PG_reserved</li>

<li>PG_slab</li>

<li>PG_locked</li>

<li>VM_LOCKED (mlock)</li>
</ol></li>

<li>Swappable

<ol class="org-ol">
<li>Anonymous mapped pages of user space</li>

<li>tmpfs</li>
</ol></li>

<li>Syncable

<ol class="org-ol">
<li>File mapped pages of user space (page cache, 包括 device file 的
buffer pages)</li>

<li>inode cache, &#x2026;</li>
</ol></li>

<li>Discardable

<ol class="org-ol">
<li>空闲的 slab</li>

<li>空闲的 dentry cache</li>

<li>&#x2026;</li>
</ol></li>
</ol>

<p>
PFRA 可以回收的 page frame 是 2,3,4 类, 这几类也可以按另一种标准分为:
</p>

<ol class="org-ol">
<li><p>
user mode address space
</p>

<p>
user mode 可以使用的 page, 即 page-&gt;_mapcount &gt;= 0 的部分, 包括
anonymous 和一部分映射到 user mode 的 page cache
</p></li>

<li><p>
page cache
</p>

<p>
还有大多数 page cache 没有映射到 user mode
</p></li>

<li><p>
disk cache
</p>

<p>
inode cache
</p></li>

<li><p>
memory cache
</p>

<p>
slab
</p></li>
</ol>

<p>
PFRA 在选择 victim page 时, 需要综合考虑以下几点:
</p>

<ol class="org-ol">
<li>考虑优先选择哪类 page frame: swappable, syncable, discardable &#x2026;</li>

<li>考虑根据 page 的 aging (LRU) 选择一个 page</li>

<li>考虑 page 的某些状态, 例如, 对于 syncable page, non-dirty 比 dirty
page 应该优先</li>
</ol>
</div>
</div>

<div id="outline-container-org8b59652" class="outline-4">
<h4 id="org8b59652"><span class="section-number-4">1.4.2</span> 反向映射</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
反向映射 (reversed mapping) 是指: 通过 PFRA 算法选择了一个 victim page
后, 如果这个 page 属于 file mapped page, 除了将这个 page 交还给 buddy
system 变成 free page 外, 还需要将引用这个 victim page 的所有 PTE 重置
为 0, 如果这个 page 属于 anonymous page, 则需要将 PTE 置为 swap
identifier. 问题是, 如何根据 victim page 找到所有指向它的 PTE?
</p>

<p>
最简单的方法也许可以这样: 在 page descriptor 中维护一个 list_head, 所
有相关的 PTE 都保存在这个 list 中.
</p>

<p>
对每个 page descriptor 都维护一个 list 可以代价太高, linux 的作法是对
page descriptor 做某种聚合: 一类 page descriptor 相关的 PTE 用同一个数
据结构来描述.
</p>
</div>

<div id="outline-container-orgfbda5cb" class="outline-5">
<h5 id="orgfbda5cb"><span class="section-number-5">1.4.2.1</span> Anonymous Pages</h5>
<div class="outline-text-5" id="text-1-4-2-1">
<p>
对于 anonymous page, linux 使用的方法和前面描述的 "最简单方法" 类似:
page descriptor 中有一个称为 anon_vma 的 list_head. 但 list 中的成员并
不是 PTE, 而是 vm_area_struct.
</p>
</div>

<div id="outline-container-org7ff10f7" class="outline-6">
<h6 id="org7ff10f7"><span class="section-number-6">1.4.2.1.1</span> Overview</h6>
<div class="outline-text-6" id="text-1-4-2-1-1">
<p>
Anonymous pages 可能会有多个 PTE 指向的它, 最常见的情形是 fork: fork
时的复制了一块 vma, 则在父子进程中这块 vma 对应的 PTE 指向相同的
anonymous page.
</p>

<p>
随着不断的 fork, 最初的 vma 在不同的进程会有多份拷贝, linux 的作法是
</p>

<ol class="org-ol">
<li>将所有这些 vma 的拷贝放在一个 list 中</li>

<li>将这些 vma 引用的所有 page (包括后续 COW 分配的新 page) 聚合在一起:
这些 page 的 anon_vma 指向同一个 list_head, 这个 list_head 指向前面
提到的 list</li>

<li>当 linux 要释放某个 victim page 时, 通过 page-&gt;anon_vma 找到所有相
关的 vma, 根据 (vma-&gt;vm_mm-&gt;pgd, vma-&gt;vm_start, page-&gt;index) 可以找
到对应的 PTE</li>
</ol>


<p>
相关的数据结构:
</p>

<ol class="org-ol">
<li>page-&gt;anon_vma</li>

<li>page-&gt;mapping</li>

<li>page-&gt;index</li>

<li>vm_area_struct-&gt;anon_vma</li>

<li>vm_area_struct-&gt;vm_start</li>

<li>vm_area_struct-&gt;vm_mm-&gt;pgd</li>
</ol>



<div id="org6acc5f8" class="figure">
<p><img src="../extra/kernel_rmap_anonymous.png" alt="kernel_rmap_anonymous.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org5b26582" class="outline-6">
<h6 id="org5b26582"><span class="section-number-6">1.4.2.1.2</span> when Demanding Page</h6>
<div class="outline-text-6" id="text-1-4-2-1-2">
<p>
Demanding page 时将 page 的 anon_vma 指向 vma-&gt;anon_vma, 若有需要, 会
分配 anon_vma, 初始化 list_head.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">handle_pte_fault</span>:
  <span style="font-weight: bold;">if</span> (!pte_present(entry)):
    do_no_page();
      <span style="font-weight: bold;">if</span> (!vma-&gt;vm_ops || !vma-&gt;vm_ops-&gt;nopage):
        do_anonymous_page(mm, vma, page_table, pmd, write_access, address);
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">1. get anon_vma from vma-&gt;anon_vma &#25110; allocate one anon_vma</span>
          <span style="font-weight: bold;">anon_vma_prepare</span>(vma)
            <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">anon_vma</span> *<span style="font-weight: bold; font-style: italic;">anon_vma</span> = vma-&gt;anon_vma;
            <span style="font-weight: bold;">if</span> (unlikely(!anon_vma)):
              anon_vma = anon_vma_alloc();
              vma-&gt;anon_vma = anon_vma;
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">2. allocate page, &#24182;&#19988;&#20250; zeroed</span>
          page = alloc_zeroed_user_highpage(vma, addr);
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">3. set page-&gt;anon_vma</span>
          <span style="font-weight: bold;">page_add_anon_rmap</span>(page, vma, addr);
            <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24403; page &#26159; anonymous page (&#32780;&#38750; file mapped page) &#26102;,</span>
            <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">page-&gt;index &#26159;&#25351; page &#30456;&#23545;&#20110; vma &#36215;&#22987;&#22320;&#22336;&#20559;&#31227;&#22810;&#23569;&#20010; page</span>
            <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">shift, page-&gt;mapping &#25351;&#21521; anon_vma. &#21518;&#38754;&#36890;&#36807;&#36825;&#20004;&#20010;&#20540;,&#21487;</span>
            <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20197;&#25214;&#21040; page &#23545;&#24212;&#30340; pte</span>
            page-&gt;index = index;
            page-&gt;mapping = (<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">address_space</span> *) anon_vma;
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">4. set pte</span>
          <span style="font-weight: bold;">set_pte</span>(page_table, entry);
</pre>
</div>
</div>
</div>

<div id="outline-container-orga385c60" class="outline-6">
<h6 id="orga385c60"><span class="section-number-6">1.4.2.1.3</span> When Fork</h6>
<div class="outline-text-6" id="text-1-4-2-1-3">
<p>
fork 时会将新的 vma 加到 anon_vma 指示的 list 中
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">do_fork</span>:
  <span style="font-weight: bold;">copy_process</span>()
    <span style="font-weight: bold;">copy_mm</span>()
      <span style="font-weight: bold;">dup_mmap</span>(mm, oldmm);
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">for each vma</span>
        <span style="font-weight: bold;">for</span> (mpnt = current-&gt;mm-&gt;mmap ; mpnt ; mpnt = mpnt-&gt;vm_next):
          new_vma = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">copy the vma, so as to vma-&gt;anon_vma</span>
          *new_vma = *mpnt;
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">add to forked vma to anon_vma list</span>
          <span style="font-weight: bold;">anon_vma_link</span>(new_vma);
            <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">anon_vma</span> *<span style="font-weight: bold; font-style: italic;">anon_vma</span> = vma-&gt;anon_vma;
            list_add(&amp;vma-&gt;anon_vma_node, &amp;anon_vma-&gt;head);
</pre>
</div>
</div>
</div>

<div id="outline-container-org0123303" class="outline-6">
<h6 id="org0123303"><span class="section-number-6">1.4.2.1.4</span> When Copy on Write</h6>
<div class="outline-text-6" id="text-1-4-2-1-4">
<p>
除了 demanding page, COW 时也会将 page 的 anon_vma 指向 vma-&gt;anon_vma
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">handle_pte_fault</span>:
  <span style="font-weight: bold;">do_wp_page</span>(mm, vma, address, pte, pmd, entry);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#24182;&#19981;&#20250;&#20998;&#37197;&#26032;&#30340; anon_vma, &#22240;&#20026;&#24403;&#21069; vma &#26159;&#20043;&#21069; fork &#26102;&#22797;&#21046;&#32780;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26469;&#30340;, vma-&gt;anon_vma &#19982; parent process &#20013; vma-&gt;anon_vma &#30456;&#21516;</span>
    <span style="font-weight: bold;">anon_vma_prepare</span>(vma)
    <span style="font-weight: bold;">alloc_zeroed_user_highpage</span>(vma, address);
    <span style="font-weight: bold;">page_add_anon_rmap</span>(new_page, vma, address);
</pre>
</div>

<p>
基本上 do_wp_page 和 do_anonymous_page 差不多, 比较奇怪的是 COW 新分配
的 new_page 的 anon_vma 被设置为 old_page 的 anon_vma, 即如果将来要回
收这个 new_page, 扫描其 anon_vma 时会遍历到那些 "旧的" vma, 显然这些旧
的 vma 的 pte 并不会指向这个 new_page: 它们都是指向 old_page 的.
</p>

<p>
感觉 new_page 不应该使用 old_page 的 anon_vma 而应该新分配一个
anon_vma? 由于 page 的 anon_vma 与 vma-&gt;anon_vma 必须是一致的, 则新进
程的 vma 的 anon_vma 也需要设为新的 anon_vma, 考虑下面这种情况:
</p>

<ol class="org-ol">
<li>A fork B, vma_A-&gt;anon_vma 链表中有两项 (vma_A,vma_B)</li>

<li>B COW 一个 new_page, 假设新生成一个 anon_vma 为 vma_B-&gt;anon_vma</li>

<li>B fork C, vma_B-&gt;anon_vma 链表会有两项 (vma_B, vma_C),
vma_A-&gt;anon_vma 还有原来的两项 (vma_A, vma_B)</li>

<li>如果此时回收 vma<sub>A,B,C</sub> 中某一个公共的 page, 则只会扫描到
vma<sub>A,B</sub> (实际需要扫描到 vma<sub>A,B,C</sub>), 因为这个 page 的 anon_vma
是指向 vma_A-&gt;anon_vma 的. 如果此时要回收 new_page, 则 vma<sub>B,C</sub> 会
扫描到, 这倒是正常的</li>
</ol>

<p>
为了应对 4 中的异常情况, 需要 B COW new_page 时将 new_page 的 anon_vma
指向最初 vma_A-&gt;anon_vma 且不修改 vma_B-&gt;anon_vma. 这也就是最初描述的:
"将这些 vma 引用的所有 page (包括后续 COW 分配的新 page) 聚合在一起"的
原因. anon_vma 是一个比 "实际" 范围更大的并集.
</p>
</div>
</div>
</div>

<div id="outline-container-orgdce8cbe" class="outline-5">
<h5 id="orgdce8cbe"><span class="section-number-5">1.4.2.2</span> file mapped pages</h5>
<div class="outline-text-5" id="text-1-4-2-2">
<p>
基于 anon_vma 链表的 reversed mapping 不适用于 file mapping pages.
</p>

<p>
由于前面提到的基于 anon_vma 的一个主要性质是 "同一个 vma 所有的 page
聚合在一起", 而 file mapping 可以有重叠, 这会导致所有重叠的 vma 的所有
page 都会聚合在一起, 导致 anon_vma 链接会是一个巨大的并集, 扫描效率会
很差.
</p>

<p>
因为, file mapped pages 使用了另一种聚合的方法: 基于 address_space 上
的 PST (Priority Search Tree) 树的聚合方式.
</p>

<p>
针对每个文件(或 address_space) 有一棵 PST 树, 树上的节点是映射了这个文
件的 vma, 通过 PST 树可以做到:
</p>

<p>
给定一段 interval (start, end), 能很快的查找到所有包含这段 interval 的
VMA
</p>
</div>
</div>

<div id="outline-container-org47dc473" class="outline-5">
<h5 id="org47dc473"><span class="section-number-5">1.4.2.3</span> try_to_unmap</h5>
</div>
</div>

<div id="outline-container-org25ed659" class="outline-4">
<h4 id="org25ed659"><span class="section-number-4">1.4.3</span> PFRA 的实现</h4>
<div class="outline-text-4" id="text-1-4-3">

<div id="org91f402b" class="figure">
<p><img src="../extra/kernel_pfra.png" alt="kernel_pfra.png" />
</p>
</div>
</div>


<div id="outline-container-org8d55649" class="outline-5">
<h5 id="org8d55649"><span class="section-number-5">1.4.3.1</span> LRU</h5>
<div class="outline-text-5" id="text-1-4-3-1">
<p>
PFRA 能回收的 page frame 中, user mode address space 占了绝大部分.
Linux 使用 LRU 机制来决定这部分 page 中哪些会被回收.
</p>
</div>

<div id="outline-container-org13045df" class="outline-6">
<h6 id="org13045df"><span class="section-number-6">1.4.3.1.1</span> 相关数据结构</h6>
<div class="outline-text-6" id="text-1-4-3-1-1">
<ol class="org-ol">
<li><p>
zone
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">zone</span> {
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">list_head</span>       <span style="font-weight: bold; font-style: italic;">active_list</span>;
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">list_head</span>       <span style="font-weight: bold; font-style: italic;">inactive_list</span>;
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span>          <span style="font-weight: bold; font-style: italic;">nr_scan_active</span>;
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span>          <span style="font-weight: bold; font-style: italic;">nr_scan_inactive</span>;
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span>          <span style="font-weight: bold; font-style: italic;">nr_active</span>;
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span>          <span style="font-weight: bold; font-style: italic;">nr_inactive</span>;
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span>          <span style="font-weight: bold; font-style: italic;">pages_scanned</span>;
}
</pre>
</div></li>

<li><p>
page
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">page</span> {
    <span style="font-weight: bold; text-decoration: underline;">page_flags_t</span> <span style="font-weight: bold; font-style: italic;">flags</span>;
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">list_head</span> <span style="font-weight: bold; font-style: italic;">lru</span>;
}
</pre>
</div></li>

<li><p>
page flags
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">#define</span> <span style="font-weight: bold; font-style: italic;">PG_lru</span>                   5
<span style="font-weight: bold;">#define</span> <span style="font-weight: bold; font-style: italic;">PG_referenced</span>            2
<span style="font-weight: bold;">#define</span> <span style="font-weight: bold; font-style: italic;">PG_active</span>                6
</pre>
</div></li>
</ol>
</div>
</div>

<div id="outline-container-org5b26495" class="outline-6">
<h6 id="org5b26495"><span class="section-number-6">1.4.3.1.2</span> Overview</h6>
<div class="outline-text-6" id="text-1-4-3-1-2">
<p>
zone 中已经分配的 page 中的一部分 (user mode address space 及 page
cache) 被组织在两个不相关的链表中: active_list 和 inactive_list
</p>

<p>
当 page 被 "访问" 时, PFRA 会将 page 移动到 active_list, 当 page 一段
时间没有被 "访问" 时, PFRA 会将它移到到 inactive_list, 当需要进行
reclaim 时, PFRA 会从 inactive_list 中找一个 victim.
</p>

<p>
所有被 active_list 和 inactive_list 管理的 page 的 PG_lru flag 会置位,
同时, 如果 page 属于 active_list, 则它的 PG_active 也会置位.
</p>

<p>
另外, 还存在一个 PG_referenced flag, 当 page 被访问时, 并不是直接将它
放在 active_list, 而是先检查 PG_referenced, 如果已经置位, 则 clear
PG_referenced, 同时将 page 放到 active_list, 否则, 仅仅将 PG_referenced
置位, 而不放在 active_list 中. 通过 PG_referenced, 实现了某种缓冲的效
果.
</p>

<p>
下图展示了 PG_active, PG_referenced 的转换.
</p>


<div id="org541d362" class="figure">
<p><img src="../extra/kernel_pfra_lru.png" alt="kernel_pfra_lru.png" />
</p>
</div>

<p>
图中提到的几个函数:
</p>

<ol class="org-ol">
<li>lru_cache_add</li>

<li>lru_cache_add_active</li>

<li>mark_page_accessed</li>

<li>page_referenced</li>

<li>refill_inactive_zone</li>
</ol>

<p>
是实现 active_list 与 inactive_list 转换的关键.
</p>
</div>
</div>

<div id="outline-container-org68d8d56" class="outline-6">
<h6 id="org68d8d56"><span class="section-number-6">1.4.3.1.3</span> lru_cache_add / lru_cache_add_active</h6>
<div class="outline-text-6" id="text-1-4-3-1-3">
<p>
这两个函数决定了 zone 中已分配的 page 中哪些是受 LRU 管理的, 简单的说:
</p>

<ol class="org-ol">
<li>通过 page fault 分配的 user mode address space 会通过
lru_cache_add_active 加入到 active_list</li>

<li>新分配的 page cache 会通过 lru_cache_add 加入到 inactive_list</li>
</ol>
</div>
</div>

<div id="outline-container-org973e5e1" class="outline-6">
<h6 id="org973e5e1"><span class="section-number-6">1.4.3.1.4</span> mark_page_accessed</h6>
<div class="outline-text-6" id="text-1-4-3-1-4">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">mark_page_accessed</span>(<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">page</span> *<span style="font-weight: bold; font-style: italic;">page</span>):
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">1. page &#22312; inactive_list &#19988; PG_referenced == 1, &#21017;&#31227;&#21160; page &#21040;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">active_list &#24182; clear PG_referenced</span>
  <span style="font-weight: bold;">if</span> (!PageActive(page) &amp;&amp; PageReferenced(page) &amp;&amp; PageLRU(page)):
    activate_page(page);
      <span style="font-weight: bold;">del_page_from_inactive_list</span>(zone, <span style="font-weight: bold; text-decoration: underline;">page</span>);
      <span style="font-weight: bold;">SetPageActive</span>(<span style="font-weight: bold; text-decoration: underline;">page</span>);
      <span style="font-weight: bold;">add_page_to_active_list</span>(zone, <span style="font-weight: bold; text-decoration: underline;">page</span>);
    <span style="font-weight: bold;">ClearPageReferenced</span>(<span style="font-weight: bold; text-decoration: underline;">page</span>);
  <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (!PageReferenced(page)):
    SetPageReferenced(page);
</pre>
</div>

<p>
mark_page_accessed 在下面这些情况下被执行:
</p>

<ul class="org-ul">
<li>do_anonymous_page</li>

<li>filemap_nopage</li>

<li>do_generic_file_read</li>

<li>do_swap_page</li>
</ul>

<p>
可见, PFRA 并没有办法做到每次 page 被 "访问" 时都更新 PG_referenced,
例如当 user mode 正常访问了某个地址时 (不涉及到 page fault) kernel 并
没有办法跟踪这次动作来更新 PG_referenced.
</p>
</div>
</div>

<div id="outline-container-orgdc1b3de" class="outline-6">
<h6 id="orgdc1b3de"><span class="section-number-6">1.4.3.1.5</span> page_referenced</h6>
<div class="outline-text-6" id="text-1-4-3-1-5">
<p>
PFRA 扫描时 (refill_inactive_zone) 会用 page_referenced 检查并清除
PG_referenced 和 PTE 的 Accessed flag.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">page_referenced</span>(<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">page</span> *<span style="font-weight: bold; font-style: italic;">page</span>):
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">1. PG_referenced</span>
  <span style="font-weight: bold;">if</span> (TestClearPageReferenced(page)):
    referenced++;
  <span style="font-weight: bold;">if</span> (page_mapped(page) &amp;&amp; page-&gt;mapping):
    <span style="font-weight: bold;">if</span> (PageAnon(page)):
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">2. &#36890;&#36807; reversed mapping &#25214;&#21040;&#25152;&#26377;&#30340; pte, &#26597;&#30475;&#24182;&#28165;&#38500; PTE &#30340;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Accessed flag CPU &#27599;&#27425;&#22312;&#35775;&#38382;&#20869;&#23384;&#26102;&#37117;&#38656;&#35201;&#20808;&#26597;&#25214;&#21040;&#23545;&#24212;&#30340; PTE,</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#26102; CPU &#20250;&#36127;&#36131;&#23558; PTE &#30340; accessed flag &#32622;&#20301;, &#20294; CPU &#19981;&#20250;&#23558;&#23427;&#22797;&#20301;, PFRA &#38656;&#35201;&#36127;&#36131;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22312; page_referenced &#20013;&#23558;&#20854;&#22797;&#20301;</span>
      referenced += page_referenced_anon(page, ignore_token);
    <span style="font-weight: bold;">else</span>:
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">3. &#19982; page_referenced_anon &#31867;&#20284;</span>
      referenced += page_referenced_file(page, ignore_token);
  <span style="font-weight: bold;">return</span> referenced
</pre>
</div>

<p>
若 page_referenced 返回值不为 0, 说明最近 (自上次 page_referenced 调用
以来) 该 page 被 reference 过
</p>
</div>
</div>

<div id="outline-container-orgba83794" class="outline-6">
<h6 id="orgba83794"><span class="section-number-6">1.4.3.1.6</span> refill_inactive_zone</h6>
<div class="outline-text-6" id="text-1-4-3-1-6">
<p>
refill_inactive_zone 是唯一可以将 active_list 中的 page 移动到
inactive_list 的函数, 由于后面 shrink_list 时只会从 inactive_list 中找
victim, 所以 refill_inactive_zone 是 PFRA 中第一个关键的函数.
</p>
</div>

<ol class="org-ol">
<li><a id="org4175540"></a>Swap Tendency<br />
<div class="outline-text-7" id="text-1-4-3-1-6-1">
<p>
PFRA 计算了一个 swap tendency 来决定是否会把 active_list 中的 page 移
动到 inactive_list 中.
</p>

<p>
Swap tendency 的计算方法为:
</p>

<blockquote>
<p>
swap_tendency = maped_ratio / 2 + distress + swappiness
</p>
</blockquote>

<p>
其中:
</p>

<ol class="org-ol">
<li>mapped_ratio 是 user mode address space 占所有内存的比例 (anonymous
<ul class="org-ul">
<li>file mapped), mapped_ratio 越大, 基本表示空闲的 (没有被 user mode
映射) page cache 占用的内存越少</li>
</ul></li>

<li>distress 对应 PFRA 扫描时使用的 prio, PFRA 工作的紧急程度, prio 为 0
时, 表示最紧急, distress 为 100, prio 为 12, 表示不紧急, distress
为 0</li>

<li>swappiness 对应于 /proc/sys/vm/swappiness, 表示是否优先回收 user
mode address space, swappiness 值越小越避免回收 user mode address
space</li>
</ol>

<p>
Swap tendency 的值 &gt;= 100 时, user mode 的 page 才可能被移动到
inactive_list 进而被回收, 所以 swappiness 的值实际的意义是 "PFRA 面临
多大压力时才可以回收 user mode address space"
</p>

<p>
实际上, swap tendency 与 swappiness 的名字是有些歧义的, swap tendency
和 swappiness 代表的 user mode address space 是否被回收, user mode
address space 不仅仅包含和 swap 相关的部分 (anonymous) 还包括 file
mapped, 后者和 swap 并没有什么关系
</p>
</div>
</li>

<li><a id="orga0c7913"></a>refill_inactive_zone<br />
<div class="outline-text-7" id="text-1-4-3-1-6-2">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">refill_inactive_zone</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">sc-&gt;nr_to_scan &#34920;&#31034;&#26368;&#22810; move &#22810;&#23569;&#20010; page &#21040; inactive_list, &#36825;&#30340;&#20540;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26368;&#22823;&#20026; 32 (SWAP_CLUSTER_MAX)</span>
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">nr_pages</span> = sc-&gt;nr_to_scan;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">1. &#20174; active list &#36873;&#25321;&#19968;&#23450;&#25968;&#30446;&#30340; page &#21040;&#20020;&#26102;&#30340; l_hold</span>
  <span style="font-weight: bold;">while</span> (pgscanned &lt; nr_pages &amp;&amp; !list_empty(&amp;zone-&gt;active_list)):
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">lru_to_page &#26159;&#21462; lru &#38142;&#34920;&#20013;&#26368;&#21518;&#19968;&#20010; page</span>
    page = lru_to_page(&amp;zone-&gt;active_list);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558; page &#20174; active_list &#31227;&#38500;</span>
    list_del(&amp;page-&gt;lru);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558; page &#25554;&#20837;&#21040;&#20020;&#26102;&#30340; l_hold &#38142;&#34920;</span>
    list_add(&amp;page-&gt;lru, &amp;l_hold);
    pgscanned++;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26681;&#25454; PFRA &#30340; priority &#35745;&#31639; distress &#20540;</span>
  distress = 100 &gt;&gt; zone-&gt;prev_priority;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35745;&#31639; mapped_ratio</span>
  mapped_ratio = (sc-&gt;nr_mapped * 100) / total_memory;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35745;&#31639; swap_tendency</span>
  swap_tendency = mapped_ratio / 2 + distress + vm_swappiness;
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold;">if</span> (swap_tendency &gt;= 100):
    reclaim_mapped = 1;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">2. &#36941;&#21382; l_hold</span>
  <span style="font-weight: bold;">while</span> (!list_empty(&amp;l_hold)):
    page = lru_to_page(&amp;l_hold);
    list_del(&amp;page-&gt;lru);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">page_mapped &#34920;&#31034; page &#23646;&#20110; user mode, &#21487;&#33021;&#26159; anonymous &#20063;&#21487;&#33021;&#26159;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">file mmaped</span>
    <span style="font-weight: bold;">if</span> (page_mapped(page)):
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#33509; reclaim_mapped &#20026; 0, &#21017;&#25152;&#26377; l_hold &#20013;&#30340; page &#26368;&#32456;&#37117;&#20250;&#34987;&#25918;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22238; active_list, &#26412;&#27425; refill_inactive_zone &#30456;&#24403;&#20110;&#31354;&#25805;&#20316;, &#21518;&#32493;&#37325;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22797;&#30340; refill_inactive_zone &#25805;&#20316;&#30001;&#20110; priority &#21464;&#23567;&#20250;&#23548;&#33268;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">distress &#21464;&#22823;,&#26368;&#32456;&#20250;&#23548;&#33268; reclaim_mapped &#20026; 1.</span>
      <span style="font-weight: bold; font-style: italic;">//</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#33509; reclaim_mapped &#20026; 1, &#34920;&#31034; user mode &#21487;&#20197;&#34987; swap, &#20294;&#20063;&#26377;&#20363;&#22806;:</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">1. &#33509;&#27492;&#26102; page &#26159; anonymous &#20294;&#27809;&#26377; swap space, &#21017;&#36824;&#26159;&#20250;&#34987;&#25918;&#22238;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">active_list.</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">2. &#33509; page_referenced &#20026;&#30495;, &#20063;&#20250;&#34987;&#25918;&#22238; active_list &#19981;&#20250;&#34987;&#22238;&#25910;</span>
      <span style="font-weight: bold;">if</span> (!reclaim_mapped || (total_swap_pages == 0 &amp;&amp; PageAnon(page)) ||
          page_referenced(page, 0, sc-&gt;priority &lt;= 0)):
        list_add(&amp;page-&gt;lru, &amp;l_active);
        <span style="font-weight: bold;">continue</span>;
    list_add(&amp;page-&gt;lru, &amp;l_inactive);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">3. &#23558; l_inactive &#20013;&#30340; page &#31227;&#21160;&#21040; inactive_list</span>
  <span style="font-weight: bold;">while</span> (!list_empty(&amp;l_inactive)):
    page = lru_to_page(&amp;l_inactive);
    list_move(&amp;page-&gt;lru, &amp;zone-&gt;inactive_list);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">4. &#23558; l_active &#20013;&#30340; page &#31227;&#21160;&#21040; active_list</span>
  <span style="font-weight: bold;">while</span> (!list_empty(&amp;l_active)):
    page = lru_to_page(&amp;l_active);
    list_move(&amp;page-&gt;lru, &amp;zone-&gt;active_list);
</pre>
</div>
</div>
</li>

<li><a id="orgad5bf87"></a>通过 refill_inactive_zone 更新 LRU list<br />
<div class="outline-text-7" id="text-1-4-3-1-6-3">
<p>
refill_inactive_zone 的作用, 除了从 active_list 移动一些 page 到
inactive_list 外, 还起到维护 LRU 的作用.
</p>

<p>
当一个 page 被 reference 时, 相关代码并不会修改 (或者根本无法修改, 比
如 PTE accessed flag 导致的 reference) 它们在 LRU list 中的位置, 但进
行 refill_inactive_zone 时, 第一次循环会从 active_list `末尾` 取一定数
量的 page, 第四次循环时又会将不符合条件的 page (例如 page_referenced
或因为 swap tendency 的原因) 放回 active_list `开头`. 通过这种方式, 实
现了 LRU 的更新.
</p>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org58b278e" class="outline-5">
<h5 id="org58b278e"><span class="section-number-5">1.4.3.2</span> Low on Memory Reclaiming: try_to_free_pages</h5>
<div class="outline-text-5" id="text-1-4-3-2">
</div>
<div id="outline-container-org2d030df" class="outline-6">
<h6 id="org2d030df"><span class="section-number-6">1.4.3.2.1</span> Overview</h6>
<div class="outline-text-6" id="text-1-4-3-2-1">
<p>
try_to_free_pages 是 `low on memory` page reclaim 主要的入口, 它会重复
的调用 shrink_caches 和 shrink_slab, 并且每次循环使用更高的优先级 (12
-&gt; 0), 直到释放了 32 个 page 为止, 若 13 次循环后还是没有成功, 返回 0,
上层调用者 (例如 __alloc_pages) 会调用 out_of_memory
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">try_to_free_pages</span>:
  <span style="font-weight: bold;">for</span> (priority = DEF_PRIORITY; priority &gt;= 0; priority--):
    sc.nr_reclaimed = 0;
    sc.priority = priority;
    <span style="font-weight: bold;">shrink_caches</span>(zones, &amp;sc);
      <span style="font-weight: bold;">shrink_zone</span>(zone)
        <span style="font-weight: bold;">refill_inactive_zone</span>(zone, sc);
        <span style="font-weight: bold;">shrink_cache</span>(zone, sc);
          shrink_list(&amp;page_list, sc)
    <span style="font-weight: bold;">shrink_slab</span>(sc.nr_scanned, gfp_mask, lru_pages);
    <span style="font-weight: bold;">if</span> (sc.nr_reclaimed &gt;= SWAP_CLUSTER_MAX):
      <span style="font-weight: bold;">return</span> 1
  <span style="font-weight: bold;">return</span> 0
</pre>
</div>
</div>
</div>

<div id="outline-container-org81f8c7b" class="outline-6">
<h6 id="org81f8c7b"><span class="section-number-6">1.4.3.2.2</span> shrink_list</h6>
<div class="outline-text-6" id="text-1-4-3-2-2">
<p>
shrink_list 是整个 PFRA 最主要的函数之一, 它的主要工作:
</p>

<ol class="org-ol">
<li>如果是 anonymous page, 通过 add_to_swap, 将其加入 swap cache 中</li>

<li>try_to_unmap, 通过 reversed mapping 修改 PTE 为空或 swap identifier</li>

<li>如果 try_to_unmap 失败 (例如 page 对应的某个 PTE 所在的 vma 是
VM_LOCKED), 则直接返回</li>

<li>若 try_to_unmap 成功, 则

<ol class="org-ol">
<li>若 PageDirty, 则 pageout, 调用 page-&gt;mapping-&gt;writepage</li>

<li>通过 __remove_from_page_cache 将 page 从 page cache 中删除</li>

<li>__pagevec_release_nonlru, 最终会调用 free_pages_bulk 将 page 交还
buddy</li>
</ol></li>
</ol>
</div>
</div>

<div id="outline-container-org20f5498" class="outline-6">
<h6 id="org20f5498"><span class="section-number-6">1.4.3.2.3</span> shrink_slab</h6>
<div class="outline-text-6" id="text-1-4-3-2-3">
</div>
<ol class="org-ol">
<li><a id="orgdf9e6bf"></a>shrink_dcache_memory<br /></li>

<li><a id="orgfb0b277"></a>shrink_icache_memory<br /></li>
</ol>
</div>
</div>

<div id="outline-container-orge86872e" class="outline-5">
<h5 id="orge86872e"><span class="section-number-5">1.4.3.3</span> Periodic Reclaiming: kswapd</h5>
<div class="outline-text-5" id="text-1-4-3-3">
<p>
除了 try_to_free_pages, PFRA 还会通过 kswapd 进行 periodic reclaiming.
</p>

<p>
如前面 <a href="#org9c39e92">alloc_pages</a> 所述, alloc_pages 时如果发现所有 zone 的可用内存都
低于 zone-&gt;page_low, 则会通过 wakeup_kswapd 唤醒 kswapd.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">kswapd</span>:
  <span style="font-weight: bold;">for</span> (;;):
    prepare_to_wait(&amp;pgdat-&gt;kswapd_wait, &amp;wait, TASK_INTERRUPTIBLE);
    <span style="font-weight: bold;">balance_pgdat</span>(pgdat, 0, order);
      <span style="font-weight: bold;">shrink_zone</span>()
      <span style="font-weight: bold;">shrink_slab</span>()
</pre>
</div>
</div>
</div>

<div id="outline-container-org2fcc98d" class="outline-5">
<h5 id="org2fcc98d"><span class="section-number-5">1.4.3.4</span> Swapping</h5>
<div class="outline-text-5" id="text-1-4-3-4">
</div>
<div id="outline-container-org87387a1" class="outline-6">
<h6 id="org87387a1"><span class="section-number-6">1.4.3.4.1</span> Swap Area</h6>
<div class="outline-text-6" id="text-1-4-3-4-1">
<p>
Swap area 即 swap file 或 swap device, linux 可以支持多个 swap area.
</p>

<p>
swap area 的作用类似于一个文件系统: swap area 被分割为大小为 4K 的
page slot. 当 PFRA 需要 swap out 时, 会通过 swap area 分配一个 page
slot, 这个 page slot index 及 swap area 的编号合成一个 swap
identifier, page 的 PTE 会被修改为这个 swap identifier.
</p>


<div id="org5763ecc" class="figure">
<p><img src="../extra/kernel_pfra_swap_identifier.png" alt="kernel_pfra_swap_identifier.png" />
</p>
</div>

<p>
当后面进程需要访问这个 PTE 时, page fault handler 通过 PTE 的值 (实际
就是 swap identifier) 能知道这个 page 已经被 swap out, 它会通过
do_swap_page (swap identifier) 从 swap area 重新加载这个 page
</p>

<p>
PFRA 与 swap area 的主要接口:
</p>

<ol class="org-ol">
<li>swap_readpage</li>

<li>swap_writepage</li>

<li>get_swap_page</li>

<li>swap_free</li>
</ol>
</div>
</div>

<div id="outline-container-org9cfe109" class="outline-6">
<h6 id="org9cfe109"><span class="section-number-6">1.4.3.4.2</span> Swap Cache</h6>
<div class="outline-text-6" id="text-1-4-3-4-2">
<p>
在 shrink_list 时, 通过 add_to_swap 并不是直接将 page 写入 swap area,
而是先将 page 加入 swap cache 中, 然后再写入 swap area. Swap cache 主
要是为了解决同步的问题:
</p>

<p>
如果 page 被 swap out, 其 PTE 已经被修改为 swap identifier, 但 page
A 正在被写入 swap area 的同时某个进程 A 又需要访问这个 page 怎么办? 由于
swap cache 暂存着这个正在写入 swap area 的 page, page fault 可以从
swap cache 中找到这个 page 给进程 A 使用.
</p>

<p>
Swap cache 本质是是一个 page cache:
</p>

<ol class="org-ol">
<li>它对应的 address_space 是 swapper_space</li>

<li>查找 radix_tree 时使用的索引是 swap identifier</li>
</ol>

<p>
shrink_list 将 page swap out 时相当于把 page 加入 swap area 的 page
cache, shrink_list 后续的代码只需要把 swapper_space 做为普通的 page
cache 处理即可, 例如在 pageout 时调用 aosp-&gt;writepage
</p>
</div>
</div>

<div id="outline-container-orge3cd0fc" class="outline-6">
<h6 id="orge3cd0fc"><span class="section-number-6">1.4.3.4.3</span> Swap Out</h6>
<div class="outline-text-6" id="text-1-4-3-4-3">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">shrink_list</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524; page &#26159; anonymous &#19988;&#20043;&#21069;&#24182;&#27809;&#26377;&#21152;&#20837; swap cache,</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21017;&#21152;&#20837; swap cache</span>
  <span style="font-weight: bold;">if</span> (PageAnon(page) &amp;&amp; !PageSwapCache(page)):
    add_to_swap(page)
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22312; swap area &#19978;&#20998;&#37197;&#19968;&#20010; page slot, &#20854;&#20013; entry-&gt;val &#26159;&#36820;&#22238;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#30340; swap identifier</span>
      entry = get_swap_page();
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21152;&#20837; swap cache &#24182;&#26631;&#35760;&#20026; dirty, &#20197;&#20415;&#21518;&#32493;&#30340; pageout &#20250;&#23558;&#23427;&#20889;&#22238;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">swap area</span>
      <span style="font-weight: bold;">__add_to_swap_cache</span>(page, entry, GFP_ATOMIC|__GFP_NOWARN);
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558; page &#21152;&#20837; swapper_space &#25351;&#23450;&#30340; page cache, &#20351;&#29992;&#30340; index &#20026;</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">get_swap_page &#36820;&#22238;&#30340; swap identifier</span>
        radix_tree_insert(&amp;swapper_space.page_tree, entry.val, page);
        <span style="font-weight: bold;">SetPageLocked</span>(page);
        <span style="font-weight: bold;">SetPageSwapCache</span>(page);
        page-&gt;private = entry.val;
      <span style="font-weight: bold;">SetPageDirty</span>(page);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110; anonymous page , page_mapping &#36820;&#22238;&#20540;&#20026; swapper_space</span>
  mapping = page_mapping(page);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20462;&#25913;&#30456;&#20851;&#30340; PTE</span>
  <span style="font-weight: bold;">try_to_unmap</span>(page)
    <span style="font-weight: bold;">if</span> (PageAnon(page)):
      try_to_unmap_anon(page);
        try_to_unmap_one
          <span style="font-weight: bold;">if</span> (PageAnon(page)):
            <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110; anonymous page, PTE &#34987;&#20462;&#25913;&#20026; swap identifier</span>
            swp_entry_t entry = { .val = page-&gt;private };
            <span style="font-weight: bold;">set_pte</span>(pte, <span style="font-weight: bold; text-decoration: underline;">swp_entry_to_pte</span>(<span style="font-weight: bold; font-style: italic;">entry</span>));
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110; anonymous page, page &#24517;&#28982;&#20026; dirty (&#21442;&#32771; add_to_swap)</span>
  <span style="font-weight: bold;">if</span> (PageDirty(page)):
    pageout(page, mapping)
      mapping-&gt;a_ops-&gt;writepage(page, &amp;wbc)
        <span style="font-weight: bold;">swap_writepage</span>()

  <span style="font-weight: bold;">if</span> (PageSwapCache(page)):
    __delete_from_swap_cache(page);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdc2f5c2" class="outline-6">
<h6 id="orgdc2f5c2"><span class="section-number-6">1.4.3.4.4</span> Swap In</h6>
<div class="outline-text-6" id="text-1-4-3-4-4">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">do_swap_page</span>:
  <span style="font-weight: bold; text-decoration: underline;">swp_entry_t</span> <span style="font-weight: bold; font-style: italic;">entry</span> = pte_to_swp_entry(orig_pte);
  page = lookup_swap_cache(entry);
  <span style="font-weight: bold;">if</span> (!page):
    page = read_swap_cache_async(entry, vma, address);
      new_page = alloc_page_vma(GFP_HIGHUSER, vma, addr);
      <span style="font-weight: bold;">add_to_swap_cache</span>(new_page, entry);
      <span style="font-weight: bold;">lru_cache_add_active</span>(new_page);
      swap_readpage(<span style="font-weight: bold; text-decoration: underline;">NULL</span>, new_page);
      <span style="font-weight: bold;">return</span> new_page;
    ret = VM_FAULT_MAJOR;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20462;&#25913; PTE</span>
  pte = mk_pte(page, vma-&gt;vm_page_prot);
  <span style="font-weight: bold;">set_pte</span>(page_table, pte);
  <span style="font-weight: bold;">page_add_anon_rmap</span>(page, vma, address);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org2bfa280" class="outline-5">
<h5 id="org2bfa280"><span class="section-number-5">1.4.3.5</span> Out Of Memory</h5>
<div class="outline-text-5" id="text-1-4-3-5">
<p>
当内存特别紧张时 __alloc_pages 最后会调用 out_of_memory 来杀死某个进程
来释放内存.
</p>

<p>
out_of_memory 的功能称为 oom killer, 它主要的功能是通过
select_bad_process 选择一个 victim, 选择的标准是:
</p>

<ol class="org-ol">
<li>victim 应该占用很多内存, 以便 kill 它会释放很多内存</li>

<li>victim 不应该是一个已经长时间运行的进程</li>

<li>victim 应该有较低的静态优先级</li>

<li>victim 不应该是 root 进程或 kernel thread (swapper, init, &#x2026;)</li>
</ol>
</div>

<div id="outline-container-org015c662" class="outline-6">
<h6 id="org015c662"><span class="section-number-6">1.4.3.5.1</span> badness</h6>
<div class="outline-text-6" id="text-1-4-3-5-1">
</div>

<ol class="org-ol">
<li><a id="org27bed1e"></a>oom_adjust<br /></li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
即使是 32 位 CPU, 其段寄存器也是 16 位
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
地址映射是否存在以及 page 权限是否一致
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
但也有例外, 比如通过 CLONE_VM 创建的进程
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <div class="footpara"><p class="footpara">
通过 page entry 的 User/Supervisor flag 来限制访问, 但这里有一
个例外: vsyscall page 位于 3G 以上 (0xffffe000), 但通过设置 page entry
的 user flag 允许 user mode 访问, 具体参考 
</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5">5</a></sup> <div class="footpara"><p class="footpara">
swapper (或 idle 进程, init_task, 0 号进程) 是一个例外: 它会使
用 swapper_pg_dir 做为 page table
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">

<p class="author">Author: sunway (sunwayforever@gmail.com)<br />
Date: 2016-06-14 Tue 00:00<br />
Last updated: 2022-01-19 Wed 13:25</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。
<br />

<div id="disqus_thread"></div>
<script>

(function() { // DON'T EDIT BELOW THIS LINE
         var d = document, s = d.createElement('script');
         s.src = '//sunwayforever-github-io.disqus.com/embed.js';
         s.setAttribute('data-timestamp', +new Date());
         (d.head || d.body).appendChild(s);
         })();
</script>
</div>
</body>
</html>
