<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-01-25 Tue 18:52 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Linux Kernel: IO</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wei Sun (孙伟)" />
<link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
<link rel = "icon" href = "/icon.png"  type = "image/x-icon">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">Linux Kernel: IO</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org8833734">1. Linux Kernel: IO</a>
<ul>
<li><a href="#orgc6951a1">1.1. Accessing Files</a>
<ul>
<li><a href="#org9ebedba">1.1.1. Reading File</a></li>
<li><a href="#orga511a13">1.1.2. Reading Block Device File</a></li>
<li><a href="#org0df90aa">1.1.3. Writing File</a></li>
<li><a href="#orga2229fa">1.1.4. Writing Dirty Pages</a></li>
<li><a href="#org3fd6eaf">1.1.5. Read ahead</a></li>
<li><a href="#org685ccb6">1.1.6. Memory Mapping</a></li>
</ul>
</li>
<li><a href="#org04340cb">1.2. Architectures</a>
<ul>
<li><a href="#orgfe1dbe2">1.2.1. Page Cache</a></li>
<li><a href="#org511d136">1.2.2. File system</a></li>
<li><a href="#org55571d5">1.2.3. Generic Block Layer</a></li>
<li><a href="#org2252fa2">1.2.4. bdev fs</a></li>
<li><a href="#org05bc2d7">1.2.5. Block Device Driver</a></li>
<li><a href="#org8288734">1.2.6. I/O Architecture</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org8833734" class="outline-2">
<h2 id="org8833734"><span class="section-number-2">1</span> Linux Kernel: IO</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgc6951a1" class="outline-3">
<h3 id="orgc6951a1"><span class="section-number-3">1.1</span> Accessing Files</h3>
<div class="outline-text-3" id="text-1-1">
</div>
<div id="outline-container-org9ebedba" class="outline-4">
<h4 id="org9ebedba"><span class="section-number-4">1.1.1</span> Reading File</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
读文件的最上层入口是 f_op-&gt;read, Linux 提供了一个 generic 的实现叫做
generic_file_read, 如果你想利用 IO architectures 中的其它部分, 例如
Page Cache, Generic Block Layer, IO Scheduler 等的功能, 必须指定
generic_file_read 做为 f_op-&gt;read 的实现.
</p>
</div>

<div id="outline-container-orga433753" class="outline-5">
<h5 id="orga433753"><span class="section-number-5">1.1.1.1</span> VFS</h5>
<div class="outline-text-5" id="text-1-1-1-1">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">generic_file_read</span> (<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">file</span> *<span style="font-weight: bold; font-style: italic;">filp</span>, <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">__user</span> *buf, <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">count</span>, <span style="font-weight: bold; text-decoration: underline;">loff_t</span> *<span style="font-weight: bold; font-style: italic;">ppos</span>):
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">iovec &#35760;&#24405;&#20102;&#26412;&#27425;&#35835;&#25805;&#20316;&#35201;&#22635;&#20805;&#30340; buffer &#21644;&#22823;&#23567;</span>
  <span style="font-weight: bold;">struct</span> iovec local_iov = { .iov_base = buf, .iov_len = count };
  __generic_file_aio_read(&amp;kiocb, &amp;local_iov, 1, ppos);
    <span style="font-weight: bold; text-decoration: underline;">read_descriptor_t</span> <span style="font-weight: bold; font-style: italic;">desc</span>;
    desc.arg.buf = iov[seg].iov_base;
    desc.count = iov[seg].iov_len;
    <span style="font-weight: bold;">do_generic_file_read</span>(filp,ppos,&amp;desc,file_read_actor);
      <span style="font-weight: bold;">do_generic_mapping_read</span>(filp-&gt;f_mapping,&amp;filp-&gt;f_ra,filp,ppos,desc,actor);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc09c75b" class="outline-5">
<h5 id="orgc09c75b"><span class="section-number-5">1.1.1.2</span> Page Cache</h5>
<div class="outline-text-5" id="text-1-1-1-2">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">do_generic_mapping_read</span>(filp-&gt;f_mapping,&amp;filp-&gt;f_ra,filp,ppos,desc,actor);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">ppos &#26159;&#35201;&#35835;&#21462;&#30340; offset (&#23383;&#33410;), index &#26159;&#36825;&#20010; offset &#23545;&#24212;&#30340; page cache &#20013;&#30340;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">page index. page index &#19982; offset &#26159;&#32447;&#24615;&#30340;&#26144;&#23556;&#20851;&#31995;</span>
  index = *ppos &gt;&gt; PAGE_CACHE_SHIFT;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">mapping &#26159; inode-&gt;address_space</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!! &#26597;&#25214; page cache !!</span>
  page = find_get_page(mapping, index);
    <span style="font-weight: bold;">return</span> radix_tree_lookup(&amp;mapping-&gt;page_tree, offset);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!! page cache miss !!</span>
  <span style="font-weight: bold;">if</span> (unlikely(page == <span style="font-weight: bold; text-decoration: underline;">NULL</span>)):
    <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">no_cached_page</span>;
  <span style="font-weight: bold;">else</span>:
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!! page cache hit !!</span>
    <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">page_ok</span>;  

<span style="font-weight: bold; text-decoration: underline;">no_cached_page</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">page cache hit, &#20998;&#37197;&#19968;&#20010;&#26032;&#30340; page, &#21152;&#21040; page cache &#20013;, &#24182; readpage</span>
  cached_page = page_cache_alloc_cold(mapping);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26032; page &#19982; mapping &#30340; index &#20851;&#32852;, &#21152;&#21040; page cache &#20013;</span>
  <span style="font-weight: bold;">add_to_page_cache_lru</span>(cached_page, mapping, index, GFP_KERNEL);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">lock page, readpage &#26159;&#20010;&#24322;&#27493;&#30340;&#35843;&#29992; (dma), do_generic_mapping_read &#38656;&#35201;&#36890;&#36807; lock_page &#38459;&#22622;&#20303;</span>
    <span style="font-weight: bold;">SetPageLocked</span>(page);
  <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">read_page</span>;

<span style="font-weight: bold; text-decoration: underline;">read_page</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">NEXT STAGE</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The read will unlock the page</span>
  mapping-&gt;a_ops-&gt;readpage(filp, page);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22240;&#20026; readpage &#26159;&#24322;&#27493;&#30340;, readpage &#36820;&#22238;&#26102; page &#19968;&#33324;&#26159; !update</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#30340; lock_page &#20250;&#20351;&#20989;&#25968;&#38459;&#22622;&#20303;, &#31561;&#24453;&#24213;&#23618;&#35835;&#25805;&#20316;&#30340;&#32467;&#26463;</span>
  <span style="font-weight: bold;">if</span> (!PageUptodate(page)):
    lock_page(page);
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">TASK_UNINTERRUPTIBLE, &#25152;&#35859;&#30340; D &#29366;&#24577;</span>
      <span style="font-weight: bold;">__wait_on_bit_lock</span>(<span style="font-weight: bold; text-decoration: underline;">page_waitqueue</span>(<span style="font-weight: bold; font-style: italic;">page</span>), &amp;wait, sync_page, TASK_UNINTERRUPTIBLE);
    <span style="font-weight: bold;">unlock_page</span>(page);
  <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">page_ok</span>;

<span style="font-weight: bold; text-decoration: underline;">page_ok</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">actor &#23454;&#38469;&#26159; file_read_actor, &#36127;&#36131;&#23558; page &#30340;&#25968;&#25454;&#22797;&#21046;&#21040; desc, &#21363;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">user space &#30340; buffer &#20013;</span>
  ret = actor(desc, page, offset, nr);
</pre>
</div>
</div>
</div>

<div id="outline-container-org103a024" class="outline-5">
<h5 id="org103a024"><span class="section-number-5">1.1.1.3</span> File System</h5>
<div class="outline-text-5" id="text-1-1-1-3">
<p>
a_ops-&gt;readpage 是和具体文件系统打交道的函数, 它的作用是真正从设备读取
一个 page.
</p>

<p>
但与 generic_file_read 类似, VFS 也提供了一个通用的函数, 比如
mpage_readpage 或 block_read_full_page.
</p>

<p>
有了这些函数, 具体文件系统不再需要考虑如何和下一层的 Generic Block
Layer 打交道, 它们只需要实现几个回调即可, 比如 get_block
</p>

<p>
以 ext2 为例, 它定义的 readpage 为:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">ext2_readpage</span>(<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">file</span> *<span style="font-weight: bold; font-style: italic;">file</span>, <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">page</span> *<span style="font-weight: bold; font-style: italic;">page</span>) {
    <span style="font-weight: bold;">return</span> mpage_readpage(page, ext2_get_block);
}
</pre>
</div>

<p>
其中的 ext2_get_block 是 get_block 回调, 这个函数是和具体文件系统相关
的, 它的作用是将 readpage 传过来的 block_in_file 映射为 logical block
(sector_t)
</p>
</div>
</div>

<div id="outline-container-org4bdf9de" class="outline-5">
<h5 id="org4bdf9de"><span class="section-number-5">1.1.1.4</span> Generic Block Layer</h5>
<div class="outline-text-5" id="text-1-1-1-4">
</div>
<ol class="org-ol">
<li><a id="org784e0f1"></a>mpage_readpage<br />
<div class="outline-text-6" id="text-1-1-1-4-1">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">mpage_readpage &#24182;&#19981;&#38656;&#35201; file &#25351;&#38024;, &#22240;&#20026; page &#20013;&#24050;&#32463;&#21253;&#21547;&#20102;&#36275;&#22815;&#30340;&#20449;&#24687;:</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">1. page-&gt;index,  &#34920;&#31034; page &#22312; address_space &#30340; index (&#25110;&#23545;&#24212;&#30340;&#25991;&#20214;&#30340; offset)</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">2. page-&gt;mapping-&gt;host, &#34920;&#31034; page &#23545;&#24212;&#30340; inode</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">inode &#21644; index &#21487;&#20197;&#26631;&#35782;&#26412;&#27425;&#35201;&#35835;&#21462;&#30340;&#20869;&#23481;</span>

<span style="font-weight: bold;">mpage_readpage</span>(<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">page</span> *<span style="font-weight: bold; font-style: italic;">page</span>, <span style="font-weight: bold; text-decoration: underline;">get_block_t</span> <span style="font-weight: bold; font-style: italic;">get_block</span>):
  bio = do_mpage_readpage(bio, page, 1, &amp;last_block_in_bio, get_block);
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">inode</span> *<span style="font-weight: bold; font-style: italic;">inode</span> = page-&gt;mapping-&gt;host;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">PAGE_CACHE_SHIFT &#20026; 12 (4KB), blkbits &#19968;&#33324;&#20026; 9 (512B)</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25152;&#20197; block_in_file = page_index * 8</span>
    block_in_file = page-&gt;index &lt;&lt; (PAGE_CACHE_SHIFT - blkbits);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">blocks_per_page = 4K &gt;&gt; 9 = 8, &#34920;&#31034;&#19968;&#20010; page &#23481;&#32435; 8 &#20010; block (sector)</span>
    blocks_per_page = PAGE_CACHE_SIZE &gt;&gt; blkbits;
    <span style="font-weight: bold;">for</span> (page_block = 0; page_block &lt; blocks_per_page; page_block++, block_in_file++):
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#36825;&#20010; page &#20013;&#30340;&#27599;&#20010; block</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35843;&#29992;&#25991;&#20214;&#31995;&#32479;&#30456;&#20851;&#30340; get_block, &#20197;&#20415;&#24471;&#21040; block_in_file &#19982;&#30495;&#27491;&#30340; sector_t &#30340;&#23545;&#24212;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20851;&#31995;, &#30495;&#27491;&#30340; sector_t &#20445;&#23384;&#22312; bh-&gt;b_blocknr &#20013;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#30340; block_in_file &#21482;&#26159;&#30456;&#24403;&#20110;&#25991;&#20214;&#30340;&#20559;&#31227;&#37327;, &#30495;&#27491;&#30340; logical block (sector_t)</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21482;&#26377;&#25991;&#20214;&#31995;&#32479;&#25165;&#30693;&#36947;   </span>
      get_block(inode, block_in_file, &amp;bh, 0)
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">blocks &#25968;&#32452;&#20445;&#23384;&#30528;&#24490;&#29615;&#36807;&#31243;&#20013;&#23545;&#24212;&#21508;&#20010; block_in_file &#30340; sector_t &#30340;&#20540;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#36825;&#20010;&#25968;&#32452;&#20013;&#30340;&#25968;&#25454;&#19981;&#26159;&#36830;&#32493;&#36882;&#22686;&#30340; (&#20363;&#22914; 23456789 &#26159;&#36830;&#32493;&#36882;&#22686;&#30340;), &#34920;&#31034;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010; page &#30340;&#25968;&#25454;&#22312;&#29289;&#29702;&#35774;&#22791;&#19978;&#19981;&#26159;&#36830;&#32493;&#30340;, &#35843;&#29992; block_read_full_page</span>
      <span style="font-weight: bold;">if</span> (page_block &amp;&amp; blocks[page_block-1] != bh.b_blocknr-1):
        block_read_full_page(page, get_block);
        <span style="font-weight: bold;">return</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#29289;&#29702;&#35774;&#22791;&#19978;&#36830;&#32493;, &#20165;&#26500;&#36896;&#19968;&#20010; BIO</span>
      bio = mpage_alloc(bdev, blocks[0],nr_pages,GFP_KERNEL);
      <span style="font-weight: bold;">bio_add_page</span>(bio, <span style="font-weight: bold; text-decoration: underline;">page</span>, length, 0)
      <span style="font-weight: bold;">mpage_bio_submit</span>(READ, bio);
</pre>
</div>
</div>
</li>

<li><a id="org8b3f623"></a>block_read_full_page<br />
<div class="outline-text-6" id="text-1-1-1-4-2">
<p>
block_read_full_page 与 mpage_readpage 类似, 也是构造相应的 BIO 并提交,
但它并不会像 mpage_readpage 一样尝试用一个 BIO 表示连续的多个 block:
block_read_full_page 对一个 page 会构造 8 个 buffer_head, 然后对每个
buffer_header 构造一个 BIO, 同时 page 会被转换为一个 buffer page.
</p>

<p>
实际上, 具体文件系统中大部分读取 block 的操作 (例如 __bread) 都是采用
类似的方法: 读取单个 block 时构造 buffer_head, submit BIO 并使用一个
buffer page 来 cache 这个 buffer_head.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">block_read_full_page &#19982; mpage_readpage &#31867;&#20284;, &#20294;&#30465;&#21435;&#20102;&#21512;&#24182; bio &#30340;&#36807;&#31243;</span>
<span style="font-weight: bold;">block_read_full_page</span>(<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">page</span> *<span style="font-weight: bold; font-style: italic;">page</span>, <span style="font-weight: bold; text-decoration: underline;">get_block_t</span> *<span style="font-weight: bold; font-style: italic;">get_block</span>):
  <span style="font-weight: bold;">struct</span> inode *inode = page-&gt;mapping-&gt;host;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">block_read_full_page &#32467;&#26463;&#21518;, page &#24517;&#28982;&#20250;&#26159;&#19968;&#20010; buffer page</span>
  <span style="font-weight: bold;">if</span> (!page_has_buffers(page))
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#29983;&#25104; 8 &#20010; buffer_head, &#24182;&#23558; page &#36716;&#25442;&#20026; buffer page</span>
    <span style="font-weight: bold;">create_empty_buffers</span>(<span style="font-weight: bold; text-decoration: underline;">page</span>, blocksize, 0);
  head = page_buffers(page);
  iblock = (<span style="font-weight: bold; text-decoration: underline;">sector_t</span>)page-&gt;index &lt;&lt; (PAGE_CACHE_SHIFT - inode-&gt;i_blkbits);

  <span style="font-weight: bold;">for_each</span> (iblock, bh):
    get_block(inode, iblock, bh, 0)
    <span style="font-weight: bold; text-decoration: underline;">arr</span>[nr++] = bh;

  for_each bh <span style="font-weight: bold; text-decoration: underline;">in</span> <span style="font-weight: bold;">arr</span>:
    submit_bh(READ, bh);
</pre>
</div>
</div>
</li>

<li><a id="org6537ba3"></a>submit_bio<br />
<div class="outline-text-6" id="text-1-1-1-4-3">
<p>
无论是 block_read_full_page 的 submit_bh 或 mpage_read 的
mpage_bio_submit, 最终都会调用到 submit_bio:
</p>

<ol class="org-ol">
<li>对于 submit_bh, 它会将 bio-&gt;bi_end_io 设置为 end_bio_bh_io_sync, 后
者会调用 end_buffer_async_read</li>

<li>对于 mpage_bio_submit, 它会将 bio-&gt;bi_end_io 设置为
mpage_end_io_read</li>
</ol>

<p>
bio-&gt;bi_end_io 都会在底层 IO 结束时被调用, 并且都会 unlock_page 从而唤
醒上层的 do_generic_mapping_read
</p>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-orga511a13" class="outline-4">
<h4 id="orga511a13"><span class="section-number-4">1.1.2</span> Reading Block Device File</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
读取块设备文件时与普通文件有些差别:
</p>

<ol class="org-ol">
<li>get_block 回调使用的是 blkdev_get_block</li>

<li>readpage 使用的是 block_read_full_page 而不是 mpage_readpage</li>
</ol>

<p>
直接读取块设备文件时, 并不需要具体文件系统提供的 Mapping Layer
(get_block), 因为它是和具体文件系统无关的, 实际上, blkdev_get_block 只
是一个 noop 函数, 它将 block index 直接映射为 sector_t
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">blkdev_get_block</span>(<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">inode</span> *<span style="font-weight: bold; font-style: italic;">inode</span>, <span style="font-weight: bold; text-decoration: underline;">sector_t</span> <span style="font-weight: bold; font-style: italic;">iblock</span>, <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">buffer_head</span> *<span style="font-weight: bold; font-style: italic;">bh</span>):
  bh-&gt;b_blocknr = iblock;
</pre>
</div>

<p>
另外, readpage 使用 block_read_full_page (而不是 mpage_readpage), 可能
原因是:
</p>

<p>
具体文件系统通常需要直接读取设备的 block, 例如 super_block,
inode_block 等, 这些操作一般都是通过 __bread (__getblk) 完成, 后者会使
用 buffer page 来 cache 这些 block 对应的 buffer_head. 而且这些 buffer
page 是挂在块设备文件对应的 inode 的 address_space 下的.
</p>

<p>
上层 readpage 使用 block_read_full_page, 可以与底层的 __bread 互通, 在
两者看来, 它们操作的是同一个 inode, 看到的是相同的 buffer page 及
buffer_head
</p>
</div>
</div>

<div id="outline-container-org0df90aa" class="outline-4">
<h4 id="org0df90aa"><span class="section-number-4">1.1.3</span> Writing File</h4>
<div class="outline-text-4" id="text-1-1-3">
</div>
<div id="outline-container-orgc5b7d00" class="outline-5">
<h5 id="orgc5b7d00"><span class="section-number-5">1.1.3.1</span> VFS</h5>
<div class="outline-text-5" id="text-1-1-3-1">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">generic_file_write</span>(<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">file</span> *<span style="font-weight: bold; font-style: italic;">file</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">__user</span> *buf,<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">count</span>, <span style="font-weight: bold; text-decoration: underline;">loff_t</span> *<span style="font-weight: bold; font-style: italic;">ppos</span>):
  __generic_file_write_nolock(file, &amp;local_iov, 1, ppos);
    __generic_file_aio_write_nolock(&amp;kiocb, iov, nr_segs, ppos);
      <span style="font-weight: bold;">generic_file_buffered_write</span>(iocb, iov, nr_segs, pos, ppos, count, written);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd4042c9" class="outline-5">
<h5 id="orgd4042c9"><span class="section-number-5">1.1.3.2</span> Page Cache</h5>
<div class="outline-text-5" id="text-1-1-3-2">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">generic_file_buffered_write</span>(<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">kiocb</span> *<span style="font-weight: bold; font-style: italic;">iocb</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">iovec</span> *<span style="font-weight: bold; font-style: italic;">iov</span>,
                            <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">nr_segs</span>, <span style="font-weight: bold; text-decoration: underline;">loff_t</span> <span style="font-weight: bold; font-style: italic;">pos</span>, <span style="font-weight: bold; text-decoration: underline;">loff_t</span> *<span style="font-weight: bold; font-style: italic;">ppos</span>,
                            <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">count</span>, <span style="font-weight: bold; text-decoration: underline;">ssize_t</span> <span style="font-weight: bold; font-style: italic;">written</span>):
  <span style="font-weight: bold;">struct</span> file *file = iocb-&gt;ki_filp;
  <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">address_space</span> * <span style="font-weight: bold; font-style: italic;">mapping</span> = file-&gt;f_mapping;
  <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">address_space_operations</span> *<span style="font-weight: bold; font-style: italic;">a_ops</span> = mapping-&gt;a_ops;
  <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">inode</span>  *<span style="font-weight: bold; font-style: italic;">inode</span> = mapping-&gt;host;

  index = pos &gt;&gt; PAGE_CACHE_SHIFT;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26597;&#25214; page cache, &#33509;&#19981;&#23384;&#22312;, &#21017;&#26032;&#24314;&#19968;&#20010; page </span>
  page = __grab_cache_page(mapping,index,&amp;cached_page,&amp;lru_pvec);
    page = find_lock_page(mapping, index);
    <span style="font-weight: bold;">if</span> (!page):
      *cached_page = page_cache_alloc(mapping);
      add_to_page_cache(*cached_page, mapping, index, GFP_KERNEL);
    <span style="font-weight: bold;">return</span> *cached_page
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">prepare_write &#19982;&#20855;&#20307;&#25991;&#20214;&#31995;&#32479;&#30456;&#20851;, &#36825;&#20010;&#20989;&#25968;&#36820;&#22238;&#21518;, &#21487;&#20197;&#20445;&#35777;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">page &#20013;&#24050;&#32463;&#26377;&#30456;&#24212;&#30340; buffer_head, &#24182;&#19988; page &#20013;&#24050;&#32463;&#21253;&#21547;&#21407;&#22987;&#30340;&#25968;&#25454;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">(write &#25805;&#20316;&#38656;&#35201;&#22312;&#21407;&#22987;&#25968;&#25454;&#30340;&#22522;&#30784;&#19978;&#36827;&#34892;&#35206;&#30422;)</span>
  a_ops-&gt;prepare_write(file, page, offset, offset+bytes);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25968;&#25454;&#34987;&#20889;&#21040; page</span>
  <span style="font-weight: bold;">filemap_copy_from_user</span>(page, offset, buf, bytes);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26681;&#25454; offset &#21644; size &#30830;&#23450; page &#20013;&#21508;&#20010; buffer_head &#30340;&#29366;&#24577;&#21482;&#26377;&#34987;&#20462;&#25913;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21040;&#30340; buffer_head &#25165;&#20250;&#25913;&#20026; dirty, &#21518;&#32493; sync &#26102;&#21482;&#38656;&#35201; sync &#36825;&#19968;&#20010;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">buffer_head</span>
  a_ops-&gt;commit_write(file, page, offset, offset+bytes);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">balance dirty page (vm_dirty_ratio)</span>
  <span style="font-weight: bold;">balance_dirty_pages_ratelimited</span>()
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#38500;&#38750;&#25351;&#23450;&#20102; O_SYNC &#25110; O_DIRECT, &#21542;&#21017; write &#25805;&#20316;&#22312; commit_write &#23601;&#32467;&#26463;&#20102;,</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#30495;&#27491;&#30340; IO &#25805;&#20316;&#21457;&#29983;&#22312; sync &#26102;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org64e91c2" class="outline-5">
<h5 id="org64e91c2"><span class="section-number-5">1.1.3.3</span> File System</h5>
<div class="outline-text-5" id="text-1-1-3-3">
<p>
与 read 时的 readpage 类似, prepare_write 和 commit_write 是和文件系统
相关的, 但有 VFS 有相应的通用实现, 具体文件系统只需要提供一个 get_block
回调.
</p>
</div>
</div>

<div id="outline-container-org8358415" class="outline-5">
<h5 id="org8358415"><span class="section-number-5">1.1.3.4</span> Generic Block Layer</h5>
<div class="outline-text-5" id="text-1-1-3-4">
</div>
<ol class="org-ol">
<li><a id="orgc7c9467"></a>prepare_write<br />
<div class="outline-text-6" id="text-1-1-3-4-1">
<p>
prepare_write 的主要功能是: 确保 page 是一个 buffer page, 并且保证
page 中已经有对应的原始数据, 所以它的代码与 block_read_full_page 有些
类似.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">block_prepare_write</span>(<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">page</span> *<span style="font-weight: bold; font-style: italic;">page</span>, <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; font-style: italic;">from</span>, <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; font-style: italic;">to</span>, <span style="font-weight: bold; text-decoration: underline;">get_block_t</span> *<span style="font-weight: bold; font-style: italic;">get_block</span>):
  <span style="font-weight: bold;">struct</span> inode *inode = page-&gt;mapping-&gt;host;
  <span style="font-weight: bold;">__block_prepare_write</span>(inode, <span style="font-weight: bold; text-decoration: underline;">page</span>, from, to, get_block);
</pre>
</div>
</div>
</li>

<li><a id="org6708da2"></a>commit_write<br />
<div class="outline-text-6" id="text-1-1-3-4-2">
<p>
commit_write 主要功能是修改 buffer_head 和 page 本身的状态, 以便随后
writepage 时能找到哪些 buffer_head 是 dirty 的.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">__block_commit_write</span>(<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">inode</span> *<span style="font-weight: bold; font-style: italic;">inode</span>, <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">page</span> *<span style="font-weight: bold; font-style: italic;">page</span>, <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; font-style: italic;">from</span>, <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; font-style: italic;">to</span>):
  for_each bh in page_buffers(page):
    unless (block_end &lt;= from || block_start &gt;= to):
      set_buffer_uptodate(bh);
      <span style="font-weight: bold;">mark_buffer_dirty</span>(bh);

</pre>
</div>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-orga2229fa" class="outline-4">
<h4 id="orga2229fa"><span class="section-number-4">1.1.4</span> Writing Dirty Pages</h4>
<div class="outline-text-4" id="text-1-1-4">
</div>
</div>

<div id="outline-container-org3fd6eaf" class="outline-4">
<h4 id="org3fd6eaf"><span class="section-number-4">1.1.5</span> Read ahead</h4>
<div class="outline-text-4" id="text-1-1-5">
<p>
每次调用 do_generic_mapping_read 时, 在查找 page cache 之前, 会通过
page_cache_readahead 尝试进行 read ahead (ra), 具体 page_cache_readahead 的
行为(是否进行 ra, ra 哪些 page 等) 由以下几方面确定:
</p>

<ol class="org-ol">
<li>通过 (ra-&gt;start, ra-&gt;size) 维护一个 current window, 通过
(ra-&gt;ahead_start, ra-&gt;ahead_size) 维护一个 ahead window, 两个
window 是前后连续的</li>

<li>若 read 是对文件开头的读操作, 则通过 get_init_ra_size 计算初始
ra-&gt;size, 其大小与 read 的 size 正相关, 大小从 16 K 到 128K 不等, 并
对 current window 进行 ra</li>

<li>若本次 read 要读取的 page_index = ra-&gt;prev_page + 1, 表示连续的读操
作, 则通过 get_next_ra_size 根据 ra-&gt;size 对 ra-&gt;ahead_size 进行倍
增 (最大 128K), 增大 ahead window, 并对 ahead window 进行 ra</li>

<li>若本次 read 的 page_index 与 ra-&gt;prev_page 不连续, 则重置 ra (例如
ra-&gt;size 置 -1), 但 ra 并不禁用.</li>

<li>若 get_next_ra_size 时发现之前对该文件的读取出现过 page cache miss
(handle_ra_miss), 表示内存可以比较紧张, 则上一步的 get_next_ra_size
会减少 ahead window 的大小 (最小 16K) 而不是倍增</li>

<li>若当前读操作已经超越 current window, 则重置 ahead window 为 current
window, 并通过 get_next_ra_size 分配一个新的(更大的) ahead window</li>

<li>若连续对 256 个 page 的 ra 都因为 page cache hit 没有执行,
则禁用 ra</li>
</ol>
</div>

<div id="outline-container-org2660911" class="outline-5">
<h5 id="org2660911"><span class="section-number-5">1.1.5.1</span> page_cache_readahead</h5>
</div>

<div id="outline-container-orgc65ea63" class="outline-5">
<h5 id="orgc65ea63"><span class="section-number-5">1.1.5.2</span> handle_ra_miss</h5>
</div>

<div id="outline-container-org08f1022" class="outline-5">
<h5 id="org08f1022"><span class="section-number-5">1.1.5.3</span> utils</h5>
<div class="outline-text-5" id="text-1-1-5-3">
<ul class="org-ul">
<li>readahead</li>

<li>posix_fadvise</li>

<li>madvise</li>

<li>blockdev</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org685ccb6" class="outline-4">
<h4 id="org685ccb6"><span class="section-number-4">1.1.6</span> Memory Mapping</h4>
<div class="outline-text-4" id="text-1-1-6">
<p>
refers to 
</p>
</div>

<div id="outline-container-orged353eb" class="outline-5">
<h5 id="orged353eb"><span class="section-number-5">1.1.6.1</span> vm_area_struct</h5>
<div class="outline-text-5" id="text-1-1-6-1">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">vm_area_struct</span> {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">vma &#20013;&#21644; file map &#30456;&#20851;&#30340;&#25104;&#21592;</span>
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">vm_start</span>;
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">rb_node</span> <span style="font-weight: bold; font-style: italic;">vm_rb</span>;
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">vm_operations_struct</span> * <span style="font-weight: bold; font-style: italic;">vm_ops</span>;
    <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; font-style: italic;">vm_pgoff</span>;
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">file</span> * <span style="font-weight: bold; font-style: italic;">vm_file</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">...</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org8b1bf89" class="outline-5">
<h5 id="org8b1bf89"><span class="section-number-5">1.1.6.2</span> filemap_nopage</h5>
<div class="outline-text-5" id="text-1-1-6-2">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23454;&#38469;&#20195;&#30721;&#20013; handle_pte_fault &#23545;&#20110; file mapping &#30340;&#35843;&#29992;&#36335;&#24452;&#26159;</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">do_file_page -&gt; filemap_getpage &#32780;&#19981;&#26159; do_no_page -&gt; filemap_nopage</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20294;&#20004;&#32773;&#20195;&#30721;&#22522;&#26412;&#31867;&#20284;</span>
<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">page</span> * <span style="font-weight: bold;">filemap_nopage</span>(<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">vm_area_struct</span> * <span style="font-weight: bold; font-style: italic;">area</span>, address, <span style="font-weight: bold; text-decoration: underline;">int</span> *<span style="font-weight: bold; font-style: italic;">type</span>):
  <span style="font-weight: bold;">struct</span> file *file = area-&gt;vm_file;
  <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">address_space</span> *<span style="font-weight: bold; font-style: italic;">mapping</span> = file-&gt;f_mapping;
  <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">file_ra_state</span> *<span style="font-weight: bold; font-style: italic;">ra</span> = &amp;file-&gt;f_ra;
  <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">inode</span> *<span style="font-weight: bold; font-style: italic;">inode</span> = mapping-&gt;host;

  pgoff = ((address - area-&gt;vm_start) &gt;&gt; PAGE_CACHE_SHIFT) + area-&gt;vm_pgoff;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">madvise (MADV_SEQUENTIAL)</span>
  <span style="font-weight: bold;">if</span> (VM_SequentialReadHint(area)):
    page_cache_readahead(mapping, ra, file, pgoff, 1);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">some logic related to ra</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">...</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26597;&#25214; page cache</span>
  page = find_get_page(mapping, pgoff);
  <span style="font-weight: bold;">if</span> (!page)
    <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">no_cached_page</span>;
  <span style="font-weight: bold;">else</span>:
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">assume page is updated for simple case</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">return minor fault, since no IO issued</span>
    *type = VM_FAULT_MINOR;
    <span style="font-weight: bold;">return</span> page 

no_cached_page:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20998;&#37197; page cache &#24182; readpage</span>
  page_cache_read(file, pgoff);
    <span style="font-weight: bold;">page_cache_alloc_cold</span>(mapping);
    <span style="font-weight: bold;">add_to_page_cache_lru</span>(<span style="font-weight: bold; text-decoration: underline;">page</span>, mapping, offset, GFP_KERNEL);
    mapping-&gt;a_ops-&gt;readpage(file, page);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">find page cache again, should hit</span>
  page = find_get_page(mapping, pgoff);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">major fault here</span>
  *type = VM_FAULT_MAJOR;
  <span style="font-weight: bold;">return</span> page
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb8a4061" class="outline-5">
<h5 id="orgb8a4061"><span class="section-number-5">1.1.6.3</span> do_page_fault</h5>
<div class="outline-text-5" id="text-1-1-6-3">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">do_page_fault</span>:
  <span style="font-weight: bold;">__asm__</span>(<span style="font-style: italic;">"movl %%cr2,%0"</span>:<span style="font-style: italic;">"=r"</span> (address));
  vma = find_vma(mm, address);
  <span style="font-weight: bold;">switch</span> (handle_mm_fault(mm, vma, address, write)) {
             handle_pte_fault(mm, vma, address, write_access, pte, pmd);
               do_no_page(mm, vma, address, write_access, pte, pmd);
                 new_page = vma-&gt;vm_ops-&gt;nopage(vma, address &amp; PAGE_MASK, &amp;ret);
                   filemap_nopage(vma, address &amp; PAGE_MASK, &amp;ret)
                 entry = mk_pte(new_page, vma-&gt;vm_page_prot);
                 set_pte(page_table, entry);
    <span style="font-weight: bold;">case</span> VM_FAULT_MINOR:
      tsk-&gt;min_flt++;
      <span style="font-weight: bold;">break</span>;
    <span style="font-weight: bold;">case</span> VM_FAULT_MAJOR:
      tsk-&gt;maj_flt++;
      <span style="font-weight: bold;">break</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">case xxx</span>
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org04340cb" class="outline-3">
<h3 id="org04340cb"><span class="section-number-3">1.2</span> Architectures</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-orgfe1dbe2" class="outline-4">
<h4 id="orgfe1dbe2"><span class="section-number-4">1.2.1</span> Page Cache</h4>
</div>

<div id="outline-container-org511d136" class="outline-4">
<h4 id="org511d136"><span class="section-number-4">1.2.2</span> File system</h4>
<div class="outline-text-4" id="text-1-2-2">
</div>
<div id="outline-container-orgd90d302" class="outline-5">
<h5 id="orgd90d302"><span class="section-number-5">1.2.2.1</span> readpage</h5>
</div>

<div id="outline-container-org44212f9" class="outline-5">
<h5 id="org44212f9"><span class="section-number-5">1.2.2.2</span> prepare_write</h5>
</div>

<div id="outline-container-org79f972a" class="outline-5">
<h5 id="org79f972a"><span class="section-number-5">1.2.2.3</span> commit_write</h5>
</div>

<div id="outline-container-org8a70c7f" class="outline-5">
<h5 id="org8a70c7f"><span class="section-number-5">1.2.2.4</span> writepage</h5>
</div>

<div id="outline-container-org36826cc" class="outline-5">
<h5 id="org36826cc"><span class="section-number-5">1.2.2.5</span> getblock</h5>
</div>
</div>

<div id="outline-container-org55571d5" class="outline-4">
<h4 id="org55571d5"><span class="section-number-4">1.2.3</span> Generic Block Layer</h4>
<div class="outline-text-4" id="text-1-2-3">
</div>
<div id="outline-container-orgea2fa13" class="outline-5">
<h5 id="orgea2fa13"><span class="section-number-5">1.2.3.1</span> Data Structure</h5>
<div class="outline-text-5" id="text-1-2-3-1">
</div>
<ol class="org-ol">
<li><a id="org5efaf61"></a>bio<br /></li>

<li><a id="org49195f9"></a>block_device<br /></li>

<li><a id="org4d99ff8"></a>gendisk<br /></li>

<li><a id="org6395c49"></a>request_queue<br /></li>

<li><a id="org4028270"></a>request<br /></li>
</ol>
</div>

<div id="outline-container-orgdfb3d76" class="outline-5">
<h5 id="orgdfb3d76"><span class="section-number-5">1.2.3.2</span> submit_bio</h5>
<div class="outline-text-5" id="text-1-2-3-2">
<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">submit_bio</span>:
  <span style="font-weight: bold;">generic_make_request</span>(bio);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35745;&#31639; bio &#21253;&#25324;&#22810;&#23569;&#20010; sector</span>
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">nr_sectors</span> = bio_sectors(bio);
    q = bdev_get_queue(bio-&gt;bi_bdev);
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">block_device-&gt;gendisk-&gt;request_queue</span>
      <span style="font-weight: bold;">return</span> bdev-&gt;bd_disk-&gt;queue;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#33509; bio-&gt;bi_dev &#25351;&#21521;&#19968;&#20010;&#20998;&#21306;, &#23558; bio-&gt;bi_sector</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36716;&#25442;&#20026;&#30456;&#23545;&#20110; bio-&gt;bi_dev-&gt;bd_contains &#30340; sector</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24182;&#23558; bio-&gt;bi_dev &#21464;&#20026; bio-&gt;bi_dev-&gt;bd_contains</span>
    <span style="font-weight: bold;">blk_partition_remap</span>(bio);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">q-&gt;make_request_fn &#26159;&#22312; block device driver &#21021;&#22987;&#26102;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36890;&#36807; blk_init_queue &#25351;&#23450;&#30340;, &#19968;&#33324;&#40664;&#35748;&#30340;&#23454;&#29616;&#20026; __make_request</span>
    q-&gt;make_request_fn(q, bio);
</pre>
</div>
</div>
</div>

<div id="outline-container-org5588388" class="outline-5">
<h5 id="org5588388"><span class="section-number-5">1.2.3.3</span> IO Scheduler</h5>
<div class="outline-text-5" id="text-1-2-3-3">
</div>
<ol class="org-ol">
<li><a id="org55f2616"></a>driver plug/unplug<br />
<div class="outline-text-6" id="text-1-2-3-3-1">
<p>
IO scheduler 作用是将多个 bio delay 一段时间再统一交给 driver 的
request_fn, 这段 delay 使得 IO scheduler 可以将 bio merger 到某个之前
的 request 中,并实现对这些 request 的排队, 那么 delay 时间有多久?
</p>

<p>
IO scheduler 通过 plug/unplug 机制控制这个 delay:
</p>

<ol class="org-ol">
<li>通过 blk_plug_device 将 device 的 request_queue 设为 plugged 状态,
这时 request_queue 的所有 request 不会被 driver 处理, request_queue
处于等待接受 quest 以便能 merge request 的状态</li>

<li>blk_plug_device 时会启动一个 timer (request_queue-&gt;unplug_timer),
timer 的 delay 为 request_queue-&gt;unplug_delay (3ms). 这个 timer 可
以保证至多 3ms 后 device 会被 unplug, 以便 driver 可以开始处理
request.</li>

<li>若 device 处理 plugged 状态, 但 request_queue 中的 pending request
个数大于 request_queue-&gt;unplug_thresh, 表示当前有足够的 pending
request, 则 device 此时也会被 unplug</li>
</ol>
</div>
</li>

<li><a id="orga592c1e"></a>__make_request<br />
<div class="outline-text-6" id="text-1-2-3-3-2">
<p>
__make_request 是 request_queue-&gt;make_request_fn 的默认实现, 如果
driver 希望使用 IO Scheduler 的功能, 则需要指定 make_request_fn 为 __make_request
</p>

<p>
__make_request 会直接与 IO scheduler 打交道.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">__make_request</span>:
  sector = bio-&gt;bi_sector;
  nr_sectors = bio_sectors(bio);
  <span style="font-weight: bold;">if</span> (elv_queue_empty(q)):
    blk_plug_device(q);
    <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">get_rq</span>;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">req &#20445;&#23384;&#30528; elevator &#36820;&#22238;&#30340;&#32467;&#26524;: elevator &#35748;&#20026; bio &#21487;&#20197;&#19982; req</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">merge &#22312;&#19968;&#36215;&#33267;&#20110;&#20026;&#20160;&#20040; elevator &#35748;&#20026;&#21487;&#20197;&#19982; req merge, &#21442;&#32771;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">elevator &#31639;&#27861;, &#31616;&#21333;&#30340;&#20197; noop elevator &#20026;&#20363;, &#22914;&#26524; elevator &#21457;&#29616;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">bio &#19982;&#26576;&#20010; req &#26159;&#36830;&#32493;&#30340; (&#20363;&#22914; req-&gt;sector + req-&gt;nr_sectors =</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">bio-&gt;bi_sector, &#34920;&#31034; bio &#21487;&#20197; merge &#21040; req &#26411;&#23614;), &#21017;&#35748;&#20026; bio &#19982;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">req &#26159;&#21487;&#20197; merge &#30340;</span>
  el_ret = elv_merge(q, &amp;req, bio);
  <span style="font-weight: bold;">switch</span> (el_ret):
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">bio &#21487;&#20197; merge &#21040; req &#30340;&#26411;&#23614;</span>
    <span style="font-weight: bold;">case</span> ELEVATOR_BACK_MERGE:
      req-&gt;biotail-&gt;bi_next = bio;
      req-&gt;biotail = bio;
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22240;&#20026; bio &#26159; merge &#21040; req &#30340;&#26411;&#23614;, &#25152;&#20197; req-&gt;sector (req &#24320;&#22987;&#30340;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">sector) &#19981;&#21464;</span>
      req-&gt;nr_sectors += nr_sectors;
    <span style="font-weight: bold;">case</span> ELEVATOR_FRONT_MERGE:
      req-&gt;bio = bio;
      req-&gt;sector = sector;
      req-&gt;nr_sectors += nr_sectors;
    <span style="font-weight: bold;">case</span> ELEVATOR_NO_MERGE:
      <span style="font-weight: bold;">break</span>;
<span style="font-weight: bold; text-decoration: underline;">get_rq</span>:
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26080;&#27861; merge, &#29983;&#25104;&#19968;&#20010;&#26032;&#30340; request</span>
    req-&gt;nr_sectors = nr_sectors;
    req-&gt;bio = req-&gt;biotail = bio;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">...</span>
    <span style="font-weight: bold;">add_request</span>(q, req);
      <span style="font-weight: bold;">__elv_add_request</span>()
        q-&gt;elevator-&gt;ops-&gt;elevator_add_req_fn(q, rq, where);
        <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">nrq</span> = q-&gt;rq.count[READ] + q-&gt;rq.count[WRITE] - q-&gt;in_flight;
        <span style="font-weight: bold;">if</span> (nrq == q-&gt;unplug_thresh):
          __generic_unplug_device(q);
            <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">!! DRIVER !!</span>
            q-&gt;request_fn(q);
</pre>
</div>

<p>
总的来说, __make_request 会:
</p>

<ol class="org-ol">
<li>通过 request_queue-&gt;elevator 找到 elevator</li>

<li>调用 elevator 的相关方法 (elv_merge 等), 将 bio 转换为 request 放
在 request_queue 中, 或将 bio merge 到某个已经存在的 request 中.</li>

<li>根据需要 (例如 unplug_thresh) 调用 generic_unplug_device 来通知
driver, 后者会调用 request_fn 来真正启动 IO</li>
</ol>
</div>
</li>

<li><a id="org91881e1"></a>IO scheduler algorithm<br />
<ol class="org-ol">
<li><a id="org66807b0"></a>common purposes<br />
<div class="outline-text-7" id="text-1-2-3-3-3-1">
<ol class="org-ol">
<li>To minimize time wasted by hard disk seeks</li>

<li>To prioritize a certain processes' I/O requests</li>

<li>To give a share of the disk bandwidth to each running process</li>

<li>To guarantee that certain requests will be issued before a particular deadline</li>
</ol>
</div>
</li>

<li><a id="org81e1832"></a>elevator_ops<br />
<div class="outline-text-7" id="text-1-2-3-3-3-2">
<p>
elevator_ops 是各个 elevator 算法需要实现的回调函数. __make_request 时
调用的 elv_queue_empty, elv_merge, elv_add_request, elv_next_request 等
都是对 elevator_ops 相应函数的封装.
</p>

<p>
IO scheduler 是位于 __make_request 与 driver 之间的一层, 两者都需要调
用 elevator_ops 相关的函数, 例如:
</p>

<ol class="org-ol">
<li>__make_request 需要调用 elevator_merge_fn 尝试进行 merge, 调用
elevator_add_req_fn 添加一个新的 request</li>

<li>driver 的 request_fn 需要调用 elevator_next_req_fn 从 request_queue
拿一个 request 进行真正的 IO</li>
</ol>
</div>

<ol class="org-ol">
<li><a id="org6dc1d75"></a>elevator_queue_empty_fn<br /></li>

<li><a id="org5beefb8"></a>elevator_merge_fn<br />
<div class="outline-text-8" id="text-1-2-3-3-3-2-2">
<p>
虽然不同的 elevator 都会实现自己的 elevator_merge_fn, 但实现起来基本都
是差不多的:
</p>

<ol class="org-ol">
<li>尝试 elv_try_last_merge, 看看 request-&gt;last_merge (上次 merge 的
request) 是否也可以满足这次 merge</li>

<li>若不行, 在 request_queue 中找一个可以 merge 的 request</li>
</ol>

<p>
`可以 merge` 的标准是某个 request 与 bio 是连续的 (adjacent).
</p>

<p>
不同的 elevator 的这个"找"的过程会有所区别, 例如 noop 直接是遍历整个
request_queue, deadline 会使用 hash, 而 anticipatory 会使用 rbtree
</p>
</div>
</li>

<li><a id="org2c2a4bc"></a>elevator_add_req_fn<br /></li>

<li><a id="org383fcc8"></a>elevator_next_req_fn<br />
<div class="outline-text-8" id="text-1-2-3-3-3-2-4">
<p>
merge 只是 elevator 的一部分功能, elv_next_request (或
elevator_next_req_fn) 才是 elevator 的主要功能.
</p>

<p>
这部分也是 IO scheduler 被称为 elevator 的原因: 它负责对多个 request 进
行排序以便减少磁盘 seek 的时间, 但与生活中的电梯不同的是, IO scheduler
的功能要简单一些: 它只需要将 request 按照 sector (楼层) 从小到大排序,
并不需要考虑磁头当前的位置 (电梯当前的楼层), 例如, 假设当前有几个
request, 其 sector 分别为: 4 8 10 3, 则 IO scheduler 会将它们排序为 3
4 8 10, 然后从 3 开始操作数据. 而对于真实的电梯来说, 假设电梯此时在 9
层, 则 10 8 4 3 更好一些.
</p>

<p>
为什么 IO scheduler 不考虑磁头的位置并采用简单的按 sector 升序扫描的方
法?
</p>

<p>
磁盘的寻址, 以 CHS 模式为例, 需要定位三个部件:
</p>

<ul class="org-ul">
<li>Cylinder, 柱面</li>

<li>Header, 磁头, 1+2 可以定位 Track, 称为寻道</li>

<li>Sector, 扇区, 1+2+3 可以定位最终的扇区</li>
</ul>

<p>
其中定位 C 和 H 称为寻道, 需要移动磁头, 时间一般为 10ms 左右, 定位 S
称为 latency, 依靠磁盘的旋转, 一般平均为 4ms (以 7200 转/分的硬盘为例,
60*1000/7200/2 = 4ms )
</p>

<p>
以下全是猜的&#x2026;
</p>

<ol class="org-ol">
<li>寻址是一个很慢的过程 (15ms 左右) , 但我认为寻址的速度和距离可能关系
不大, 即磁头 1 -&gt; 2 和 1 -&gt; 10 可能时间是差不多的 (磁头并不需要像电
梯一样 1 -&gt; 2 -&gt; 3 .. -&gt; 10, 而是可以直接 1 -&gt; 10), 所以不需要太在
意初始磁头的位置</li>

<li>一次 IO 的初始扇区定位后, 后续对连续扇区的操作可能只需要旋转磁盘(S)
即可, 不需要寻道 (CH), 将 sector 升序排序可以尽可能的利用这一性质</li>

<li>磁盘片的转动应该是固定一个方向, 所以固定的升序也是必要的.</li>
</ol>

<p>
综上, IO scheduler 采取的直接排序后线性扫描的方式应该也能尽可能的减少
磁盘寻址的次数
</p>

<p>
猜测结束&#x2026;
</p>

<p>
不同的 elevator 的 elevator_next_req_fn 基本都是这种简单的排序, 但各个
elevator 在解决 IO 优先级, 防止 starvation 等方面会有不同. 
</p>
</div>
</li>
</ol>
</li>

<li><a id="orgc713d69"></a>algorithm<br />
<ol class="org-ol">
<li><a id="org2221b19"></a>noop<br />
<ol class="org-ol">
<li><a id="org67c667e"></a>elevator_merge_fn<br /></li>

<li><a id="orga096992"></a>elevator_next_req_fn<br /></li>
</ol>
</li>

<li><a id="org45039cc"></a>deadline<br /></li>

<li><a id="org3ee5e62"></a>CFQ<br />
<ol class="org-ol">
<li><a id="org21675e7"></a>ionice<br /></li>
</ol>
</li>

<li><a id="orga759b7a"></a>anticipatory<br /></li>
</ol>
</li>
</ol>
</li>
</ol>
</div>
</div>

<div id="outline-container-org2252fa2" class="outline-4">
<h4 id="org2252fa2"><span class="section-number-4">1.2.4</span> bdev fs</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
bdev 文件系统是一个很特殊的伪文件系统, 它和其它文件系统一样, 提供了各
种 ops, 但并不会被 mount 到某个 dentry&#x2026;
</p>
</div>

<div id="outline-container-org2b9aabe" class="outline-5">
<h5 id="org2b9aabe"><span class="section-number-5">1.2.4.1</span> bdev fs 的作用</h5>
<div class="outline-text-5" id="text-1-2-4-1">
<ol class="org-ol">
<li>访问 block device file 时会关联到 bdev fs 定义的各种 ops, 但这种关
联并不是通过 mount 确立的, 而是通过 init_special_inode 这种代码实现
的.</li>

<li>bdev fs 还是一个作用是通过 inode cache 来维护 dev_t 和 block_device
的关联, 例如 bdget</li>
</ol>
</div>
</div>

<div id="outline-container-org03f570c" class="outline-5">
<h5 id="org03f570c"><span class="section-number-5">1.2.4.2</span> bdev_cache_init</h5>
</div>

<div id="outline-container-orga7fa3e3" class="outline-5">
<h5 id="orga7fa3e3"><span class="section-number-5">1.2.4.3</span> init_special_inode</h5>
</div>

<div id="outline-container-org7d20795" class="outline-5">
<h5 id="org7d20795"><span class="section-number-5">1.2.4.4</span> bdget</h5>
</div>
</div>

<div id="outline-container-org05bc2d7" class="outline-4">
<h4 id="org05bc2d7"><span class="section-number-4">1.2.5</span> Block Device Driver</h4>
<div class="outline-text-4" id="text-1-2-5">
</div>
<div id="outline-container-org9e9e312" class="outline-5">
<h5 id="org9e9e312"><span class="section-number-5">1.2.5.1</span> Initialization</h5>
<div class="outline-text-5" id="text-1-2-5-1">
</div>
<ol class="org-ol">
<li><a id="org48e28e6"></a>register_blkdev<br /></li>

<li><a id="org28acc66"></a>blk_init_queue<br /></li>
</ol>
</div>

<div id="outline-container-orgf73436b" class="outline-5">
<h5 id="orgf73436b"><span class="section-number-5">1.2.5.2</span> request_fn</h5>
<div class="outline-text-5" id="text-1-2-5-2">
<p>
do_xxx_request
</p>
</div>
</div>

<div id="outline-container-orge189d95" class="outline-5">
<h5 id="orge189d95"><span class="section-number-5">1.2.5.3</span> interrupt handler</h5>
</div>

<div id="outline-container-orgdd3d17f" class="outline-5">
<h5 id="orgdd3d17f"><span class="section-number-5">1.2.5.4</span> DMA</h5>
</div>
</div>

<div id="outline-container-org8288734" class="outline-4">
<h4 id="org8288734"><span class="section-number-4">1.2.6</span> I/O Architecture</h4>
<div class="outline-text-4" id="text-1-2-6">
</div>
<div id="outline-container-org491c153" class="outline-5">
<h5 id="org491c153"><span class="section-number-5">1.2.6.1</span> I/O port</h5>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

<p class="author">Author: sunway (sunwayforever@gmail.com)<br />
Date: 2016-05-16 Mon 00:00<br />
Last updated: 2021-09-16 Thu 11:06</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。
<br />

<div id="disqus_thread"></div>
<script>

(function() { // DON'T EDIT BELOW THIS LINE
         var d = document, s = d.createElement('script');
         s.src = '//sunwayforever-github-io.disqus.com/embed.js';
         s.setAttribute('data-timestamp', +new Date());
         (d.head || d.body).appendChild(s);
         })();
</script>
</div>
</body>
</html>
