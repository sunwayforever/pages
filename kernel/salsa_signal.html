<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>Signal Handling in DBT</title>

<link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
<link rel="stylesheet" type="text/css" href="../main.css" media="screen" />
<link rel="stylesheet" type="text/css" href="./main.css" media="screen" />
<link rel = "icon" href = "/icon.png"  type = "image/x-icon">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">Signal Handling in DBT</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org0000034">1. Signal Handling in DBT</a>
<ul>
<li><a href="#org0000000">1.1. testing code</a></li>
<li><a href="#org0000004">1.2. tombstone info</a></li>
<li><a href="#org0000007">1.3. before SIGSEGV</a></li>
<li><a href="#org000000a">1.4. page fault</a></li>
<li><a href="#org000000d">1.5. prepare to invoke the master_signal_handler</a></li>
<li><a href="#org0000010">1.6. master_signal_handler</a></li>
<li><a href="#org0000013">1.7. sigreturn</a></li>
<li><a href="#org0000016">1.8. dispatcher_trampoline</a></li>
<li><a href="#org000001f">1.9. dispatcher</a>
<ul>
<li><a href="#org0000019">1.9.1. dispatcher</a></li>
<li><a href="#org000001c">1.9.2. raise_sync_signal</a></li>
</ul>
</li>
<li><a href="#org0000022">1.10. translated sa_handler</a></li>
<li><a href="#org0000025">1.11. ARM_RT_SIGRETURN_TRAMPOLINE</a></li>
<li><a href="#org0000028">1.12. svc_trampoline</a></li>
<li><a href="#org000002b">1.13. SIGSEGV again</a></li>
<li><a href="#org000002e">1.14. back to debuggerd32</a></li>
<li><a href="#org0000031">1.15. To summaries</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org0000034" class="outline-2">
<h2 id="org0000034"><span class="section-number-2">1</span> Signal Handling in DBT</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org0000000" class="outline-3">
<h3 id="org0000000"><span class="section-number-3">1.1</span> testing code</h3>
<div class="outline-text-3" id="text-1-1">
<div class="org-src-container">
<pre class="src src-c"><span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
     <span class="org-keyword">__asm__</span>(
         <span class="org-string">"mov r0, #100\n\t"</span>                    \
         <span class="org-string">"mov r1, #100\n\t"</span>                    \
         :);
     <span class="org-type">int</span> <span class="org-variable-name">x</span> = *((<span class="org-type">int</span> *)0);
     <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org0000004" class="outline-3">
<h3 id="org0000004"><span class="section-number-3">1.2</span> tombstone info</h3>
<div class="outline-text-3" id="text-1-2">
<p>
tombstone generated by debuggerd32 when running the previous testing
code with arm_translator:
</p>

<pre class="example" id="org0000003">
01-19 22:25:39.278 E/DEBUG   ( 2381): ABI: arm
01-19 22:25:39.279 F/DEBUG   ( 2381): pid: 3867, tid: 3867, name: a.out  &gt;&gt;&gt; ./arm_translator &lt;&lt;&lt;
01-19 22:25:39.281 E/DEBUG   ( 2381): AM write failed: Broken pipe
01-19 22:25:39.282 F/DEBUG   ( 2381): signal 11 (SIGSEGV), code 2 (SEGV_ACCERR), fault addr 0x0
01-19 22:25:39.288 F/DEBUG   ( 2381):     r0 00000064  r1 00000064  r2 bffddb2c  r3 00000000
01-19 22:25:39.289 F/DEBUG   ( 2381):     r4 bffddb2c  r5 bffddb24  r6 00000001  r7 80000334
01-19 22:25:39.289 F/DEBUG   ( 2381):     r8 00000000  r9 00000000  sl 00000000  fp bffddaec
01-19 22:25:39.290 F/DEBUG   ( 2381):     ip bf7a55e0  sp bffddad8  lr bf74635f  pc 7f4239f0  cpsr 40000000
01-19 22:25:39.292 F/DEBUG   ( 2381):
01-19 22:25:39.292 F/DEBUG   ( 2381): backtrace:
01-19 22:25:39.293 F/DEBUG   ( 2381):     #00 pc 7f4239f0  &lt;unknown&gt;
01-19 22:25:39.294 F/DEBUG   ( 2381):     #01 pc 0001735d  /system/lib/libc.so (__libc_init+44)
01-19 22:25:39.294 F/DEBUG   ( 2381):     #02 pc 007ffb18  &lt;unknown&gt;
01-19 22:25:39.331 F/DEBUG   ( 2381):
01-19 22:25:39.331 F/DEBUG   ( 2381): Tombstone written to: /data/tombstones/tombstone_03
</pre>
</div>
</div>

<div id="outline-container-org0000007" class="outline-3">
<h3 id="org0000007"><span class="section-number-3">1.3</span> before SIGSEGV</h3>
<div class="outline-text-3" id="text-1-3">
<p>
before crash, it should be running in the code cache:
</p>

<div class="org-src-container">
<pre class="src src-asm"><span class="org-function-name">3867</span>| DEBUG(translate): emit: 0x7f7f42088c: movz w0, #0x64
<span class="org-function-name">3867</span>| DEBUG(translate): emit: 0x7f7f420890: movz w1, #0x64
<span class="org-function-name">3867</span>| DEBUG(translate): emit: 0x7f7f420894: movz w3, #0
<span class="org-function-name">3867</span>| DEBUG(translate): emit: 0x7f7f420898: ldr w3, [x3]
</pre>
</div>

<p>
which is translated from:
</p>

<div class="org-src-container">
<pre class="src src-asm"><span class="org-function-name">3867</span>| DEBUG(translate): 80000348: mov r0, #0x64
<span class="org-function-name">3867</span>| DEBUG(translate): 8000034c: mov r1, #0x64
<span class="org-function-name">3867</span>| DEBUG(translate): 80000350: mov r3, #0
<span class="org-function-name">3867</span>| DEBUG(translate): 80000354: ldr r3, [r3]
</pre>
</div>

<p>
when executing the translated instruction
</p>

<div class="org-src-container">
<pre class="src src-asm"><span class="org-function-name">0x7f7f420898</span>: <span class="org-keyword">ldr</span> w3,[x3]
</pre>
</div>

<p>
a page fault will be triggerd
</p>
</div>
</div>

<div id="outline-container-org000000a" class="outline-3">
<h3 id="org000000a"><span class="section-number-3">1.4</span> page fault</h3>
<div class="outline-text-3" id="text-1-4">
<p>
current user space context (gp[0..15], pc, sp, &#x2026;) will be stored in
the kernel stack by hardware and kernel.
</p>

<p>
ptrace(PTRACE_GETREGS&#x2026;) will fetch register from the kernel stack,
which is shown in the tombstone
</p>
</div>
</div>

<div id="outline-container-org000000d" class="outline-3">
<h3 id="org000000d"><span class="section-number-3">1.5</span> prepare to invoke the master_signal_handler</h3>
<div class="outline-text-3" id="text-1-5">
<p>
page fault will deliver SIGSEGV to the process itself. before return
to userspace, the master_signal_handler registered by the translator
need to be invoked first.
</p>

<p>
kernel will setup a sigframe on user stack. the sigframe contains:
</p>

<ol class="org-ol">
<li>retcode, which is sigreturn in vdso</li>
<li>ucontext, which is filled with the kernel stack content (or the user space
context before the page fault)</li>
<li>siginfo</li>
<li>signo</li>
</ol>

<p>
then, the pc stored in kernel stack is changed to the
master_signal_handler, so that ret_from_intr will pop the kernel stack
then jump to the master_signal_handler
</p>
</div>
</div>

<div id="outline-container-org0000010" class="outline-3">
<h3 id="org0000010"><span class="section-number-3">1.6</span> master_signal_handler</h3>
<div class="outline-text-3" id="text-1-6">
<div class="org-src-container">
<pre class="src src-c"><span class="org-function-name">master_signal_handler</span>(signo, siginfo, uc):
  dbt_handle_signal(siginfo, uc)
    <span class="org-comment-delimiter">/* </span><span class="org-comment">uc-&gt;uc_mcontext.pc is the pc that caused the SIGSEGV in</span>
<span class="org-comment">     * translated code, which is saved on the kernel stack and copied</span>
<span class="org-comment">     * to uc</span><span class="org-comment-delimiter">*/</span>
    <span class="org-type">fragment_lookup_result_t</span> <span class="org-variable-name">result</span> = fragment_lookup_by_addr(frag_abs_to_offset((<span class="org-type">void</span>*)uc-&gt;uc_mcontext.pc));
    saved_desc = result.frag-&gt;desc;
    <span class="org-comment-delimiter">/* </span><span class="org-comment">saved_desc.pc is the entry address in the guest code</span><span class="org-comment-delimiter"> */</span>
    <span class="org-function-name">recover_fault_info</span>(uc, &amp;saved_desc, fault_offset, metadata)

    <span class="org-comment-delimiter">// </span><span class="org-comment">uc-&gt;uc_mcontext.pc is chaged to the dispatcher_trampoline</span>
    uc-&gt;uc_mcontext.pc = (<span class="org-type">uintptr_t</span>)<span class="org-function-name">frag_offset_to_abs</span>(dispatcher_trampoline);
    uc-&gt;uc_mcontext.regs[16] = DISPATCH_DATA_ABORT;
</pre>
</div>
</div>
</div>

<div id="outline-container-org0000013" class="outline-3">
<h3 id="org0000013"><span class="section-number-3">1.7</span> sigreturn</h3>
<div class="outline-text-3" id="text-1-7">
<p>
when the master_signal_handler returns, it will call sigreturn, which
is setup by the kernel when setting up sigframe.
</p>

<p>
sigreturn will fetch the sigframe on the user stack and recover the
`origin` kernel stack, but since we have changed the uc_mcontext.pc to
dispatcher_trampoline, when sigreturn returns to user space, pc will
point to `dispatcher_trampoline`
</p>
</div>
</div>

<div id="outline-container-org0000016" class="outline-3">
<h3 id="org0000016"><span class="section-number-3">1.8</span> dispatcher_trampoline</h3>
<div class="outline-text-3" id="text-1-8">
<p>
the dispatcher_trampoline is in the begining of code cache, it
generally works like this:
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">save all 15 gp registers to dbt_context_t</span><span class="org-comment-delimiter"> */</span>
<span class="org-keyword">for</span> (<span class="org-type">unsigned</span> <span class="org-variable-name">i</span> = 0; i &lt; 15; i++)
  <span class="org-function-name">emit</span>(trans, aarch64_encode_LDR_STR_unsigned_immed(2, 0, 0, (offsetof(<span class="org-type">dbt_context_t</span>, gp) &gt;&gt; 2) + i, 31, i)); <span class="org-comment-delimiter">// </span><span class="org-comment">STR Wi, [SP, #gp[i]]</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">load dispatcher to x4 and branch to it</span><span class="org-comment-delimiter"> */</span>
<span class="org-function-name">emit_load_immediate64</span>(trans, (<span class="org-type">uint64_t</span>)dispatcher, 4); <span class="org-comment-delimiter">// </span><span class="org-comment">MOV X4, #dispatcher</span>
<span class="org-function-name">emit</span>(trans, aarch64_encode_BLR(4)); <span class="org-comment-delimiter">// </span><span class="org-comment">BLR X4</span>
<span class="org-function-name">emit</span>(trans, aarch64_encode_logical_reg(1, 1, 0, 0, 0, 0, 31, 16)); <span class="org-comment-delimiter">// </span><span class="org-comment">MOV X16, X0</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">restore gp registers from dbt_context_t</span><span class="org-comment-delimiter"> */</span>
<span class="org-keyword">for</span> (<span class="org-type">unsigned</span> <span class="org-variable-name">i</span> = 0; i &lt; 15; i++)
  <span class="org-function-name">emit</span>(trans, aarch64_encode_LDR_STR_unsigned_immed(2, 0, 1, (offsetof(<span class="org-type">dbt_context_t</span>, gp) &gt;&gt; 2) + i, 31, i)); <span class="org-comment-delimiter">// </span><span class="org-comment">LDR Wi, [SP, #gp[i]]</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">branch to the PC value returned by the dispatcher</span><span class="org-comment-delimiter"> */</span>
<span class="org-function-name">emit</span>(trans, aarch64_encode_BR(16)); <span class="org-comment-delimiter">// </span><span class="org-comment">BR X16</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org000001f" class="outline-3">
<h3 id="org000001f"><span class="section-number-3">1.9</span> dispatcher</h3>
<div class="outline-text-3" id="text-1-9">
</div>
<div id="outline-container-org0000019" class="outline-4">
<h4 id="org0000019"><span class="section-number-4">1.9.1</span> dispatcher</h4>
<div class="outline-text-4" id="text-1-9-1">
<div class="org-src-container">
<pre class="src src-c"><span class="org-function-name">dispatcher</span>(<span class="org-type">dbt_context_t</span>):
  <span class="org-keyword">if</span> (reason == DISPATCH_DATA_ABORT || reason == DISPATCH_PENDING_SIGNAL):
    <span class="org-comment-delimiter">/* </span><span class="org-comment">saved_desc.pc point to the guest code that cause the abort</span><span class="org-comment-delimiter"> */</span>
    desc = saved_desc;

  <span class="org-keyword">switch</span> (reason):
  <span class="org-keyword">case</span> DISPATCH_DATA_ABORT:
    target_regs_t regs;
    ctx_to_target_regs(&amp;regs, ctx, &amp;desc);
      <span class="org-keyword">for</span> (<span class="org-type">unsigned</span> <span class="org-variable-name">i</span> = 0; i &lt; 15; i++):
        regs-&gt;gp[i] = ctx-&gt;gp[i];
      regs-&gt;pc = desc-&gt;pc &amp; ~1;

    raise_sync_signal(&amp;regs, &amp;abort_siginfo, &amp;abort_extra_siginfo)
    <span class="org-comment-delimiter">/* </span><span class="org-comment">raise_sync_signal will put the real sa_handler (in guest code)</span>
<span class="org-comment">     * in regs-&gt;pc</span><span class="org-comment-delimiter"> */</span>

    <span class="org-function-name">target_regs_to_ctx</span>(ctx, &amp;desc, &amp;regs);
      <span class="org-keyword">for</span> (<span class="org-type">unsigned</span> <span class="org-variable-name">i</span> = 0; i &lt; 15; i++)
        ctx-&gt;gp[i] = regs-&gt;gp[i];
      <span class="org-keyword">if</span> (regs-&gt;pstate &amp; BIT(5))
        desc-&gt;pc = regs-&gt;pc | 1;
      <span class="org-keyword">else</span>
       desc-&gt;pc = regs-&gt;pc &amp; ~3;

  <span class="org-comment-delimiter">// </span><span class="org-comment">desc-&gt;pc now points to the sa_handler in guest code</span>
  <span class="org-type">fragment_lookup_result_t</span> <span class="org-variable-name">result</span> = fragment_lookup_by_desc(&amp;desc, flexible_bindings);
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>result.frag &amp;&amp; <span class="org-negation-char">!</span>result.persist_frag):
    result.frag = translate_basic_block(&amp;desc);
  <span class="org-type">frag_offset_t</span> <span class="org-variable-name">next_pc</span> = result.frag-&gt;start

  <span class="org-comment-delimiter">// </span><span class="org-comment">return the sa_handler in code cache, the dispatcher_trampoline</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">will branch to it</span>
  <span class="org-keyword">return</span> frag_offset_to_abs(next_pc);
</pre>
</div>
</div>
</div>

<div id="outline-container-org000001c" class="outline-4">
<h4 id="org000001c"><span class="section-number-4">1.9.2</span> raise_sync_signal</h4>
<div class="outline-text-4" id="text-1-9-2">
<div class="org-src-container">
<pre class="src src-c"><span class="org-type">raise_sync_signal</span>
  <span class="org-function-name">do_signal</span>(regs, si, ...)
    <span class="org-comment-delimiter">/*</span><span class="org-comment">setup a sigframe in the user stack as the kernel will do</span><span class="org-comment-delimiter"> */</span>
    <span class="org-function-name">target_setup_sigframe</span>()
      sp -= <span class="org-keyword">sizeof</span>(target_rt_sigframe_t);
      rt_frame = (<span class="org-type">target_rt_sigframe_t</span>*)sp;
      <span class="org-comment-delimiter">/* </span><span class="org-comment">remember that regs-&gt;pc points to guest code, so sig handler</span>
<span class="org-comment">       * could get the `real` pc (pc in guest code) from</span>
<span class="org-comment">       * uc_mcontext.arm_pc</span><span class="org-comment-delimiter"> */</span>
      safe_write(&amp;frame-&gt;uc.uc_mcontext.arm_pc, regs-&gt;pc)
      regs-&gt;gp[0] = si-&gt;si_signo;
      regs-&gt;gp[1] = (<span class="org-type">uintptr_t</span>)&amp;rt_frame-&gt;info;
      regs-&gt;gp[2] = (<span class="org-type">uintptr_t</span>)&amp;frame-&gt;uc;
      regs-&gt;gp[14] = (sa-&gt;sa_flags &amp; SA_SIGINFO) ? ARM_RT_SIGRETURN_TRAMPOLINE : ARM_SIGRETURN_TRAMPOLINE;
      <span class="org-comment-delimiter">/* </span><span class="org-comment">regs-&gt;pc now points to the sig handler in guest code</span><span class="org-comment-delimiter"> */</span>
      regs-&gt;pc = sa-&gt;sa_handler_;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org0000022" class="outline-3">
<h3 id="org0000022"><span class="section-number-3">1.10</span> translated sa_handler</h3>
<div class="outline-text-3" id="text-1-10">
<p>
the translated sal_handler will notify debuggerd32 to ptrace it and
debuggerd will wait on waitpid for another signal, then sal_handler
will branch to something (maybe the ret_r14_trampoline?) to make a
branch_return to ARM_RT_SIGRETURN_TRAMPOLINE (setup by
target_setup_sigframe)
</p>
</div>
</div>

<div id="outline-container-org0000025" class="outline-3">
<h3 id="org0000025"><span class="section-number-3">1.11</span> ARM_RT_SIGRETURN_TRAMPOLINE</h3>
<div class="outline-text-3" id="text-1-11">
<p>
ARM_RT_SIGRETURN_TRAMPOLINE is a trampoline in the guest memory, which
is:
</p>

<div class="org-src-container">
<pre class="src src-asm"><span class="org-function-name">MOV</span> <span class="org-keyword">R7</span>, #TARGET_NR_rt_sigreturn
<span class="org-function-name">SVC</span> #0
</pre>
</div>

<p>
somthing (maybe the ret_r14_trampoline?) will translate the
ARM_RT_SIGRETURN_TRAMPOLINE and branch to the translated code, which
will be a svc_trampoline
</p>
</div>
</div>

<div id="outline-container-org0000028" class="outline-3">
<h3 id="org0000028"><span class="section-number-3">1.12</span> svc_trampoline</h3>
<div class="outline-text-3" id="text-1-12">
<p>
svc_trampoline will invoke:
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-function-name">dispatcher_trampoline</span>():
  dispatcher()
    <span class="org-function-name">do_syscall</span>()
      <span class="org-function-name">do_sigreturn</span>()
        <span class="org-function-name">target_restore_sigframe</span>()
          safe_read(&amp;frame-&gt;uc.uc_mcontext.arm_pc, regs-&gt;pc)
</pre>
</div>

<p>
the last `target_restore_sigframe` will restore target_regs with the
sigframe setup by target_setup_sigframe.
</p>

<p>
note that target_regs.pc is same as the arm32 pc that cause the
SIGSEGV
</p>

<p>
as shown in <a href="#org000001f">dispatcher</a>, dispatcher will find the corresponding arm64
pc of arm32 pc by fragment_lookup_by_desc or
translate_basic_block. then branch to the arm64 pc
</p>
</div>
</div>

<div id="outline-container-org000002b" class="outline-3">
<h3 id="org000002b"><span class="section-number-3">1.13</span> SIGSEGV again</h3>
<div class="outline-text-3" id="text-1-13">
<p>
the arm64 pc will cause SIGSEGV again
</p>
</div>
</div>

<div id="outline-container-org000002e" class="outline-3">
<h3 id="org000002e"><span class="section-number-3">1.14</span> back to debuggerd32</h3>
<div class="outline-text-3" id="text-1-14">
<p>
the second SIGSEGV will wake up debuggerd32 from waitpid, then
debuggerd32 will use ptrace(PTRACE_GETREGS,&#x2026;) to dump registers,
which is shown in the <a href="#org0000004">tombstone info</a>
</p>
</div>
</div>

<div id="outline-container-org0000031" class="outline-3">
<h3 id="org0000031"><span class="section-number-3">1.15</span> To summaries</h3>
<div class="outline-text-3" id="text-1-15">
<ol class="org-ol">
<li>master_signal_handler found the arm32 pc that cause the SIGSEGV by
fragment_lookup_by_addr</li>
<li>master_signal_handler branch to the dispatcher_trampoline by
modifying the uc_mcontext-&gt;pc</li>
<li>dispatcher_trampoline will:
<ol class="org-ol">
<li>set up the sigframe in user stack</li>
<li>find the arm64 pc of the translated sa_handler by
fragment_lookup_by_desc or translate_basic_block</li>
<li>branch to translated sa_handler</li>
</ol></li>
<li>return address of the translated sa_handler will branch to the
svc_trampoline corresponding to rt_sigreturn_trampoline</li>
<li>translated rt_sigreturn_trampoline will call do_sigreturn, which
will call target_restore_sigframe to restore the context of
translated code</li>
<li>dispatcher will find fragment corresponding to arm32 pc that cause
the SIGSEGV and branch to it, which will cause another SIGSEGV</li>
<li>the second SIGSEGV will wake up debuggerd32 and debuggerd32 will
dump the tombstone</li>
</ol>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

<p class="author">Author: sunway (sunwayforever@gmail.com)<br />
Date: 2017-01-20 Fri 00:00<br />
Last updated: 2022-02-25 Fri 22:34</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。
<br />

<div id="disqus_thread"></div>
<script>

(function() { // DON'T EDIT BELOW THIS LINE
         var d = document, s = d.createElement('script');
         s.src = '//sunwayforever-github-io.disqus.com/embed.js';
         s.setAttribute('data-timestamp', +new Date());
         (d.head || d.body).appendChild(s);
         })();
</script>
</div>
</body>
</html>
