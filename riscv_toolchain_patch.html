<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>RISC-V Toolchain Patch</title>


           <link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
           <link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
           <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
           <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
           <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
           <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
           <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
           <link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
           <link rel="stylesheet" type="text/css" href="../main.css" media="screen" />
           <link rel="stylesheet" type="text/css" href="./main.css" media="screen" />
           <link rel = "icon" href = "/icon.png"  type = "image/x-icon">
</head>
<body>
<div id="content" class="content">
<h1 class="title">RISC-V Toolchain Patch</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org0000052">1. RISC-V Toolchain Patch</a>
<ul>
<li><a href="#org000004f">1.1. T-Head</a>
<ul>
<li><a href="#org0000043">1.1.1. gcc</a></li>
<li><a href="#org0000046">1.1.2. gdb</a></li>
<li><a href="#org0000049">1.1.3. qemu</a></li>
<li><a href="#org000004c">1.1.4. spike</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org0000052" class="outline-2">
<h2 id="org0000052"><span class="section-number-2">1.</span> RISC-V Toolchain Patch</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org000004f" class="outline-3">
<h3 id="org000004f"><span class="section-number-3">1.1.</span> T-Head</h3>
<div class="outline-text-3" id="text-1-1">
</div>
<div id="outline-container-org0000043" class="outline-4">
<h4 id="org0000043"><span class="section-number-4">1.1.1.</span> gcc</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
<a href="https://github.com/T-head-Semi/gcc/commit/f342d033dbaa0a748c4867b1edb7d97dddd71873">https://github.com/T-head-Semi/gcc/commit/f342d033dbaa0a748c4867b1edb7d97dddd71873</a>
</p>

<p>
针对 gcc 的修改主要包括:
</p>

<ol class="org-ol">
<li>定义指令的 latency 和 pipeline 信息</li>
<li>p 扩展</li>
<li>v 扩展</li>
<li>zfh 扩展</li>
<li>t-head 自定义扩展</li>
</ol>

<p>
其中:
</p>

<ol class="org-ol">
<li>p/v 扩展主要是实现 intrinsic</li>

<li>zfh 扩展没有对应的 intrinsic, 因为 gcc 本来就支持 `__fp16` 类型及 `HF` mode,
zfh 只需要定义 md, 例如标准的 F 扩展要定义 addsf3, zfh 只需要定义 addhf3 即可</li>

<li>t-head 自定义扩展, 参考
<a href="https://github.com/T-head-Semi/thead-extension-spec/blob/master/intro.adoc">https://github.com/T-head-Semi/thead-extension-spec/blob/master/intro.adoc</a> 和
<a href="https://occ-oss-prod.oss-cn-hangzhou.aliyuncs.com/resource/undefined/1623288429903/%E7%8E%84%E9%93%81E906R2S0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_v03.pdf">https://occ-oss-prod.oss-cn-hangzhou.aliyuncs.com/resource/undefined/1623288429903/%E7%8E%84%E9%93%81E906R2S0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_v03.pdf</a>,
主要包括 mac (multiply-accumulate), vdot (vector-dot), bb (bit-manipulation)
等</li>
</ol>
</div>

<div id="outline-container-org0000001" class="outline-5">
<h5 id="org0000001"><span class="section-number-5">1.1.1.1.</span> by file</h5>
<div class="outline-text-5" id="text-1-1-1-1">
<p>
去掉脚本生成的代码以及测试代码, 剩下大约 20K 行代码, 一半为脚本, 一半为 md
</p>

<pre class="example" id="org0000000">
2396 files changed, 361667 insertions(+), 301 deletions(-)
gcc/combine.c                                      |      5 +
gcc/common/config/riscv/riscv-common.c             |    112 +-
---解析新增的 march 字符串
gcc/config.gcc                                     |      8 +-
gcc/config/riscv/c906.md                           |    156 +
---添加了 c906 的 latency 和 pipepline 信息

gcc/config/riscv/constraints.md                    |      2 +-
gcc/config/riscv/predicates.md                     |      4 +
gcc/config/riscv/riscv-builtins-p.def              |    513 +
---p 扩展的 builtin 声明, 脚本生成

gcc/config/riscv/riscv-builtins-thead.c            |    388 +
gcc/config/riscv/riscv-builtins-thead.h            |     20 +
gcc/config/riscv/riscv-builtins-v-a.def            |    121 +
gcc/config/riscv/riscv-builtins-v.def              |  22362 +++
---v 扩展的 builtin 声明

gcc/config/riscv/riscv-builtins.c                  |     67 +-
---init/expand builtin

gcc/config/riscv/riscv-c.c                         |     30 +
---t-head 新增的预定义宏, 例如 __riscv_xthead

gcc/config/riscv/riscv-cores.def                   |      9 +
---t-head 新增的 cpu, arch, tune 的声明

gcc/config/riscv/riscv-dsp.h                       |   4686 +
---这个文件是用 riscv-p-builtins-gen.py 生成的, 给应用程序使用

gcc/config/riscv/riscv-fp16.md                     |    342 +
---zfh 扩展对应的 md

gcc/config/riscv/riscv-ftypes-p.def                |    114 +
gcc/config/riscv/riscv-ftypes-special.def          |    332 +
gcc/config/riscv/riscv-ftypes-v.def                |   5252 +
---p/v 扩展对应的 builtin function prototyple 声明, 脚本生成

gcc/config/riscv/riscv-modes.def                   |     26 +
gcc/config/riscv/riscv-opts.h                      |     14 +-
gcc/config/riscv/riscv-p-builtins-gen.py           |   4684 +
gcc/config/riscv/riscv-p.md                        |   3591 +
---p 扩展对应的 md

gcc/config/riscv/riscv-passes-thead.def            |      2 +
gcc/config/riscv/riscv-protos.h                    |      4 +
gcc/config/riscv/riscv-seg-modes.def               |     77 +
gcc/config/riscv/riscv-thead-dfsrm.c               |     92 +
---自定义 rtl pass

gcc/config/riscv/riscv-thead-dsext.c               |    673 +
---自定义 rtl pass, 它会把多余的 sext 去掉, 例如 a+(b&lt;&lt;c) 时会有多余的
sext 指令生成, 会导致 addsl 无法匹配

gcc/config/riscv/riscv-thead-tune.h                |     53 +
--thead tune 定义

gcc/config/riscv/riscv-thead.c                     |   1188 +
gcc/config/riscv/riscv-thead.h                     |    173 +
gcc/config/riscv/riscv-thead.md                    |   1081 +
---thead 自定义扩展对应的 md

gcc/config/riscv/riscv-v-auto.md                   |    530 +
gcc/config/riscv/riscv-v-builtins-gen.py           |   4029 +
gcc/config/riscv/riscv-v-float.md                  |   2621 +
gcc/config/riscv/riscv-v-iterators.md              |   2459 +
gcc/config/riscv/riscv-v-mem.md                    |    838 +
gcc/config/riscv/riscv-v-seg-iterators.md          |    110 +
gcc/config/riscv/riscv-v-segmem.md                 |    751 +
gcc/config/riscv/riscv-v.h                         |     81 +
gcc/config/riscv/riscv-v.md                        |   3940 +
---v 扩展对应的 md

gcc/config/riscv/riscv-vector-seg-type.def         |    121 +
gcc/config/riscv/riscv-vector-type.def             |    120 +
gcc/config/riscv/riscv-vector.h                    | 174973 ++++++++++++++++++
---脚本生成, 给用户程序使用

gcc/config/riscv/riscv.c                           |    459 +-
---新的寄存器, tune info, cost

gcc/config/riscv/riscv.h                           |    135 +-
gcc/config/riscv/riscv.md                          |    182 +-
gcc/config/riscv/riscv.opt                         |    162 +-
gcc/genemit.c                                      |    104 +-
gcc/ipa-inline.c                                   |     11 +-
gcc/loop-iv.c                                      |     22 +-
gcc/testsuite/gcc.target/riscv/dsp/add16.c         |     14 +
gcc/testsuite/gcc.target/riscv/dsp/add32.c         |     14 +
gcc/testsuite/gcc.target/riscv/dsp/add8.c          |     14 +
---p/v 指令对应的 dg 测试代码, 由脚本生成

</pre>
</div>
</div>

<div id="outline-container-org0000040" class="outline-5">
<h5 id="org0000040"><span class="section-number-5">1.1.1.2.</span> by insn</h5>
<div class="outline-text-5" id="text-1-1-1-2">
</div>
<div id="outline-container-org0000007" class="outline-6">
<h6 id="org0000007"><span class="section-number-6">1.1.1.2.1.</span> p extension</h6>
<div class="outline-text-6" id="text-1-1-1-2-1">
<p>
riscv-builtins-p.def 使用 DIRECT_BUILTIN 宏声明 builtin:
</p>

<pre class="example" id="org0000004">
DIRECT_BUILTIN (zunpkd810_v4qi, RISCV_UV2HI_FTYPE_UV4QI, dsp32),
DIRECT_BUILTIN (zunpkd810_v8qi, RISCV_UV4HI_FTYPE_UV8QI, dsp64),
</pre>

<p>
其中 zunpkd810_v4qi 表示它需要对应 riscv-p.md 中的一条 insn: riscv_zunpkd810_v4qi
</p>

<pre class="example" id="org0000005">
(define_insn "riscv_&lt;unpkd_int_str&gt;_&lt;mode&gt;"
  [(set (match_operand:&lt;vqvhmod_attr&gt; 0 "register_operand" "=r")
     (unspec:&lt;vqvhmod_attr&gt;
      [(match_operand:VQIMOD 1 "register_operand" "r")]
       UNSPEC_UNPKD))]
  "TARGET_XTHEAD_DSP"
  "&lt;unpkd_int_insn&gt;\\t%0,%1"
)
</pre>

<p>
其中 unpkd_int_str 是一个 attribute, 包含 zunpkd810, zunpkd820 等不同的值, 以简化 md 的编写
</p>

<p>
RISCV_UV2HI_FTYPE_UV4QI 代表 function prototype, 指函数有唯一参数为 UV4QI, 即
uint8x4_t, 返回值为 UV2HI, 即 uint16x2_t.
</p>

<p>
这些 prototype 在 riscv-ftypes-p.def 中定义, 例如
</p>

<pre class="example" id="org0000006">
// 展开为 RISCV_UV2HI_FTYPE_UV4QI
DEF_RISCV_FTYPE (1, (UV2HI, UV4QI))

// 展开为 RISCV_DI_FTYPE_DI_DI
DEF_RISCV_FTYPE (2, (DI, DI, DI)) 
</pre>
</div>
</div>

<div id="outline-container-org000000a" class="outline-6">
<h6 id="org000000a"><span class="section-number-6">1.1.1.2.2.</span> v extension</h6>
<div class="outline-text-6" id="text-1-1-1-2-2">
<p>
v extension 与 p extension 类似, 不同的是 v 使用专门的 v 寄存器 (p 使用 x 寄存器)
</p>

<p>
因此 v extension 有些代码和寄存器有关, 例如:
</p>

<p>
riscv_compute_frame_info 是需要考虑是否要保存 v_reg
</p>
</div>
</div>

<div id="outline-container-org000000d" class="outline-6">
<h6 id="org000000d"><span class="section-number-6">1.1.1.2.3.</span> zfh extension</h6>
<div class="outline-text-6" id="text-1-1-1-2-3">
<p>
zfh 不需要提供 intrinsic, 因为 gcc 本身支持 __fp16, thead 针对 HF mode 定义相应的 md 即可
</p>
</div>
</div>

<div id="outline-container-org000003d" class="outline-6">
<h6 id="org000003d"><span class="section-number-6">1.1.1.2.4.</span> thead extsion</h6>
<div class="outline-text-6" id="text-1-1-1-2-4">
<p>
<a href="https://github.com/T-head-Semi/thead-extension-spec">https://github.com/T-head-Semi/thead-extension-spec</a>
</p>
</div>

<ol class="org-ol">
<li><a id="org0000014"></a>xheadba<br />
<ol class="org-ol">
<li><a id="org0000011"></a>addsl<br />
<div class="outline-text-8" id="text-1-1-1-2-4-1-1">
<p>
addsl 是用一条指令实现 <code>a+b&lt;&lt;c</code> 的操作, t-head 实现时只需要定义其 md:
</p>

<pre class="example" id="org0000010">
(define_insn "*xthead_addsl&lt;mode&gt;"
  [(set (match_operand:X 0 "register_operand" "=r")
    (plus:X (ashift:X (match_operand:X 2 "register_operand" "r")
              (match_operand:QI 3 "const_twobit_operand" "i"))
        (match_operand:X 1 "register_operand" "r")))]
   "TARGET_XTHEAD_ADDSL"
   "addsl\t%0, %1, %2, %3"
   [(set_attr "type" "arith")]
)
</pre>

<p>
gcc 在 rtl combine pass 里会把两条 rtl (ashift, plus) 合并成一条 (plus(shift)),
rtl 在 code emission 时根据 rtl 模板会找到这条指令
</p>
</div>
</li>
</ol>
</li>

<li><a id="org000001f"></a>xheadbb<br />
<ol class="org-ol">
<li><a id="org0000018"></a>ext<br />
<div class="outline-text-8" id="text-1-1-1-2-4-2-1">
<p>
ext/extu 是 t-head 提供的加速 sext 和 zext 的指令
</p>

<pre class="example" id="org0000017">
(define_insn "*xthead_extend&lt;SHORT:mode&gt;&lt;X:mode&gt;2"
  [(set (match_operand:X       0 "register_operand"    "=r")
    (sign_extend:X
      (match_operand:SHORT  1 "register_operand"    "r")))]
  "TARGET_XTHEAD_EXT"
  {
    operands[2] = GEN_INT (GET_MODE_BITSIZE (&lt;SHORT:MODE&gt;mode) - 1);
    return "ext\t%0,%1,%2,0";
  }
  [(set_attr "type" "arith")
   (set_attr "mode" "&lt;X:MODE&gt;")])
</pre>

<p>
同时修改了对应的 cost:
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">riscv_extend_cost</span>(<span class="org-type">rtx</span> <span class="org-variable-name">op</span>, <span class="org-type">bool</span> <span class="org-variable-name">unsigned_p</span>) {
    <span class="org-keyword">if</span> (MEM_P(op)) <span class="org-keyword">return</span> 0;

    <span class="org-keyword">if</span> (unsigned_p &amp;&amp; GET_MODE(op) == QImode) <span class="org-comment-delimiter">/* </span><span class="org-comment">We can use ANDI.</span><span class="org-comment-delimiter">  */</span>
        <span class="org-keyword">return</span> COSTS_N_INSNS(1);

    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>unsigned_p &amp;&amp; GET_MODE(op) == SImode) <span class="org-comment-delimiter">/* </span><span class="org-comment">We can use SEXT.W.</span><span class="org-comment-delimiter">  */</span>
        <span class="org-keyword">return</span> COSTS_N_INSNS(1);

    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>optimize_size &amp;&amp; TARGET_XTHEAD_C) <span class="org-keyword">return</span> tune_param-&gt;extend;

    <span class="org-comment-delimiter">/* </span><span class="org-comment">We need to use a shift left and a shift right.</span><span class="org-comment-delimiter">  */</span>
    <span class="org-keyword">return</span> COSTS_N_INSNS(2);
}
</pre>
</div>
</div>
</li>

<li><a id="org000001c"></a>srri<br />
<div class="outline-text-8" id="text-1-1-1-2-4-2-2">
<pre class="example" id="org000001b">
(define_insn "rotrsi3"
  [(set (match_operand:SI              0 "register_operand"     "=r")
    (rotatert:SI (match_operand:SI 1 "register_operand"     "r")
             (match_operand:SI 2 "const_int_operand"    "QcL")))]
  "TARGET_XTHEAD_SRRIW || (TARGET_XTHEAD_SRRI &amp;&amp; !TARGET_64BIT)"
  {
    return TARGET_XTHEAD_SRRIW ? "srriw\t%0, %1, %2" : "srri\t%0, %1, %2";
  }
  [(set_attr "type" "arith")
   (set_attr "mode" "DI")]
)
</pre>

<p>
gcc 本身已经定义了 rotr_optab, 所以后端只需要定义 rotrsi3 之类即可支持
</p>
</div>
</li>
</ol>
</li>

<li><a id="org0000026"></a>xheadint<br />
<ol class="org-ol">
<li><a id="org0000023"></a>ipush<br />
<div class="outline-text-8" id="text-1-1-1-2-4-3-1">
<p>
ipush 用来加速 interrupt handler 的处理, 可以一条指令完成多个 reg 的入栈.
</p>

<p>
实现上 t-head 定义了其 md:
</p>

<pre class="example" id="org0000022">
(define_insn "riscv_ipush"
  [(unspec_volatile [(const_int 0)] UNSPECV_IPUSH)
   (use (reg RETURN_ADDR_REGNUM))
   (use (reg T0_REGNUM))
   (use (reg T1_REGNUM))
   // ...
   (use (reg T4_REGNUM))
   (use (reg T5_REGNUM))
   (use (reg T6_REGNUM))]
  "TARGET_XTHEAD_IPUSH"
  "ipush")
</pre>

<p>
同时修改了负责生成 function prologue 和 epilogue 的部分:
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="org-type">void</span> <span class="org-function-name">riscv_expand_prologue</span>(<span class="org-type">void</span>) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
    <span class="org-keyword">if</span> (TARGET_XTHEAD_INTERRUPT_HANDLER_P()) {
        <span class="org-type">rtx</span> <span class="org-variable-name">dwarf</span> = riscv_adjust_ipush_cfi_prologue();
        frame-&gt;mask &amp;= ~frame-&gt;imask;
        frame-&gt;gp_sp_offset -= frame-&gt;save_ipush_adjustment;
        size -= frame-&gt;save_ipush_adjustment;
        insn = emit_insn(gen_riscv_ipush());
        <span class="org-comment-delimiter">// </span><span class="org-comment">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

        RTX_FRAME_RELATED_P(insn) = 1;
        REG_NOTES(insn) = dwarf;
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
}
</pre>
</div>
</div>
</li>
</ol>
</li>


<li><a id="org000002d"></a>xheadmempair<br />
<ol class="org-ol">
<li><a id="org000002a"></a>ldd/sdd<br />
<div class="outline-text-8" id="text-1-1-1-2-4-4-1">
<pre class="example" id="org0000029">
(define_insn "load_pairdi"
  [(set (match_operand:DI 0 "register_operand"        "=r")
    (match_operand:DI 1 "riscv_mem_pair_operand"  "Qmp"))
   (set (match_operand:DI 2 "register_operand"        "=r")
    (mem:DI (plus:DI (match_operand:DI 3 "register_operand"      "r")
             (match_operand  4 "const_Pi_operand"     "Pi"))))]
  "TARGET_XTHEAD_LDD
  &amp;&amp; rtx_equal_p (plus_constant (Pmode, operands[3], INTVAL (operands[4])),
      plus_constant (Pmode, XEXP (operands[1], 0), GET_MODE_SIZE (DImode)))
  &amp;&amp; REGNO (operands[0]) != REGNO (operands[3])
  &amp;&amp; REGNO (operands[2]) != REGNO (operands[3])"
  "ldd\t%0,%2,(%3),%j4,4"
  [(set_attr "type" "load")
   (set_attr "mode" "DI")])
</pre>

<p>
对连续内存的两个 ld 可以合并成一个 ldd 指令
</p>
</div>
</li>
</ol>
</li>

<li><a id="org0000033"></a>xheadmemidx<br />
<ol class="org-ol">
<li><a id="org0000030"></a>flrd<br /></li>
</ol>
</li>

<li><a id="org000003a"></a>xheadmac<br />
<ol class="org-ol">
<li><a id="org0000037"></a>mula<br />
<div class="outline-text-8" id="text-1-1-1-2-4-6-1">
<pre class="example" id="org0000036">
(define_insn "*xthead_madd&lt;mode&gt;"
  [(set (match_operand:X 0 "register_operand" "=r")
          (plus:X (mult:X (match_operand:X 1 "register_operand" "r")
                  (match_operand:X 2 "register_operand" "r"))
              (match_operand:X 3 "register_operand" "0")))]
  "TARGET_MUL &amp;&amp; TARGET_XTHEAD_MULA"
  "mula\\t%0,%1,%2"
  [(set_attr "type" "imul")
   (set_attr "mode" "&lt;MODE&gt;")]
)
</pre>

<p>
<code>REG[rd]+=REG[rs1]*REG[rs2]</code>
</p>
</div>
</li>
</ol>
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org0000046" class="outline-4">
<h4 id="org0000046"><span class="section-number-4">1.1.2.</span> gdb</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
同样要支持 p/v/zfh 和 t-head 自定义扩展, 但修改主要在 opcodes 中, 和 disass 有关.
还有小部分和 gdbarch (tdep) 有关, 例如新增的 v 寄存器信息
</p>
</div>
</div>

<div id="outline-container-org0000049" class="outline-4">
<h4 id="org0000049"><span class="section-number-4">1.1.3.</span> qemu</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
<a href="https://github.com/T-head-Semi/qemu/commit/fd25f40f7d66d6fe5caffa9ef4b610434de6cf42#diff-8f4b85f7d35aa3058c602811cdac2dfa6c09fbea8d897de3b2e0c6905be3fbfa">https://github.com/T-head-Semi/qemu/commit/fd25f40f7d66d6fe5caffa9ef4b610434de6cf42#diff-8f4b85f7d35aa3058c602811cdac2dfa6c09fbea8d897de3b2e0c6905be3fbfa</a>
</p>

<p>
qemu 上游已经支持 v 扩展.
</p>

<p>
t-head 主要是支持 p/zfh 和 t-head 自定义扩展. 主要修改部分是 <a href="toolchain/qemu_tcg.html#ID-fedb153b-c9a7-4ad1-a66e-e08b91173dd3">QEMU TCG</a>, 包括
insn32.decode, translate.c, xxx_helper.c
</p>
</div>
</div>

<div id="outline-container-org000004c" class="outline-4">
<h4 id="org000004c"><span class="section-number-4">1.1.4.</span> spike</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
没有和 t-head 相关的修改, 看起来只是加了一个
<a href="https://github.com/openhwgroup/force-riscv">https://github.com/openhwgroup/force-riscv</a> 到 spike
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

<p class="author">Author: sunway@dogdog.run<br />
Date: 2023-02-17 Fri 10:02<br />
Last updated: 2023-03-03 Fri 09:35</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
</div>
</body>
</html>