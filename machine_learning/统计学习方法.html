<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>统计学习方法</title>


           <link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
           <link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
           <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
           <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
           <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
           <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
           <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
           <link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
           <link rel="stylesheet" type="text/css" href="../main.css" media="screen" />
           <link rel="stylesheet" type="text/css" href="./main.css" media="screen" />
           <link rel = "icon" href = "/icon.png"  type = "image/x-icon">
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">统计学习方法</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org0000093">1. 统计学习方法</a>
<ul>
<li><a href="#org0000000">1.1. 概论</a></li>
<li><a href="#org0000006">1.2. 感知机</a></li>
<li><a href="#org0000021">1.3. 朴素贝叶斯</a>
<ul>
<li><a href="#org0000009">1.3.1. 概率</a></li>
<li><a href="#org000000c">1.3.2. 朴素贝叶斯方法</a></li>
<li><a href="#org000000f">1.3.3. 极大似然估计</a></li>
<li><a href="#org0000012">1.3.4. 为什么需要使用条件独立假设</a></li>
<li><a href="#org0000015">1.3.5. 生成模型</a></li>
<li><a href="#org0000018">1.3.6. 举例</a></li>
<li><a href="#org000001b">1.3.7. 拉普拉斯平滑</a></li>
<li><a href="#org000001e">1.3.8. 高斯朴素贝叶斯方法</a></li>
</ul>
</li>
<li><a href="#org000003b">1.4. 决策树</a>
<ul>
<li><a href="#org0000025">1.4.1. 决策树的表示</a></li>
<li><a href="#org0000028">1.4.2. 决策树算法的三个过程:</a></li>
<li><a href="#org000002b">1.4.3. 特征选择</a></li>
<li><a href="#org000002f">1.4.4. 信息增益</a></li>
<li><a href="#org0000032">1.4.5. 决策树的生成: ID3 算法</a></li>
<li><a href="#org0000035">1.4.6. 决策树的剪枝</a></li>
<li><a href="#org0000038">1.4.7. 为什么使用信息增益来选择</a></li>
</ul>
</li>
<li><a href="#org0000049">1.5. logistic 回归</a>
<ul>
<li><a href="#org0000040">1.5.1. logistic 分布</a></li>
<li><a href="#org0000043">1.5.2. 二项 logistic 回归</a></li>
<li><a href="#org0000046">1.5.3. 二项 logistic 回归的模型参数估计</a></li>
</ul>
</li>
<li><a href="#org0000076">1.6. 支持向量机</a>
<ul>
<li><a href="#org000004c">1.6.1. 拉格朗日乘子法</a></li>
<li><a href="#org000004f">1.6.2. 支持向量机</a></li>
<li><a href="#org0000052">1.6.3. 点到超平面的距离</a></li>
<li><a href="#org0000055">1.6.4. 间隔最大化</a></li>
<li><a href="#org0000058">1.6.5. 支持向量</a></li>
<li><a href="#org000005c">1.6.6. 使用拉格朗日乘子法求解间隔最大化问题</a></li>
<li><a href="#org000005f">1.6.7. 使用梯度下降求解间隔最大化问题</a></li>
<li><a href="#org0000062">1.6.8. 软间隔支持向量机</a></li>
<li><a href="#org0000066">1.6.9. 支持向量机与 logistic 回归</a></li>
<li><a href="#org000006a">1.6.10. 非线性支持向量机</a></li>
<li><a href="#org000006d">1.6.11. 对偶问题</a></li>
<li><a href="#org0000070">1.6.12. 核函数</a></li>
<li><a href="#org0000073">1.6.13. SMO 算法</a></li>
</ul>
</li>
<li><a href="#org0000090">1.7. 隐马尔可夫模型</a>
<ul>
<li><a href="#org0000079">1.7.1. 定义</a></li>
<li><a href="#org000007c">1.7.2. 举例</a></li>
<li><a href="#org000007f">1.7.3. 概率计算问题</a></li>
<li><a href="#org0000082">1.7.4. 学习问题</a></li>
<li><a href="#org0000087">1.7.5. 解码问题</a></li>
<li><a href="#org000008a">1.7.6. 应用举例: 词性标注</a></li>
<li><a href="#org000008d">1.7.7. 应用举例: 拼音输入法</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org0000093" class="outline-2">
<h2 id="org0000093"><span class="section-number-2">1.</span> 统计学习方法</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org0000000" class="outline-3">
<h3 id="org0000000"><span class="section-number-3">1.1.</span> 概论</h3>
<div class="outline-text-3" id="text-1-1">
<ol class="org-ol">
<li>概率模型(P(y|x)与非概率模型 (y=f(x))</li>
<li>模型(线性, 概率&#x2026;) + 策略 ( 损失函数, hypothesis func&#x2026;)+算法
(sgd&#x2026;)</li>
<li>过拟合测试时性能不好是因为训练数据中包含噪声</li>
<li>regularization 是结构最小化的一种方法,
目的是使算法能选择结构最小化的模型, 符合 occam's razor 原则</li>
<li>生成模型与判别模型

<ul class="org-ul">
<li>生成模型学习 P(X,Y), 然后再利用条件概率推导出 P(Y|X) 进行分类</li>
<li>判别模型直接学习 P(Y|X)</li>
<li>生成模型学习到的是联合概率分布, 所以可以用来=生成=数据: 选择 P(X,Y)
较大的 值作为生成的数据, 较小的不考虑.</li>
<li>例如, X 包括 {高矮, 丑美, 贫富&#x2026;}, Y 包含 {嫁/不嫁},
如果学习到了P(X,Y), 我们可以选择一个 P(X,Y) 较大的数据,
并认为它是现实了可能存在的一个样本,例如 {高, 丑, 富 -&gt; 嫁}.
但如果我们学习到的是 P(Y|X), 我们只知道 X 成立时 Y会成 立(例如 {高,
美,富 -&gt; 嫁}), 但这个样本在现实中是否存在并不知道</li>
</ul></li>

<li>分类器性能评价

<ul class="org-ul">
<li><p>
accuracy
</p>

<p>
预测的正确率
</p></li>

<li><p>
precision
</p>

<p>
预测为正类的 case 中的正确率: 查准率
</p></li>

<li><p>
recall
</p>

<p>
实际为正类的 case 中的正确率: 查全率
</p></li>

<li><p>
P 和 R 没有直接关系但经常会相互制约
</p>

<p>
为了提高查全率, 算法会倾向于预测为真, 导致查准率下降为了提高查准率, 算法会倾向于预测为假, 导致查全率下降
</p></li>

<li><p>
F1
</p>

<p>
F1 是 P 和 R 的调和均值<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>
</p>

<p>
\(\frac{2}{F_1}=\frac{1}{P}+\frac{1}{R}\)
</p></li>

<li><p>
为什么需要 P 和 R
</p>

<p>
假设测试集中正例为 90%, 反例为 10%, 预测模型 A 预测的正确率是 70%, 另一个模型 B 简单的把所有样本都预测为正例, 所以它的正确率是 90%&#x2026;那么对于这样正例很多的问题, 是否简单的都预测为正例就是好的模型?　
</p>

<p>
对于模型　A, 有可能它预测为正类的都是对的, 但有些正类被预测为负类, 导致正确率不高, 但它的 P 却是 100%, 即模型 A　预测正类时比较保守. 相对来说, 模型 B
的　P 只有 90%. 所以如果现在的任务是`务必从测试集中选出一个正类`, 则模型 A
更好一些.
</p></li>
</ul></li>
</ol>
</div>
</div>

<div id="outline-container-org0000006" class="outline-3">
<h3 id="org0000006"><span class="section-number-3">1.2.</span> 感知机</h3>
<div class="outline-text-3" id="text-1-2">
<ol class="org-ol">
<li>感知机 (perceptron) 是 NN 和 SVM 的基础</li>

<li>把实例划分为正负两类的超平面, 实例的类别分别取 +1, -1, 假设函数为 \(\hat
   y=sign(wx+b)\)</li>

<li><p>
损失函数
</p>

<p>
损失函数定义为误分类的点到超平面的几何距离之和, 即
\(-\frac{1}{||w||}\sum{y_i*(wx_i+b)}\).
</p>

<p>
对 \(w\) 和 \(b\) 进行等比例缩放时并不改变超平面的位置, 即最终 \(w\), \(b\) 会有无数多组解, 不妨选择 \(||w||=1\) 那个解
</p>

<p>
最终的损失函数 为 \(-\sum{y_i*(wx_i+b)}\) (针对误分类的点), 或者使用 hinge loss
表示: \(\sum{\max{(0,-y_i(wx_i+b))}}\) (针对所有的点)
</p></li>

<li><p>
单个 perceptron 无法解决异或问题, 因为它是一个线性模型.
</p>


<div id="org0000003" class="figure">
<p><img src="../extra/perceptron_xor.png" alt="perceptron_xor.png" />
</p>
</div></li>

<li><p>
多个 perceptron 构成网络后可以解决异或问题, 因为整个网络因为中间 perceptron
节点的 sign 函数变为非线性.
</p>

<p>
用一个 perceptron 可以实现 nand gate, 而多个 nand gate 组成网络后可以实现 xor
gate
</p>


<div id="org0000004" class="figure">
<p><img src="../extra/xor.png" alt="xor.png" />
</p>
</div></li>

<li>可以通过简单的变换把 perceptron 输出的范围从 (-1,+1) 变为 (0,1): 把之前的假设函数和损失函数中的 \(y\) 换成 \(2y-1\) 即可</li>

<li><p>
使用 perceptron 可以构造网络, 但无法构造神经网络, 因为单个 perceptron 的输出是阶跃函数 (step function), 不适用于梯度下降. 在神经网络中, 基本单元是
sigmoid neuron, 它和perceptron 基本相同, 但输出换成为可导的 sigmoid 函数.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> matplotlib.pyplot <span class="org-keyword">as</span> plt

plt.style.use(<span class="org-string">"classic"</span>)

<span class="org-variable-name">x</span> = np.linspace(-10, 10, 1000)
<span class="org-variable-name">y1</span> = 1 / (1 + np.exp(-x))
<span class="org-variable-name">y2</span> = (np.sign(x) + 1) / 2.
plt.ylim(-1.5,1.5)
plt.plot(x, y1,label=<span class="org-string">"sigmoid"</span>)
plt.plot(x, y2,label=<span class="org-string">"perceptron"</span>)
plt.axhline(0, color=<span class="org-string">"black"</span>)
plt.axvline(0, color=<span class="org-string">"black"</span>)
plt.legend()
plt.show()
</pre>
</div>


<div id="org0000005" class="figure">
<p><img src="../extra/perceptron_sigmoid.png" alt="perceptron_sigmoid.png" />
</p>
</div></li>
</ol>
</div>
</div>

<div id="outline-container-org0000021" class="outline-3">
<h3 id="org0000021"><span class="section-number-3">1.3.</span> 朴素贝叶斯</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-org0000009" class="outline-4">
<h4 id="org0000009"><span class="section-number-4">1.3.1.</span> 概率</h4>
<div class="outline-text-4" id="text-1-3-1">
<ul class="org-ul">
<li><p>
条件概率公式
</p>

<p>
\(P(y|x)=\frac{P(y,x)}{P(x)}\)
</p></li>

<li><p>
全概率公式
</p>

<p>
\(P(x)=\sum_k{(P(x|y_k)*P(y_k))}\)
</p></li>

<li><p>
条件独立假设
</p>

<p>
\(P(x|y)=\prod_i{P(x_i|y)}\)
</p></li>

<li><p>
贝叶斯公式
</p>

<p>
\(P(y|x)=\frac{P(x|y)*P(y)}{P(x)}\)
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org000000c" class="outline-4">
<h4 id="org000000c"><span class="section-number-4">1.3.2.</span> 朴素贝叶斯方法</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
naive Bayesian 方法基于贝叶斯公式和条件独立假设, 其公式为:
</p>

<ol class="org-ol">
<li>\(P(y_j|x)=\frac{P(x|y_j)*P(y_j)}{P(x)}\)</li>
<li>\(P(x|y_j)\) 使用条件独立假设替换为 \(\prod_i{P(x_i|y_j)}\)</li>
<li>\(P(x)\) 使用全概率公式替换为 \(\sum_k{(P(x|y_k)*P(y_k))}\)</li>
<li>\(P(x|y_k)\) 使用条件独立假设替换为 \(\prod_i{P(x_i|y_k)}\)</li>
<li><p>
最终的朴素贝叶斯方法的公式为:
</p>

<p>
\(P(y_j|x)=\frac{P(y_j)*\prod_i{P(x_i|y_j)}}{\sum_k{(P(y_k)*\prod_i{P(x_i|y_k))}}}\)
</p></li>

<li>使用朴素贝叶斯方法分类时, 我们需要求的是
\(y=argmax_{y_j}(P(y_j|x))\), 即 给定 \(x\), 哪个 \(y_j\) 的概率最大?</li>
</ol>
</div>
</div>

<div id="outline-container-org000000f" class="outline-4">
<h4 id="org000000f"><span class="section-number-4">1.3.3.</span> 极大似然估计<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup></h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
假设事件 A 发生的概率 P 未知, 通过 K+J 次伯努利实验, 发现 A 发生了 K次, 此事件服从二项分布, 其概率为 \(C_{K+J}^K P^K*(1-P)^{J}\), P 取多少时这个概率最大? 通过求导可以确认\(P=\frac{K}{K+J\) 时概率最大.
</p>

<p>
在朴素贝叶斯方法中, 学习意味着估计 \(P(y_j)\) 和 \(P(x_i|y_j)\)
</p>

<p>
\(P(y_j)\) 的极大似然估计为 \(\frac{\sum_{k=1}^N{I(y_j=y_k)}}{N}\)<sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup>
</p>

<p>
\(P(x_i|y_j)\) 的极大似然估计为
\(\frac{\sum_{k=1}^N{I(x_k=x_i, y_k=y_j)}}{\sum_{k=1}^N{I(y_k=y_j)}}\)
</p>
</div>
</div>

<div id="outline-container-org0000012" class="outline-4">
<h4 id="org0000012"><span class="section-number-4">1.3.4.</span> 为什么需要使用条件独立假设</h4>
<div class="outline-text-4" id="text-1-3-4">
<p>
若直接计算 \(P(x|y_k)\), 假设 x 包含 L 个 feature (\(x_1,x_2,\ldots x_S\)), 每个
\(x_i\) 有 \(S_i\) 种取值, 一共有\(\prod\limits_{i=1}^L{S_i}\) 中可能, 训练集的规模与这个相差很大,直接估计 \(P(x|y_k)\) 会不准确 (有可能都是 0)
</p>

<p>
同理, 我们无法直接估计 \(P(x,y_k)\)
</p>
</div>
</div>

<div id="outline-container-org0000015" class="outline-4">
<h4 id="org0000015"><span class="section-number-4">1.3.5.</span> 生成模型</h4>
<div class="outline-text-4" id="text-1-3-5">
<p>
朴素贝叶斯方法使用 \(P(Y|X)\) 来分类, 但它在前面已经得到了 \(P(X,Y)\),所以它是一种生成模型
</p>
</div>
</div>

<div id="outline-container-org0000018" class="outline-4">
<h4 id="org0000018"><span class="section-number-4">1.3.6.</span> 举例</h4>
<div class="outline-text-4" id="text-1-3-6">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">3</th>
<th scope="col" class="org-right">4</th>
<th scope="col" class="org-right">5</th>
<th scope="col" class="org-right">6</th>
<th scope="col" class="org-right">7</th>
<th scope="col" class="org-right">8</th>
<th scope="col" class="org-right">9</th>
<th scope="col" class="org-right">10</th>
<th scope="col" class="org-right">11</th>
<th scope="col" class="org-right">12</th>
<th scope="col" class="org-right">13</th>
<th scope="col" class="org-right">14</th>
<th scope="col" class="org-right">15</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">x1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">2</td>
<td class="org-right">2</td>
<td class="org-right">2</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
<td class="org-right">3</td>
<td class="org-right">3</td>
<td class="org-right">3</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">x2</td>
<td class="org-right">S</td>
<td class="org-right">M</td>
<td class="org-right">M</td>
<td class="org-right">S</td>
<td class="org-right">S</td>
<td class="org-right">S</td>
<td class="org-right">M</td>
<td class="org-right">M</td>
<td class="org-right">L</td>
<td class="org-right">L</td>
<td class="org-right">L</td>
<td class="org-right">M</td>
<td class="org-right">M</td>
<td class="org-right">L</td>
<td class="org-right">L</td>
</tr>

<tr>
<td class="org-left">Y</td>
<td class="org-right">-1</td>
<td class="org-right">-1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">-1</td>
<td class="org-right">-1</td>
<td class="org-right">-1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">-1</td>
</tr>
</tbody>
</table>

<p>
x1=2, x2=S 时, Y=?
</p>

<ol class="org-ol">
<li>计算 \(P(x1=2,x2=S,y=1)\)

<ol class="org-ol">
<li>\(P(y=1)=\frac{\sum_{k=1}^N{I(y_j=y_k)}}{N}=\frac{9}{15}\)</li>
<li>\(P(x1=2,x2=S|y=1)=P(x1=2|y=1)*P(x2=S|y=1)=\frac{3}{9}*\frac{1}{9}=\frac{3}{81}\)</li>
<li>\(P(x1=2,x2=S,y=1)=P(y=1)*P(x1=2,x2=S|y=1)=\frac{9}{15}*\frac{3}{81}=\frac{1}{45}\)</li>
</ol></li>

<li>计算 \(P(x1=2,x2=S,y=-1)\)

<ol class="org-ol">
<li>\(P(y=-1)=\frac{\sum_{k=1}^N{I(y_j=y_k)}}{N}=\frac{6}{15}\)</li>
<li>\(P(x1=2,x2=S|y=-1)=P(x1=2|y=-1)*P(x2=S|y=-1)=\frac{2}{6}*\frac{3}{6}=\frac{1}{6}\)</li>
<li>\(P(x1=2,x2=S,y=-1)=P(y=-1)*P(x1=2,x2=S|y=-1)=\frac{6}{15}*\frac{1}{6}=\frac{1}{15}\)</li>
</ol></li>

<li>因为 \(P(x1=2,x2=S,y=-1) > P(x1=2,x2=S,y=1)\), 所以结果为 -1</li>
</ol>
</div>
</div>

<div id="outline-container-org000001b" class="outline-4">
<h4 id="org000001b"><span class="section-number-4">1.3.7.</span> 拉普拉斯平滑</h4>
<div class="outline-text-4" id="text-1-3-7">
<p>
使用极大似然估计时, 可能会因为训练集过小导致估计出的 \(P(x_i|y_j)\) 或\(P(y_j)\) 为
0, 可以通过加上一个小的系数避免这种情况,称为拉普拉斯平滑, 公式 为:
</p>

<p>
\(P(x_i|y_i)=\frac{\sum_{k=1}^N{I(x_k=x_i,
y_k=y_j)}+1}{\sum_{k=1}^N{I(y_k=y_j)}+S_i}\),其中 \(S_i\) 表示 \(x_i\) 有 \(S_i\) 种 值
</p>

<p>
\(P(y_i)=\frac{\sum_{k=1}^N{I(y_j=y_k)}+1}{N+K}\), 其中 \(K\) 表示 \(y\) 为\(K\) 种值
</p>
</div>
</div>

<div id="outline-container-org000001e" class="outline-4">
<h4 id="org000001e"><span class="section-number-4">1.3.8.</span> 高斯朴素贝叶斯方法</h4>
<div class="outline-text-4" id="text-1-3-8">
<p>
当 x 是连续值时, 采用上述的方法会导致大量的 \(P(x_i|y_j)\) 为零(不做平滑时), 不能反映真实情况, 这时可以假设 \(P(x_i|y_j)\) 服从高斯分布, 通过样本计算出 \(\mu\) 和
\(\delta\),然后通过高斯分布的概率密度函数计算出 \(P(x_i|y_j)\)
</p>
</div>
</div>
</div>

<div id="outline-container-org000003b" class="outline-3">
<h3 id="org000003b"><span class="section-number-3">1.4.</span> 决策树</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-org0000025" class="outline-4">
<h4 id="org0000025"><span class="section-number-4">1.4.1.</span> 决策树的表示</h4>
<div class="outline-text-4" id="text-1-4-1">
<ol class="org-ol">
<li>决策树的中间节点表示特征, 叶节点表示分类</li>
<li><p>
由决策树根节点到叶结点的每一条路径构成一个=规则=,这些规则是=互斥且完备=的,即特征空间上的每个特征向量都对应且仅对应一条路径或规则. 另外,
可以把=规则=看成 特征空间上的一个=划分=, 这些=划分=是互斥且完备的
</p>


<div id="org0000024" class="figure">
<p><img src="../extra/decision_tree.png" alt="decision_tree.png" />
</p>
</div></li>
</ol>
</div>
</div>

<div id="outline-container-org0000028" class="outline-4">
<h4 id="org0000028"><span class="section-number-4">1.4.2.</span> 决策树算法的三个过程:</h4>
<div class="outline-text-4" id="text-1-4-2">
<ol class="org-ol">
<li>特征选择</li>
<li>决策树生成</li>
<li>决策树剪枝</li>
</ol>
</div>
</div>

<div id="outline-container-org000002b" class="outline-4">
<h4 id="org000002b"><span class="section-number-4">1.4.3.</span> 特征选择</h4>
<div class="outline-text-4" id="text-1-4-3">
<p>
特征选择是为了提高决策树的学习效率: 每一个中间节点可以使用不同的特征进行分类, 选择哪一个特征最合适? 选择 <code>信息增益大</code> 的特征
</p>
</div>
</div>

<div id="outline-container-org000002f" class="outline-4">
<h4 id="org000002f"><span class="section-number-4">1.4.4.</span> 信息增益</h4>
<div class="outline-text-4" id="text-1-4-4">
<ol class="org-ol">
<li><p>
熵
</p>

<p>
设 X 是一个离散随机变量, 其概率分布为 \(P(X=x_i)=p_i, i=1,2,\ldots,n\) X 的熵定义为 \(H(X)=-\sum\limits_1^n{p_i*\log{p_i}}\)
</p>

<p>
熵反映了随机变量的不确定性, 假设 X 服从 0-1 分布,
\(H(X)=-p*\log{p}-(1-p)*\log{(1-p)}\) 随 p 变化的情况为:
</p>

<div class="org-src-container">
<pre class="src src-ipython">%matplotlib inline
<span class="org-keyword">import</span> matplotlib.pyplot <span class="org-keyword">as</span> plt
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-variable-name">x</span> = np.linspace(0.001, 0.999, 100)
<span class="org-variable-name">y</span> = -x * np.log(x) - (1 - x) * np.log(1 - x)
plt.plot(x, y)
</pre>
</div>

<pre class="example">
[&lt;matplotlib.lines.Line2D at 0x7fc2f728e7f0&gt;]
</pre>


<div id="org000002e" class="figure">
<p><img src="../extra/entropy.png" alt="entropy.png" />
</p>
</div>

<p>
当 p=0 或 1 时, H(X)=0, X 完全没有不确定性, 当 p=0.5 时, X 的不确定性最大
</p></li>

<li><p>
条件熵
</p>

<p>
条件熵 \(H(Y|X)\) 定义为在 X 的条件下 Y 的不确定性:
\(H(Y|X)=\sum_i{p_i*H(Y|x_i)}\), 其中 \(p_i=P(X=x_i)\)
</p></li>

<li><p>
信息增益
</p>

<p>
信息增益即 \(H(Y)-H(Y|X)\), 即已知 X 的情况下不确定性减少多少. 在选择特征时,
我们倾向于选择使得信息增益最大的, 或者说使条件熵最小的 X. 直观的理解是:
</p>

<p>
<code>如果 $P(Y|x_i)$ 普遍都很大(或很小), 说明 X 可以很好的对 Y 进行区分, 而不是模棱两可的状态</code>
</p></li>

<li><p>
举例
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">年龄</th>
<th scope="col" class="org-left">工作</th>
<th scope="col" class="org-left">房子</th>
<th scope="col" class="org-left">信贷情况</th>
<th scope="col" class="org-left">可否贷款</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">青年</td>
<td class="org-left">N</td>
<td class="org-left">N</td>
<td class="org-left">一般</td>
<td class="org-left">N</td>
</tr>

<tr>
<td class="org-left">青年</td>
<td class="org-left">N</td>
<td class="org-left">N</td>
<td class="org-left">好</td>
<td class="org-left">N</td>
</tr>

<tr>
<td class="org-left">青年</td>
<td class="org-left">Y</td>
<td class="org-left">N</td>
<td class="org-left">好</td>
<td class="org-left">Y</td>
</tr>

<tr>
<td class="org-left">青年</td>
<td class="org-left">Y</td>
<td class="org-left">Y</td>
<td class="org-left">一般</td>
<td class="org-left">Y</td>
</tr>

<tr>
<td class="org-left">青年</td>
<td class="org-left">N</td>
<td class="org-left">N</td>
<td class="org-left">一般</td>
<td class="org-left">N</td>
</tr>

<tr>
<td class="org-left">中年</td>
<td class="org-left">N</td>
<td class="org-left">N</td>
<td class="org-left">一般</td>
<td class="org-left">N</td>
</tr>

<tr>
<td class="org-left">中年</td>
<td class="org-left">N</td>
<td class="org-left">N</td>
<td class="org-left">好</td>
<td class="org-left">N</td>
</tr>

<tr>
<td class="org-left">中年</td>
<td class="org-left">Y</td>
<td class="org-left">Y</td>
<td class="org-left">好</td>
<td class="org-left">Y</td>
</tr>

<tr>
<td class="org-left">中年</td>
<td class="org-left">N</td>
<td class="org-left">Y</td>
<td class="org-left">非常好</td>
<td class="org-left">Y</td>
</tr>

<tr>
<td class="org-left">中年</td>
<td class="org-left">N</td>
<td class="org-left">Y</td>
<td class="org-left">非常好</td>
<td class="org-left">Y</td>
</tr>

<tr>
<td class="org-left">老年</td>
<td class="org-left">N</td>
<td class="org-left">Y</td>
<td class="org-left">非常好</td>
<td class="org-left">Y</td>
</tr>

<tr>
<td class="org-left">老年</td>
<td class="org-left">N</td>
<td class="org-left">Y</td>
<td class="org-left">好</td>
<td class="org-left">Y</td>
</tr>

<tr>
<td class="org-left">老年</td>
<td class="org-left">Y</td>
<td class="org-left">N</td>
<td class="org-left">好</td>
<td class="org-left">Y</td>
</tr>

<tr>
<td class="org-left">老年</td>
<td class="org-left">Y</td>
<td class="org-left">N</td>
<td class="org-left">非常好</td>
<td class="org-left">Y</td>
</tr>

<tr>
<td class="org-left">老年</td>
<td class="org-left">N</td>
<td class="org-left">N</td>
<td class="org-left">一般</td>
<td class="org-left">N</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li><p>
\(H(Y)\)
</p>

<p>
\(P(Y=不贷款)=\frac{6}{15}\)
\(P(Y=贷款)=\frac{9}{15}\)
</p>

<p>
\(H(Y)=-\frac{6}{15}*\log{\frac{6}{15}}-\frac{9}{15}*\log{\frac{9}{15}}\)
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
-6 / 15. * np.log2(6 / 15.) - 9 / 15. * np.log2(9 / 15.)
</pre>
</div>

<pre class="example">
0.9709505944546686
</pre></li>

<li><p>
\(H(Y|工作)\)
</p>

<p>
\(P(Y=贷款|有工作)=\frac{5}{5}\)
\(P(Y=不贷款|有工作)=\frac{0}{5}\)
</p>

<p>
\(P(Y=贷款|没工作)=\frac{4}{10}\)
\(P(Y=不贷款|没工作)=\frac{6}{10}\)
</p>

<p>
\(P(有工作)=\frac{5}{15}\)
\(P(没工作)=\frac{10}{15}\)
</p>

<p>
\(H(Y|工作)=P(有工作)*H(Y|有工作)+P(没工作)*H(Y|没工作)\)
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-variable-name">p_yy</span> = 1
<span class="org-variable-name">p_ny</span> = 1 - p_yy
<span class="org-variable-name">p_yn</span> = 0.4
<span class="org-variable-name">p_nn</span> = 1 - p_yn
<span class="org-variable-name">p_work</span> = 5 / 15.
<span class="org-variable-name">p_nwork</span> = 1 - p_work

<span class="org-keyword">def</span> <span class="org-function-name">entropy</span>(*P):
    <span class="org-variable-name">ret</span> = 0
    <span class="org-keyword">for</span> p <span class="org-keyword">in</span> P:
        <span class="org-keyword">if</span> p!=0:
            <span class="org-variable-name">ret</span> += -p * np.log2(p)
    <span class="org-keyword">return</span> ret

<span class="org-variable-name">H</span> = p_work * entropy(p_yy, p_ny) + p_nwork * entropy(p_yn, p_nn)
H
</pre>
</div>

<pre class="example">
0.6473003963031124
</pre></li>

<li><p>
\(H(Y|有房子)\)
\(P(Y=贷款|有房子)=\frac{6}{6}\)
\(P(Y=不贷款|有房子)=\frac{0}{6}\)
</p>

<p>
\(P(Y=贷款|没房子)=\frac{3}{9}\)
\(P(Y=不贷款|没房子)=\frac{6}{9}\)
</p>

<p>
\(P(有房子)=\frac{6}{15}\)
\(P(没房子)=\frac{9}{15}\)
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-variable-name">p_yy</span> = 1
<span class="org-variable-name">p_ny</span> = 1 - p_yy
<span class="org-variable-name">p_yn</span> = 1/3.
<span class="org-variable-name">p_nn</span> = 1 - p_yn
<span class="org-variable-name">p_house</span> = 6 / 15.
<span class="org-variable-name">p_nhouse</span> = 1 - p_house

<span class="org-variable-name">H</span> = p_house * entropy(p_yy, p_ny) + p_nhouse * entropy(p_yn, p_nn)
H
</pre>
</div>

<pre class="example">
0.5509775004326937
</pre>

<p>
可见`房子`的条件熵更小, 表示`是否有房子`确定后, `是否贷款`的不确定性更小,所以我们优先选择`房子`这个特征而不是`工作`这个特征
</p></li>
</ul></li>
</ol>
</div>
</div>

<div id="outline-container-org0000032" class="outline-4">
<h4 id="org0000032"><span class="section-number-4">1.4.5.</span> 决策树的生成: ID3 算法</h4>
<div class="outline-text-4" id="text-1-4-5">
<p>
ID3 算法根据 <code>信息增益最大化</code> 的原则选择特征, 递归的构造决策树.
</p>

<p>
ID3 算法主要逻辑是判断数据是否可分, 如果可分则根据信息增益最大化的原则选择一个特征,根据这个特征的取值个数把数据分为几类, 构造中间节点, 然后递归去分类. 如果不可分(所有数据都属于同一类, 或所有数据都有相同的特征, 或者增益过小&#x2026;), 则不再分类,
构造叶节点, 且叶节点的类别由当前数据集中最多的那个类别决定
</p>
</div>
</div>

<div id="outline-container-org0000035" class="outline-4">
<h4 id="org0000035"><span class="section-number-4">1.4.6.</span> 决策树的剪枝</h4>
<div class="outline-text-4" id="text-1-4-6">
<p>
通过剪枝可以为了减少决策树的过拟合. 通过剪枝, 减少树的复杂度, 相当于结构最小化.
</p>

<p>
剪枝时自底向上的考查每一个中间节点: 把中间节点替换为叶节点, 并使用子树包含的D 中最多的类型做为叶节点的类别.然后在验证集上测试, 若准确率有提高, 则删除整个子树,
把中间节点替换为叶节点.
</p>
</div>
</div>

<div id="outline-container-org0000038" class="outline-4">
<h4 id="org0000038"><span class="section-number-4">1.4.7.</span> 为什么使用信息增益来选择</h4>
<div class="outline-text-4" id="text-1-4-7">
<p>
实际应用中, 决策树算法只会选择有限个信息增益最大的特征而不是使用所有特征, 原因有两个:
</p>

<ol class="org-ol">
<li>特征越多, 分析训练的时间越长. 树形结构决定了算法复杂度随特征的数目指数上升</li>
<li>特征越多, 模型越复杂, 越容易过拟合</li>
</ol>

<p>
所以决策树通过选择有限个 <code>信息增益最大的特征</code> 使得系统在保证复杂度较小的前提下达到系统熵较小
</p>
</div>
</div>
</div>

<div id="outline-container-org0000049" class="outline-3">
<h3 id="org0000049"><span class="section-number-3">1.5.</span> logistic 回归</h3>
<div class="outline-text-3" id="text-1-5">
</div>
<div id="outline-container-org0000040" class="outline-4">
<h4 id="org0000040"><span class="section-number-4">1.5.1.</span> logistic 分布</h4>
<div class="outline-text-4" id="text-1-5-1">
<ul class="org-ul">
<li><p>
密度函数
</p>

<p>
\(f(x)=\frac{e^{-(x-\mu)/\lambda}}{\lambda*(1+e^{-(x-\mu)/\lambda})^2}\)
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> matplotlib.pyplot <span class="org-keyword">as</span> plt

<span class="org-variable-name">x</span> = np.linspace(-10, 10, 10000)
<span class="org-variable-name">y</span> = np.exp(-x) / np.power(1 + np.exp(-x), 2)
plt.axhline(0, color=<span class="org-string">"black"</span>)
plt.axvline(0, color=<span class="org-string">"black"</span>)

plt.plot(x, y)
plt.show()
</pre>
</div>


<div id="org000003e" class="figure">
<p><img src="../extra/logistic1.png" alt="logistic1.png" />
</p>
</div></li>
<li><p>
分布函数
</p>

<p>
\(F(x)=\int\limits_{-\infty}^{x}f(x)dx=\frac{1}{1+e^{-(x-\mu)/\lambda}}\)
</p>

<p>
取 \(\mu=0\) 和 \(\lambda=1\) 时, \(F(x)\) 即常见的 sigmoid 函数 \(\frac{1}{1+e^{-x}}\)
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> matplotlib.pyplot <span class="org-keyword">as</span> plt

plt.style.use(<span class="org-string">"classic"</span>)
<span class="org-variable-name">x</span> = np.linspace(-10, 10, 10000)
<span class="org-variable-name">y</span> = 1 / (1 + np.exp(-x))
plt.axhline(0, color=<span class="org-string">"black"</span>)
plt.axvline(0, color=<span class="org-string">"black"</span>)

plt.plot(x, y)
plt.show()
</pre>
</div>


<div id="org000003f" class="figure">
<p><img src="../extra/logistic2.png" alt="logistic2.png" />
</p>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-org0000043" class="outline-4">
<h4 id="org0000043"><span class="section-number-4">1.5.2.</span> 二项 logistic 回归</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
用 \(P(Y|X)\) 表示, 其中 Y 的值为 1 或 0.
</p>

<p>
\(P(y=1|x)=\frac{1}{1+e^{-(wx+b)}}=\frac{e^{wx+b}}{1+e^{wx+b}}\)
</p>

<p>
上式也可以写作 \(\ln{\frac{P(y=1|x)}{1-P(y=1|x)}}=wx+b\), 其中
\(\ln{\frac{p}{1-p}}\) 称为对数几率 (log odds 或 logit)
</p>
</div>
</div>

<div id="outline-container-org0000046" class="outline-4">
<h4 id="org0000046"><span class="section-number-4">1.5.3.</span> 二项 logistic 回归的模型参数估计</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
设 \(P(y=1|x) = \pi(x)\), \(P(y=0|x)=1-\pi(x)\)
</p>

<p>
训练集中有 N 个样本 \((x_i,y_i)\), 使用 MLE (极大似然估计), 似然函数为:
</p>

<p>
\(L=\prod_{i=1}^N{\pi(x_i)^{y_i}*\big(1-\pi(x_i)\big)^{1-y_i}}\)
</p>

<p>
实际上它就是 N 个样本的联合概率
</p>

<p>
把 \(L\) 转换为最小化问题:
</p>

<p>
\(-\ln{L}=\sum_{i=1}^{N}{-y_i*\ln(\pi(x_i))-(1-y_i)*\big(\ln(1-\pi{(x_i))}\big)}\)
</p>

<p>
即 logistic 回归的交叉熵损失函数
</p>
</div>
</div>
</div>

<div id="outline-container-org0000076" class="outline-3">
<h3 id="org0000076"><span class="section-number-3">1.6.</span> 支持向量机</h3>
<div class="outline-text-3" id="text-1-6">
</div>
<div id="outline-container-org000004c" class="outline-4">
<h4 id="org000004c"><span class="section-number-4">1.6.1.</span> 拉格朗日乘子法</h4>
<div class="outline-text-4" id="text-1-6-1">
<ol class="org-ol">
<li><p>
拉格朗日乘子法
</p>

<p>
拉格朗日乘子法(lagrange multiplier) 用来求解函数在约束条件下的极值问题.
</p>

<p>
例如, 求 \(f(x,y)=x^2y\) 的极值, 约束条件为 \(g(x,y)=x^2+y^2-1=0\)
</p>

<p>
一种方法是消元, 根据约束条件主把 \(x^2\) 替换为 \(1-y^2\) 后代入 \(f(x,y)\) 求极值.
但有时对于复杂的问题这种方法并不容易, 这时可以使用拉格朗日乘子法.
</p>

<p>
\(\phi(x,y,\lambda)=f(x,y)+\lambda g(x,y)\)
</p>

<p>
对 \(x\),\(y\),\(\lambda\) 求偏导:
</p>

<p>
\(\frac{\partial\phi}{\partial x}=2xy+2\lambda x=0\)
</p>

<p>
\(\frac{\partial\phi}{\partial y}=x^2+2\lambda y=0\)
</p>

<p>
\(\frac{\partial\phi}{\partial\lambda}=x^2+y^2-1=0\)
</p>

<p>
可得 \(x=\pm\frac{\sqrt{6}}{3}\), \(y=\pm\frac{\sqrt{3}}{3}\), \(\lambda=-y\) 时, \(f(x,y)\) 有极值
</p>

<p>
当存在多个约束条件 \(g(x,y)\), \(k(x,y)\) &#x2026;时,
</p>

<p>
\(\phi(x,y,\lambda,\beta\,\ldots)=f(x,y)+\lambda g(x,y)+\beta k(x,y)+\ldots\)
</p></li>
<li><p>
不等式约束条件
</p>

<p>
上面提到的 \(g(x,y)\), \(k(x,y)\) 等都是等式约束, 如果约束条件变为 \(g(x,y)<=0\)
怎么办?
</p>

<p>
定义广义的拉格朗日函数:
</p>

<p>
\(l(x,\alpha,\beta)=f(x)+\sum_i{\alpha_i c_i(x)}+\sum_i{\beta_i h_i(x)}\)
</p>

<p>
其中 \(c_i(x)<=0\), \(h_i(x)=0\)
</p>

<p>
由于 \(c_i(x)\) 不是等式约束, 所以 \(f(x)\) 取得极值有两种情况:
</p>

<ol class="org-ol">
<li>\(f(x)\) 的极值点位于\(c_i(x)\) 上, 即 \(c_i(x)=0\)</li>

<li>\(f(x)\) 无约束的极值点本身就位于\(c_i(x)\) 内部, 即 \(c_i(x)\) 约束等于不存在,
\(\alpha_i=0\)</li>
</ol>

<p>
<a href="../extra/kkt.png">kkt</a>
</p>

<p>
综上, 符合以下条件时可以得到 \(f(x)\) 极值
</p>

<ol class="org-ol">
<li>\(\frac{\partial l}{\partial x}=0\)</li>

<li>\(h_i(x)=0\)</li>

<li>\(\alpha_i c_i(x)=0\)</li>

<li>\(\alpha_i \geqslant 0\)</li>
</ol>

<p>
上面的条件称为 kkt 条件 <a href="http://www.onmyphd.com/?p=kkt.karush.kuhn.tucker">kkt</a>   
</p></li>
<li><p>
kkt 举例
</p>

<p>
\(f(p)=\sum_{i=1}^n{ln(1+\frac{p_i}{n_i})}\)
</p>

<p>
其中 \(\sum{p_i}<=p\), \(p_i>=0\)
</p>

<p>
\(l(p, \mu)=\sum_{i=1}^{n}ln(1+\frac{p_i}{n_i})+\mu_0(\sum_{i=1}^{n}{p_i}-p)+\sum_{i=1}^{n}{\mu_i(-p_i)}\)
</p>

<p>
\(\frac{\partial{l}}{\partial{p_i}}=\frac{1}{p_i+n_i}-\mu_0+\mu_i=0 \implies p_i+n_i=\frac{1}{\mu_0-\mu_i}\)
</p>

<p>
\(n_i>0\implies \mu_0>\mu_i \implies \mu_0>0 \implies P=\sum{p_i}\)
</p>

<p>
所以 \(p_i>0 \implies \mu_i=0 \implies p_i=\frac{1}{\mu_0}-n_i\)
</p>

<p>
再由 \(P=\sum{p_i}\), 得到 \(p_i\) 的值
</p></li>
<li>拉格朗日对偶问题</li>
</ol>
</div>
</div>

<div id="outline-container-org000004f" class="outline-4">
<h4 id="org000004f"><span class="section-number-4">1.6.2.</span> 支持向量机</h4>
<div class="outline-text-4" id="text-1-6-2">
<p>
给定线性可分的的训练集 \(\{(x_i,y_i),\ldots \}\), \(y_i\in\{1,-1\}\) 通过 <code>间隔最大化</code> 学习到的超平面为 \(wx+b\), 相应的假设函数为 \(f(x)=sign(wx+b)\), 称为线性可分支持向量机或硬间隔支持向量机
</p>
</div>
</div>

<div id="outline-container-org0000052" class="outline-4">
<h4 id="org0000052"><span class="section-number-4">1.6.3.</span> 点到超平面的距离</h4>
<div class="outline-text-4" id="text-1-6-3">
<p>
考虑两个向量 \(\alpha,\beta\), \(\alpha\) 在 \(\beta\) 上的投影长度为
\(\frac{\alpha^T\times \beta}{||\beta||}\), 对于超平面 \(wx+b\), \(w\) 为法向量,
垂直于超平面, b 为截距, 所以点 \(x_i\) 到超平面的距离为 \(x_i\) 在 \(w\) 上的投影加上截距, 即 \(\gamma_i=\frac{wx_i}{||w||}+\frac{b}{||w||}\), \(\gamma_i\) 有正负之分, 表示 \(x_i\) 在平面的上方或是下方.
</p>

<p>
为了考虑分类正确与否, 我们把点到超平面的距离定义为:
</p>

<p>
\(\gamma_i=y_i*(\frac{wx_i}{||w||}+\frac{b}{||w||})\), 当 \(x_i\) 被正确分类时,
\(\gamma_i\) 为正数, 否则为负数
</p>
</div>
</div>

<div id="outline-container-org0000055" class="outline-4">
<h4 id="org0000055"><span class="section-number-4">1.6.4.</span> 间隔最大化</h4>
<div class="outline-text-4" id="text-1-6-4">
<p>
定义 \(\gamma=min\gamma_i\), 所谓间隔最大化, 是为了使 \(\gamma\) 最大化
</p>

<p>
对于线性可分的训练数据, 可分离超平面有无穷多个(与感知机等价), 但间隔最大化的超平面是唯一的. 间隔最大化直观的解释是, 寻找间隔最大的超平面把数据分开, 意味着更大的确信度对数据分类. 即使对最难分的点, 也尽量把它们分开的足够远
</p>

<ol class="org-ol">
<li>寻找间隔最大超平面的问题可以表示为如下的带约束的最优化问题:

<ul class="org-ul">
<li>约束为 \(\gamma_i \geqslant \gamma\), 即所有点到超平面的距离都大于等于 \(\gamma\)</li>

<li>最大化 \(\gamma\)</li>
</ul></li>

<li>记 \(\gamma\) 的分子部分 \(y_i*(wx_i+b)\) 为 \(\hat{\gamma}\), 则问题变为:

<ul class="org-ul">
<li>最大化 \(\frac{\hat{\gamma}}{||w||}\)</li>

<li>约束为 \(y_i*(wx_i+b) \geqslant \hat{\gamma}\)</li>
</ul></li>

<li><p>
假设该最优化问题的解为 \(\{\hat w, \hat b\}\), 则把 \(\{\hat w, \hat b\}\) 任意等比例缩放为 \(\{\lambda \hat w, \lambda \hat b\}\) 时, 原问题不变.
</p>

<p>
所以原问题可以变为:
</p>

<ul class="org-ul">
<li>最大化 \(\frac{1}{||w||}\)</li>

<li>约束为 \(y_i*(wx_i+b) -1 \geqslant 0\)</li>
</ul></li>

<li>为计算方便, \(||w||\) 可以替换为 \(w^2\), 硬间隔支持向量机最终的优化问题是:

<ul class="org-ul">
<li>最小化 \(\frac{1}{2}w^2\)</li>

<li>约束为 \(1-y_i*(wx_i+b) \leqslant 0\)</li>
</ul></li>
</ol>
</div>
</div>

<div id="outline-container-org0000058" class="outline-4">
<h4 id="org0000058"><span class="section-number-4">1.6.5.</span> 支持向量</h4>
<div class="outline-text-4" id="text-1-6-5">
<p>
训练集样本点中与超平面最近的点称为支持向量, 这些点使得约束
\(y_i*(wx_i+b)-1=0\) 成立, 它们到超平面的距离为 \(\frac{1}{||w||}\)
</p>

<p>
<a href="../extra/support_vector.png">支持向量</a>
</p>
</div>
</div>

<div id="outline-container-org000005c" class="outline-4">
<h4 id="org000005c"><span class="section-number-4">1.6.6.</span> 使用拉格朗日乘子法求解间隔最大化问题</h4>
<div class="outline-text-4" id="text-1-6-6">
<p>
假设训练集只有两个点, 正例为 \(x_1=(3,3)\), 反例为 \(x_3=(1,1)\), 求最大分隔超平面
</p>


<div id="org000005b" class="figure">
<p><img src="../extra/support_vector2.png" alt="support_vector2.png" />
</p>
</div>

<ul class="org-ul">
<li>最小化 \(\frac{1}{2}(w_1^2+w_2^2)\)</li>

<li>约束条件为:

<ul class="org-ul">
<li>\(w_1*3+w_2*3+b-1 \geqslant 0\)</li>

<li>\(-w_1*1-w_2*1-b-1 \geqslant 0\)</li>
</ul></li>
</ul>

<p>
\(L(x, \alpha, \beta)=\frac{1}{2}(w_1^2+w_2^2)+\alpha (1-b-3w_1-3w_2)+\beta
  (1+b+w_1+w_2)\)
</p>

<p>
kkt 条件为:
</p>

<ol class="org-ol">
<li>\(\alpha \geqslant 0\)</li>
<li>\(\beta \geqslant 0\)</li>
<li>\(\alpha (1-b-3w_1-3w_2)=0\)</li>
<li>\(\beta(1+b+w_1+w_2)=0\)</li>
</ol>

<p>
先求偏导得到
</p>

<p>
\(w_1-3\alpha+\beta=0\), \(w_2-3\alpha+\beta=0\), \(\alpha=\beta, w_1=w_2\)
</p>

<p>
有四种情况需要考虑, 但只下下面一种是可行的:
</p>

<p>
\(1-b-3w_1-3w_2=0, 1+b+w_1+w_2=0, \alpha \neq 0, \beta \neq 0\)
</p>

<p>
可得: \(w_1=w_2=\frac{1}{2}, b=-2\)
</p>
</div>
</div>

<div id="outline-container-org000005f" class="outline-4">
<h4 id="org000005f"><span class="section-number-4">1.6.7.</span> 使用梯度下降求解间隔最大化问题</h4>
<div class="outline-text-4" id="text-1-6-7">
<p>
约束条件可以使用 hinge loss 表示为惩罚项, 例如:
</p>

<p>
约束条件为 \(1-y_i(wx_i+b) \leqslant 0\), 我们可以使用
\(hinge\_loss(1-y_i(wx_i+b)\) 表示惩罚项, 其中 \(hinge\_loss(x)=\max(0,x)\)
</p>

<p>
因此间隔最大化问题可以表示为
</p>

<p>
\(loss=\frac{1}{2}w^2+\sum hinge\_loss\big(1-y_i(wx_i+b)\big)\)
</p>
</div>
</div>

<div id="outline-container-org0000062" class="outline-4">
<h4 id="org0000062"><span class="section-number-4">1.6.8.</span> 软间隔支持向量机</h4>
<div class="outline-text-4" id="text-1-6-8">
<p>
有时数据并非完全可分的, 或者我们允许超平面把测试集中的某些正例分类为反例, 以得于更大的间隔. 从损失函数的角度考虑, 可以认为把损失函数的惩罚项乘上一个系数 C, 变为
</p>

<p>
\(loss=\frac{1}{2}w^2+C*\sum hinge\_loss\big(1-y_i(wx_i+b)\big)\),
</p>

<p>
当 \(C\) 较大时, 表示我们希望超平面分类需要尽量正确, 当 \(C\) 较小时, 表示我们希望间隔足够大
</p>

<p>
上面的 loss 还可以改写成
</p>

<p>
\(loss=\frac{\lambda}{2}w^2+\sum hinge\_loss\big(1-y_i(wx_i+b)\big)\)
</p>

<p>
所以 <code>支持向量机本质上就是一个带 L2-norm 的感知机</code>
</p>
</div>
</div>

<div id="outline-container-org0000066" class="outline-4">
<h4 id="org0000066"><span class="section-number-4">1.6.9.</span> 支持向量机与 logistic 回归</h4>
<div class="outline-text-4" id="text-1-6-9">
<p>
logistic 回归的 loss 为:
</p>

<p>
\(loss = \frac{\lambda}{2}w^2+\sum -y_i\log(p_i)-(1-y_i)\log(1-p_i)\)
</p>

<p>
其中 \(p_i=\frac{1}{1+e^{-(wx_i+b)})}\), \(y_i \in \{1,0\}\)
</p>

<ul class="org-ul">
<li>当 \(y_i\) 为 0 时, logistic loss 后半部分为 \(-\log(1-\frac{1}{1+e^{-(wx_i+b)}})\)</li>

<li>当\(y_i\) 为 -1 时, 支持向量机的 loss 的后半部分为 \(\max(0,1+(wx_i+b))\)</li>

<li>当 \(y_i\) 为 1 时, logistic loss 后半部分为 \(-\log(\frac{1}{1+e^{-(wx_i+b)}})\)</li>

<li><p>
当 \(y_i\) 为 1 时, 支持向量机的 loss 的后半部分为 \(\max(0,1-(wx_i+b))\)
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> matplotlib.pyplot <span class="org-keyword">as</span> plt

plt.style.use(<span class="org-string">"classic"</span>)

plt.subplot(121)
<span class="org-variable-name">x</span> = np.linspace(-5, 5, 100)
<span class="org-variable-name">y1</span> = np.maximum(0, 1 + x)
<span class="org-variable-name">y2</span> = -np.log(1 - 1 / (1 + np.exp (-x)))
plt.plot(x, y1, x, y2)
plt.title(<span class="org-string">"y!=1"</span>)
plt.axhline(0, color=<span class="org-string">"black"</span>)
plt.axvline(0, color=<span class="org-string">"black"</span>)

plt.subplot(122)
<span class="org-variable-name">y1</span> = np.maximum(0, 1 - x)
<span class="org-variable-name">y2</span> = -np.log(1 / (1 + np.exp (-x)))
plt.plot(x,y1,x,y2)
plt.title(<span class="org-string">"y=1"</span>)
plt.axhline(0, color=<span class="org-string">"black"</span>)
plt.axvline(0, color=<span class="org-string">"black"</span>)

plt.show()
</pre>
</div>


<div id="org0000065" class="figure">
<p><img src="../extra/logistic_svm.png" alt="logistic_svm.png" />
</p>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-org000006a" class="outline-4">
<h4 id="org000006a"><span class="section-number-4">1.6.10.</span> 非线性支持向量机</h4>
<div class="outline-text-4" id="text-1-6-10">
<p>
有些问题无法找到一个超平面把正反例分开. 例如:
</p>


<div id="org0000069" class="figure">
<p><img src="../extra/non_linear_svm.png" alt="non_linear_svm.png" />
</p>
</div>

<p>
左边显示的数据中正例集中在一个椭圆内, 无法找到一个超平面把正反例分开. 这里就需要非线性支持向量机.
</p>

<p>
非线性支持向量机的思想是把原空间的数据通过一个变换映射到新的空间, 变换后的数据在新空间就有可能是线性可分的了.
</p>

<p>
上图左边显示的空间 \(\chi \subset R^2\) , \(x=(x^{(1)},x^{(2)}) \in \chi\).
</p>

<p>
定义映射函数 \(z=\phi(x)=((x^{(1)})^2,(x^{(2)})^2)\) 把 \(\chi\) 映射到上图右边显示的空间 \(Z \subset R^2\), \(z=(z^{(1)},z^{(2)}) \in Z\)
</p>

<p>
原空间 \(\chi\) 中的椭圆 \(w_1 (x^{(1)})^2+w_2 (x^{(2)})^2+b=0\) 变换为新空间中的直线 \(w_1 z^{(1)}+w_2 z^{(2)}+b=0\)
</p>

<p>
这样原空间的非线性可分问题就变成了新空间的线性可分问题.
</p>
</div>
</div>

<div id="outline-container-org000006d" class="outline-4">
<h4 id="org000006d"><span class="section-number-4">1.6.11.</span> 对偶问题</h4>
<div class="outline-text-4" id="text-1-6-11">
<p>
原始问题 \(loss=\frac{1}{2}w^2+\sum hinge\_loss\big(1-y_i(wx_i+b)\big)\), 令
\(w=a\cdot x=\sum_j^N \alpha_j x_j\), 即 \(w\) 是 \(x\) 的加权和. 所以\(w\cdot x_i
= \alpha \cdot x \cdot x_i\), 把 \(\alpha\) 看作 \(w^{\ast}\), \(x \cdot x_i\) 看作 \(x^{\ast}\), 构成对偶问题, \(w^{\ast}\) 和 \(x^{\ast}\) 的 shape 均变为 \(N*N\)
</p>

<p>
\(x_i \cdot x\) 反映了原问题中第 i 个样本的特征向量与其它所有样本的特征向量的相似性.
</p>

<p>
对偶问题把原始的特征向量替换为原始特征向量与其它所有样本的特征向量的相似性,
但原问题不是线性可分时, 对偶问题同样不是线性可分的.
</p>
</div>
</div>

<div id="outline-container-org0000070" class="outline-4">
<h4 id="org0000070"><span class="section-number-4">1.6.12.</span> 核函数</h4>
<div class="outline-text-4" id="text-1-6-12">
<p>
核函数 \(K(x_i,x_j)\) 表示原问题的两个样本的特征向量被映射到高维空间后的点积,
即 \(\phi(x_i)\cdot\phi(x_j)\)
</p>

<p>
正常情况下, 我们要解决非线性支持向量机问题时, 需要确定 \(\phi(x)\), 然后把
\(x\) 通过 \(\phi(x)\) 映射后代入原问题或对偶问题中求解. 但 \(\phi(x)\) 如何确定?
新空间的维度直觉上越高越有可能线性可分, 但维度越高计算量越大&#x2026;
</p>

<p>
核函数并没有给定 \(\phi(x)\), 而是直接给出了 \(\phi(x)\cdot\phi(x)\) 的值, 从而避免高维空间上的点积计算, 因为对偶问题不需要单独计算\(\phi(x)\), 它只需要计算点积.
</p>

<p>
以高斯核为例, \(K(x_i,x_j)=exp(-\frac{||x_i-x_j||^2}{2\delta^2})\), 根据泰勒级数展开, 它对应的 \(\phi(x)\) 有无穷维<sup><a id="fnr.4" class="footref" href="#fn.4" role="doc-backlink">4</a></sup> , 但我们在低维空间通过高斯核函数就能计算出超高维空间里对应的两个向量的点积.
</p>

<p>
除了高斯核, 还有:
</p>

<ol class="org-ol">
<li>多项式核 \(K(x_i,x_j)=(x_i\cdot x_j+1)^p\), 与非线性 logistic 回归时使用 polynomial feature 类似?</li>

<li>线性核 \(K(x_i,x_j)=x_i\cdot x_j\), 线性核相当于没有作映射, 可以用来解决本来就线性可分的问题.</li>
</ol>
</div>
</div>

<div id="outline-container-org0000073" class="outline-4">
<h4 id="org0000073"><span class="section-number-4">1.6.13.</span> SMO 算法</h4>
</div>
</div>

<div id="outline-container-org0000090" class="outline-3">
<h3 id="org0000090"><span class="section-number-3">1.7.</span> 隐马尔可夫模型</h3>
<div class="outline-text-3" id="text-1-7">
</div>
<div id="outline-container-org0000079" class="outline-4">
<h4 id="org0000079"><span class="section-number-4">1.7.1.</span> 定义</h4>
<div class="outline-text-4" id="text-1-7-1">
<p>
隐马尔可夫模型(HMM, Hidden Markov Model) 是关于序列的概率模型, 描述一个由隐藏的马尔可夫链生成一个隐藏的状态序列, 然后再由隐藏状态序列生成观测序列的过程.
</p>

<p>
HMM 由初始状态分布, 状态转移概率分布和观测概率分布确定. 其形式定义如下:
</p>

<ul class="org-ul">
<li>Q 是所有状态的集合, \(Q=\{q_1,q_2,\ldots, q_N\}\)</li>

<li>V 是所有观测的集合, \(V=\{v_1,v_2,\ldots,v_M\}\)</li>

<li>I 是长度为 T 的状态序列, \(I=\{i_1,i_2,\ldots,i_T\}\)</li>

<li>O 为对应的观测序列, \(O=\{o_1,o_2,\ldots,o_T\}\)</li>

<li>A 为状态转移矩阵, \(A=\big[a_{ij}\big]_{N\times N}\), \(a_{ij}\) 表示状态由
\(q_i\) 转移到 \(q_j\) 的概率</li>

<li>B 为观测概率矩阵, \(B=\big[ b_j(k)\big]_{N\times M}\), 表示状态为 \(q_j\) 的条件下观测结果为 \(v_k\) 的概率</li>

<li>\(\pi\) 是初始状态分布, \(\pi_i=P(i_1=q_i)\)</li>

<li>HMM 由 A, B 和 \(\pi\) 决定, \(\lambda=(A,B,\pi)\)</li>

<li>HMM 假设任意时刻 t 的状态 \(i_t\) 只由前一时刻的 \(i_{t-1}\) 决定, 与其它时刻无关</li>

<li>HMM 假设任意时刻 t 的观察  \(o_t\) 只与 \(i_t\) 有关</li>
</ul>
</div>
</div>

<div id="outline-container-org000007c" class="outline-4">
<h4 id="org000007c"><span class="section-number-4">1.7.2.</span> 举例</h4>
<div class="outline-text-4" id="text-1-7-2">
<p>
假设有 4 个盒子, 每个盒子有红白两种球, 个数如下:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">盒子</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">3</th>
<th scope="col" class="org-right">4</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">红球数</td>
<td class="org-right">5</td>
<td class="org-right">3</td>
<td class="org-right">6</td>
<td class="org-right">8</td>
</tr>

<tr>
<td class="org-left">白球数</td>
<td class="org-right">5</td>
<td class="org-right">7</td>
<td class="org-right">4</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table>

<p>
以如下方法产生一个观测序列:
</p>

<ol class="org-ol">
<li>初始时以等概率从四个盒子中选一个, 然后从选中的盒子中随机选一个球, 记录后放回</li>

<li>从当前盒子转移到下一下盒子, 方法如下: 若当前是盒子1, 则转移到盒子2. 若 2
或 3, 则以 0.4 和 0.6 的概率转移到左边或右边的盒子. 若 4, 则以 0.5 和 0.5
的概率停留在 4 或转移到 3</li>

<li>转移到下一个盒子后从盒子随机选一个球, 记录后放回, 重复 5 次, 假设得到的观测序列为 {红,红,白,白,红}</li>

<li>整个过程中观察者无法看到盒子的序列</li>
</ol>

<p>
上面的例子中:
</p>

<ul class="org-ul">
<li>Q = {盒子1,盒子2,盒子3,盒子4}</li>
<li>V = {红球,白球}</li>
<li>O = {红,红,白,白,红}</li>
<li>\(\pi=\begin{bmatrix}0.25&0.25&0.25&0.25\end{bmatrix}\)</li>
<li>\(A=\begin{bmatrix} 0&1&0&0\\0.4&0&0.6&0\\0&0.4&0&0.6\\0&0&0.5&0.5\end{bmatrix}\)</li>
<li>\(B=\begin{bmatrix}0.5&0.5\\0.3&0.7\\0.6&0.4\\0.8&0.2\end{bmatrix}\)</li>
</ul>
</div>
</div>

<div id="outline-container-org000007f" class="outline-4">
<h4 id="org000007f"><span class="section-number-4">1.7.3.</span> 概率计算问题</h4>
<div class="outline-text-4" id="text-1-7-3">
<p>
给定模型 \(\lambda=(A, B,\pi)\) 和观测序列 \(O=\{o_1,o_2,\ldots,o_T\}\), 计算 \(O\)
出现的概率
</p>

<ol class="org-ol">
<li><p>
直接计算
</p>

<p>
根据全概率率公式: \(P(O)=\sum{_I}P(O|I)P(I)\), 因为一共有 \(N^T\) 种 I 序列, 所以复杂度为 \(\mathcal{O}(TN^T)\)
</p></li>

<li><p>
前向算法
</p>

<p>
前向算法的思想是, 若已知 \(\alpha_t=P(o_1,o_2,\ldots, o_{t})\) , 如何求
\(\alpha_{t+1}=P(o_1,o2,\ldots,o_{t},o_{t+1})\) ?
</p>

<p>
由于在 t 时刻时 \(i_t\) 可能是 \(\{q_1,q_2,\ldots,q_N\}\) 中的任一个, 所以定义
\(\alpha_t(i) = P(o_1,o_2,\ldots,o_t|i_t=q_i)\)
</p>

<ul class="org-ul">
<li>前向算法

<ol class="org-ol">
<li>初始值 \(\alpha_1(i)=\pi_i b_i(o_1)\)</li>

<li>\(\alpha\) 的递推公式为 \(\alpha_{t+1}{i}=\big(\sum{\alpha_t(j)a_{ji}\big)b_i(o_{t+1})\)</li>

<li>输出 \(P(O)=\sum_{i=1}^N{\alpha_T(i)}\)</li>
</ol></li>

<li><p>
复杂度
</p>

<p>
前向算法的复杂度是 \(\mathcal{O}(N^2 T)\), 因为算法一共递推 \(T\) 次, 每次需要计算每个状态向其它 N 个状态转移时的概率,复杂度为 \(\mathcal{O}(N^2)\)
</p></li>
</ul></li>
</ol>
</div>
</div>

<div id="outline-container-org0000082" class="outline-4">
<h4 id="org0000082"><span class="section-number-4">1.7.4.</span> 学习问题</h4>
<div class="outline-text-4" id="text-1-7-4">
<p>
给定转移序列 \(I\) 和观测序列 \(O\), 计算 \(A,B,\pi\)
</p>

<p>
有足够多的标记信息时, 可以使用 MLE (极大似然估计) 来估计 HMM 的参数
</p>

<ol class="org-ol">
<li>设样本中状态 i 转移到状态 j 的样本数为 \(A_{ij}\), 则 \(\hat{a}_{ij}= \frac{A_{ij}}{\sum_k{A_{ik}}}\)</li>
<li>设样本中状态为 j 且观测为 k 的样本数为 \(B_{jk}\), 则 \(\hat{b}_{j}(k)=\frac{B_{jk}}{\sum_i{B_{ji}}}\)</li>
<li>\(\hat{\pi}_i\) 为样本中初始状态为 \(q_i\) 的频率</li>
</ol>
</div>
</div>

<div id="outline-container-org0000087" class="outline-4">
<h4 id="org0000087"><span class="section-number-4">1.7.5.</span> 解码问题</h4>
<div class="outline-text-4" id="text-1-7-5">
<p>
给定 \(\lambda\) 和 \(O\), 计算 \(O\) 最有可能对应的 \(I\)
</p>

<ol class="org-ol">
<li><p>
直接计算
</p>

<p>
穷举所有的 \(I\), 选择使得 \(P(O|I)\) 最大的 \(I\)
</p></li>

<li><p>
维特比算法
</p>

<p>
维特比算法是一个基本的动态规则算法<sup><a id="fnr.5" class="footref" href="#fn.5" role="doc-backlink">5</a></sup>
</p>

<p>
引入一个 \(\delta_t(i)\) 保存 t 时刻状态为 i 的所有路径中概率的最大值
</p>

<ul class="org-ul">
<li>输出为 \(P=\max_{i=1}^N{\delta_T(i)}\)</li>

<li>递推公式为 \(\delta_{t+1}(i)=\max_{j=1}^{N}[\delta_t(j)a_{ji}]b_i(o_{t+1})\)</li>
</ul>

<p>
算法与概率计算的前向算法类似, 复杂度为 \(\mathcal{O}(N^2 T)\)
</p></li>

<li><p>
举例
</p>

<p>
给定一个模型 \(\lambda = (A,B,\pi)\), 其中:
</p>

<p>
\(A=\begin{bmatrix}0.5&0.2&0.3\\0.3&0.5&0.2\\0.2&0.3&0.5\end{bmatrix}\)
</p>

<p>
\(B=\begin{bmatrix}0.5&0.5\\0.4&0.6\\0.7&0.3\end{bmatrix}\)
</p>

<p>
\(\pi=\begin{bmatrix}0.2&0.4&0.4\end{bmatrix}\)
</p>

<p>
已知观测序列为 {红， 绿， 红}， 求最优状态序列 I
</p>

<p>
虚线表示观测概率, 实线表示转移概率
</p>


<div id="org0000085" class="figure">
<p><img src="../extra/viterbi.png" alt="viterbi.png" />
</p>
</div>

<p>
\(\delta_1(1)=0.1\)
\(\delta_1(2)=0.16\)
\(\delta_1(3)=0.28\)
</p>

<p>
\(\delta_2(1)=\max(0.1*0.5,0.16*0.3,\underline{0.28*0.2})*0.5=0.028\)
\(\delta_2(2)=\max(0.1*0.2,0.16*0.5,\underline{0.28*0.3})*0.6=0.0504\)
\(\delta_2(3)=\max(0.1*0.3,0.16*0.2,\underline{0.28*0.5})*0.3=0.042\)
</p>

<p>
\(\delta_3(1)=\max(0.028*0.5,\underline{0.0504*0.3},0.042*0.2)*0.5=0.00756\)
\(\delta_3(2)=\max(0.028*0.2,\underline{0.0504*0.5},0.042*0.3)*0.4=0.01008\)
\(\delta_3(3)=\max(0.028*0.3,0.0504*0.2,\underline{0.042*0.521})*0.7=0.0147\)
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np

<span class="org-variable-name">A</span> = np.array([[.5, .2, .3], [.3, .5, .2], [.2, .3, .5]])
<span class="org-variable-name">B</span> = np.array([[.5, .5], [.4, .6], [.7,.3]])
<span class="org-variable-name">pi</span> = np.array([[.2, .4, .4]])

<span class="org-variable-name">delta_1</span> = pi * B[:, 0]

<span class="org-variable-name">delta_2</span> = delta_1.T * A * B[:, 1]
<span class="org-variable-name">delta_2</span> = np.<span class="org-builtin">max</span>(delta_2, axis=0)

<span class="org-variable-name">delta_3</span> = delta_2.T * A * B[:, 0]
<span class="org-variable-name">delta_3</span> = np.<span class="org-builtin">max</span>(delta_3, axis=0)

(delta_1, delta_2, delta_3)
</pre>
</div>

<pre class="example" id="org0000086">
(array([[0.1 , 0.16, 0.28]]),
array([0.028 , 0.0504, 0.042 ]),
array([0.007  , 0.01008, 0.0147 ]))
</pre>

<p>
最终求得的最大概率为 0.0147， 对应于 \(3-3-3\) 这条路径, 所以最优状态序列为 \(I=(i_3,i_3,i_3)\)
</p></li>
</ol>
</div>
</div>

<div id="outline-container-org000008a" class="outline-4">
<h4 id="org000008a"><span class="section-number-4">1.7.6.</span> 应用举例: 词性标注</h4>
<div class="outline-text-4" id="text-1-7-6">
<p>
应用 HMM 进行预测时， 输入信息做为观测序列 \(O\), 预测结果做为状态序列 \(I\), 我们需要先用学习算法学习到 HMM 的参数 \(A,B,\pi\), 然后应用维特比算法计算出对应于输入信息 \(O\) 的最可能的预测结果 \(I\)
</p>

<p>
以词性标注问题为例:
</p>

<ul class="org-ul">
<li>\(Q\) 是所有的词性组成的集合, {v,n,vt,a,ad,&#x2026;}</li>
<li>\(V\) 是所有单词组成的集合， {我,你,可是,如果,&#x2026;}</li>
<li>\(O\) 是一句话， 例如 {结合， 成， 分子，时}</li>
<li><p>
\(A\) 是状态转移矩阵, 通过学习获得, 例如
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">v</th>
<th scope="col" class="org-right">n</th>
<th scope="col" class="org-right">p</th>
<th scope="col" class="org-left">&#x2026;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">v</td>
<td class="org-right">0.1</td>
<td class="org-right">0.8</td>
<td class="org-right">0.1</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">n</td>
<td class="org-right">0.8</td>
<td class="org-right">0.01</td>
<td class="org-right">0.19</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">p</td>
<td class="org-right">0.9</td>
<td class="org-right">0.05</td>
<td class="org-right">0.05</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#x2026;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table></li>
</ul>


<ul class="org-ul">
<li><p>
\(B\) 是观测概率矩阵，通过学习获得, 例如
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">结合</th>
<th scope="col" class="org-right">我</th>
<th scope="col" class="org-right">是</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">v</td>
<td class="org-right">0.2</td>
<td class="org-right">0.001</td>
<td class="org-right">0.001</td>
</tr>

<tr>
<td class="org-left">&#x2026;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
</tr>
</tbody>
</table></li>

<li>\(\pi\) 是初始状态分布, 通过学习获得</li>
</ul>

<p>
通过以上信息应用维特比算法计算 I={结合, 成, 分子, 时} 对应的　O, 即为对应的词性.
</p>
</div>
</div>

<div id="outline-container-org000008d" class="outline-4">
<h4 id="org000008d"><span class="section-number-4">1.7.7.</span> 应用举例: 拼音输入法<sup><a id="fnr.6" class="footref" href="#fn.6" role="doc-backlink">6</a></sup></h4>
<div class="outline-text-4" id="text-1-7-7">
<p>
输入的拼音例如 {bu zhi dao} 做为观测序列，　预测结果例如 {不　知　道}　做为状态序列.
</p>

<ul class="org-ul">
<li>\(Q\) 是所有的汉字组成的集合</li>
<li>\(V\) 是所有拼音组成的集合</li>
<li>\(O\) 是一段拼音</li>
<li><p>
\(A\) 是状态转移矩阵, 通过学习获得, 例如
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">个</th>
<th scope="col" class="org-right">些</th>
<th scope="col" class="org-right">会</th>
<th scope="col" class="org-left">&#x2026;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">一</td>
<td class="org-right">0.8</td>
<td class="org-right">0.7</td>
<td class="org-right">0.6</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#x2026;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table></li>
</ul>


<ul class="org-ul">
<li><p>
\(B\) 是观测概率矩阵，通过学习获得, 例如
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">he</th>
<th scope="col" class="org-right">hu</th>
<th scope="col" class="org-right">ha</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">和</td>
<td class="org-right">0.9</td>
<td class="org-right">0.1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">&#x2026;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
</tr>
</tbody>
</table></li>
</ul>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
调和均值即倒数均值,
例如两个电阻并联后的总电阻是两个电阻的调和均值
<a href="https://www.zhihu.com/question/23096098?sort=created">如何理解与应用调和平均数？</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
<a href="http://www.360doc.com/content/17/0511/23/42200978_653134402.shtml">5分钟让你了解什么是极大似然估计</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
I 为指示函数 (indicator function)
<a href="https://baike.baidu.com/item/%E6%8C%87%E7%A4%BA%E5%87%BD%E6%95%B0/3774265?fr=aladdin">指示函数</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4" role="doc-backlink">4</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
SVM中，高斯核为什么会把原始维度映射到无穷多维？<a href="https://www.zhihu.com/question/35602879/answer/63963315">https://www.zhihu.com/question/35602879/answer/63963315</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5" role="doc-backlink">5</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
<a href="https://leetcode.com/problems/triangle/description/">https://leetcode.com/problems/triangle/description/</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6" role="doc-backlink">6</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
<a href="https://zhuanlan.zhihu.com/p/25132270">https://zhuanlan.zhihu.com/p/25132270</a>
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">

<p class="author">Author: sunway@dogdog.run<br />
Date: 2018-06-25 Mon 00:00<br />
Last updated: 2022-09-29 Thu 21:51</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
</div>
</body>
</html>
