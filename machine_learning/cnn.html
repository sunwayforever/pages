<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-01-25 Tue 18:52 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CNN</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wei Sun (孙伟)" />
<link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
<link rel = "icon" href = "/icon.png"  type = "image/x-icon">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">CNN</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org6c10ff6">1. CNN</a>
<ul>
<li><a href="#orgd82c826">1.1. Conv1D</a></li>
<li><a href="#org6109321">1.2. Conv2D</a>
<ul>
<li><a href="#orgd8379f1">1.2.1. padding</a></li>
<li><a href="#orgd0aa13d">1.2.2. Conv2d Impl</a></li>
</ul>
</li>
<li><a href="#ID-2375bfaf-7532-4aeb-ba5f-739d48fb5f36">1.3. Deconv2D</a>
<ul>
<li><a href="#orga19e247">1.3.1. 通过加 padding 和 dilation 转换为 Conv2D</a></li>
<li><a href="#org5b77b63">1.3.2. 通过 gemm+col2im</a></li>
</ul>
</li>
<li><a href="#org15e6eca">1.4. DepthwiseConv2D</a>
<ul>
<li><a href="#org17c81c9">1.4.1. DepthwiseConv2D</a></li>
<li><a href="#ID-960181e1-fe13-4407-aba5-ebafd845ef5f">1.4.2. SeparatableConv2D</a></li>
<li><a href="#ID-2b0c7962-fc44-4e5c-9521-39d5ea59b4fd">1.4.3. group conv2d</a></li>
</ul>
</li>
<li><a href="#orga81ecaa">1.5. Dynamic Shaped Network</a></li>
<li><a href="#org9073b13">1.6. Conv2d FLOPs</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org6c10ff6" class="outline-2">
<h2 id="org6c10ff6"><span class="section-number-2">1</span> CNN</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgd82c826" class="outline-3">
<h3 id="orgd82c826"><span class="section-number-3">1.1</span> Conv1D</h3>
<div class="outline-text-3" id="text-1-1">

<div id="org2f6b84a" class="figure">
<p><img src="../extra/conv1.png" alt="conv1.png" />
</p>
</div>

<div class="org-src-container">
<pre class="src src-python">keras.layers.Conv1D(<span style="font-weight: bold;">input</span>, filters, kernel_size, strides=(1, 1), padding=<span style="font-style: italic;">"valid"</span>)
</pre>
</div>

<ul class="org-ul">
<li>input 是三维: (batch, H, input_channel), conv 发生在 H 这一维上</li>
<li>kernel_size 是一个 scaler, 与 input 的 H 对应</li>
<li>stride 是一个 scaler</li>
<li>单个 filter 的尺寸是 (kernel_size, input_channel)</li>
</ul>
</div>
</div>

<div id="outline-container-org6109321" class="outline-3">
<h3 id="org6109321"><span class="section-number-3">1.2</span> Conv2D</h3>
<div class="outline-text-3" id="text-1-2">

<div id="orge49e5c0" class="figure">
<p><img src="../extra/conv2.png" alt="conv2.png" />
</p>
<p><span class="figure-number">Figure 2: </span>conv2</p>
</div>

<p>
kernel=[0,1,2; 2,2,0; 0,1,2] <img src="../extra/conv_ani.gif" alt="conv_ani.gif" />
</p>

<div class="org-src-container">
<pre class="src src-python">keras.layers.Conv2D(<span style="font-weight: bold;">input</span>, filters, kernel_size, strides=(1, 1), padding=<span style="font-style: italic;">"valid"</span>)
</pre>
</div>

<ul class="org-ul">
<li>input 是四维: (batch, H, W, input_channel), conv 发生成 H,W 这两维上</li>
<li>kernel_size 是 scaler(表示 H,W 方向使用相同的值) 或 (h,w), 与 input 的 (H,W)
对应</li>
<li>单个 filter 的尺寸为 (kernel_size_h, kernel_size_w, input_channel)</li>
</ul>
</div>

<div id="outline-container-orgd8379f1" class="outline-4">
<h4 id="orgd8379f1"><span class="section-number-4">1.2.1</span> padding</h4>
<div class="outline-text-4" id="text-1-2-1">
<ul class="org-ul">
<li>W original size</li>
<li>F kernel size</li>
<li>S stride</li>
<li>O output size</li>
<li>P padding</li>
</ul>

<p>
\(O=\frac{W+2*P-F}{S}+1\)
</p>

<p>
若考虑 dilation 参数:
</p>

<ul class="org-ul">
<li>D dilation, 默认为 1</li>
</ul>

<p>
\(O=\frac{W+2*P-(D*(F-1)+1)}{S}+1\)
</p>

<p>
其中 \(D*(F-1)+1\) 相当于膨胀后的 kernel 大小
</p>


<div id="org2771926" class="figure">
<p><img src="../extra/conv_padding.gif" alt="conv_padding.gif" />
</p>
<p><span class="figure-number">Figure 3: </span>padding</p>
</div>

<ul class="org-ul">
<li><p>
valid padding
</p>

<p>
当 padding = valid 时, input 中无法对齐的部分被丢弃
</p></li>

<li><p>
same padding
</p>

<p>
当 padding = same 时, input 中无法对齐时会在前后补 0 
</p></li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> tensorflow
<span style="font-weight: bold;">import</span> tensorflow <span style="font-weight: bold;">as</span> tf
<span style="font-weight: bold;">import</span> numpy <span style="font-weight: bold;">as</span> np
<span style="font-weight: bold;">from</span> tensorflow.keras <span style="font-weight: bold;">import</span> layers

<span style="font-weight: bold; font-style: italic;">x</span> = np.random.normal(size=(1, 15, 1)).astype(<span style="font-style: italic;">"float32"</span>)
<span style="font-weight: bold; font-style: italic;">y</span> = layers.Conv1D(filters = 1, kernel_size = 10, strides = 3, padding = <span style="font-style: italic;">"same"</span>)(x)
<span style="font-weight: bold; font-style: italic;">y2</span> = layers.Conv1D(filters = 1, kernel_size = 15, strides = 3, padding = <span style="font-style: italic;">"same"</span>)(x)
<span style="font-weight: bold; font-style: italic;">y3</span> = layers.Conv1D(filters = 1, kernel_size = 10, strides = 3, padding = <span style="font-style: italic;">"valid"</span>)(x)
<span style="font-weight: bold;">print</span>(x.shape,y.shape,y2.shape,y3.shape)
</pre>
</div>

<p>
(1, 15, 1) (1, 5, 1) (1, 5, 1) (1, 2, 1)
</p>

<p>
当 padding=same 时,  \(O=floor(\frac{W}{S})\), <span class="underline">与 kernel 无关</span>. 特别
的, 当 S = 1 时, O == W, 这也是 SAME 名字的由来
</p>

<p>
当 padding=valid 时, \(O=(W - F)//S + 1\)
</p>

<p>
所以使用 same 能更容易的控制 conv 的 output shape
</p>
</div>
</div>

<div id="outline-container-orgd0aa13d" class="outline-4">
<h4 id="orgd0aa13d"><span class="section-number-4">1.2.2</span> Conv2d Impl</h4>
<div class="outline-text-4" id="text-1-2-2">
</div>
<div id="outline-container-orga82efde" class="outline-5">
<h5 id="orga82efde"><span class="section-number-5">1.2.2.1</span> naive</h5>
<div class="outline-text-5" id="text-1-2-2-1">
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> matplotlib.pyplot <span style="font-weight: bold;">as</span> plt
<span style="font-weight: bold;">import</span> numpy <span style="font-weight: bold;">as</span> np

<span style="font-weight: bold;">from</span> skimage <span style="font-weight: bold;">import</span> io, color
<span style="font-weight: bold;">import</span> scipy.signal

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">convolve2d</span>(image, kernel):
    <span style="font-weight: bold; font-style: italic;">kernel</span> = np.flipud(np.fliplr(kernel))   
    <span style="font-weight: bold; font-style: italic;">output</span> = np.zeros_like(image)    
    <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Add zero padding to the input image</span>
    <span style="font-weight: bold; font-style: italic;">padding</span>=kernel.shape[0]-1
    <span style="font-weight: bold;">if</span> padding%2!=0:
        <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">"error zero_padding"</span>)
    <span style="font-weight: bold; font-style: italic;">offset</span>=padding//2
    <span style="font-weight: bold; font-style: italic;">image_padded</span> = np.zeros((image.shape[0] + padding, image.shape[1] + padding))  
    <span style="font-weight: bold; font-style: italic;">image_padded</span>[offset:-offset, offset:-offset] = image
    <span style="font-weight: bold;">for</span> x <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(image.shape[1]):  
        <span style="font-weight: bold;">for</span> y <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(image.shape[0]):
            <span style="font-weight: bold; font-style: italic;">output</span>[y,x]=(kernel*image_padded[y:y+kernel.shape[0],x:x+kernel.shape[0]]).<span style="font-weight: bold;">sum</span>()        
    <span style="font-weight: bold;">return</span> output

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">show_result</span>(img,title):
    <span style="font-weight: bold;">global</span> orig_image

    <span style="font-weight: bold; font-style: italic;">ax1</span>=plt.subplot(1,2,1)
    ax1.imshow(orig_image, cmap=plt.cm.gray)
    ax1.axis(<span style="font-style: italic;">"off"</span>)

    <span style="font-weight: bold; font-style: italic;">image_sharpen</span> = img
    <span style="font-weight: bold; font-style: italic;">ax2</span>=plt.subplot(1,2,2)
    ax2.imshow(image_sharpen, cmap=plt.cm.gray)
    ax2.axis(<span style="font-style: italic;">"off"</span>)
    plt.title(title)
    plt.show()

<span style="font-weight: bold; font-style: italic;">orig_image</span> = io.imread(<span style="font-style: italic;">'../extra/image.png'</span>) 
<span style="font-weight: bold; font-style: italic;">orig_image</span> = color.rgb2gray(orig_image)
<span style="font-weight: bold; font-style: italic;">kernel_sharpen</span>=np.array([[0,-1,0],[-1,5,-1],[0,-1,0]])
<span style="font-weight: bold; font-style: italic;">kernel_edge</span>=np.array([[-1,-1,-1],[-1,8,-1],[-1,-1,-1]])

show_result(convolve2d(orig_image,kernel_sharpen),<span style="font-style: italic;">"sharpen"</span>)    
show_result(convolve2d(orig_image,kernel_edge),<span style="font-style: italic;">"edge detection"</span>)    
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">m</span>=np.array([[1,1,1],[1,1,1,],[1,1,1]])
<span style="font-weight: bold; font-style: italic;">kernel</span>=np.array([[0,1,0],[0,1,0],[0,1,0]])
<span style="font-weight: bold;">print</span>(m)
<span style="font-weight: bold;">print</span>(kernel)
<span style="font-weight: bold;">print</span>(convolve2d(m,kernel))
</pre>
</div>

<pre class="example" id="orge68b6e7">
[[1 1 1]
 [1 1 1]
 [1 1 1]]
[[0 1 0]
 [0 1 0]
 [0 1 0]]
[[2 2 2]
 [3 3 3]
 [2 2 2]]
</pre>
</div>
</div>

<div id="outline-container-orgd784b5b" class="outline-5">
<h5 id="orgd784b5b"><span class="section-number-5">1.2.2.2</span> im2col</h5>
<div class="outline-text-5" id="text-1-2-2-2">
<p>
卷积操作实际上可以转换为普通的矩阵乘法
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> numpy <span style="font-weight: bold;">as</span> np


<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">get_im2col_indices</span>(x_shape, field_height, field_width, padding=1, stride=1):
  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">First figure out what the size of the output should be</span>
  <span style="font-weight: bold; font-style: italic;">N</span>, <span style="font-weight: bold; font-style: italic;">C</span>, <span style="font-weight: bold; font-style: italic;">H</span>, <span style="font-weight: bold; font-style: italic;">W</span> = x_shape
  <span style="font-weight: bold;">assert</span> (H + 2 * padding - field_height) % stride == 0
  <span style="font-weight: bold;">assert</span> (W + 2 * padding - field_height) % stride == 0
  <span style="font-weight: bold; font-style: italic;">out_height</span> = (H + 2 * padding - field_height) // stride + 1
  <span style="font-weight: bold; font-style: italic;">out_width</span> = (W + 2 * padding - field_width) // stride + 1

  <span style="font-weight: bold; font-style: italic;">i0</span> = np.repeat(np.arange(field_height), field_width)
  <span style="font-weight: bold; font-style: italic;">i0</span> = np.tile(i0, C)
  <span style="font-weight: bold; font-style: italic;">i1</span> = stride * np.repeat(np.arange(out_height), out_width)
  <span style="font-weight: bold; font-style: italic;">j0</span> = np.tile(np.arange(field_width), field_height * C)
  <span style="font-weight: bold; font-style: italic;">j1</span> = stride * np.tile(np.arange(out_width), out_height)
  <span style="font-weight: bold; font-style: italic;">i</span> = i0.reshape(-1, 1) + i1.reshape(1, -1)
  <span style="font-weight: bold; font-style: italic;">j</span> = j0.reshape(-1, 1) + j1.reshape(1, -1)

  <span style="font-weight: bold; font-style: italic;">k</span> = np.repeat(np.arange(C), field_height * field_width).reshape(-1, 1)

  <span style="font-weight: bold;">return</span> (k, i, j)


<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">im2col_indices</span>(x, field_height, field_width, padding=1, stride=1):
  <span style="font-style: italic;">""" An implementation of im2col based on some fancy indexing """</span>
  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Zero-pad the input</span>
  <span style="font-weight: bold; font-style: italic;">p</span> = padding
  <span style="font-weight: bold; font-style: italic;">x_padded</span> = np.pad(x, ((0, 0), (0, 0), (p, p), (p, p)), mode=<span style="font-style: italic;">'constant'</span>)

  <span style="font-weight: bold; font-style: italic;">k</span>, <span style="font-weight: bold; font-style: italic;">i</span>, <span style="font-weight: bold; font-style: italic;">j</span> = get_im2col_indices(x.shape, field_height, field_width, padding,
                               stride)

  <span style="font-weight: bold; font-style: italic;">cols</span> = x_padded[:, k, i, j]
  <span style="font-weight: bold; font-style: italic;">C</span> = x.shape[1]
  <span style="font-weight: bold; font-style: italic;">cols</span> = cols.transpose(1, 2, 0).reshape(field_height * field_width * C, -1)
  <span style="font-weight: bold;">return</span> cols


<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">col2im_indices</span>(cols, x_shape, field_height=3, field_width=3, padding=1,
                   stride=1):
  <span style="font-style: italic;">""" An implementation of col2im based on fancy indexing and np.add.at """</span>
  <span style="font-weight: bold; font-style: italic;">N</span>, <span style="font-weight: bold; font-style: italic;">C</span>, <span style="font-weight: bold; font-style: italic;">H</span>, <span style="font-weight: bold; font-style: italic;">W</span> = x_shape
  <span style="font-weight: bold; font-style: italic;">H_padded</span>, <span style="font-weight: bold; font-style: italic;">W_padded</span> = H + 2 * padding, W + 2 * padding
  <span style="font-weight: bold; font-style: italic;">x_padded</span> = np.zeros((N, C, H_padded, W_padded), dtype=cols.dtype)
  <span style="font-weight: bold; font-style: italic;">k</span>, <span style="font-weight: bold; font-style: italic;">i</span>, <span style="font-weight: bold; font-style: italic;">j</span> = get_im2col_indices(x_shape, field_height, field_width, padding,
                               stride)
  <span style="font-weight: bold; font-style: italic;">cols_reshaped</span> = cols.reshape(C * field_height * field_width, -1, N)
  <span style="font-weight: bold; font-style: italic;">cols_reshaped</span> = cols_reshaped.transpose(2, 0, 1)
  np.add.at(x_padded, (<span style="font-weight: bold;">slice</span>(<span style="font-weight: bold; text-decoration: underline;">None</span>), k, i, j), cols_reshaped)
  <span style="font-weight: bold;">if</span> padding == 0:
    <span style="font-weight: bold;">return</span> x_padded
  <span style="font-weight: bold;">return</span> x_padded[:, :, padding:-padding, padding:-padding]

<span style="font-weight: bold;">pass</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">def</span> <span style="font-weight: bold;">convolve_im2col</span>(image,kernel):
    <span style="font-weight: bold; font-style: italic;">image</span>=image.reshape(1,1,160,160)
    <span style="font-weight: bold; font-style: italic;">image_col</span>=im2col_indices(image, kernel.shape[0],kernel.shape[1])
    <span style="font-weight: bold; font-style: italic;">kernel</span>=kernel.reshape(1,-1)
    <span style="font-weight: bold; font-style: italic;">image_conv</span>=np.dot(kernel,image_col).reshape(160,160)
    <span style="font-weight: bold;">return</span> image_conv

show_result(convolve_im2col(orig_image,kernel_sharpen),<span style="font-style: italic;">"sharpen"</span>)  
show_result(convolve_im2col(orig_image,kernel_edge),<span style="font-style: italic;">"edge"</span>)  
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">test_image</span>=np.arange(0,64,1).reshape(1,1,8,8)
<span style="font-weight: bold;">print</span>(test_image)
<span style="font-weight: bold; font-style: italic;">col</span>=im2col_indices(test_image,3,3,1,1)
<span style="font-weight: bold;">print</span>(col.shape)
<span style="font-weight: bold;">print</span>(col[:,0])
<span style="font-weight: bold;">print</span>(col[:,1])
<span style="font-weight: bold;">print</span>(col[:,2])

</pre>
</div>

<pre class="example" id="org6d86f48">
[[[[ 0  1  2  3  4  5  6  7]
   [ 8  9 10 11 12 13 14 15]
   [16 17 18 19 20 21 22 23]
   [24 25 26 27 28 29 30 31]
   [32 33 34 35 36 37 38 39]
   [40 41 42 43 44 45 46 47]
   [48 49 50 51 52 53 54 55]
   [56 57 58 59 60 61 62 63]]]]
(9, 64)
[0 0 0 0 0 1 0 8 9]
[ 0  0  0  0  1  2  8  9 10]
[ 0  0  0  1  2  3  9 10 11]
</pre>
</div>
</div>

<div id="outline-container-orgd721770" class="outline-5">
<h5 id="orgd721770"><span class="section-number-5">1.2.2.3</span> winograd</h5>
<div class="outline-text-5" id="text-1-2-2-3">
<p>
<a href="https://arxiv.org/pdf/1509.09308.pdf">https://arxiv.org/pdf/1509.09308.pdf</a>
</p>

<p>
winograd 在实现上有许多限制:
<a href="http://nvdla.org/hw/v1/ias/unit_description.html#winograd-convolution">http://nvdla.org/hw/v1/ias/unit_description.html#winograd-convolution</a>
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-ID-2375bfaf-7532-4aeb-ba5f-739d48fb5f36" class="outline-3">
<h3 id="ID-2375bfaf-7532-4aeb-ba5f-739d48fb5f36"><span class="section-number-3">1.3</span> Deconv2D</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Deconv2D 有两种等价的计算方法:
</p>
</div>

<div id="outline-container-orga19e247" class="outline-4">
<h4 id="orga19e247"><span class="section-number-4">1.3.1</span> 通过加 padding 和 dilation 转换为 Conv2D</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
<a href="https://datascience.stackexchange.com/questions/6107/what-are-deconvolutional-layers">https://datascience.stackexchange.com/questions/6107/what-are-deconvolutional-layers</a>
</p>
</div>
</div>

<div id="outline-container-org5b77b63" class="outline-4">
<h4 id="org5b77b63"><span class="section-number-4">1.3.2</span> 通过 gemm+col2im</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
<a href="https://bbs.cvmart.net/articles/1755">https://bbs.cvmart.net/articles/1755</a>
假设:
</p>

<ol class="org-ol">
<li>output 的 shape 为 \(C_{out}*H_{out}*W_{out}\)</li>
<li>W 的 shape 为 \(C_{out}*C_{in}*K_h*W_h\)</li>
<li>input 为 \(Cin*Hin*Win\)</li>
</ol>

<p>
计算 Conv2D 的过程为:
</p>

<ol class="org-ol">
<li>input 通过 im2col 转换为 \((C_{in}*K_h*K_w)*H_{out}*W_{out}\)</li>
<li>\(W = C_{out}*(C_{in}*K_h*K_w) \implies output = W * input = C_{out}*H_{out}*W_{out}\)</li>
</ol>

<p>
计算 Deconv2D 的过程为:
</p>

<ol class="org-ol">
<li>\(W^T = C_{out}*(K_h*W_h)*C_{in}\)</li>
<li>\(output = W^T * input = C_{out}*(K_h*W_h)*H_{in}*W_{in}\)</li>
<li>通过 col2im 填充输出为 \(C_{out}*H_{out}*W_{out}\)</li>
</ol>

<p>
我觉得可以这样直观的理解一下 gemm+col2im 的方式:
</p>

<p>
conv 本质上是把长度为 k 的 block 变成一个点, 实际就是一个 matmul((x,k),(k,1))
</p>

<p>
deconv 需要把这一个点再变回长度为 k 的 block, 那么做一个 matmul((x,1),(1,k)) 就可以了&#x2026;
</p>

<p>
(k,1) 是 conv kernel, (1,k) 是 deconv kernel, 所以 deconv 也叫 conv_transposed
</p>
</div>
</div>
</div>

<div id="outline-container-org15e6eca" class="outline-3">
<h3 id="org15e6eca"><span class="section-number-3">1.4</span> DepthwiseConv2D</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-org17c81c9" class="outline-4">
<h4 id="org17c81c9"><span class="section-number-4">1.4.1</span> DepthwiseConv2D</h4>
<div class="outline-text-4" id="text-1-4-1">
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> numpy <span style="font-weight: bold;">as</span> np
<span style="font-weight: bold;">import</span> tensorflow <span style="font-weight: bold;">as</span> tf
<span style="font-weight: bold;">from</span> tensorflow <span style="font-weight: bold;">import</span> keras
<span style="font-weight: bold;">from</span> tensorflow.keras <span style="font-weight: bold;">import</span> layers, losses, metrics, optimizers, models


<span style="font-weight: bold; font-style: italic;">inputs</span> = keras.Input(shape=(10, 10, 3))

<span style="font-weight: bold; font-style: italic;">outputs_ds_cnn</span> = layers.DepthwiseConv2D(
    kernel_size=[2, 2], strides=[2, 2], padding=<span style="font-style: italic;">"same"</span>
)(inputs)
<span style="font-weight: bold; font-style: italic;">outputs_ds_cnn</span> = layers.Conv2D(
    filters=20, kernel_size=[1, 1], strides=[1, 1], padding=<span style="font-style: italic;">"same"</span>
)(outputs_ds_cnn)
<span style="font-weight: bold; font-style: italic;">outputs_cnn</span> = layers.Conv2D(20, kernel_size=[2, 2], strides=[2, 2], padding=<span style="font-style: italic;">"same"</span>)(
    inputs
)
<span style="font-weight: bold; font-style: italic;">model_dscnn</span> = keras.Model(inputs, outputs_ds_cnn)
<span style="font-weight: bold; font-style: italic;">model_cnn</span> = keras.Model(inputs, outputs_cnn)

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">5,5,20</span>
<span style="font-weight: bold;">print</span>(<span style="font-style: italic;">"output_shape:"</span>)
<span style="font-weight: bold;">print</span>(outputs_ds_cnn.shape)
<span style="font-weight: bold;">print</span>(outputs_cnn.shape)
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">2,2,3,20</span>
<span style="font-weight: bold;">print</span>(<span style="font-style: italic;">"conv weight:"</span>)
<span style="font-weight: bold;">print</span>(model_cnn.layers[1].weights[0].shape)
<span style="font-weight: bold;">print</span>(<span style="font-style: italic;">"ds conv weight:"</span>)
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">2,2,3,1</span>
<span style="font-weight: bold;">print</span>(model_dscnn.layers[1].weights[0].shape)
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">1,1,3,20</span>
<span style="font-weight: bold;">print</span>(model_dscnn.layers[2].weights[0].shape)
</pre>
</div>

<p>
output_shape:
(None, 5, 5, 20)
(None, 5, 5, 20)
conv weight:
(2, 2, 3, 20)
ds conv weight:
(2, 2, 3, 1)
(1, 1, 3, 20)
</p>

<p>
假设 input_channel 为 c, depth_multiplier 为 m.
</p>

<p>
DepthwiseConv2D 有 c 个 kernel, 每个 kernel 为 [m, 1, h, w]
</p>

<p>
input 沿 channel 划分为 c 份 , 每份为 ([N, 1, H, W]), 使用一个 kernel 做
conv2d.
</p>

<p>
一共做 c 次 conv2d, 每个 conv2d 的 output channel 为 m, 所以 DepthwiseConv2D 总
的 ouput channel 为 m*c.
</p>

<p>
与 Conv2D 相比, DepthwiseConv2D 的参数个数和计算量减少很多: DepthwiseConv2D 的参
数为 c 个 [m, 1, h, w], Conv2D 为 [o, c, h, w], 两者比例为 m/o
</p>
</div>
</div>

<div id="outline-container-ID-960181e1-fe13-4407-aba5-ebafd845ef5f" class="outline-4">
<h4 id="ID-960181e1-fe13-4407-aba5-ebafd845ef5f"><span class="section-number-4">1.4.2</span> SeparatableConv2D</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
DepthwiseConv2D 后再接一个 1x1 的 Conv2D 可以把 output channel 从 m*c 变为 O
</p>

<p>
DepthwiseConv2D + 1x1 Conv2d 即 SeparatableConv2D
</p>
</div>
</div>

<div id="outline-container-ID-2b0c7962-fc44-4e5c-9521-39d5ea59b4fd" class="outline-4">
<h4 id="ID-2b0c7962-fc44-4e5c-9521-39d5ea59b4fd"><span class="section-number-4">1.4.3</span> group conv2d</h4>
<div class="outline-text-4" id="text-1-4-3">
<p>
caffe, tensorflow, pytorch 的 conv2d 均支持 group 参数, 称为 group conv2d.
</p>

<p>
group conv2d 是指 input channel/output channel 均被划分为 m 个 group, 每个 group
使用单独的 kenrel 计算 conv2d, 每个 kernel shape 为 [O/m, I/m, h, w].
</p>

<p>
例如, input channel 为 40, output channel 为 60, group 为 10, 则 kernel 为 10 个
[6, 4, h, w]
</p>

<p>
实际上, 如果像 1x1 卷积那样, 把卷积部分看做一个简单的乘法, 考虑针对 channel 的操
作, 可以把 conv2d 看作 IxO 的 fc, 那么 group conv2d 就相当于 g 个 (I/g) x (O/g)
的 fc. 例如, 把 10x10 的 fc 变成两个 5x5 的 fc 再把结果拼起来.
</p>

<p>
DepthwiseConv2D 是 group conv2d 的特殊情况:
</p>

<ol class="org-ol">
<li>ouput channel 等于 input channel</li>
<li>group 等于 input channel</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-orga81ecaa" class="outline-3">
<h3 id="orga81ecaa"><span class="section-number-3">1.5</span> <a href="dynamic_shaped_network.html#ID-6f4a00fd-5bed-48f5-af06-e9596a1b14e1">Dynamic Shaped Network</a></h3>
</div>

<div id="outline-container-org9073b13" class="outline-3">
<h3 id="org9073b13"><span class="section-number-3">1.6</span> <a href="nn_benchmark.html#ID-69f8b289-0141-4084-9516-8d8a40d9fbed">Conv2d FLOPs</a></h3>
</div>
</div>
</div>
<div id="postamble" class="status">

<p class="author">Author: sunway (sunwayforever@gmail.com)<br />
Date: <br />
Last updated: 2022-01-25 Tue 18:50</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。
<br />

<div id="disqus_thread"></div>
<script>

(function() { // DON'T EDIT BELOW THIS LINE
         var d = document, s = d.createElement('script');
         s.src = '//sunwayforever-github-io.disqus.com/embed.js';
         s.setAttribute('data-timestamp', +new Date());
         (d.head || d.body).appendChild(s);
         })();
</script>
</div>
</body>
</html>
