<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-01-25 二 10:46 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CNN</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wei Sun (孙伟)" />
<link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
<link rel = "icon" href = "/icon.png"  type = "image/x-icon">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">CNN</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgd47d4af">1. CNN</a>
<ul>
<li><a href="#org4d44c58">1.1. Conv1D</a></li>
<li><a href="#orgf59d42a">1.2. Conv2D</a>
<ul>
<li><a href="#orgb2a0f9f">1.2.1. padding</a></li>
<li><a href="#org324063e">1.2.2. Conv2d Impl</a></li>
</ul>
</li>
<li><a href="#org7aafa0e">1.3. Deconv2D</a>
<ul>
<li><a href="#org692830e">1.3.1. 通过加 padding 和 dilation 转换为 Conv2D</a></li>
<li><a href="#orgd1bf7c9">1.3.2. 通过 gemm+col2im</a></li>
</ul>
</li>
<li><a href="#orge6398c6">1.4. DepthwiseConv2D</a>
<ul>
<li><a href="#org44540b8">1.4.1. DepthwiseConv2D</a></li>
<li><a href="#org3016a0f">1.4.2. SeparatableConv2D</a></li>
<li><a href="#org38b7822">1.4.3. group conv2d</a></li>
</ul>
</li>
<li><a href="#org57ebfa9">1.5. Dynamic Shaped Network</a></li>
<li><a href="#orgd660d59">1.6. How To Calculate FLOPs</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgd47d4af" class="outline-2">
<h2 id="orgd47d4af"><span class="section-number-2">1</span> CNN</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org4d44c58" class="outline-3">
<h3 id="org4d44c58"><span class="section-number-3">1.1</span> Conv1D</h3>
<div class="outline-text-3" id="text-1-1">

<div id="orgb7c1c1a" class="figure">
<p><img src="../extra/conv1.png" alt="conv1.png" />
</p>
</div>

<div class="org-src-container">
<pre class="src src-python">keras.layers.Conv1D<span style="color: #757575;">(</span><span style="color: #839496;">input</span><span style="color: #757575;">,</span> filters<span style="color: #757575;">,</span> kernel_size<span style="color: #757575;">,</span> strides=<span style="color: #757575;">(</span>1<span style="color: #757575;">,</span> 1<span style="color: #757575;">),</span> padding=<span style="color: #2aa198;">"valid"</span><span style="color: #757575;">)</span>
</pre>
</div>

<ul class="org-ul">
<li>input 是三维: (batch, H, input_channel), conv 发生在 H 这一维上</li>
<li>kernel_size 是一个 scaler, 与 input 的 H 对应</li>
<li>stride 是一个 scaler</li>
<li>单个 filter 的尺寸是 (kernel_size, input_channel)</li>
</ul>
</div>
</div>

<div id="outline-container-orgf59d42a" class="outline-3">
<h3 id="orgf59d42a"><span class="section-number-3">1.2</span> Conv2D</h3>
<div class="outline-text-3" id="text-1-2">

<div id="org1208612" class="figure">
<p><img src="../extra/conv2.png" alt="conv2.png" />
</p>
<p><span class="figure-number">Figure 2: </span>conv2</p>
</div>

<p>
kernel=[0,1,2; 2,2,0; 0,1,2] <img src="../extra/conv_ani.gif" alt="conv_ani.gif" />
</p>

<div class="org-src-container">
<pre class="src src-python">keras.layers.Conv2D<span style="color: #757575;">(</span><span style="color: #839496;">input</span><span style="color: #757575;">,</span> filters<span style="color: #757575;">,</span> kernel_size<span style="color: #757575;">,</span> strides=<span style="color: #757575;">(</span>1<span style="color: #757575;">,</span> 1<span style="color: #757575;">),</span> padding=<span style="color: #2aa198;">"valid"</span><span style="color: #757575;">)</span>
</pre>
</div>

<ul class="org-ul">
<li>input 是四维: (batch, H, W, input_channel), conv 发生成 H,W 这两维上</li>
<li>kernel_size 是 scaler(表示 H,W 方向使用相同的值) 或 (h,w), 与 input 的 (H,W)
对应</li>
<li>单个 filter 的尺寸为 (kernel_size_h, kernel_size_w, input_channel)</li>
</ul>
</div>

<div id="outline-container-orgb2a0f9f" class="outline-4">
<h4 id="orgb2a0f9f"><span class="section-number-4">1.2.1</span> padding</h4>
<div class="outline-text-4" id="text-1-2-1">
<ul class="org-ul">
<li>W original size</li>
<li>F kernel size</li>
<li>S stride</li>
<li>O output size</li>
<li>P padding</li>
</ul>

<p>
\(O=\frac{W+2*P-F}{S}+1\)
</p>

<p>
若考虑 dilation 参数:
</p>

<ul class="org-ul">
<li>D dilation, 默认为 1</li>
</ul>

<p>
\(O=\frac{W+2*P-(D*(F-1)+1)}{S}+1\)
</p>

<p>
其中 \(D*(F-1)+1\) 相当于膨胀后的 kernel 大小
</p>


<div id="org9a85d97" class="figure">
<p><img src="../extra/conv_padding.gif" alt="conv_padding.gif" />
</p>
<p><span class="figure-number">Figure 3: </span>padding</p>
</div>

<ul class="org-ul">
<li><p>
valid padding
</p>

<p>
当 padding = valid 时, input 中无法对齐的部分被丢弃
</p></li>

<li><p>
same padding
</p>

<p>
当 padding = same 时, input 中无法对齐时会在前后补 0 
</p></li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900;">import</span> tensorflow
<span style="color: #859900;">import</span> tensorflow <span style="color: #859900;">as</span> tf
<span style="color: #859900;">import</span> numpy <span style="color: #859900;">as</span> np
<span style="color: #859900;">from</span> tensorflow.keras <span style="color: #859900;">import</span> layers

<span style="color: #268bd2;">x</span> = np.random.normal<span style="color: #757575;">(</span>size=<span style="color: #757575;">(</span>1<span style="color: #757575;">,</span> 15<span style="color: #757575;">,</span> 1<span style="color: #757575;">))</span>.astype<span style="color: #757575;">(</span><span style="color: #2aa198;">"float32"</span><span style="color: #757575;">)</span>
<span style="color: #268bd2;">y</span> = layers.Conv1D<span style="color: #757575;">(</span>filters = 1<span style="color: #757575;">,</span> kernel_size = 10<span style="color: #757575;">,</span> strides = 3<span style="color: #757575;">,</span> padding = <span style="color: #2aa198;">"same"</span><span style="color: #757575;">)(</span>x<span style="color: #757575;">)</span>
<span style="color: #268bd2;">y2</span> = layers.Conv1D<span style="color: #757575;">(</span>filters = 1<span style="color: #757575;">,</span> kernel_size = 15<span style="color: #757575;">,</span> strides = 3<span style="color: #757575;">,</span> padding = <span style="color: #2aa198;">"same"</span><span style="color: #757575;">)(</span>x<span style="color: #757575;">)</span>
<span style="color: #268bd2;">y3</span> = layers.Conv1D<span style="color: #757575;">(</span>filters = 1<span style="color: #757575;">,</span> kernel_size = 10<span style="color: #757575;">,</span> strides = 3<span style="color: #757575;">,</span> padding = <span style="color: #2aa198;">"valid"</span><span style="color: #757575;">)(</span>x<span style="color: #757575;">)</span>
<span style="color: #859900;">print</span><span style="color: #757575;">(</span>x.shape<span style="color: #757575;">,</span>y.shape<span style="color: #757575;">,</span>y2.shape<span style="color: #757575;">,</span>y3.shape<span style="color: #757575;">)</span>
</pre>
</div>

<p>
(1, 15, 1) (1, 5, 1) (1, 5, 1) (1, 2, 1)
</p>

<p>
当 padding=same 时,  \(O=floor(\frac{W}{S})\), <span class="underline">与 kernel 无关</span>. 特别的, 当 S = 1 时, O == W, 这也是 SAME 名字的由来
</p>

<p>
当 padding=valid 时, \(O=(W - F)//S + 1\)
</p>

<p>
所以使用 same 能更容易的控制 conv 的 output shape
</p>
</div>
</div>

<div id="outline-container-org324063e" class="outline-4">
<h4 id="org324063e"><span class="section-number-4">1.2.2</span> Conv2d Impl</h4>
<div class="outline-text-4" id="text-1-2-2">
</div>
<div id="outline-container-orgef357c9" class="outline-5">
<h5 id="orgef357c9"><span class="section-number-5">1.2.2.1</span> naive</h5>
<div class="outline-text-5" id="text-1-2-2-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900;">import</span> matplotlib.pyplot <span style="color: #859900;">as</span> plt
<span style="color: #859900;">import</span> numpy <span style="color: #859900;">as</span> np

<span style="color: #859900;">from</span> skimage <span style="color: #859900;">import</span> io<span style="color: #757575;">,</span> color
<span style="color: #859900;">import</span> scipy.signal

<span style="color: #859900;">def</span> <span style="color: #268bd2;">convolve2d</span><span style="color: #757575;">(</span>image<span style="color: #757575;">,</span> kernel<span style="color: #757575;">)</span>:
    <span style="color: #268bd2;">kernel</span> = np.flipud<span style="color: #757575;">(</span>np.fliplr<span style="color: #757575;">(</span>kernel<span style="color: #757575;">))</span>   
    <span style="color: #268bd2;">output</span> = np.zeros_like<span style="color: #757575;">(</span>image<span style="color: #757575;">)</span>    
    <span style="color: #586e75;"># </span><span style="color: #586e75;">Add zero padding to the input image</span>
    <span style="color: #268bd2;">padding</span>=kernel.shape[0]-1
    <span style="color: #859900;">if</span> padding%2!=0:
        <span style="color: #859900;">print</span><span style="color: #757575;">(</span><span style="color: #2aa198;">"error zero_padding"</span><span style="color: #757575;">)</span>
    <span style="color: #268bd2;">offset</span>=padding//2
    <span style="color: #268bd2;">image_padded</span> = np.zeros<span style="color: #757575;">((</span>image.shape[0] + padding<span style="color: #757575;">,</span> image.shape[1] + padding<span style="color: #757575;">))</span>  
    <span style="color: #268bd2;">image_padded</span>[offset:-offset<span style="color: #757575;">,</span> offset:-offset] = image
    <span style="color: #859900;">for</span> x <span style="color: #859900;">in</span> <span style="color: #839496;">range</span><span style="color: #757575;">(</span>image.shape[1]<span style="color: #757575;">)</span>:  
        <span style="color: #859900;">for</span> y <span style="color: #859900;">in</span> <span style="color: #839496;">range</span><span style="color: #757575;">(</span>image.shape[0]<span style="color: #757575;">)</span>:
            <span style="color: #268bd2;">output</span>[y<span style="color: #757575;">,</span>x]=<span style="color: #757575;">(</span>kernel*image_padded[y:y+kernel.shape[0]<span style="color: #757575;">,</span>x:x+kernel.shape[0]]<span style="color: #757575;">)</span>.<span style="color: #839496;">sum</span><span style="color: #757575;">()</span>        
    <span style="color: #859900;">return</span> output

<span style="color: #859900;">def</span> <span style="color: #268bd2;">show_result</span><span style="color: #757575;">(</span>img<span style="color: #757575;">,</span>title<span style="color: #757575;">)</span>:
    <span style="color: #859900;">global</span> orig_image

    <span style="color: #268bd2;">ax1</span>=plt.subplot<span style="color: #757575;">(</span>1<span style="color: #757575;">,</span>2<span style="color: #757575;">,</span>1<span style="color: #757575;">)</span>
    ax1.imshow<span style="color: #757575;">(</span>orig_image<span style="color: #757575;">,</span> cmap=plt.cm.gray<span style="color: #757575;">)</span>
    ax1.axis<span style="color: #757575;">(</span><span style="color: #2aa198;">"off"</span><span style="color: #757575;">)</span>

    <span style="color: #268bd2;">image_sharpen</span> = img
    <span style="color: #268bd2;">ax2</span>=plt.subplot<span style="color: #757575;">(</span>1<span style="color: #757575;">,</span>2<span style="color: #757575;">,</span>2<span style="color: #757575;">)</span>
    ax2.imshow<span style="color: #757575;">(</span>image_sharpen<span style="color: #757575;">,</span> cmap=plt.cm.gray<span style="color: #757575;">)</span>
    ax2.axis<span style="color: #757575;">(</span><span style="color: #2aa198;">"off"</span><span style="color: #757575;">)</span>
    plt.title<span style="color: #757575;">(</span>title<span style="color: #757575;">)</span>
    plt.show<span style="color: #757575;">()</span>

<span style="color: #268bd2;">orig_image</span> = io.imread<span style="color: #757575;">(</span><span style="color: #2aa198;">'../extra/image.png'</span><span style="color: #757575;">)</span> 
<span style="color: #268bd2;">orig_image</span> = color.rgb2gray<span style="color: #757575;">(</span>orig_image<span style="color: #757575;">)</span>
<span style="color: #268bd2;">kernel_sharpen</span>=np.array<span style="color: #757575;">(</span>[[0<span style="color: #757575;">,</span>-1<span style="color: #757575;">,</span>0]<span style="color: #757575;">,</span>[-1<span style="color: #757575;">,</span>5<span style="color: #757575;">,</span>-1]<span style="color: #757575;">,</span>[0<span style="color: #757575;">,</span>-1<span style="color: #757575;">,</span>0]]<span style="color: #757575;">)</span>
<span style="color: #268bd2;">kernel_edge</span>=np.array<span style="color: #757575;">(</span>[[-1<span style="color: #757575;">,</span>-1<span style="color: #757575;">,</span>-1]<span style="color: #757575;">,</span>[-1<span style="color: #757575;">,</span>8<span style="color: #757575;">,</span>-1]<span style="color: #757575;">,</span>[-1<span style="color: #757575;">,</span>-1<span style="color: #757575;">,</span>-1]]<span style="color: #757575;">)</span>

show_result<span style="color: #757575;">(</span>convolve2d<span style="color: #757575;">(</span>orig_image<span style="color: #757575;">,</span>kernel_sharpen<span style="color: #757575;">),</span><span style="color: #2aa198;">"sharpen"</span><span style="color: #757575;">)</span>    
show_result<span style="color: #757575;">(</span>convolve2d<span style="color: #757575;">(</span>orig_image<span style="color: #757575;">,</span>kernel_edge<span style="color: #757575;">),</span><span style="color: #2aa198;">"edge detection"</span><span style="color: #757575;">)</span>    
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #268bd2;">m</span>=np.array<span style="color: #757575;">(</span>[[1<span style="color: #757575;">,</span>1<span style="color: #757575;">,</span>1]<span style="color: #757575;">,</span>[1<span style="color: #757575;">,</span>1<span style="color: #757575;">,</span>1<span style="color: #757575;">,</span>]<span style="color: #757575;">,</span>[1<span style="color: #757575;">,</span>1<span style="color: #757575;">,</span>1]]<span style="color: #757575;">)</span>
<span style="color: #268bd2;">kernel</span>=np.array<span style="color: #757575;">(</span>[[0<span style="color: #757575;">,</span>1<span style="color: #757575;">,</span>0]<span style="color: #757575;">,</span>[0<span style="color: #757575;">,</span>1<span style="color: #757575;">,</span>0]<span style="color: #757575;">,</span>[0<span style="color: #757575;">,</span>1<span style="color: #757575;">,</span>0]]<span style="color: #757575;">)</span>
<span style="color: #859900;">print</span><span style="color: #757575;">(</span>m<span style="color: #757575;">)</span>
<span style="color: #859900;">print</span><span style="color: #757575;">(</span>kernel<span style="color: #757575;">)</span>
<span style="color: #859900;">print</span><span style="color: #757575;">(</span>convolve2d<span style="color: #757575;">(</span>m<span style="color: #757575;">,</span>kernel<span style="color: #757575;">))</span>
</pre>
</div>

<pre class="example" id="org5a61e1c">
[[1 1 1]
 [1 1 1]
 [1 1 1]]
[[0 1 0]
 [0 1 0]
 [0 1 0]]
[[2 2 2]
 [3 3 3]
 [2 2 2]]
</pre>
</div>
</div>

<div id="outline-container-org2b7b156" class="outline-5">
<h5 id="org2b7b156"><span class="section-number-5">1.2.2.2</span> im2col</h5>
<div class="outline-text-5" id="text-1-2-2-2">
<p>
卷积操作实际上可以转换为普通的矩阵乘法
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900;">import</span> numpy <span style="color: #859900;">as</span> np


<span style="color: #859900;">def</span> <span style="color: #268bd2;">get_im2col_indices</span><span style="color: #757575;">(</span>x_shape<span style="color: #757575;">,</span> field_height<span style="color: #757575;">,</span> field_width<span style="color: #757575;">,</span> padding=1<span style="color: #757575;">,</span> stride=1<span style="color: #757575;">)</span>:
  <span style="color: #586e75;"># </span><span style="color: #586e75;">First figure out what the size of the output should be</span>
  <span style="color: #268bd2;">N</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">C</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">H</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">W</span> = x_shape
  <span style="color: #859900;">assert</span> <span style="color: #757575;">(</span>H + 2 * padding - field_height<span style="color: #757575;">)</span> % stride == 0
  <span style="color: #859900;">assert</span> <span style="color: #757575;">(</span>W + 2 * padding - field_height<span style="color: #757575;">)</span> % stride == 0
  <span style="color: #268bd2;">out_height</span> = <span style="color: #757575;">(</span>H + 2 * padding - field_height<span style="color: #757575;">)</span> // stride + 1
  <span style="color: #268bd2;">out_width</span> = <span style="color: #757575;">(</span>W + 2 * padding - field_width<span style="color: #757575;">)</span> // stride + 1

  <span style="color: #268bd2;">i0</span> = np.repeat<span style="color: #757575;">(</span>np.arange<span style="color: #757575;">(</span>field_height<span style="color: #757575;">),</span> field_width<span style="color: #757575;">)</span>
  <span style="color: #268bd2;">i0</span> = np.tile<span style="color: #757575;">(</span>i0<span style="color: #757575;">,</span> C<span style="color: #757575;">)</span>
  <span style="color: #268bd2;">i1</span> = stride * np.repeat<span style="color: #757575;">(</span>np.arange<span style="color: #757575;">(</span>out_height<span style="color: #757575;">),</span> out_width<span style="color: #757575;">)</span>
  <span style="color: #268bd2;">j0</span> = np.tile<span style="color: #757575;">(</span>np.arange<span style="color: #757575;">(</span>field_width<span style="color: #757575;">),</span> field_height * C<span style="color: #757575;">)</span>
  <span style="color: #268bd2;">j1</span> = stride * np.tile<span style="color: #757575;">(</span>np.arange<span style="color: #757575;">(</span>out_width<span style="color: #757575;">),</span> out_height<span style="color: #757575;">)</span>
  <span style="color: #268bd2;">i</span> = i0.reshape<span style="color: #757575;">(</span>-1<span style="color: #757575;">,</span> 1<span style="color: #757575;">)</span> + i1.reshape<span style="color: #757575;">(</span>1<span style="color: #757575;">,</span> -1<span style="color: #757575;">)</span>
  <span style="color: #268bd2;">j</span> = j0.reshape<span style="color: #757575;">(</span>-1<span style="color: #757575;">,</span> 1<span style="color: #757575;">)</span> + j1.reshape<span style="color: #757575;">(</span>1<span style="color: #757575;">,</span> -1<span style="color: #757575;">)</span>

  <span style="color: #268bd2;">k</span> = np.repeat<span style="color: #757575;">(</span>np.arange<span style="color: #757575;">(</span>C<span style="color: #757575;">),</span> field_height * field_width<span style="color: #757575;">)</span>.reshape<span style="color: #757575;">(</span>-1<span style="color: #757575;">,</span> 1<span style="color: #757575;">)</span>

  <span style="color: #859900;">return</span> <span style="color: #757575;">(</span>k<span style="color: #757575;">,</span> i<span style="color: #757575;">,</span> j<span style="color: #757575;">)</span>


<span style="color: #859900;">def</span> <span style="color: #268bd2;">im2col_indices</span><span style="color: #757575;">(</span>x<span style="color: #757575;">,</span> field_height<span style="color: #757575;">,</span> field_width<span style="color: #757575;">,</span> padding=1<span style="color: #757575;">,</span> stride=1<span style="color: #757575;">)</span>:
  <span style="color: #2aa198;">""" An implementation of im2col based on some fancy indexing """</span>
  <span style="color: #586e75;"># </span><span style="color: #586e75;">Zero-pad the input</span>
  <span style="color: #268bd2;">p</span> = padding
  <span style="color: #268bd2;">x_padded</span> = np.pad<span style="color: #757575;">(</span>x<span style="color: #757575;">,</span> <span style="color: #757575;">((</span>0<span style="color: #757575;">,</span> 0<span style="color: #757575;">),</span> <span style="color: #757575;">(</span>0<span style="color: #757575;">,</span> 0<span style="color: #757575;">),</span> <span style="color: #757575;">(</span>p<span style="color: #757575;">,</span> p<span style="color: #757575;">),</span> <span style="color: #757575;">(</span>p<span style="color: #757575;">,</span> p<span style="color: #757575;">)),</span> mode=<span style="color: #2aa198;">'constant'</span><span style="color: #757575;">)</span>

  <span style="color: #268bd2;">k</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">i</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">j</span> = get_im2col_indices<span style="color: #757575;">(</span>x.shape<span style="color: #757575;">,</span> field_height<span style="color: #757575;">,</span> field_width<span style="color: #757575;">,</span> padding<span style="color: #757575;">,</span>
                               stride<span style="color: #757575;">)</span>

  <span style="color: #268bd2;">cols</span> = x_padded[:<span style="color: #757575;">,</span> k<span style="color: #757575;">,</span> i<span style="color: #757575;">,</span> j]
  <span style="color: #268bd2;">C</span> = x.shape[1]
  <span style="color: #268bd2;">cols</span> = cols.transpose<span style="color: #757575;">(</span>1<span style="color: #757575;">,</span> 2<span style="color: #757575;">,</span> 0<span style="color: #757575;">)</span>.reshape<span style="color: #757575;">(</span>field_height * field_width * C<span style="color: #757575;">,</span> -1<span style="color: #757575;">)</span>
  <span style="color: #859900;">return</span> cols


<span style="color: #859900;">def</span> <span style="color: #268bd2;">col2im_indices</span><span style="color: #757575;">(</span>cols<span style="color: #757575;">,</span> x_shape<span style="color: #757575;">,</span> field_height=3<span style="color: #757575;">,</span> field_width=3<span style="color: #757575;">,</span> padding=1<span style="color: #757575;">,</span>
                   stride=1<span style="color: #757575;">)</span>:
  <span style="color: #2aa198;">""" An implementation of col2im based on fancy indexing and np.add.at """</span>
  <span style="color: #268bd2;">N</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">C</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">H</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">W</span> = x_shape
  <span style="color: #268bd2;">H_padded</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">W_padded</span> = H + 2 * padding<span style="color: #757575;">,</span> W + 2 * padding
  <span style="color: #268bd2;">x_padded</span> = np.zeros<span style="color: #757575;">((</span>N<span style="color: #757575;">,</span> C<span style="color: #757575;">,</span> H_padded<span style="color: #757575;">,</span> W_padded<span style="color: #757575;">),</span> dtype=cols.dtype<span style="color: #757575;">)</span>
  <span style="color: #268bd2;">k</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">i</span><span style="color: #757575;">,</span> <span style="color: #268bd2;">j</span> = get_im2col_indices<span style="color: #757575;">(</span>x_shape<span style="color: #757575;">,</span> field_height<span style="color: #757575;">,</span> field_width<span style="color: #757575;">,</span> padding<span style="color: #757575;">,</span>
                               stride<span style="color: #757575;">)</span>
  <span style="color: #268bd2;">cols_reshaped</span> = cols.reshape<span style="color: #757575;">(</span>C * field_height * field_width<span style="color: #757575;">,</span> -1<span style="color: #757575;">,</span> N<span style="color: #757575;">)</span>
  <span style="color: #268bd2;">cols_reshaped</span> = cols_reshaped.transpose<span style="color: #757575;">(</span>2<span style="color: #757575;">,</span> 0<span style="color: #757575;">,</span> 1<span style="color: #757575;">)</span>
  np.add.at<span style="color: #757575;">(</span>x_padded<span style="color: #757575;">,</span> <span style="color: #757575;">(</span><span style="color: #839496;">slice</span><span style="color: #757575;">(</span><span style="color: #268bd2; font-weight: bold;">None</span><span style="color: #757575;">),</span> k<span style="color: #757575;">,</span> i<span style="color: #757575;">,</span> j<span style="color: #757575;">),</span> cols_reshaped<span style="color: #757575;">)</span>
  <span style="color: #859900;">if</span> padding == 0:
    <span style="color: #859900;">return</span> x_padded
  <span style="color: #859900;">return</span> x_padded[:<span style="color: #757575;">,</span> :<span style="color: #757575;">,</span> padding:-padding<span style="color: #757575;">,</span> padding:-padding]

<span style="color: #859900;">pass</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900;">def</span> <span style="color: #268bd2;">convolve_im2col</span><span style="color: #757575;">(</span>image<span style="color: #757575;">,</span>kernel<span style="color: #757575;">)</span>:
    <span style="color: #268bd2;">image</span>=image.reshape<span style="color: #757575;">(</span>1<span style="color: #757575;">,</span>1<span style="color: #757575;">,</span>160<span style="color: #757575;">,</span>160<span style="color: #757575;">)</span>
    <span style="color: #268bd2;">image_col</span>=im2col_indices<span style="color: #757575;">(</span>image<span style="color: #757575;">,</span> kernel.shape[0]<span style="color: #757575;">,</span>kernel.shape[1]<span style="color: #757575;">)</span>
    <span style="color: #268bd2;">kernel</span>=kernel.reshape<span style="color: #757575;">(</span>1<span style="color: #757575;">,</span>-1<span style="color: #757575;">)</span>
    <span style="color: #268bd2;">image_conv</span>=np.dot<span style="color: #757575;">(</span>kernel<span style="color: #757575;">,</span>image_col<span style="color: #757575;">)</span>.reshape<span style="color: #757575;">(</span>160<span style="color: #757575;">,</span>160<span style="color: #757575;">)</span>
    <span style="color: #859900;">return</span> image_conv

show_result<span style="color: #757575;">(</span>convolve_im2col<span style="color: #757575;">(</span>orig_image<span style="color: #757575;">,</span>kernel_sharpen<span style="color: #757575;">),</span><span style="color: #2aa198;">"sharpen"</span><span style="color: #757575;">)</span>  
show_result<span style="color: #757575;">(</span>convolve_im2col<span style="color: #757575;">(</span>orig_image<span style="color: #757575;">,</span>kernel_edge<span style="color: #757575;">),</span><span style="color: #2aa198;">"edge"</span><span style="color: #757575;">)</span>  
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #268bd2;">test_image</span>=np.arange<span style="color: #757575;">(</span>0<span style="color: #757575;">,</span>64<span style="color: #757575;">,</span>1<span style="color: #757575;">)</span>.reshape<span style="color: #757575;">(</span>1<span style="color: #757575;">,</span>1<span style="color: #757575;">,</span>8<span style="color: #757575;">,</span>8<span style="color: #757575;">)</span>
<span style="color: #859900;">print</span><span style="color: #757575;">(</span>test_image<span style="color: #757575;">)</span>
<span style="color: #268bd2;">col</span>=im2col_indices<span style="color: #757575;">(</span>test_image<span style="color: #757575;">,</span>3<span style="color: #757575;">,</span>3<span style="color: #757575;">,</span>1<span style="color: #757575;">,</span>1<span style="color: #757575;">)</span>
<span style="color: #859900;">print</span><span style="color: #757575;">(</span>col.shape<span style="color: #757575;">)</span>
<span style="color: #859900;">print</span><span style="color: #757575;">(</span>col[:<span style="color: #757575;">,</span>0]<span style="color: #757575;">)</span>
<span style="color: #859900;">print</span><span style="color: #757575;">(</span>col[:<span style="color: #757575;">,</span>1]<span style="color: #757575;">)</span>
<span style="color: #859900;">print</span><span style="color: #757575;">(</span>col[:<span style="color: #757575;">,</span>2]<span style="color: #757575;">)</span>

</pre>
</div>

<pre class="example" id="orge9c5c55">
[[[[ 0  1  2  3  4  5  6  7]
   [ 8  9 10 11 12 13 14 15]
   [16 17 18 19 20 21 22 23]
   [24 25 26 27 28 29 30 31]
   [32 33 34 35 36 37 38 39]
   [40 41 42 43 44 45 46 47]
   [48 49 50 51 52 53 54 55]
   [56 57 58 59 60 61 62 63]]]]
(9, 64)
[0 0 0 0 0 1 0 8 9]
[ 0  0  0  0  1  2  8  9 10]
[ 0  0  0  1  2  3  9 10 11]
</pre>
</div>
</div>

<div id="outline-container-orgbbd78e7" class="outline-5">
<h5 id="orgbbd78e7"><span class="section-number-5">1.2.2.3</span> winograd</h5>
<div class="outline-text-5" id="text-1-2-2-3">
<p>
<a href="https://arxiv.org/pdf/1509.09308.pdf">https://arxiv.org/pdf/1509.09308.pdf</a>
</p>

<p>
winograd 在实现上有许多限制:
<a href="http://nvdla.org/hw/v1/ias/unit_description.html#winograd-convolution">http://nvdla.org/hw/v1/ias/unit_description.html#winograd-convolution</a>
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org7aafa0e" class="outline-3">
<h3 id="org7aafa0e"><span class="section-number-3">1.3</span> Deconv2D</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Deconv2D 有两种等价的计算方法:
</p>
</div>

<div id="outline-container-org692830e" class="outline-4">
<h4 id="org692830e"><span class="section-number-4">1.3.1</span> 通过加 padding 和 dilation 转换为 Conv2D</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
<a href="https://datascience.stackexchange.com/questions/6107/what-are-deconvolutional-layers">https://datascience.stackexchange.com/questions/6107/what-are-deconvolutional-layers</a>
</p>
</div>
</div>

<div id="outline-container-orgd1bf7c9" class="outline-4">
<h4 id="orgd1bf7c9"><span class="section-number-4">1.3.2</span> 通过 gemm+col2im</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
<a href="https://bbs.cvmart.net/articles/1755">https://bbs.cvmart.net/articles/1755</a>
假设:
</p>

<ol class="org-ol">
<li>output 的 shape 为 \(C_{out}*H_{out}*W_{out}\)</li>
<li>W 的 shape 为 \(C_{out}*C_{in}*K_h*W_h\)</li>
<li>input 为 \(Cin*Hin*Win\)</li>
</ol>

<p>
计算 Conv2D 的过程为:
</p>

<ol class="org-ol">
<li>input 通过 im2col 转换为 \((C_{in}*K_h*K_w)*H_{out}*W_{out}\)</li>
<li>\(W = C_{out}*(C_{in}*K_h*K_w) \implies output = W * input = C_{out}*H_{out}*W_{out}\)</li>
</ol>

<p>
计算 Deconv2D 的过程为:
</p>

<ol class="org-ol">
<li>\(W^T = C_{out}*(K_h*W_h)*C_{in}\)</li>
<li>\(output = W^T * input = C_{out}*(K_h*W_h)*H_{in}*W_{in}\)</li>
<li>通过 col2im 填充输出为 \(C_{out}*H_{out}*W_{out}\)</li>
</ol>

<p>
我觉得可以这样直观的理解一下 gemm+col2im 的方式:
</p>

<p>
conv 本质上是把长度为 k 的 block 变成一个点, 实际就是一个 matmul((x,k),(k,1))
</p>

<p>
deconv 需要把这一个点再变回长度为 k 的 block, 那么做一个 matmul((x,1),(1,k)) 就可以了&#x2026;
</p>

<p>
(k,1) 是 conv kernel, (1,k) 是 deconv kernel, 所以 deconv 也叫 conv_transposed
</p>
</div>
</div>
</div>

<div id="outline-container-orge6398c6" class="outline-3">
<h3 id="orge6398c6"><span class="section-number-3">1.4</span> DepthwiseConv2D</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-org44540b8" class="outline-4">
<h4 id="org44540b8"><span class="section-number-4">1.4.1</span> DepthwiseConv2D</h4>
<div class="outline-text-4" id="text-1-4-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900;">import</span> numpy <span style="color: #859900;">as</span> np
<span style="color: #859900;">import</span> tensorflow <span style="color: #859900;">as</span> tf
<span style="color: #859900;">from</span> tensorflow <span style="color: #859900;">import</span> keras
<span style="color: #859900;">from</span> tensorflow.keras <span style="color: #859900;">import</span> layers<span style="color: #757575;">,</span> losses<span style="color: #757575;">,</span> metrics<span style="color: #757575;">,</span> optimizers<span style="color: #757575;">,</span> models


<span style="color: #268bd2;">inputs</span> = keras.Input<span style="color: #757575;">(</span>shape=<span style="color: #757575;">(</span>10<span style="color: #757575;">,</span> 10<span style="color: #757575;">,</span> 3<span style="color: #757575;">))</span>

<span style="color: #268bd2;">outputs_ds_cnn</span> = layers.DepthwiseConv2D<span style="color: #757575;">(</span>
    kernel_size=[2<span style="color: #757575;">,</span> 2]<span style="color: #757575;">,</span> strides=[2<span style="color: #757575;">,</span> 2]<span style="color: #757575;">,</span> padding=<span style="color: #2aa198;">"same"</span>
<span style="color: #757575;">)(</span>inputs<span style="color: #757575;">)</span>
<span style="color: #268bd2;">outputs_ds_cnn</span> = layers.Conv2D<span style="color: #757575;">(</span>
    filters=20<span style="color: #757575;">,</span> kernel_size=[1<span style="color: #757575;">,</span> 1]<span style="color: #757575;">,</span> strides=[1<span style="color: #757575;">,</span> 1]<span style="color: #757575;">,</span> padding=<span style="color: #2aa198;">"same"</span>
<span style="color: #757575;">)(</span>outputs_ds_cnn<span style="color: #757575;">)</span>
<span style="color: #268bd2;">outputs_cnn</span> = layers.Conv2D<span style="color: #757575;">(</span>20<span style="color: #757575;">,</span> kernel_size=[2<span style="color: #757575;">,</span> 2]<span style="color: #757575;">,</span> strides=[2<span style="color: #757575;">,</span> 2]<span style="color: #757575;">,</span> padding=<span style="color: #2aa198;">"same"</span><span style="color: #757575;">)(</span>
    inputs
<span style="color: #757575;">)</span>
<span style="color: #268bd2;">model_dscnn</span> = keras.Model<span style="color: #757575;">(</span>inputs<span style="color: #757575;">,</span> outputs_ds_cnn<span style="color: #757575;">)</span>
<span style="color: #268bd2;">model_cnn</span> = keras.Model<span style="color: #757575;">(</span>inputs<span style="color: #757575;">,</span> outputs_cnn<span style="color: #757575;">)</span>

<span style="color: #586e75;"># </span><span style="color: #586e75;">5,5,20</span>
<span style="color: #859900;">print</span><span style="color: #757575;">(</span><span style="color: #2aa198;">"output_shape:"</span><span style="color: #757575;">)</span>
<span style="color: #859900;">print</span><span style="color: #757575;">(</span>outputs_ds_cnn.shape<span style="color: #757575;">)</span>
<span style="color: #859900;">print</span><span style="color: #757575;">(</span>outputs_cnn.shape<span style="color: #757575;">)</span>
<span style="color: #586e75;"># </span><span style="color: #586e75;">2,2,3,20</span>
<span style="color: #859900;">print</span><span style="color: #757575;">(</span><span style="color: #2aa198;">"conv weight:"</span><span style="color: #757575;">)</span>
<span style="color: #859900;">print</span><span style="color: #757575;">(</span>model_cnn.layers[1].weights[0].shape<span style="color: #757575;">)</span>
<span style="color: #859900;">print</span><span style="color: #757575;">(</span><span style="color: #2aa198;">"ds conv weight:"</span><span style="color: #757575;">)</span>
<span style="color: #586e75;"># </span><span style="color: #586e75;">2,2,3,1</span>
<span style="color: #859900;">print</span><span style="color: #757575;">(</span>model_dscnn.layers[1].weights[0].shape<span style="color: #757575;">)</span>
<span style="color: #586e75;"># </span><span style="color: #586e75;">1,1,3,20</span>
<span style="color: #859900;">print</span><span style="color: #757575;">(</span>model_dscnn.layers[2].weights[0].shape<span style="color: #757575;">)</span>
</pre>
</div>

<p>
output_shape:
(None, 5, 5, 20)
(None, 5, 5, 20)
conv weight:
(2, 2, 3, 20)
ds conv weight:
(2, 2, 3, 1)
(1, 1, 3, 20)
</p>

<p>
假设 input_channel 为 c, depth_multiplier 为 m.
</p>

<p>
DepthwiseConv2D 有 c 个 kernel, 每个 kernel 为 [m, 1, h, w]
</p>

<p>
input 沿 channel 划分为 c 份 , 每份为 ([N, 1, H, W]), 使用一个 kernel 做
conv2d.
</p>

<p>
一共做 c 次 conv2d, 每个 conv2d 的 output channel 为 m, 所以 DepthwiseConv2D 总的 ouput channel 为 m*c.
</p>

<p>
与 Conv2D 相比, DepthwiseConv2D 的参数个数和计算量减少很多: DepthwiseConv2D 的参数为 c 个 [m, 1, h, w], Conv2D 为 [o, c, h, w], 两者比例为 m/o
</p>
</div>
</div>

<div id="outline-container-org3016a0f" class="outline-4">
<h4 id="org3016a0f"><span class="section-number-4">1.4.2</span> SeparatableConv2D</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
DepthwiseConv2D 后再接一个 1x1 的 Conv2D 可以把 output channel 从 m*c 变为 O
</p>

<p>
DepthwiseConv2D + 1x1 Conv2d 即 SeparatableConv2D
</p>
</div>
</div>

<div id="outline-container-org38b7822" class="outline-4">
<h4 id="org38b7822"><span class="section-number-4">1.4.3</span> group conv2d</h4>
<div class="outline-text-4" id="text-1-4-3">
<p>
caffe, tensorflow, pytorch 的 conv2d 均支持 group 参数, 称为 group conv2d.
</p>

<p>
group conv2d 是指 input channel/output channel 均被划分为 m 个 group, 每个 group
使用单独的 kenrel 计算 conv2d, 每个 kernel shape 为 [O/m, I/m, h, w].
</p>

<p>
例如, input channel 为 40, output channel 为 60, group 为 10, 则 kernel 为 10 个
[6, 4, h, w]
</p>

<p>
实际上, 如果像 1x1 卷积那样, 把卷积部分看做一个简单的乘法, 考虑针对 channel 的操作, 可以把 conv2d 看作 IxO 的 fc, 那么 group conv2d 就相当于 g 个 (I/g) x (O/g)
的 fc. 例如, 把 10x10 的 fc 变成两个 5x5 的 fc 再把结果拼起来.
</p>

<p>
DepthwiseConv2D 是 group conv2d 的特殊情况:
</p>

<ol class="org-ol">
<li>ouput channel 等于 input channel</li>
<li>group 等于 input channel</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org57ebfa9" class="outline-3">
<h3 id="org57ebfa9"><span class="section-number-3">1.5</span> <a href="dynamic_shaped_network.html#org23fdf8a">Dynamic Shaped Network</a></h3>
</div>

<div id="outline-container-orgd660d59" class="outline-3">
<h3 id="orgd660d59"><span class="section-number-3">1.6</span> <a href="nn_benchmark.html#org10d1c68">How To Calculate FLOPs</a></h3>
</div>
</div>
</div>
<div id="postamble" class="status">

<p class="author">Author: sunway (sunwayforever@gmail.com)<br />
Date: <br />
Last updated: 2022-01-25 二 10:45</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。
<br />

<div id="disqus_thread"></div>
<script>

(function() { // DON'T EDIT BELOW THIS LINE
         var d = document, s = d.createElement('script');
         s.src = '//sunwayforever-github-io.disqus.com/embed.js';
         s.setAttribute('data-timestamp', +new Date());
         (d.head || d.body).appendChild(s);
         })();
</script>
</div>
</body>
</html>
