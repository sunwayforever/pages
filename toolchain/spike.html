<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>Spike</title>


           <link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
           <link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
           <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
           <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
           <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
           <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
           <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
           <link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
           <link rel="stylesheet" type="text/css" href="../main.css" media="screen" />
           <link rel="stylesheet" type="text/css" href="./main.css" media="screen" />
           <link rel = "icon" href = "/icon.png"  type = "image/x-icon">
</head>
<body>
<div id="content" class="content">
<h1 class="title">Spike</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org0000039">1. Spike</a>
<ul>
<li><a href="#org000002a">1.1. interpreter</a>
<ul>
<li><a href="#org0000003">1.1.1. register</a></li>
<li><a href="#org0000006">1.1.2. init</a></li>
<li><a href="#org0000024">1.1.3. execute</a></li>
<li><a href="#org0000027">1.1.4. 添加新的指令</a></li>
</ul>
</li>
<li><a href="#org000002d">1.2. htif</a></li>
<li><a href="#org0000030">1.3. pk</a></li>
<li><a href="#org0000033">1.4. boot</a></li>
<li><a href="#org0000037">1.5. commit log</a></li>
<li><a href="#org000003a">1.6. force-riscv</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org0000039" class="outline-2">
<h2 id="org0000039"><span class="section-number-2">1.</span> Spike</h2>
<div class="outline-text-2" id="text-1">
<p>
基于 <a href="https://github.com/riscv/riscv-isa-sim.git">https://github.com/riscv/riscv-isa-sim.git</a>, master 分支, commit: 1cfffe
</p>
</div>

<div id="outline-container-org000002a" class="outline-3">
<h3 id="org000002a"><span class="section-number-3">1.1.</span> interpreter</h3>
<div class="outline-text-3" id="text-1-1">
<p>
spike 和 qemu 类似, 但它不像 <a href="qemu_tcg.html#ID-fedb153b-c9a7-4ad1-a66e-e08b91173dd3">QEMU TCG</a> 那样执行二进制翻译: 它通过一个 interpreter
在 host 上执行 riscv 指令
</p>

<p>
interpreter 的核心是一个 loop:
</p>

<ol class="org-ol">
<li><p>
fetch
</p>

<p>
通过虚拟的 mmu 来执行
</p></li>

<li><p>
decode
</p>

<p>
spike 并没有像 qemu/objdump/gdb 一样使用 binutils 来解析指令, 但也是用的类似的机制: 根据每条指令的 mask 和 match 来匹配二进制指令
</p></li>

<li><p>
execute
</p>

<p>
由于 spike 不需要进行二进制翻译, 所以指令执行通过一个简单的回调即可, 例如
<code>rv64i_addi</code> 函数用来执行 addi 指令
</p></li>
</ol>

<p>
spike 通过 DECLARE_INSN 完成 decode 和 execute 所需的相关信息 (mask, match,
callback) 的注册
</p>
</div>

<div id="outline-container-org0000003" class="outline-4">
<h4 id="org0000003"><span class="section-number-4">1.1.1.</span> register</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
binutils 的 opcodes 用来定义支持的 opcode, 对应的 mask 和 match. spike 通过
riscv.mk.in 和 encoding.h 来实现.
</p>

<p>
riscv.mk.in 是 automake 的输入, 做为 Makefile 的模板. 指令列表定义在这里.
</p>

<pre class="example" id="org0000000">
riscv_insn_ext_i = \
    add \
    addi \
    addiw \
    addw \
    and \
    andi \
    auipc \
    beq \
    bge \
    bgeu \
    ...

riscv_insn_list = \
    $(riscv_insn_ext_a) \
    $(riscv_insn_ext_c) \
    $(riscv_insn_ext_i) \
    ...

insn_list.h: $(src_dir)/riscv/riscv.mk.in
    for insn in $(foreach insn,$(riscv_insn_list),$(subst .,_,$(insn))) ; do \
        printf 'DEFINE_INSN(%s)\n' "$${insn}" ; \
    done &gt; $@.tmp
    mv $@.tmp $@    
</pre>

<p>
make 时生成的 insn_list.h:
</p>

<pre class="example" id="org0000001">
...
DEFINE_INSN(addi)
DEFINE_INSN(addiw)
...
</pre>

<p>
使用 insn_list.h 完成指令的注册:
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">processor_t</span>::<span class="org-function-name">register_base_instructions</span>() {
<span class="org-preprocessor">#define</span> <span class="org-function-name">DECLARE_INSN</span>(<span class="org-variable-name">name</span>, <span class="org-variable-name">match</span>, <span class="org-variable-name">mask</span>)                       \
    insn_bits_t name##_match = (match), name##_mask = (mask); \
    <span class="org-type">bool</span> <span class="org-variable-name">name</span>##_supported = <span class="org-constant">true</span>;

<span class="org-preprocessor">#include</span> <span class="org-string">"encoding.h"</span>
<span class="org-preprocessor">#undef</span> DECLARE_INSN

<span class="org-preprocessor">#define</span> <span class="org-function-name">DEFINE_INSN</span>(<span class="org-variable-name">name</span>)                                          \
    <span class="org-keyword">extern</span> reg_t rv32i_##name(<span class="org-type">processor_t</span>*, insn_t, reg_t);        \
    <span class="org-keyword">extern</span> reg_t rv64i_##name(<span class="org-type">processor_t</span>*, insn_t, reg_t);        \
    <span class="org-keyword">extern</span> reg_t rv32e_##name(<span class="org-type">processor_t</span>*, insn_t, reg_t);        \
    <span class="org-keyword">extern</span> reg_t rv64e_##name(<span class="org-type">processor_t</span>*, insn_t, reg_t);        \
    register_insn((insn_desc_t){                                   \
        name##_supported, name##_match, name##_mask, rv32i_##name, \
        rv64i_##name, rv32e_##name, rv64e_##name});
<span class="org-preprocessor">#include</span> <span class="org-string">"insn_list.h"</span>
<span class="org-preprocessor">#undef</span> DEFINE_INSN
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
}

<span class="org-type">void</span> <span class="org-constant">processor_t</span>::<span class="org-function-name">register_insn</span>(<span class="org-type">insn_desc_t</span> <span class="org-variable-name">desc</span>) {
    instructions.push_back(desc);
}
</pre>
</div>

<p>
其中 DEFINE_INSN 需要的 xxx_supported, xxx_match, xxx_mask 定义在 encoding.h 中
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
<span class="org-preprocessor">#define</span> <span class="org-variable-name">MATCH_ADDI</span> 0x13
<span class="org-preprocessor">#define</span> <span class="org-variable-name">MASK_ADDI</span>  0x707f
<span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
DECLARE_INSN(addi, MATCH_ADDI, MASK_ADDI)
<span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
</pre>
</div>

<p>
DEFINE_INSN 还需要 rv64i_xxx 等函数, 它们定义在 build/xxx.cc 中, 但这个文件是编译时生成的
</p>

<pre class="example" id="org0000002">
$(riscv_gen_srcs): %.cc: insns/%.h insn_template.cc
    sed 's/NAME/$(subst .cc,,$@)/' $(src_dir)/riscv/insn_template.cc | sed 's/OPCODE/$(call get_opcode,$(src_dir)/riscv/encoding.h,$(subst .cc,,$@))/' &gt; $@
</pre>

<p>
即 make 进会根据 riscv_insn_list 找到 insns 下的 xxx.h, 然后根据
<code>riscv/insn_template.cc</code> 生成 xxx.cc, 里面会 rv64i_xxx 的定义
</p>
</div>
</div>

<div id="outline-container-org0000006" class="outline-4">
<h4 id="org0000006"><span class="section-number-4">1.1.2.</span> init</h4>
<div class="outline-text-4" id="text-1-1-2">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span>** <span class="org-variable-name">argv</span>)
  <span class="org-comment-delimiter">// </span>
  <span class="org-type">sim_t</span> <span class="org-variable-name">s</span>(&amp;cfg, halted,
      mems, plugin_devices, htif_args, dm_config, log_path, dtb_enabled, dtb_file, cmd_file);        
    <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; cfg-&gt;nprocs(); i++): 
      procs[i] = <span class="org-keyword">new</span> <span class="org-type">processor_t</span>(&amp;isa, cfg-&gt;varch(), <span class="org-keyword">this</span>, cfg-&gt;hartids()[i], halted, log_file.get(), sout_);
        register_base_instructions();
        mmu = <span class="org-keyword">new</span> <span class="org-type">mmu_t</span>(sim, <span class="org-keyword">this</span>);
        <span class="org-keyword">for</span> (<span class="org-keyword">auto</span> <span class="org-variable-name">e</span> : isa-&gt;get_extensions()) register_extension(e.second);
        reset();
</pre>
</div>

<p>
其中 reset 会把 target pc 设置为 DEFAULT_RSTVEC (0x00001000), 这是 target 指令的首地址, 位于 bootrom
</p>
</div>
</div>

<div id="outline-container-org0000024" class="outline-4">
<h4 id="org0000024"><span class="section-number-4">1.1.3.</span> execute</h4>
<div class="outline-text-4" id="text-1-1-3">
</div>
<div id="outline-container-org0000009" class="outline-5">
<h5 id="org0000009"><span class="section-number-5">1.1.3.1.</span> host</h5>
<div class="outline-text-5" id="text-1-1-3-1">
<p>
spike 执行时分为 host 和 target 两部分, host 和 target 可以用不同的 thread 来实现, 但默认配置下它们是通过 <a href="../tech/coroutine.html#ID-054e8734-5bc9-4d12-8714-a3e39e9e92ce">coroutine</a> 实现的 (swapcontext)
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">spike.cc</span>
<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span>** <span class="org-variable-name">argv</span>)
  <span class="org-comment-delimiter">// </span>
  <span class="org-type">sim_t</span> <span class="org-variable-name">s</span>(&amp;cfg, halted,
      mems, plugin_devices, htif_args, dm_config, log_path, dtb_enabled, dtb_file,
      cmd_file);        
  <span class="org-keyword">auto</span> <span class="org-variable-name">return_code</span> = s.run();

<span class="org-comment-delimiter">// </span><span class="org-comment">sim.cc</span>
<span class="org-type">int</span> <span class="org-constant">sim_t</span>::<span class="org-function-name">run</span>() {
  host = <span class="org-constant">context_t</span>::current();
  target.init(sim_thread_main, <span class="org-keyword">this</span>);
  <span class="org-keyword">return</span> <span class="org-constant">htif_t</span>::run();
}
</pre>
</div>

<p>
其中 htif (Host Target InterFace) 用来沟通 host 与 target, 例如, target 的 pk
(proxy kernel) 通过 htif 让 host 响应 target 发起的 syscall
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">int</span> <span class="org-constant">htif_t</span>::<span class="org-function-name">run</span>():
  start();
    load_program();
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#21069;&#38754; sim_t &#21021;&#22987;&#21270;&#26102;&#24050;&#32463;&#35774;&#32622;&#20102; target pc &#21040; bootrom &#30340; DEFAULT_RSTVEC (0x00001000) &#22788;</span>
    reset();
      set_rom();
  <span class="org-keyword">if</span> (tohost_addr == 0) {
    <span class="org-keyword">while</span> (<span class="org-constant">true</span>)
      idle();
  }
  <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>

<span class="org-type">void</span> <span class="org-constant">sim_t</span>::<span class="org-function-name">idle</span>():
  target.switch_to();
  <span class="org-comment-delimiter">// </span><span class="org-comment">~~~~~~~~~~~~~~~~</span>
    swapcontext(prev-&gt;context.get(), context.get())
      sim_thread_main()
        <span class="org-constant">sim_t</span>::main()

<span class="org-constant">sim_t</span>::<span class="org-function-name">main</span>() : 
  <span class="org-keyword">while</span> (<span class="org-negation-char">!</span>done()): 
    step(INTERLEAVE);

<span class="org-type">void</span> <span class="org-constant">sim_t</span>::<span class="org-function-name">step</span>(<span class="org-type">size_t</span> <span class="org-variable-name">n</span>): 
    <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0, <span class="org-variable-name">steps</span> = 0; i &lt; n; i += steps):
    steps = <span class="org-constant">std</span>::min(n - i, INTERLEAVE - current_step);
    procs[current_proc]-&gt;step(steps);

    current_step += steps;
    <span class="org-keyword">if</span> (current_step == INTERLEAVE): 
      current_step = 0;
      procs[current_proc]-&gt;get_mmu()-&gt;yield_load_reservation();
      host-&gt;switch_to();
      <span class="org-comment-delimiter">// </span><span class="org-comment">~~~~~~~~~~~~~~~</span>
</pre>
</div>

<p>
target 执行一定 step 后, 会通过 host 的 switch_to 切换到 host, 后者对应
<code>htif_t::run</code>, 会处理和 fromhost, tohost 相关的功能:
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">int</span> <span class="org-constant">htif_t</span>::<span class="org-function-name">run</span>():
  <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  <span class="org-keyword">while</span> (<span class="org-negation-char">!</span>signal_exit &amp;&amp; exitcode == 0)
  {
    <span class="org-type">uint64_t</span> <span class="org-variable-name">tohost</span>;

    <span class="org-keyword">try</span> {
      <span class="org-keyword">if</span> ((tohost = from_target(mem.read_uint64(tohost_addr))) != 0)
        mem.write_uint64(tohost_addr, <span class="org-constant">target_endian</span>&lt;<span class="org-type">uint64_t</span>&gt;::zero);
    } <span class="org-keyword">catch</span> (<span class="org-type">mem_trap_t</span>&amp; <span class="org-variable-name">t</span>) {
      bad_address(<span class="org-string">"accessing tohost"</span>, t.get_tval());
    }

    <span class="org-keyword">try</span> {
      <span class="org-keyword">if</span> (tohost != 0) {
        <span class="org-type">command_t</span> <span class="org-variable-name">cmd</span>(mem, tohost, fromhost_callback);
        device_list.handle_command(cmd);
      } <span class="org-keyword">else</span> {
        idle();
      }
      device_list.tick();
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  }

  stop();

  <span class="org-keyword">return</span> exit_code();
}
</pre>
</div>

<p>
假设 target 是 pk, 希望调用 sys_write 这个 syscall:
</p>

<ol class="org-ol">
<li>target::step 会把 sys_write 对应的信息以特定的编码写到 tohost memory 中</li>

<li>target 会 switch_to host, host 从 idle 处开始执行</li>

<li>host 从 tohost buffer 拿到具体的信息放在 mem 中</li>

<li>host 调用 device 的 handle_command, 在初始化时注册的 syscall_proxy 这个
device 会响应这个 cmd, 最终代理执行这个 sys_write</li>
</ol>
</div>
</div>

<div id="outline-container-org0000021" class="outline-5">
<h5 id="org0000021"><span class="section-number-5">1.1.3.2.</span> target</h5>
<div class="outline-text-5" id="text-1-1-3-2">
<p>
target 端执行的代码在 <code>processor_t::step</code>, 用来处理 target 指令的
fetch/decode/execute
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">processor_t</span>::<span class="org-function-name">step</span>(<span class="org-type">size_t</span> <span class="org-variable-name">n</span>):
  <span class="org-keyword">try</span>:
    <span class="org-keyword">while</span> (n &gt; 0) {
      <span class="org-type">size_t</span> <span class="org-variable-name">instret</span> = 0;
      <span class="org-type">reg_t</span> <span class="org-variable-name">pc</span> = state.pc;
      <span class="org-type">mmu_t</span>* <span class="org-variable-name">_mmu</span> = mmu;

      <span class="org-keyword">while</span> (instret &lt; n):
        <span class="org-type">insn_fetch_t</span> <span class="org-variable-name">fetch</span> = mmu-&gt;load_insn(pc);
        pc = execute_insn(<span class="org-keyword">this</span>, pc, fetch);
      n -= instret;
  <span class="org-keyword">catch</span> (<span class="org-type">trap_t</span> &amp;<span class="org-variable-name">t</span>):
    take_trap(t, pc);  
</pre>
</div>
</div>

<div id="outline-container-org000000c" class="outline-6">
<h6 id="org000000c"><span class="section-number-6">1.1.3.2.1.</span> load_insn</h6>
<div class="outline-text-6" id="text-1-1-3-2-1">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">insn_fetch_t</span> <span class="org-function-name">load_insn</span>(<span class="org-type">reg_t</span> <span class="org-variable-name">addr</span>): 
  <span class="org-type">icache_entry_t</span> <span class="org-variable-name">entry</span>;
  <span class="org-keyword">return</span> refill_icache(addr, &amp;entry)-&gt;data;

<span class="org-type">icache_entry_t</span>* <span class="org-function-name">refill_icache</span>(<span class="org-type">reg_t</span> <span class="org-variable-name">addr</span>, <span class="org-type">icache_entry_t</span>* <span class="org-variable-name">entry</span>): 
  <span class="org-keyword">auto</span> <span class="org-variable-name">tlb_entry</span> = translate_insn_addr(addr);
  <span class="org-type">insn_bits_t</span> <span class="org-variable-name">insn</span> = from_le(*(<span class="org-type">uint16_t</span>*)(tlb_entry.host_offset + addr));
  <span class="org-type">int</span> <span class="org-variable-name">length</span> = insn_length(insn);

  <span class="org-keyword">if</span> (likely(length == 4)) {
    insn |= (<span class="org-type">insn_bits_t</span>)from_le(*(<span class="org-keyword">const</span> <span class="org-type">int16_t</span>*)translate_insn_addr_to_host(addr + 2)) &lt;&lt; 16;
  } <span class="org-keyword">else</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">... }</span>

  <span class="org-type">insn_fetch_t</span> <span class="org-variable-name">fetch</span> = {proc-&gt;decode_insn(insn), insn};
  entry-&gt;tag = addr;
  entry-&gt;next = &amp;icache[icache_index(addr + length)];
  entry-&gt;data = fetch;
  <span class="org-keyword">return</span> entry;
</pre>
</div>
</div>
</div>

<div id="outline-container-org000000f" class="outline-6">
<h6 id="org000000f"><span class="section-number-6">1.1.3.2.2.</span> decode_insn</h6>
<div class="outline-text-6" id="text-1-1-3-2-2">
<p>
decode_insn 扫描 register_base_instructions 注册的 insn_desc_t, 查找与
mask/match 匹配的指令, 返回到对应的 callback 例如 rv64i_addi
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">insn_func_t</span> <span class="org-constant">processor_t</span>::<span class="org-function-name">decode_insn</span>(<span class="org-type">insn_t</span> <span class="org-variable-name">insn</span>):
  <span class="org-type">int</span> <span class="org-variable-name">cnt</span> = 0;
  <span class="org-type">insn_desc_t</span>* <span class="org-variable-name">p</span> = &amp;instructions[0];
  <span class="org-keyword">while</span> ((insn.bits() &amp; p-&gt;mask) != p-&gt;match || <span class="org-negation-char">!</span>desc.func(xlen, rve))
    p++, cnt++;
  desc = *p;

  <span class="org-keyword">if</span> (p-&gt;mask != 0 &amp;&amp; p &gt; &amp;instructions[0]) {
    <span class="org-keyword">if</span> (p-&gt;match != (p - 1)-&gt;match &amp;&amp; p-&gt;match != (p + 1)-&gt;match) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">move to front of opcode list to reduce miss penalty</span>
      <span class="org-keyword">while</span> (--p &gt;= &amp;instructions[0])
        *(p + 1) = *p;
        instructions[0] = desc;

    opcode_cache[idx] = desc;
    opcode_cache[idx].match = insn.bits();

  <span class="org-keyword">return</span> desc.func(xlen, rve);
</pre>
</div>
</div>
</div>

<div id="outline-container-org0000012" class="outline-6">
<h6 id="org0000012"><span class="section-number-6">1.1.3.2.3.</span> execute_insn</h6>
<div class="outline-text-6" id="text-1-1-3-2-3">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">reg_t</span> <span class="org-function-name">execute_insn</span>(<span class="org-type">processor_t</span>* <span class="org-variable-name">p</span>, <span class="org-type">reg_t</span> <span class="org-variable-name">pc</span>, <span class="org-type">insn_fetch_t</span> <span class="org-variable-name">fetch</span>)
  <span class="org-keyword">return</span> fetch.func(p, fetch.insn, pc);
</pre>
</div>

<p>
其中 fetch.func 对应具体的指令实现, 以 rv64i_addi 为例:
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">reg_t</span> <span class="org-function-name">rv64i_addi</span>(<span class="org-type">processor_t</span>* <span class="org-variable-name">p</span>, <span class="org-type">insn_t</span> <span class="org-variable-name">insn</span>, <span class="org-type">reg_t</span> <span class="org-variable-name">pc</span>) {
<span class="org-preprocessor">#define</span> <span class="org-variable-name">xlen</span> 64
    <span class="org-type">reg_t</span> <span class="org-variable-name">npc</span> = sext_xlen(pc + insn_length(MATCH_ADDI));
<span class="org-preprocessor">#include</span> <span class="org-string">"insns/addi.h"</span>
<span class="org-preprocessor">#undef</span> xlen
    <span class="org-keyword">return</span> npc;
}
</pre>
</div>

<p>
<code>insns/addi.h</code> 的内容为:
</p>

<div class="org-src-container">
<pre class="src src-C++">WRITE_RD(sext_xlen(RS1 + insn.i_imm()));
</pre>
</div>

<p>
WRITE_RD 最终会修改 <code>processor-&gt;state_t-&gt;XPR</code>, 以模拟修改寄存器的操作
</p>
</div>
</div>

<div id="outline-container-org000001e" class="outline-6">
<h6 id="org000001e"><span class="section-number-6">1.1.3.2.4.</span> trap</h6>
<div class="outline-text-6" id="text-1-1-3-2-4">
</div>
<ol class="org-ol">
<li><a id="org0000018"></a>ecall<br />
<div class="outline-text-7" id="text-1-1-3-2-4-1">
<p>
导致 trap 的 ecall 指令在模拟时只是 throw 一个 c++ 的 trap_t exception 即可, 外层的 processor_t::step 会 catch 这个 trap_t, 调用 take_trap
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">switch</span> (STATE.prv)
{
  <span class="org-keyword">case</span> PRV_U: <span class="org-keyword">throw</span> trap_user_ecall();
  <span class="org-keyword">case</span> PRV_S:
    <span class="org-keyword">if</span> (STATE.v)
      <span class="org-keyword">throw</span> trap_virtual_supervisor_ecall();
    <span class="org-keyword">else</span>
      <span class="org-keyword">throw</span> trap_supervisor_ecall();
  <span class="org-keyword">case</span> PRV_M: <span class="org-keyword">throw</span> trap_machine_ecall();
  <span class="org-keyword">default</span>: abort();
}
</pre>
</div>
</div>
</li>

<li><a id="org0000015"></a>take_trap<br />
<div class="outline-text-7" id="text-1-1-3-2-4-2">
<p>
take_trap 模拟了中断的处理: 跳转到 tvec, 设置 epc, cause 等
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">processor_t</span>::<span class="org-function-name">take_trap</span>(<span class="org-type">trap_t</span>&amp; <span class="org-variable-name">t</span>, <span class="org-type">reg_t</span> <span class="org-variable-name">epc</span>):
  <span class="org-comment-delimiter">// </span><span class="org-comment">....</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">default handle the trap in M-mode</span>
  <span class="org-type">reg_t</span> <span class="org-variable-name">vector</span> = (state.mtvec-&gt;read() &amp; 1) &amp;&amp; interrupt ? 4 * bit : 0;
  state.pc = (state.mtvec-&gt;read() &amp; ~(<span class="org-type">reg_t</span>)1) + vector;
  state.mepc-&gt;write(epc);
  state.mcause-&gt;write(t.cause());
  state.mtval-&gt;write(t.get_tval());
  <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  <span class="org-type">reg_t</span> <span class="org-variable-name">s</span> = state.mstatus-&gt;read();
  s = set_field(s, MSTATUS_MPIE, get_field(s, MSTATUS_MIE));
  s = set_field(s, MSTATUS_MPP, state.prv);
  <span class="org-comment-delimiter">// </span><span class="org-comment">..</span>
  state.mstatus-&gt;write(s);
  set_privilege(PRV_M);
</pre>
</div>
</div>
</li>

<li><a id="org000001b"></a>mret<br />
<div class="outline-text-7" id="text-1-1-3-2-4-3">
<p>
从 trap 返回的 mret 指令:
</p>

<div class="org-src-container">
<pre class="src src-C++">require_privilege(PRV_M);
<span class="org-comment-delimiter">// </span><span class="org-comment">&#20174; mepc &#24674;&#22797; pc</span>
set_pc_and_serialize(p-&gt;get_state()-&gt;mepc-&gt;read());
<span class="org-type">reg_t</span> <span class="org-variable-name">s</span> = STATE.mstatus-&gt;read();
<span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
s = set_field(s, MSTATUS_MIE, get_field(s, MSTATUS_MPIE));
s = set_field(s, MSTATUS_MPIE, 1);
<span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
p-&gt;put_csr(CSR_MSTATUS, s);
p-&gt;set_privilege(prev_prv);
<span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org0000027" class="outline-4">
<h4 id="org0000027"><span class="section-number-4">1.1.4.</span> 添加新的指令</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
添加新的指令时有两种选择:
</p>

<ol class="org-ol">
<li>把它做为 base instruction

<ul class="org-ul">
<li>修改 riscv.mk.in 中指令的列表,</li>

<li>添加 insns/xxx.h</li>

<li>为了支持 debug, 还需要修改 disasm/disasm.cc, 添加针对 xxx 指令的部分</li>
</ul></li>

<li>使用 spike 自带的 extension 机制, 可以参考 riscv/extension.h</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org000002d" class="outline-3">
<h3 id="org000002d"><span class="section-number-3">1.2.</span> htif</h3>
<div class="outline-text-3" id="text-1-2">
<p>
htif 是 Host Target InterFace, 代码在 fesvr 目录 (Front End SerVeR), spike 通过它可以与 host 交互:
</p>

<ol class="org-ol">
<li>读取 host 的数据</li>

<li>发送数据给 host</li>
</ol>

<p>
有了这个 IO 通道, 可以完成一些更复杂的功能, 例如:
</p>

<ol class="org-ol">
<li>target 通知 host 程序执行结果并返回结果</li>

<li>target 要求 host 执行 syscall</li>
</ol>

<p>
例如
<a href="https://github.com/sunwayforever/code/blob/master/hello_world/hello_baremetal/riscv/main.c">https://github.com/sunwayforever/code/blob/master/hello_world/hello_baremetal/riscv/main.c</a>,
通过把 tohost 置为 1, 可以通知 host 停止模拟并返回结果
</p>
</div>
</div>

<div id="outline-container-org0000030" class="outline-3">
<h3 id="org0000030"><span class="section-number-3">1.3.</span> pk</h3>
<div class="outline-text-3" id="text-1-3">
<p>
spike 可以直接运行 bare-metal 程序 (例如
<a href="https://github.com/sunwayforever/code/tree/master/hello_world/hello_baremetal/riscv">https://github.com/sunwayforever/code/tree/master/hello_world/hello_baremetal/riscv</a>).
</p>

<p>
如果要运行非 bare-metal 程序, 则需要 pk (Proxy Kernel), 为非 bare-metal 的 riscv
程序提供一个基本的执行环境, 类似于 qemu 的 user-mode emulation. 例如:
</p>

<ol class="org-ol">
<li>bootloader</li>

<li>中断向量</li>

<li>加载 elf</li>

<li>支持 syscall, 主要是 IO 和 memory 相关</li>
</ol>

<p>
pk 本身可以响应一部分 syscall, 例如 sys_dup, 但有一些 syscall 例如 sys_write 需要通过 htif 由 host 去执行
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="org-type">ssize_t</span> <span class="org-function-name">sys_write</span>(<span class="org-type">int</span> <span class="org-variable-name">fd</span>, <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">buf</span>, <span class="org-type">size_t</span> <span class="org-variable-name">n</span>) {
    <span class="org-comment-delimiter">/* </span><span class="org-comment">...</span><span class="org-comment-delimiter"> */</span>
    <span class="org-keyword">if</span> (f) {
        <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">total</span> = 0;;) {
            <span class="org-comment-delimiter">/* </span><span class="org-comment">...</span><span class="org-comment-delimiter"> */</span>
            r = file_write(f, kbuf, cur);
            <span class="org-comment-delimiter">/* </span><span class="org-comment">...</span><span class="org-comment-delimiter"> */</span>
        }
    }
    <span class="org-keyword">return</span> r;
}

<span class="org-type">ssize_t</span> <span class="org-function-name">file_write</span>(<span class="org-type">file_t</span>* <span class="org-variable-name">f</span>, <span class="org-keyword">const</span> <span class="org-type">void</span>* <span class="org-variable-name">buf</span>, <span class="org-type">size_t</span> <span class="org-variable-name">size</span>) {
    <span class="org-keyword">return</span> frontend_syscall(SYS_write, f-&gt;kfd, kva2pa(buf), size, 0, 0, 0, 0);
}

<span class="org-type">long</span> <span class="org-function-name">frontend_syscall</span>(
    <span class="org-type">long</span> <span class="org-variable-name">n</span>, <span class="org-type">uint64_t</span> <span class="org-variable-name">a0</span>, <span class="org-type">uint64_t</span> <span class="org-variable-name">a1</span>, <span class="org-type">uint64_t</span> <span class="org-variable-name">a2</span>, <span class="org-type">uint64_t</span> <span class="org-variable-name">a3</span>, <span class="org-type">uint64_t</span> <span class="org-variable-name">a4</span>,
    <span class="org-type">uint64_t</span> <span class="org-variable-name">a5</span>, <span class="org-type">uint64_t</span> <span class="org-variable-name">a6</span>) {
    <span class="org-keyword">static</span> <span class="org-keyword">volatile</span> <span class="org-type">uint64_t</span> <span class="org-variable-name">magic_mem</span>[8];

    <span class="org-keyword">static</span> <span class="org-type">spinlock_t</span> <span class="org-variable-name">lock</span> = SPINLOCK_INIT;
    spinlock_lock(&amp;lock);

    magic_mem[0] = n;
    magic_mem[1] = a0;
    magic_mem[2] = a1;
    magic_mem[3] = a2;
    magic_mem[4] = a3;
    magic_mem[5] = a4;
    magic_mem[6] = a5;
    magic_mem[7] = a6;

    htif_syscall(kva2pa_maybe(magic_mem));

    <span class="org-type">long</span> <span class="org-variable-name">ret</span> = magic_mem[0];

    spinlock_unlock(&amp;lock);
    <span class="org-keyword">return</span> ret;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org0000033" class="outline-3">
<h3 id="org0000033"><span class="section-number-3">1.4.</span> boot</h3>
<div class="outline-text-3" id="text-1-4">
<p>
spike 定义了 abstract_device_t, 其实现包括 mem_t, rom_device_t, mmio_device_t,
bus_t, 每个 device 需要指定其对应的地址范围, 后续 target 对相应内存的访问会被
relay 到不同的 device.
</p>

<p>
htif_t::run 会调用 set_rom 设置 bootrom 的内容:
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">sim_t</span>::<span class="org-function-name">set_rom</span>() {
    <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">reset_vec_size</span> = 8;

    <span class="org-type">reg_t</span> <span class="org-variable-name">start_pc</span> = cfg-&gt;start_pc.value_or(get_entry_point());

    <span class="org-type">uint32_t</span> <span class="org-variable-name">reset_vec</span>[reset_vec_size] = {
        0x297,                                         <span class="org-comment-delimiter">// </span><span class="org-comment">auipc  t0,0x0</span>
        0x28593 + (reset_vec_size * 4 &lt;&lt; 20),          <span class="org-comment-delimiter">// </span><span class="org-comment">addi   a1, t0, &amp;dtb</span>
        0xf1402573,                                    <span class="org-comment-delimiter">// </span><span class="org-comment">csrr   a0, mhartid</span>
        get_core(0)-&gt;get_xlen() == 32 ? 0x0182a283u :  <span class="org-comment-delimiter">// </span><span class="org-comment">lw     t0,24(t0)</span>
            0x0182b283u,                               <span class="org-comment-delimiter">// </span><span class="org-comment">ld     t0,24(t0)</span>
        0x28067,                                       <span class="org-comment-delimiter">// </span><span class="org-comment">jr     t0</span>
        0,
        (<span class="org-type">uint32_t</span>)(start_pc &amp; 0xffffffff),
        (<span class="org-type">uint32_t</span>)(start_pc &gt;&gt; 32)};
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
    <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">char</span>&gt; <span class="org-variable-name">rom</span>(
        (<span class="org-type">char</span>*)reset_vec, (<span class="org-type">char</span>*)reset_vec + <span class="org-keyword">sizeof</span>(reset_vec));

    rom.insert(rom.end(), dtb.begin(), dtb.end());
    <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">align</span> = 0x1000;
    rom.resize((rom.size() + align - 1) / align * align);

    boot_rom.reset(<span class="org-keyword">new</span> <span class="org-type">rom_device_t</span>(rom));
    bus.add_device(DEFAULT_RSTVEC, boot_rom.get());
}
</pre>
</div>

<ol class="org-ol">
<li>sim_t 初始化时已经把 target pc 设置为 DEFAULT_RSTVEC (0x00001000)</li>

<li>bus.add_device 后 target 针对 DEFAULT_RSTVEC 地址的访问会读取到 bootrom 的数据</li>

<li>bootrom 把 elf 的 entry (start_pc) 直接写到 reset_vec 中, 所以 bootrom 启动后会跳转到 elf 的 entry, 完成启动</li>
</ol>
</div>
</div>

<div id="outline-container-org0000037" class="outline-3">
<h3 id="org0000037"><span class="section-number-3">1.5.</span> commit log</h3>
<div class="outline-text-3" id="text-1-5">
<p>
spike 是一个 riscv 的 ISS (instruction stream simulator), 运行时可以产生
commit log, 用来比对 DUT 和 DUV 的结果. 默认情况下不产生 commit log, 要生成
commit log 需要:
</p>

<ol class="org-ol">
<li>configure 时指定 <code>--enable-commitlog</code></li>

<li>运行时指定 <code>--log-commits</code></li>
</ol>

<p>
找开 commit log 后, 针对寄存器和内存的读写操作都会被记录下来, 例如:
</p>

<pre class="example" id="org0000036">
core   0: 3 0x0000000000001000 (0x00000297) x 5 0x0000000000001000
core   0: 3 0x0000000000001004 (0x02028593) x11 0x0000000000001020
core   0: 3 0x0000000000001008 (0xf1402573) x10 0x0000000000000000
core   0: 3 0x000000000000100c (0x0182b283) x 5 0x0000000080000040 mem 0x0000000000001018
core   0: 3 0x0000000000001010 (0x00028067)
core   0: 3 0x0000000080000040 (0x00001117) x 2 0x0000000080001040
core   0: 3 0x0000000080000044 (0xfc010113) x 2 0x0000000080001000
core   0: 3 0x0000000080000048 (0xfb9ff0ef) x 1 0x000000008000004c
core   0: 3 0x0000000080000000 (0xfe010113) x 2 0x0000000080000fe0
core   0: 3 0x0000000080000004 (0x00813c23) mem 0x0000000080000ff8 0x0000000000000000
core   0: 3 0x0000000080000008 (0x02010413) x 8 0x0000000080001000
core   0: 3 0x000000008000000c (0x00100793) x15 0x0000000000000001
core   0: 3 0x0000000080000010 (0xfef42623) mem 0x0000000080000fec 0x00000001
core   0: 3 0x0000000080000014 (0xfec42783) x15 0x0000000000000001 mem 0x0000000080000fec
core   0: 3 0x0000000080000018 (0x0017879b) x15 0x0000000000000002
core   0: 3 0x000000008000001c (0xfef42423) mem 0x0000000080000fe8 0x00000002
core   0: 3 0x0000000080000020 (0x00001797) x15 0x0000000080001020
core   0: 3 0x0000000080000024 (0xfe078793) x15 0x0000000080001000
core   0: 3 0x0000000080000028 (0x00100713) x14 0x0000000000000001
core   0: 3 0x000000008000002c (0x00e7b023) mem 0x0000000080001000 0x0000000000000001
core   0: 3 0x0000000080000030 (0x00000013)
core   0: 3 0x0000000080000034 (0x01813403) x 8 0x0000000000000000 mem 0x0000000080000ff8
core   0: 3 0x0000000080000038 (0x02010113) x 2 0x0000000080001000
core   0: 3 0x000000008000003c (0x00008067)
</pre>

<p>
使用 spike 做 ISS 的例子参考 <a href="https://github.com/chipsalliance/riscv-dv">https://github.com/chipsalliance/riscv-dv</a> 及 <a href="https://riscv.org/wp-content/uploads/2019/12/12.10-16.10b-Open-Source-Verification-Platform-for-RISC-V-Processors.pdf">Open-Source-Verification-Platform-for-RISC-V-Processors</a>
</p>
</div>
</div>

<div id="outline-container-org000003a" class="outline-3">
<h3 id="org000003a"><span class="section-number-3">1.6.</span> force-riscv</h3>
<div class="outline-text-3" id="text-1-6">
<p>
<a href="https://github.com/openhwgroup/force-riscv">https://github.com/openhwgroup/force-riscv</a>
</p>

<p>
force-riscv 是一个 RISC-V 的 ISG (instruction stream generator), 但它内置了一个名为 handcar 的模拟器, handcar 基于 spike 改写, 添加了一些功能例如提供了读写寄存器的接口.
</p>

<p>
由于它内置了一个模拟器, 所以 fore-riscv 在生成随机指令时是可以用一些 `运行时` 的信息来控制指令的生成, 例如:
</p>

<ol class="org-ol">
<li>根据寄存器的值生成不同的指令</li>

<li>生成对齐或非对齐的数据访问</li>

<li>生成指令访问指定的虚拟地址</li>
</ol>

<p>
force-riscv 通过 python api 可以控制具体生成什么样的指令, 例如:
</p>

<ol class="org-ol">
<li>指定使用特定的寄存器</li>

<li>指定 imm 的值</li>

<li>使用随机的寄存器时 reserve 某些寄存器</li>
</ol>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">from</span> riscv.EnvRISCV <span class="org-keyword">import</span> EnvRISCV
<span class="org-keyword">from</span> riscv.GenThreadRISCV <span class="org-keyword">import</span> GenThreadRISCV
<span class="org-keyword">from</span> base.Sequence <span class="org-keyword">import</span> Sequence


<span class="org-keyword">class</span> <span class="org-type">MySequence</span>(Sequence):
    <span class="org-keyword">def</span> <span class="org-function-name">generate</span>(<span class="org-keyword">self</span>, <span class="org-operator">**</span>kargs):
        <span class="org-comment-delimiter"># </span><span class="org-comment">&#36890;&#36807; handcar &#32473; x5 &#36171;&#20540;</span>
        <span class="org-keyword">self</span>.initializeRegister(<span class="org-string">"x5"</span>, 0x123)
        <span class="org-comment-delimiter"># </span><span class="org-comment">&#29983;&#25104;&#38543;&#26426;&#30340; addi &#25351;&#20196;</span>
        <span class="org-keyword">self</span>.genInstruction(<span class="org-string">"ADDI##RISCV"</span>)
        <span class="org-comment-delimiter"># </span><span class="org-comment">&#25351;&#23450; addi &#20351;&#29992; x5, &#19988; imm &#20351;&#29992;&#29305;&#23450;&#33539;&#22260;&#30340;&#38543;&#26426;&#20540;</span>
        <span class="org-keyword">self</span>.genInstruction(<span class="org-string">"ADDI##RISCV"</span>, {<span class="org-string">"rs1"</span>: 5, <span class="org-string">"simm12"</span>: <span class="org-string">"0x123-0x126"</span>, <span class="org-string">"rd"</span>: 5})
        (<span class="org-variable-name">reg_value</span>, <span class="org-variable-name">value_valid</span>) <span class="org-operator">=</span> <span class="org-keyword">self</span>.readRegister(<span class="org-string">"x5"</span>)
        <span class="org-comment-delimiter"># </span><span class="org-comment">&#26681;&#25454; x5 &#30340;&#20540;&#29983;&#25104;&#19981;&#21516;&#30340;&#25351;&#20196;</span>
        <span class="org-keyword">if</span> reg_value <span class="org-operator">==</span> 0x123:
            <span class="org-keyword">self</span>.genInstruction(<span class="org-string">"ADD##RISCV"</span>, {<span class="org-string">"rs1"</span>: 5, <span class="org-string">"rs2"</span>: 5, <span class="org-string">"rd"</span>: 5})
        <span class="org-keyword">else</span>:
            <span class="org-keyword">self</span>.genInstruction(<span class="org-string">"ADD##RISCV"</span>, {<span class="org-string">"rs1"</span>: 5, <span class="org-string">"rs2"</span>: 6, <span class="org-string">"rd"</span>: 5})

        <span class="org-comment-delimiter"># </span><span class="org-comment">handcar &#26412;&#36523;&#37197;&#32622;&#20102;&#39029;&#34920; (&#21442;&#32771; riscv/arch_data/paging/ &#19979;&#30340; xml), &#36825;&#37324;&#21487;</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">&#20197;&#29983;&#25104;&#38024;&#23545;&#25351;&#23450; va &#30340;&#20869;&#23384;&#35775;&#38382;</span>
        <span class="org-variable-name">target_addr</span> <span class="org-operator">=</span> <span class="org-keyword">self</span>.genVA(Range <span class="org-operator">=</span> <span class="org-string">"0x10000-0x10000"</span>)
        <span class="org-keyword">self</span>.genInstruction(<span class="org-string">"LD##RISCV"</span>,{<span class="org-string">"LSTarget"</span>: target_addr})

        <span class="org-keyword">self</span>.genInstruction(<span class="org-string">"SRA##RISCV"</span>)

<span class="org-variable-name">MainSequenceClass</span> <span class="org-operator">=</span> MySequence
<span class="org-variable-name">GenThreadClass</span> <span class="org-operator">=</span> GenThreadRISCV
<span class="org-variable-name">EnvClass</span> <span class="org-operator">=</span> EnvRISCV
</pre>
</div>

<p>
python api 可以使用的指令 (例如 ADD##RISCV) 及配置 (例如 rs1, simm12) 在
riscv/arch_data/instr/ 下的 xml 里可以找到
</p>

<p>
另外, force-riscv 生成的 elf 里并不仅仅包含 python api (例如上面
Sequence::generate) 生成的指令, 它还会自己生成一些初始化的代码, 例如完成寄存器
(包括 CSR) 的初始化, 例如初始化中断和页表等.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

<p class="author">Author: sunway@dogdog.run<br />
Date: 2023-02-15 Wed 10:22<br />
Last updated: 2023-03-07 Tue 17:06</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
</div>
</body>
</html>