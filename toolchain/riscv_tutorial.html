<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>RISC-V Tutorial</title>

<link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
<link rel="stylesheet" type="text/css" href="../main.css" media="screen" />
<link rel="stylesheet" type="text/css" href="./main.css" media="screen" />
<link rel = "icon" href = "/icon.png"  type = "image/x-icon">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">RISC-V Tutorial</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org00000e5">1. RISC-V Tutorial</a>
<ul>
<li><a href="#org000001d">1.1. Setup Environment</a>
<ul>
<li><a href="#org0000001">1.1.1. Install Toolchain</a></li>
<li><a href="#org000001a">1.1.2. Build &amp; Run</a></li>
</ul>
</li>
<li><a href="#org000006c">1.2. RISC-V Assembly</a>
<ul>
<li><a href="#org00000cd">1.2.1. Overview</a></li>
<li><a href="#org0000024">1.2.2. Register</a></li>
<li><a href="#org000004c">1.2.3. RV32I</a></li>
<li><a href="#org000004f">1.2.4. Pseudo Instruction</a></li>
<li><a href="#ID-4db5f11b-34ce-491b-beaf-eb3333381f12">1.2.5. Relocation</a></li>
<li><a href="#org000007b">1.2.6. Demo</a></li>
</ul>
</li>
<li><a href="#org0000070">1.3. GNU Assembler</a>
<ul>
<li><a href="#org0000081">1.3.1. label</a></li>
<li><a href="#org0000085">1.3.2. directive</a></li>
<li><a href="#org0000052">1.3.3. risc-v modifiers</a></li>
</ul>
</li>
<li><a href="#org00000b2">1.4. Standard Extention</a>
<ul>
<li><a href="#org0000074">1.4.1. RV32M</a></li>
<li><a href="#org0000089">1.4.2. RV32F and RV32D</a></li>
<li><a href="#org0000097">1.4.3. RV32A</a></li>
<li><a href="#org000009a">1.4.4. RV32C</a></li>
<li><a href="#org00000b5">1.4.5. RV32V</a></li>
<li><a href="#org00000af">1.4.6. RV64G</a></li>
</ul>
</li>
<li><a href="#org00000c1">1.5. Privileged ISA</a>
<ul>
<li><a href="#org00000ce">1.5.1. Overview</a></li>
<li><a href="#org00000b8">1.5.2. Machine-Level CSRs</a></li>
<li><a href="#org00000bb">1.5.3. Supervisor-Level CSRs</a></li>
<li><a href="#org00000d7">1.5.4. Sample</a></li>
</ul>
</li>
<li><a href="#org00000ca">1.6. Misc</a>
<ul>
<li><a href="#org00000dc">1.6.1. RISC-V vs. MIPS</a></li>
<li><a href="#org00000c7">1.6.2. Arithmetic Overflow</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org00000e5" class="outline-2">
<h2 id="org00000e5"><span class="section-number-2">1</span> RISC-V Tutorial</h2>
<div class="outline-text-2" id="text-1">
<p>
<a href="https://riscv.org/technical/specifications/">https://riscv.org/technical/specifications/</a>
</p>

<p>
<a href="http://riscvbook.com/chinese/RISC-V-Reader-Chinese-v2p1.pdf">http://riscvbook.com/chinese/RISC-V-Reader-Chinese-v2p1.pdf</a>
</p>

<p>
<a href="https://tinyurl.com/2p8ezuym">Computer Organization and Design RISC-V Edition</a>
</p>
</div>

<div id="outline-container-org000001d" class="outline-3">
<h3 id="org000001d"><span class="section-number-3">1.1</span> Setup Environment</h3>
<div class="outline-text-3" id="text-1-1">
</div>
<div id="outline-container-org0000001" class="outline-4">
<h4 id="org0000001"><span class="section-number-4">1.1.1</span> Install Toolchain</h4>
<div class="outline-text-4" id="text-1-1-1">
<pre class="example" id="org0000000">
$&gt; sudo apt install gcc-riscv64-linux-gnu
$&gt; sudo apt install qemu-user
$&gt; sudo ln -s /usr/riscv64-linux-gnu/lib/ld-linux-riscv64-lp64d.so.1 /lib
</pre>
</div>
</div>

<div id="outline-container-org000001a" class="outline-4">
<h4 id="org000001a"><span class="section-number-4">1.1.2</span> Build &amp; Run</h4>
<div class="outline-text-4" id="text-1-1-2">
</div>
<div id="outline-container-org0000005" class="outline-5">
<h5 id="org0000005"><span class="section-number-5">1.1.2.1</span> C</h5>
<div class="outline-text-5" id="text-1-1-2-1">
<pre class="example" id="org0000004">
$&gt; riscv64-linux-gnu-gcc test.c -Wl,-rpath,/usr/riscv64-linux-gnu/lib/
$&gt; ./a.out
hello
</pre>
</div>
</div>

<div id="outline-container-org0000010" class="outline-5">
<h5 id="org0000010"><span class="section-number-5">1.1.2.2</span> ASM</h5>
<div class="outline-text-5" id="text-1-1-2-2">
</div>
<div id="outline-container-org0000009" class="outline-6">
<h6 id="org0000009"><span class="section-number-6">1.1.2.2.1</span> nostdlib</h6>
<div class="outline-text-6" id="text-1-1-2-2-1">
<div class="org-src-container">
<pre class="src src-asm">    ## riscv64-linux-gnu-gcc ./test.s -nostdlib -static
    ## or riscv64-linux-gnu-as ./test.s -o test.o &amp;&amp; riscv64-linux-gnu-ld ./test.o -o ./a.out

    <span class="org-keyword">.global</span> _start

<span class="org-function-name">_start</span>:
    <span class="org-keyword">addi</span>  a0, x0, 1
    <span class="org-keyword">la</span>    a1, helloworld 
    <span class="org-keyword">addi</span>  a2, x0, 13
    ## &#22240;&#20026;&#26159;&#29992; qemu + linux &#26469;&#25191;&#34892;, &#25152;&#20197;&#36825;&#37324;&#20351;&#29992;&#30340;&#26159; linux &#30340; syscall num
    ## 64 &#26159; write, 93 &#26159; exit
    <span class="org-keyword">addi</span>  a7, x0, 64 
    <span class="org-keyword">ecall</span> 

    <span class="org-keyword">addi</span>    a0, x0, 0
    <span class="org-keyword">addi</span>    a7, x0, 93
    <span class="org-keyword">ecall</span> 

    <span class="org-keyword">.data</span>
<span class="org-function-name">helloworld</span>:      .ascii <span class="org-string">"Hello World!\n"</span>

</pre>
</div>

<pre class="example" id="org0000008">
Hello World!
</pre>
</div>
</div>

<div id="outline-container-org000000d" class="outline-6">
<h6 id="org000000d"><span class="section-number-6">1.1.2.2.2</span> stdlib</h6>
<div class="outline-text-6" id="text-1-1-2-2-2">
<div class="org-src-container">
<pre class="src src-asm">    ## riscv64-linux-gnu-gcc test.s -static
    <span class="org-keyword">.global</span> main

<span class="org-function-name">main</span>:
    <span class="org-keyword">addi</span> sp, sp, -4
    <span class="org-keyword">sw</span> ra, 4(sp)

    <span class="org-keyword">la</span> a0, helloworld
    <span class="org-keyword">li</span> a1, 10
    <span class="org-keyword">jal</span> printf

    <span class="org-keyword">li</span> a0, 0
    <span class="org-keyword">lw</span> ra, 4(sp)
    <span class="org-keyword">addi</span> sp, sp, 4
    <span class="org-keyword">jr</span> ra

    <span class="org-keyword">.data</span>
<span class="org-function-name">helloworld</span>:      .ascii <span class="org-string">"Hello World: %d!\n"</span>

</pre>
</div>

<pre class="example" id="org000000c">
Hello World: 10!
</pre>
</div>
</div>
</div>

<div id="outline-container-org0000014" class="outline-5">
<h5 id="org0000014"><span class="section-number-5">1.1.2.3</span> Debug with QEMU GDB Server</h5>
<div class="outline-text-5" id="text-1-1-2-3">
<pre class="example" id="org0000013">
$&gt; qemu-riscv64 -g 12345  ./a.out

;; in another shell
$&gt; gdb-multiarch ./a.out
(gdb) target remote localhost 12345
Remote debugging using localhost:12345
_start () at test.s:7
7           addi  a0, x0, 1
</pre>

<p>
or use a simple wrapper script:
</p>

<div class="org-src-container">
<pre class="src src-bash"><span class="org-comment-delimiter">#</span><span class="org-comment">!/bin/</span><span class="org-keyword">bash</span>
<span class="org-keyword">if</span> [[ $<span class="org-variable-name">#</span> == 0 ]]; <span class="org-keyword">then</span>
    <span class="org-builtin">echo</span> <span class="org-string">"usage qemu-gdb.sh &lt;exec&gt;"</span>
    <span class="org-keyword">exit</span> 1
<span class="org-keyword">fi</span>

<span class="org-variable-name">app</span>=$<span class="org-variable-name">1</span>

cat &gt;/tmp/gdb.cmds &lt;&lt;hello
<span class="org-sh-heredoc">target remote localhost:12345</span>
<span class="org-sh-heredoc">hello</span>

qemu-riscv64 -g 12345  ./a.out &amp;
<span class="org-variable-name">qemu_pid</span>=$<span class="org-variable-name">!</span>
gdb-multiarch $<span class="org-variable-name">app</span> -x /tmp/gdb.cmds
<span class="org-builtin">kill</span> -9 $<span class="org-variable-name">qemu_pid</span> &amp;&gt;/dev/null
</pre>
</div>
</div>
</div>

<div id="outline-container-org0000017" class="outline-5">
<h5 id="org0000017"><span class="section-number-5">1.1.2.4</span> Debug with Spike</h5>
<div class="outline-text-5" id="text-1-1-2-4">
<p>
<a href="https://github.com/riscv-software-src/riscv-isa-sim">https://github.com/riscv-software-src/riscv-isa-sim</a>
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org000006c" class="outline-3">
<h3 id="org000006c"><span class="section-number-3">1.2</span> RISC-V Assembly</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-org00000cd" class="outline-4">
<h4 id="org00000cd"><span class="section-number-4">1.2.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
RSIC-V ISA 由一个基础指令集 RV32I 和一系列的扩展指令集组成:
</p>

<ul class="org-ul">
<li>RV32I 针对整数操作的 ISA, 47 条指令</li>
<li>RV32M 乘法和除法, 8 条</li>
<li>RV32F 单精度浮点数, 32 条</li>
<li>RV32D 双精度浮点数, 32 条</li>
<li>RV32A 原子操作, 11 条</li>
</ul>

<p>
以上所有加起来称为 RV32G, 除此以外, 还有额外两个扩展:
</p>

<ul class="org-ul">
<li>RV32C 指令压缩</li>
<li>RV32V 向量操作</li>
</ul>
</div>
</div>

<div id="outline-container-org0000024" class="outline-4">
<h4 id="org0000024"><span class="section-number-4">1.2.2</span> Register</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
RV32I 共定义了 32 个寄存器, 寄存器宽度为 32, 用 XLEN 表示
</p>


<div id="org0000023" class="figure">
<p><img src="../extra/riscv_reg.png" alt="riscv_reg.png" />
</p>
</div>

<p>
其中:
</p>

<ul class="org-ul">
<li>zero 始终为 0, 可以用来实现一些其它指令, 例如 addi t0, zero, 0x1 相当于给 t0
赋值为 1</li>

<li>ra 是 return address, 函数返回时默认返回地址在 ra, 通过 jalr zero, 0(ra) 返回</li>

<li>tp 是 thread pointer, 用来实现 <a href="thread_local_storage.html#ID-aee24416-b9d0-4295-9511-7dcf4b29468d">Thread Local Storage</a></li>

<li>gp 是 <a href="mips_tutorial.html#ID-dad2ac71-9292-447c-8f15-5882363d5993">global pointer</a></li>

<li>a0&#x2026;a7 做为函数参数, 同时 a0&#x2026;a1 做为函数返回值</li>

<li>t0&#x2026;t6 是 caller saved 通用寄存器</li>

<li>s1&#x2026;s11 是 callee saved 通用寄存器</li>

<li>fp 是 frame pointer, 主要和 <a href="backtrace.html#ID-c7408db7-c6d4-4085-97a1-644a9c61bd7b">Backtrace</a> 有关</li>

<li>sp</li>
</ul>
</div>
</div>

<div id="outline-container-org000004c" class="outline-4">
<h4 id="org000004c"><span class="section-number-4">1.2.3</span> RV32I</h4>
<div class="outline-text-4" id="text-1-2-3">
</div>
<div id="outline-container-org000002f" class="outline-5">
<h5 id="org000002f"><span class="section-number-5">1.2.3.1</span> Overview</h5>
<div class="outline-text-5" id="text-1-2-3-1">
<p>
RV32I 共 47 条指令, 长度均为 32bit, 分为 6 种格式:
</p>


<div id="org0000027" class="figure">
<p><img src="../extra/riscv_format.png" alt="riscv_format.png" />
</p>
</div>

<p>
操作码 (operator):
</p>

<ul class="org-ul">
<li>opcode, 类似的指令有相同的 opcode, 例如:

<ul class="org-ul">
<li>I 指令中的 load 指令 opcode 都是 b11</li>

<li>I 指令中的算术运算都是 b10011</li>

<li>R 指令都是 b110011</li>

<li>S 指令都是 b100011, B 指令都是 b1100111</li>

<li>U 指令为 b110111, J 指令为 b1101111</li>
</ul></li>

<li>funct3, funct7 是对 opcode 的补充, 例如所有的 load 指令的 opcode 都是 b11, 通过 func3 来区分 lb, lh, lw &#x2026;</li>
</ul>

<p>
操作数 (operand):
</p>

<ul class="org-ul">
<li>rd 目标寄存器</li>

<li>rs1 源寄存器 1</li>

<li>rs2 源寄存器 2</li>

<li>imm 立即数</li>
</ul>

<p>
其中 U,J 类型需要支持两个操作数, R,I,S,B 支持三个操作数.
</p>

<ol class="org-ol">
<li><p>
I, intermediate
</p>

<p>
I 指令需要三个操作数: rd, rs1, imm
</p>

<p>
I 指令包含 imm 和 load 两种操作, 因为两者的用法类似:
</p>

<ul class="org-ul">
<li>imm: rd(dest), rs1(op1), imm (op2)</li>

<li>load: rd(dest), rs1(base), imm(offset)</li>
</ul>

<p>
addi:
</p>

<pre class="example" id="org0000028">
12          5   3     5     7
------------------------------
imm[11:0]   rs1 000   rd    0010011
------------------------------
op1         op2       dest 
</pre>

<p>
lw:
</p>

<pre class="example" id="org0000029">
imm[11:0]   rs1   010   rd    0000011
-------------------------------------
offset      base        dest 
</pre></li>

<li><p>
R, register-register
</p>

<p>
R 指令需要三个操作数: rd(dest), rs1(op1), rs2(op2)
</p>

<p>
以 add 为例:
</p>

<pre class="example" id="org000002a">
7       5     5   3   5  7
------------------------------   
0000000 rs2   rs1 000 rd 0110011
------------------------------
        op1   op2     dest
</pre></li>

<li><p>
S, store
</p>

<p>
S 指令需要 3 个操作数: rs1(src), rs2(base), imm(offset)
</p>

<p>
以 sw 为例:
</p>

<pre class="example" id="org000002b">
7              5     5   3   5        7 
---------------------------------------------
imm[11:5]      rs2   rs1 010 imm[4:0] 0100011
---------------------------------------------
offset[11:5]   src   base    offset[4:0]
</pre></li>

<li><p>
B, branch
</p>

<p>
B 指令和 S 格式基本相同, 只是 imm 部分 bit 分配有些不同.
</p>

<p>
rs1 (op1), rs2 (op2), imm (offset)
</p>

<p>
以 blt 为例:
</p>

<pre class="example" id="org000002c">
imm[12|10:5] rs2 rs1 100 imm[4:1|11] 1100011
</pre>

<p>
imm 使用的是 imm[12:1], 因为 risc-v 指令最短是 16 bit (RV32C), 所以 offset 是
2 字节对齐的, 即 imm[0] 必定为 0, 使用 imm[12:1] 可以使 branch 范围变为
(-4k,+4k)+pc.
</p>

<p>
`+pc` 是指 pc-relative, B/J 指令都是 pc-relative 的, 它的操作数中的 imm 是跳转目标相对当前 pc 的偏移量.
</p>

<p>
如果 B 指令要跳转的范围大于 8k 小于 2M, 可以使用 jal:
</p>

<div class="org-src-container">
<pre class="src src-asm">## before
<span class="org-function-name">beq</span> <span class="org-keyword">s1</span>, s2, L1

## after
<span class="org-function-name">bne</span> <span class="org-keyword">s1</span>, s2, L2
<span class="org-function-name">jal</span> <span class="org-keyword">zero</span>, L1
</pre>
</div>

<p>
如果跳转范围大于 2M, 则需要换成 jalr:
</p>

<div class="org-src-container">
<pre class="src src-asm"><span class="org-function-name">1</span>:  <span class="org-keyword">auipc</span> a0, <span class="org-variable-name">%pcrel</span>_hi(L1)
    <span class="org-keyword">addi</span> a0, a0, <span class="org-variable-name">%pcrel</span>_lo(1b)

    <span class="org-keyword">bne</span> s1, s2, L2
    <span class="org-keyword">jalr</span> zero, 0(a0)
</pre>
</div></li>

<li><p>
U, upper intermediate
</p>

<p>
U 有两个操作数 rd (dest), imm, 加载 imm 到 rd 的高 20 bit
</p>

<p>
lui:
</p>

<pre class="example" id="org000002d">
imm[31:12] rd 0110111
</pre></li>

<li><p>
J, jump
</p>

<p>
J 指令与 U 指令格式基本相同
</p>

<p>
jal:
</p>

<pre class="example" id="org000002e">
imm[20|10:1|11|19:12] rd 1101111
</pre>

<p>
与 B 指令类似, 没有使用 imm[0], J 跳转范围扩大为 [-1M, +1M]+pc (<a href="#ID-119c2664-36d0-4cf5-ae13-0686350c3df8">relocation of jal</a>)
</p></li>
</ol>
</div>
</div>

<div id="outline-container-org00000d6" class="outline-5">
<h5 id="org00000d6"><span class="section-number-5">1.2.3.2</span> Sample</h5>
<div class="outline-text-5" id="text-1-2-3-2">
</div>
<div id="outline-container-org0000033" class="outline-6">
<h6 id="org0000033"><span class="section-number-6">1.2.3.2.1</span> I-Type Instructions</h6>
<div class="outline-text-6" id="text-1-2-3-2-1">
<p>
I 类型指令都是 `xxx rd, rs1, imm` 的形式, 其中 imm 12 bit, 包含以下指令:
</p>

<ul class="org-ul">
<li>addi</li>
<li>slti, sltiu</li>
<li>andi, ori, xori</li>
<li>slli, srli, srai</li>
<li>lw, lh, lb</li>
<li>lhu, lbu</li>
<li>jalr</li>
</ul>

<div class="org-src-container">
<pre class="src src-asm">    ## riscv64-linux-gnu-gcc test.s -static
    <span class="org-keyword">.global</span> main

<span class="org-function-name">main</span>:
    <span class="org-keyword">addi</span> sp, sp, -4
    <span class="org-keyword">sw</span> ra, 4(sp)

    ## ------ addi (add imm) ------
    <span class="org-keyword">la</span> a0, addi_msg
    ## i &#25351;&#20196;&#30340; imm &#26159; 12 bit, &#33539;&#22260;&#26159; -2048, 2047, &#36229;&#36807;&#20250;&#32534;&#35793;&#19981;&#36807;
    ## a1 = zero + (-2048)
    <span class="org-keyword">addi</span> a1, zero, -2048
    <span class="org-keyword">jal</span> printf

    ## ------ slti (set less than imm), sltiu (set less than imm unsigned) ------
    <span class="org-keyword">la</span> a0, slti_msg
    <span class="org-keyword">li</span> t0, 1023
    ## &#24403; t0 &lt; 1024 &#26102;, a1 = 1, &#21542;&#21017; a1 = 0
    <span class="org-keyword">slti</span> a1, t0, 1024
    <span class="org-keyword">jal</span> printf

    <span class="org-keyword">la</span> a0, slti_msg
    <span class="org-keyword">li</span> t0, 1024
    <span class="org-keyword">slti</span> a1, t0, 1024
    <span class="org-keyword">jal</span> printf

    <span class="org-keyword">la</span> a0, sltiu_msg
    <span class="org-keyword">li</span> t0, -1
    ## &#24403; (unsiged)t0 &lt; (unsigned)1024 &#26102;, a1 = 1, &#21542;&#21017; a1 = 0
    <span class="org-keyword">sltiu</span> a1, t0, 1024
    <span class="org-keyword">jal</span> printf

    ## ------ andi, ori, xori ------
    <span class="org-keyword">la</span> a0, and_or_xor_msg
    <span class="org-keyword">li</span> t0, 0x11
    <span class="org-keyword">andi</span> a1, t0, 0x01
    <span class="org-keyword">ori</span> a2, t0, 0x01
    <span class="org-keyword">xori</span> a3, t0, 0x01
    <span class="org-keyword">jal</span> printf

    ## ------ slli (shift left logical imm) ------
    ## ------ srli (shift right logical imm) ------
    ## ------ srai (shift right arithmetic imm) ------
    <span class="org-keyword">la</span> a0, shift_msg
    <span class="org-keyword">li</span> t0, 0x11
    <span class="org-keyword">slli</span> a1, t0, 4
    <span class="org-keyword">srli</span> a2, t0, 4
    <span class="org-keyword">li</span> t0, -0x11
    <span class="org-keyword">srli</span> a3, t0, 4
    <span class="org-keyword">srai</span> a4, t0, 4
    <span class="org-keyword">jal</span> printf

    ## ------ load: lw, lh, lb ------
    <span class="org-keyword">la</span> a0, load_msg
    <span class="org-keyword">la</span> t0, load_data
    <span class="org-keyword">lw</span> a1, 0(t0)
    <span class="org-keyword">lh</span> a2, 4(t0)
    <span class="org-keyword">lb</span> a3, 6(t0)
    <span class="org-keyword">lb</span> a4, 7(t0)
    ## load &#25351;&#20196;&#20250;&#20808;&#36890;&#36807;&#31526;&#21495;&#25193;&#23637; (sign extention) &#25226;&#25968;&#25454;&#21464;&#25104; XLEN &#20301;, &#20877;&#20889;&#20837;&#23492;&#23384;&#22120;
    ## lw, lh, lb &#20250;&#23545;&#25968;&#25454;&#36827;&#34892;&#26377;&#31526;&#21495;&#25193;&#23637; (&#39640;&#20301;&#22797;&#21046;&#31526;&#21495;&#20301;)
    ## lwu, lhu, lbu &#20250;&#23545;&#25968;&#25454;&#36827;&#34892;&#26080;&#31526;&#21495;&#25193;&#23637; (&#39640;&#20301;&#32622; 0)
    <span class="org-keyword">lbu</span> a5, 7(t0)    
    <span class="org-keyword">jal</span> ra, printf

    ## ------ jalr ------
    <span class="org-keyword">call</span> jalr_test

    ## return
    <span class="org-keyword">li</span> a0, 0
    <span class="org-keyword">lw</span> ra, 4(sp)
    <span class="org-keyword">addi</span> sp, sp, 4
    <span class="org-keyword">jr</span> ra

<span class="org-function-name">jalr_test</span>:
    ## jalr rd, imm(rs1), &#30456;&#24403;&#20110; rd=pc+4<span class="org-comment-delimiter">; </span><span class="org-comment">pc=imm(rs1)</span>
    ## jalr &#21487;&#20197;&#29992;&#26469;&#20174;&#20989;&#25968;&#20013;&#36820;&#22238;
    ## &#21478;&#22806;, J &#21644; B &#25351;&#20196;&#36339;&#36716;&#26102;&#37117;&#26159; pc relative &#36339;&#36716;. &#36890;&#36807; I &#25351;&#20196;&#30340; jalr
    ## &#21487;&#20197;&#23454;&#29616;&#25972;&#20010;&#22320;&#22336;&#31354;&#38388;&#33539;&#22260;&#30340;&#36339;&#36716;
    ## jalr &#30340;&#20856;&#22411;&#24212;&#29992;&#26159; procedure return &#21644;&#38024;&#23545;
    ## `switch ... case` &#30340; branch table
    <span class="org-keyword">jalr</span> zero, 0(ra)

    <span class="org-keyword">.data</span>
<span class="org-function-name">addi_msg</span>:      .asciz <span class="org-string">"addi: %d\n"</span>
<span class="org-function-name">slti_msg</span>:      .asciz <span class="org-string">"slti: %d\n"</span>
<span class="org-function-name">sltiu_msg</span>:     .asciz <span class="org-string">"sltiu: %d\n"</span>
<span class="org-function-name">and_or_xor_msg</span>:     .asciz <span class="org-string">"and_or_xor: 0x%x, 0x%x, 0x%x\n"</span>
<span class="org-function-name">shift_msg</span>:     .asciz <span class="org-string">"slli: 0x%x, srli: 0x%x, negative: srli: %lld srai: %lld\n"</span>
<span class="org-function-name">load_msg</span>:       .asciz <span class="org-string">"load: %d, %d, %d, %d, %d\n"</span>
<span class="org-function-name">load_data</span>:
    <span class="org-keyword">.word</span> 1
    <span class="org-keyword">.half</span> 2
    <span class="org-keyword">.byte</span> 3
    <span class="org-keyword">.byte</span> -4

</pre>
</div>

<pre class="example" id="org0000032">
addi: -2048
slti: 1
slti: 0
sltiu: 0
and_or_xor: 0x1, 0x11, 0x10
slli: 0x110, srli: 0x1, negative: srli: 1152921504606846974 srai: -2
load: 1, 2, 3, -4, 252
</pre>
</div>
</div>

<div id="outline-container-org0000037" class="outline-6">
<h6 id="org0000037"><span class="section-number-6">1.2.3.2.2</span> R-Type Instructions</h6>
<div class="outline-text-6" id="text-1-2-3-2-2">
<p>
R 类型指令格式为 `xxx rd, rs1, rs2`, 与 I 类型指令有许多类似, 包含以下指令:
</p>

<ul class="org-ul">
<li>add, sub</li>
<li>slt, sltu</li>
<li>and, or, xor</li>
<li>sll, srl, sra</li>
</ul>

<div class="org-src-container">
<pre class="src src-asm">    ## riscv64-linux-gnu-gcc test.s -static
    <span class="org-keyword">.global</span> main

<span class="org-keyword">.text</span>
<span class="org-function-name">main</span>:
    <span class="org-keyword">addi</span> sp, sp, -4
    <span class="org-keyword">sw</span> ra, 4(sp)

    ## ------ addi (add imm) ------
    <span class="org-keyword">la</span> a0, sub_msg
    <span class="org-keyword">li</span> a1, 10
    <span class="org-keyword">sub</span> a1, zero, a1
    <span class="org-keyword">jal</span> printf

    ## ------ slt (set less than imm), sltu (set less than imm unsigned) ------
    <span class="org-keyword">la</span> a0, slt_msg
    <span class="org-keyword">li</span> t0, 1023
    <span class="org-keyword">li</span> t1, 1024
    <span class="org-keyword">slt</span> a1, t0, t1
    <span class="org-keyword">jal</span> printf

    ## ------ and, or, xor ------
    <span class="org-keyword">la</span> a0, and_or_xor_msg
    <span class="org-keyword">li</span> t0, 0x11
    <span class="org-keyword">li</span> t1, 0x01
    <span class="org-keyword">and</span> a1, t0, t1
    <span class="org-keyword">or</span> a2, t0, t1
    <span class="org-keyword">xor</span> a3, t0, t1
    <span class="org-keyword">jal</span> printf

    ## ------ sll (shift left logical imm) ------
    ## ------ srl (shift right logical imm) ------
    ## ------ sra (shift right arithmetic imm) ------
    <span class="org-keyword">la</span> a0, shift_msg
    <span class="org-keyword">li</span> t0, 0x11
    <span class="org-keyword">li</span> t1, 4
    <span class="org-keyword">sll</span> a1, t0, t1
    <span class="org-keyword">srl</span> a2, t0, t1
    <span class="org-keyword">li</span> t0, -0x11
    <span class="org-keyword">srl</span> a3, t0, t1
    <span class="org-keyword">sra</span> a4, t0, t1
    <span class="org-keyword">jal</span> printf

    ## return
    <span class="org-keyword">li</span> a0, 0
    <span class="org-keyword">lw</span> ra, 4(sp)
    <span class="org-keyword">addi</span> sp, sp, 4
    <span class="org-keyword">jr</span> ra

    <span class="org-keyword">.data</span>
<span class="org-function-name">sub_msg</span>:      .asciz <span class="org-string">"sub: %d\n"</span>
<span class="org-function-name">slt_msg</span>:      .asciz <span class="org-string">"slt: %d\n"</span>
<span class="org-function-name">and_or_xor_msg</span>:     .asciz <span class="org-string">"and_or_xor: 0x%x, 0x%x, 0x%x\n"</span>
<span class="org-function-name">shift_msg</span>:     .asciz <span class="org-string">"sll: 0x%x, srli: 0x%x, negative: srl: %lld srai: %lld\n"</span>

</pre>
</div>

<pre class="example" id="org0000036">
sub: -10
slt: 1
and_or_xor: 0x1, 0x11, 0x10
sll: 0x110, srli: 0x1, negative: srl: 1152921504606846974 srai: -2
</pre>
</div>
</div>

<div id="outline-container-org000003b" class="outline-6">
<h6 id="org000003b"><span class="section-number-6">1.2.3.2.3</span> S-Type Instructions</h6>
<div class="outline-text-6" id="text-1-2-3-2-3">
<p>
S 指令用于 store, 格式为 `xxx rs1, (imm)rs2`, 表示把 rs1 的数据保存到 (imm)rs2的地址上. risc-v 的 load/store 只支持这一种寻址方式, 相当于 x86 的 `寄存器相对寻址
`, 这种寻址方式非常适合表示高级语言中 `data[i]` 这种形式的内存访问
</p>

<p>
risc-v 的 load/store 没有地址对齐的要求, 即 sw/lw 不需要 4 bytes 对齐
</p>

<p>
一共有三条指令:
</p>

<ul class="org-ul">
<li>sw</li>
<li>sh</li>
<li>sb</li>
</ul>

<div class="org-src-container">
<pre class="src src-asm">    ## riscv64-linux-gnu-gcc test.s -static
    <span class="org-keyword">.global</span> main

<span class="org-keyword">.text</span>
<span class="org-function-name">main</span>:
    <span class="org-keyword">addi</span> sp, sp, -4
    <span class="org-keyword">sw</span> ra, 4(sp)

    <span class="org-keyword">la</span> t0, test_data
    <span class="org-keyword">lw</span> t1, 0(t0)
    <span class="org-keyword">addi</span> t1, t1, 1
    <span class="org-keyword">sw</span> t1, 0(t0)

    <span class="org-keyword">la</span> a0, test_msg
    <span class="org-keyword">lw</span> a1, 0(t0)
    <span class="org-keyword">call</span> printf

    ## return
    <span class="org-keyword">lw</span> ra, 4(sp)
    <span class="org-keyword">addi</span> sp, sp, 4
    <span class="org-keyword">li</span> a0, 0
    <span class="org-keyword">jr</span> ra

    <span class="org-keyword">.data</span>
<span class="org-function-name">test_data</span>:     .word 1
<span class="org-function-name">test_msg</span>:    .asciz <span class="org-string">"hello: %d\n"</span>

</pre>
</div>

<pre class="example" id="org000003a">
hello: 2
</pre>
</div>
</div>

<div id="outline-container-org000003e" class="outline-6">
<h6 id="org000003e"><span class="section-number-6">1.2.3.2.4</span> B-Type Instructions</h6>
<div class="outline-text-6" id="text-1-2-3-2-4">
<p>
B 指令用于条件跳转, 它的格式与 S 指令基本相同, 只是 imm 的某些 bit 换了下位置, 格式为 `xxx rs1, rs2, imm`, 表示根据 rs1 的 rs2 比较的结果跳转到 pc+imm 的位置. 有以下几条指令:
</p>

<ul class="org-ul">
<li>beq</li>
<li>bne</li>
<li>blt/bltu</li>
<li>bge/bgeu</li>
</ul>

<p>
由于 imm encode 为 imm[12:1], 所以跳转的范围为 (-4k, +4k)
</p>

<p>
riscv 的 b 指令直接比较 rs1, rs2 并跳转, 而不是像 arm 那样拆分成两条指令: 第一条比较并设置 flag, 第二条根据 flag 跳转.
</p>
</div>
</div>

<div id="outline-container-org0000042" class="outline-6">
<h6 id="org0000042"><span class="section-number-6">1.2.3.2.5</span> U-Type Instructions</h6>
<div class="outline-text-6" id="text-1-2-3-2-5">
<p>
U 指令用来操作一个 imm 的高位, 可以和其它指令配合来操作 32 位数, 有两条指令:
</p>

<ul class="org-ul">
<li>lui (load upper imm)</li>
<li>auipc (append upper imm to pc)</li>
</ul>

<div class="org-src-container">
<pre class="src src-asm">    ## riscv64-linux-gnu-gcc test.s -static
    <span class="org-keyword">.global</span> main

<span class="org-keyword">.text</span>
<span class="org-function-name">main</span>:
    <span class="org-keyword">addi</span> sp, sp, -4
    <span class="org-keyword">sw</span> ra, 4(sp)

    ## ------ lui ------
    ## lui &#21152;&#36733;&#19968;&#20010; imm &#21040;&#23492;&#23384;&#22120;&#30340;&#39640; 20 &#20301;
    ## &#37197;&#21512; addi &#30340; 12 &#20301; imm, &#21487;&#20197;&#21152;&#36733; 32 &#20301; imm
    <span class="org-keyword">la</span> a0, lui_msg
    <span class="org-keyword">lui</span> a1, 1&lt;&lt;16
    <span class="org-keyword">addi</span> a1, a1, 1
    <span class="org-keyword">call</span> printf

    ## &#36825;&#37324;&#29992; lui, addi &#26469;&#21152;&#36733; lui_msg &#22320;&#22336;&#21040; a0
    ## &#20294;&#19982; la &#20266;&#25351;&#20196;&#25928;&#26524;&#24182;&#38750;&#23436;&#20840;&#30456;&#21516;, &#22240;&#20026;&#36890;&#36807; lui, addi &#26041;&#24335;
    ## &#26159;&#23545; lui_msg &#30340;&#32477;&#23545;&#22320;&#22336;&#23547;&#22336;, &#20294; la &#36890;&#24120;&#20250;&#20351;&#29992; GOT &#25110; pc relative &#23547;&#22336;
    <span class="org-keyword">lui</span> a0, <span class="org-variable-name">%hi</span>(lui_msg)
    <span class="org-keyword">addi</span> a0, a0, <span class="org-variable-name">%lo</span>(lui_msg)
    <span class="org-keyword">lui</span> a1, 1&lt;&lt;16
    <span class="org-keyword">addi</span> a1, a1, 1
    <span class="org-keyword">call</span> printf

    ## ------ auipc ------
    ## auipc rd, imm &#30456;&#24403;&#20110; rd=pc+(imm&lt;&lt;12), &#37197;&#21512; addi &#21487;&#20197;&#24471;&#21040;&#30456;&#23545;&#20110; pc &#30340; 32 &#20301;&#22320;&#22336;
<span class="org-function-name">1</span>:  <span class="org-keyword">auipc</span> a0, <span class="org-variable-name">%pcrel</span>_hi(auipc_msg)
    ## &#36825;&#37324;&#26159;&#29992;&#30340;&#30340; pcrel_lo (1b) &#32780;&#19981;&#26159; pcrel_lo(auipc_msg), &#26159; linker &#35748;&#35782;&#30340;&#29305;&#27530;&#20889;&#27861;.
    ## &#22240;&#20026; pcrel_lo &#35201;&#35745;&#31639; auipc_msg &#20302; 12 &#20301;&#19982; pc &#20302; 12 &#20301;&#30340;&#24046;, &#20294; addi &#26102;&#29992;&#30340; pc &#19982; auipc
    ## &#26102;&#30340; pc &#24050;&#32463;&#19981;&#21516;&#20102;, addi &#22788;&#30340; pcrel_lo &#24212;&#24403;&#20351;&#29992;&#19978;&#19968;&#26465;&#25351;&#20196;&#30340; pc &#26469;&#35745;&#31639;&#24046;&#20540;
    ## https:<span class="org-comment-delimiter">//</span><span class="org-comment">sourceware.org/binutils/docs/as/RISC_002dV_002dModifiers.html</span>
    ## 
    <span class="org-keyword">addi</span> a0, a0, <span class="org-variable-name">%pcrel</span>_lo(1b)
    <span class="org-keyword">call</span> printf

    <span class="org-keyword">lw</span> ra, 4(sp)
    <span class="org-keyword">addi</span> sp, sp, 4
    <span class="org-keyword">li</span> a0, 0
    <span class="org-keyword">jr</span> ra

    <span class="org-keyword">.data</span>

<span class="org-function-name">lui_msg</span>:    .asciz <span class="org-string">"lui: %x\n"</span>
<span class="org-function-name">auipc_msg</span>:   .asciz <span class="org-string">"auipc\n"</span>
</pre>
</div>

<pre class="example" id="org0000041">
lui: 10000001
lui: 10000001
auipc
</pre>

<p>
如果要加载一个 64 位的立即数, 可以有两种方法:
</p>

<ol class="org-ol">
<li>通过 ld</li>

<li>先加载高 32 位 (lui, addi) 到 x, 然后 x 左移 32 位, 最后加载低 32 位到 x</li>
</ol>
</div>
</div>


<div id="outline-container-org0000046" class="outline-6">
<h6 id="org0000046"><span class="section-number-6">1.2.3.2.6</span> J-Type Instructions</h6>
<div class="outline-text-6" id="text-1-2-3-2-6">
<p>
J 指令和 U 指令格式类似, 只有一条 jal (jump and link) 指令, 可以支持 2M 范围的
pc 相对跳转
</p>

<div class="org-src-container">
<pre class="src src-asm">    ## riscv64-linux-gnu-gcc test.s -static
    <span class="org-keyword">.global</span> main

    <span class="org-keyword">.text</span>
<span class="org-function-name">main</span>:
    <span class="org-keyword">addi</span> sp, sp, -4
    <span class="org-keyword">sw</span> ra, 4(sp)

    <span class="org-keyword">la</span> a0, hello_msg
    <span class="org-keyword">jal</span> ra, printf

    <span class="org-keyword">lw</span> ra, 4(sp)
    <span class="org-keyword">addi</span> sp, sp, 4
    <span class="org-keyword">li</span> a0, 0
    <span class="org-keyword">jr</span> ra

    <span class="org-keyword">.data</span>
<span class="org-function-name">hello_msg</span>:    .asciz <span class="org-string">"hello\n"</span>

</pre>
</div>

<pre class="example" id="org0000045">
hello
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org000004f" class="outline-4">
<h4 id="org000004f"><span class="section-number-4">1.2.4</span> Pseudo Instruction</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
伪指令是 assembler 提供的, 和 ISA 没有关系, 主要是为了方便使用, 尤其是涉及到符号重定位的操作, 例如 la, call 等.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">la rd, symbol</td>
<td class="org-left">auipc rd, symbol[31:12]; addi rd, rd, symbol[11:0]</td>
</tr>

<tr>
<td class="org-left">l{b,h,w,d} rd, symbol</td>
<td class="org-left">auipc rd, symbol[31:12]; l{b,h,w,d} rd, symbol[11:0](rd)</td>
</tr>

<tr>
<td class="org-left">s{b,h,w,d} rd, symbol, rt</td>
<td class="org-left">auipc rt, symbol[31:12]; s{b,h,w,d} rd, symbol[11:0](rt)</td>
</tr>

<tr>
<td class="org-left">fl{w,d} rd, symbol, rt</td>
<td class="org-left">auipc rt, symbol[31:12]; fl{w,d} rd, symbol[11:0](rt)</td>
</tr>

<tr>
<td class="org-left">fs{w,d} rd, symbol, rt</td>
<td class="org-left">auipc rt, symbol[31:12]; fs{w,d} rd, symbol[11:0](rt)</td>
</tr>

<tr>
<td class="org-left">nop</td>
<td class="org-left">addi x0, x0, 0</td>
</tr>

<tr>
<td class="org-left">li rd, immediate</td>
<td class="org-left">myriad sequences</td>
</tr>

<tr>
<td class="org-left">mv rd, rs</td>
<td class="org-left">addi rd, rs, 0</td>
</tr>

<tr>
<td class="org-left">not rd, rs</td>
<td class="org-left">xori rd, rs, -1</td>
</tr>

<tr>
<td class="org-left">neg rd, rs</td>
<td class="org-left">sub rd, x0, rs</td>
</tr>

<tr>
<td class="org-left">negw rd, rs</td>
<td class="org-left">subw rd, x0, rs</td>
</tr>

<tr>
<td class="org-left">sext.b rd, rs</td>
<td class="org-left">slli rd, rs, XLEN - 8; srai rd, rd, XLEN - 8</td>
</tr>

<tr>
<td class="org-left">sext.h rd, rs</td>
<td class="org-left">slli rd, rs, XLEN - 16; srai rd, rd, XLEN - 16</td>
</tr>

<tr>
<td class="org-left">sext.w rd, rs</td>
<td class="org-left">addiw rd, rs, 0</td>
</tr>

<tr>
<td class="org-left">zext.b rd, rs</td>
<td class="org-left">andi rd, rs, 255</td>
</tr>

<tr>
<td class="org-left">zext.h rd, rs</td>
<td class="org-left">slli rd, rs, XLEN - 16; srli rd, rd, XLEN - 16</td>
</tr>

<tr>
<td class="org-left">zext.w rd, rs</td>
<td class="org-left">slli rd, rs, XLEN - 32; srli rd, rd, XLEN - 32</td>
</tr>

<tr>
<td class="org-left">seqz rd, rs</td>
<td class="org-left">sltiu rd, rs, 1</td>
</tr>

<tr>
<td class="org-left">snez rd, rs</td>
<td class="org-left">sltu rd, x0, rs</td>
</tr>

<tr>
<td class="org-left">sltz rd, rs</td>
<td class="org-left">slt rd, rs, x0</td>
</tr>

<tr>
<td class="org-left">sgtz rd, rs</td>
<td class="org-left">slt rd, x0, rs</td>
</tr>

<tr>
<td class="org-left">beqz rs, offset</td>
<td class="org-left">beq rs, x0, offset</td>
</tr>

<tr>
<td class="org-left">bnez rs, offset</td>
<td class="org-left">bne rs, x0, offset</td>
</tr>

<tr>
<td class="org-left">blez rs, offset</td>
<td class="org-left">bge x0, rs, offset</td>
</tr>

<tr>
<td class="org-left">bgez rs, offset</td>
<td class="org-left">bge rs, x0, offset</td>
</tr>

<tr>
<td class="org-left">bltz rs, offset</td>
<td class="org-left">blt rs, x0, offset</td>
</tr>

<tr>
<td class="org-left">bgtz rs, offset</td>
<td class="org-left">blt x0, rs, offset</td>
</tr>

<tr>
<td class="org-left">bgt rs, rt, offset</td>
<td class="org-left">blt rt, rs, offset</td>
</tr>

<tr>
<td class="org-left">ble rs, rt, offset</td>
<td class="org-left">bge rt, rs, offset</td>
</tr>

<tr>
<td class="org-left">bgtu rs, rt, offset</td>
<td class="org-left">bltu rt, rs, offset</td>
</tr>

<tr>
<td class="org-left">bleu rs, rt, offset</td>
<td class="org-left">bgeu rt, rs, offset</td>
</tr>

<tr>
<td class="org-left">j offset</td>
<td class="org-left">jal x0, offset</td>
</tr>

<tr>
<td class="org-left">jal offset</td>
<td class="org-left">jal x1, offset</td>
</tr>

<tr>
<td class="org-left">jr rs</td>
<td class="org-left">jalr x0, rs, 0</td>
</tr>

<tr>
<td class="org-left">jalr rs</td>
<td class="org-left">jalr x1, rs, 0</td>
</tr>

<tr>
<td class="org-left">ret</td>
<td class="org-left">jalr x0, x1, 0</td>
</tr>

<tr>
<td class="org-left">call offset</td>
<td class="org-left">auipc x6, offset[31:12]; jalr x1, x6, offset[11:0]</td>
</tr>

<tr>
<td class="org-left">tail offset</td>
<td class="org-left">auipc x6, offset[31:12]; jalr x0, x6, offset[11:0]</td>
</tr>

<tr>
<td class="org-left">fence</td>
<td class="org-left">fence iorw, iorw</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-ID-4db5f11b-34ce-491b-beaf-eb3333381f12" class="outline-4">
<h4 id="ID-4db5f11b-34ce-491b-beaf-eb3333381f12"><span class="section-number-4">1.2.5</span> Relocation</h4>
<div class="outline-text-4" id="text-1-2-5">
<p>
有些指令的操作数是 symbol, symbol 地址在 assembling 阶段无法确定, assembler 只能通过 <a href="bfd.html#ID-7569396e-eef7-485b-a1eb-8a545dec44ba">BFD</a> 写入重定位信息, 后面需要 link edtitor 进行重定位.
</p>
</div>


<div id="outline-container-org0000053" class="outline-5">
<h5 id="org0000053"><span class="section-number-5">1.2.5.1</span> relocation of `load address`</h5>
<div class="outline-text-5" id="text-1-2-5-1">
<p>
load address 类的指令 (auipc, lui, la, &#x2026;) 的操作数是 symbol 时, 可以使用不同的
reloc_type, 例如:
</p>

<ul class="org-ul">
<li>使用绝对地址</li>

<li>PCREL</li>

<li>TPREL</li>

<li>GPREL</li>

<li>GOT</li>

<li>&#x2026;</li>
</ul>

<p>
所谓不同的 reloc_type, 是指 linker 计算出真实地址后, 根据 reloc_type 决定如何
patch 指令:
</p>

<ol class="org-ol">
<li>要 patch 的数据相对于要 patch 的指令的 offset</li>

<li>要 patch 的数据的长度</li>

<li>是不是 relative</li>
</ol>

<p>
例如, 若 reloc_type 是 pc-relative (例如 auipc, jal, bne, &#x2026;), 则会把 `真实地址
` 与 `要 patch 的指令` 某种差值写入要 patch 的指令的操作数位置.
</p>

<div class="org-src-container">
<pre class="src src-asm">    ## riscv64-linux-gnu-gcc test.s -static
    <span class="org-keyword">.global</span> main

    <span class="org-keyword">.text</span>
<span class="org-function-name">main</span>:
    <span class="org-keyword">addi</span> sp, sp, -4
    <span class="org-keyword">sw</span> ra, 4(sp)

    ## &#32477;&#23545;&#22320;&#22336;
    ## &#22312;&#27719;&#32534;&#26102;&#24182;&#19981;&#20250;&#30495;&#27491;&#35745;&#31639; hello_msg &#30340;&#22320;&#22336;&#30340;&#39640; 20 &#20301;,
    ## &#22240;&#20026;&#27719;&#32534;&#26102;&#26080;&#27861;&#30830;&#23450; hello_msg &#30340;&#22320;&#22336;.
    ## &#36825;&#37324;&#21482;&#26159;&#30830;&#23450;&#19968;&#20010; symbol (hello_msg) &#21644; reloc_type (BFD_RELOC_RISCV_HI20),
    ## &#36825;&#20004;&#20010;&#20449;&#24687;&#21253;&#21547;&#22312; obj &#25991;&#20214;&#20013;, &#26368;&#21518;&#22312;&#38142;&#25509;&#26102;&#30001; link editor &#22788;&#29702;
    <span class="org-keyword">lui</span> a0, <span class="org-variable-name">%hi</span>(hello_msg)
    <span class="org-keyword">addi</span> a0, a0, <span class="org-variable-name">%lo</span>(hello_msg)
    <span class="org-keyword">call</span> printf

    ## pc-relative &#22320;&#22336;
<span class="org-function-name">1</span>:
    <span class="org-keyword">auipc</span> a0, <span class="org-variable-name">%pcrel</span>_hi(hello_msg)
    <span class="org-keyword">addi</span> a0, a0, <span class="org-variable-name">%pcrel</span>_lo(1b)
    <span class="org-keyword">call</span> printf

    ## got &#22320;&#22336;
<span class="org-function-name">1</span>:
    <span class="org-keyword">auipc</span> a0, $got_pcrel_hi(hello_msg)
    <span class="org-keyword">addi</span> a0, $pcrel_lo(1b)
    ## got &#38656;&#35201;&#19968;&#20010;&#39069;&#22806;&#30340; ld &#25165;&#33021;&#33719;&#21462; hello_msg &#30340;&#22320;&#22336;
    <span class="org-keyword">ld</span> a0, 0(a0)
    ## la &#20266;&#25351;&#20196;&#22312; pic &#26102;&#20250;&#29983;&#25104;&#31867;&#20284;&#30340;&#20195;&#30721;:
    ## auipc   a0,0x60
    ## ld      a0,956(a0) # 70810 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;
    ## la a0,hello_msg
    <span class="org-keyword">call</span> printf

    <span class="org-keyword">lw</span> ra, 4(sp)
    <span class="org-keyword">addi</span> sp, sp, 4
    <span class="org-keyword">move</span> a0, zero
    <span class="org-keyword">ret</span>

    <span class="org-keyword">.data</span>
<span class="org-function-name">hello_msg</span>:    .asciz <span class="org-string">"hello\n"</span>
</pre>
</div>

<p>
上面的 `%hi`, `pcrel_hi` 等是 <a href="#org0000052">risc-v modifiers</a>, 会导致 obj 中不同的 relocation
type:
</p>

<pre class="example" id="org0000055">
readelf -a test.o
------
Relocation section '.rela.text' at offset 0x180 contains 17 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000004  00040000001a R_RISCV_HI20      0000000000000000 hello_msg + 0
000000000004  000000000033 R_RISCV_RELAX                        0
000000000008  00040000001b R_RISCV_LO12_I    0000000000000000 hello_msg + 0
000000000008  000000000033 R_RISCV_RELAX                        0
00000000000c  000800000012 R_RISCV_CALL      0000000000000000 printf + 0
00000000000c  000000000033 R_RISCV_RELAX                        0
000000000014  000400000017 R_RISCV_PCREL_HI2 0000000000000000 hello_msg + 0
000000000014  000000000033 R_RISCV_RELAX                        0
000000000018  000500000018 R_RISCV_PCREL_LO1 0000000000000014 .1 + 0
000000000018  000000000033 R_RISCV_RELAX                        0
00000000001c  000800000012 R_RISCV_CALL      0000000000000000 printf + 0
00000000001c  000000000033 R_RISCV_RELAX                        0
000000000024  000400000014 R_RISCV_GOT_HI20  0000000000000000 hello_msg + 0
000000000028  000600000018 R_RISCV_PCREL_LO1 0000000000000024 .L0  + 0
000000000028  000000000033 R_RISCV_RELAX                        0
00000000002c  000800000012 R_RISCV_CALL      0000000000000000 printf + 0
00000000002c  000000000033 R_RISCV_RELAX                        0

objdump -d test.o
------
0000000000000000 &lt;main&gt;:
   0:   1171                    addi    sp,sp,-4
   2:   c206                    sw      ra,4(sp)
   4:   00000537                lui     a0,0x0
   8:   00050513                mv      a0,a0
   c:   00000097                auipc   ra,0x0
  10:   000080e7                jalr    ra # c &lt;main+0xc&gt;

0000000000000014 &lt;.1&gt;:
  14:   00000517                auipc   a0,0x0
  18:   00050513                mv      a0,a0
  1c:   00000097                auipc   ra,0x0
  20:   000080e7                jalr    ra # 1c &lt;.1+0x8&gt;
  24:   00000517                auipc   a0,0x0
  28:   00053503                ld      a0,0(a0) # 24 &lt;.1+0x10&gt;
  2c:   00000097                auipc   ra,0x0
  30:   000080e7                jalr    ra # 2c &lt;.1+0x18&gt;
  34:   4092                    lw      ra,4(sp)
  36:   0111                    addi    sp,sp,4
  38:   00000513                li      a0,0
  3c:   8082                    ret

</pre>
</div>

<div id="outline-container-org0000057" class="outline-6">
<h6 id="org0000057"><span class="section-number-6">1.2.5.1.1</span> R_RISCV_PCREL_HI2</h6>
<div class="outline-text-6" id="text-1-2-5-1-1">
<pre class="example" id="org0000056">
000000000014  000400000017 R_RISCV_PCREL_HI2 0000000000000000 hello_msg + 0

表示

  14:   00000517                auipc   a0,0x0

这条指令在重定位时需要用 hello_msg 的真正地址的高 20 位与 pc 的高 20 位的差值
写到原指令中 (00000517) 的 imm 部分.
</pre>
</div>
</div>

<div id="outline-container-org000005b" class="outline-6">
<h6 id="org000005b"><span class="section-number-6">1.2.5.1.2</span> R_RISCV_PCREL_LO12</h6>
<div class="outline-text-6" id="text-1-2-5-1-2">
<pre class="example" id="org000005a">
000000000018  000500000018 R_RISCV_PCREL_LO1 0000000000000014 .1 + 0

对应

  18:   00050513                mv      a0,a0

表示指令的 imm 部分应该用 hello_msg 的低 12 位于 pc 的低 12 的差来填充
</pre>
</div>
</div>

<div id="outline-container-org000005f" class="outline-6">
<h6 id="org000005f"><span class="section-number-6">1.2.5.1.3</span> R_RISCV_HI20</h6>
<div class="outline-text-6" id="text-1-2-5-1-3">
<pre class="example" id="org000005e">
000000000004  00040000001a R_RISCV_HI20      0000000000000000 hello_msg + 0

表示

   4:   00000537                lui     a0,0x0

这条指令的 imm 部分应该用 hello_msg 的真正地址的高 20 位直接填充

</pre>
</div>
</div>

<div id="outline-container-org0000062" class="outline-6">
<h6 id="org0000062"><span class="section-number-6">1.2.5.1.4</span> R_RISCV_RELAX</h6>
<div class="outline-text-6" id="text-1-2-5-1-4">
<p>
这个和 <a href="linker_relaxation.html#ID-b861e156-7ced-4e25-b047-455b5b075c1e">Linker Relaxation</a> 有关
</p>
</div>
</div>
</div>

<div id="outline-container-ID-119c2664-36d0-4cf5-ae13-0686350c3df8" class="outline-5">
<h5 id="ID-119c2664-36d0-4cf5-ae13-0686350c3df8"><span class="section-number-5">1.2.5.2</span> relocation of jal</h5>
<div class="outline-text-5" id="text-1-2-5-2">
<p>
jal 的操作数也是一个 symbol, 但根据 symbol 的位置, 分为两种情况:
</p>

<ol class="org-ol">
<li>symbol 在当前 section</li>

<li>symbol 在其它 section</li>
</ol>

<p>
之所以区分这两种情况, 是因为 section 的地址是不确定的 (<a href="linker_script.html#ID-1047822f-1bc3-4e98-8874-d7fa2e59260e">Linker Script</a> 可以配置
section 的地址). 但如果 symbol 在当前 section, 因为 jal 的操作数是 PCREL 的, 所以操作数会是确定的值.
</p>

<p>
symbol 在同一个 section:
</p>

<div class="org-src-container">
<pre class="src src-asm">    <span class="org-keyword">.global</span> _start
    <span class="org-keyword">.section</span> .text
<span class="org-function-name">_start</span>:
    <span class="org-keyword">jal</span> here

<span class="org-function-name">here</span>:
    <span class="org-keyword">ret</span>
</pre>
</div>

<pre class="example" id="org0000068">
$&gt; /opt/riscv/bin/riscv-elf-gcc test.S -O0 -c
$&gt; /opt/riscv/bin/riscv-elf-objdump -d test.o

Disassembly of section .text:

0000000000000000 &lt;_start&gt;:
   0:   004000ef                jal     ra,4 &lt;here&gt;

0000000000000004 &lt;here&gt;:
   4:   8082                    ret
</pre>

<p>
symbol 不在同一个 section:
</p>

<div class="org-src-container">
<pre class="src src-asm">    <span class="org-keyword">.global</span> _start
    <span class="org-keyword">.section</span> .text
<span class="org-function-name">_start</span>:
    <span class="org-keyword">jal</span> here

    <span class="org-keyword">.section</span> .mysection
<span class="org-function-name">here</span>:
    <span class="org-keyword">ret</span>
</pre>
</div>

<pre class="example" id="org0000069">
$&gt; riscv64-linux-gnu-objdump -d test.o

Disassembly of section .text:

0000000000000000 &lt;_start&gt;:
   0:   000000ef                jal     ra,0 &lt;_start&gt; 

$&gt; readelf -a test.o

Relocation section '.rela.text' at offset 0x100 contains 1 entry:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000000  000400000011 R_RISCV_JAL       0000000000000000 here + 0
</pre>

<p>
R_RISCV_JAL 类型的 reloc_type 和 PCREL 应该类似, 但 JAL 有一个额外的限制是它跳转的范围在 [-1M,1M] 之间, 所以下面的代码会链接不过
</p>

<div class="org-src-container">
<pre class="src src-asm">    <span class="org-keyword">.global</span> _start
    <span class="org-keyword">.section</span> .text
<span class="org-function-name">_start</span>:
    <span class="org-keyword">jal</span> here
    ## &#30475;&#36215;&#26469;&#20687; ld &#30340; bug: jal &#30340;&#36339;&#36716;&#33539;&#22260;&#24212;&#35813;&#26159; [-1m,1m], &#20294;
    ## &#36825;&#37324;&#26174;&#31034;&#26159; [-0.5m,0.5m]...
    ## .rept 0x7ffff-1 &#21487;&#20197;&#38142;&#25509;&#36890;&#36807;    
    <span class="org-keyword">.rept</span> 0x7ffff
    <span class="org-keyword">.byte</span>   0
    <span class="org-keyword">.endr</span>
<span class="org-function-name">here</span>:
    <span class="org-keyword">ret</span>
</pre>
</div>

<pre class="example" id="org000006a">
$&gt; riscv64-linux-gnu-gcc test.S  -nostdlib -O0
/tmp/ccuebMtl.o: in function `_start':
(.text+0x0): relocation truncated to fit: R_RISCV_JAL against `here'
collect2: error: ld returned 1 exit status
</pre>
</div>
</div>


<div id="outline-container-org00000ac" class="outline-5 references">
<h5 id="org00000ac">Backlinks</h5>
<div class="outline-text-5" id="text-org00000ac">
<p>
<a href="retargeting_gcc_to_riscv.html#ID-303d0f7f-03c2-4f31-ad7e-064162e3af10">Retargeting GCC To RISC-V</a>
(<i>Retargeting GCC To RISC-V &gt; binutils &gt; as &gt; append_insn</i>):      2. TODO: 使用 symbol 的指令无法把 symbol 的地址直接编码到指令中, assembling 阶段    只能确定 symbol 和 reloc_type (<a href="#ID-4db5f11b-34ce-491b-beaf-eb3333381f12">Relocation</a>), 最终地址在链接阶段由 link editor    来处理.
</p>
</div>



<div id="outline-container-org000006e" class="outline-6 references">
<h6 id="org000006e">Backlinks</h6>
<div class="outline-text-6" id="text-org000006e">
<p>
<a href="riscv_tutorial.html#ID-653c6b58-7ee1-4e07-bf3f-d5eea450748e">RISC-V Tutorial</a>
(<i>RISC-V Tutorial &gt; RISC-V Assembly &gt; RV32I &gt; Overview</i>):     与 B 指令类似, 没有使用 imm[0], J 跳转范围扩大为 [-1M, +1M]+pc (<a href="#ID-119c2664-36d0-4cf5-ae13-0686350c3df8">relocation of jal</a>)
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org000007b" class="outline-4">
<h4 id="org000007b"><span class="section-number-4">1.2.6</span> Demo</h4>
<div class="outline-text-4" id="text-1-2-6">
</div>
<div id="outline-container-org0000061" class="outline-5">
<h5 id="org0000061"><span class="section-number-5">1.2.6.1</span> Bubble Sort</h5>
<div class="outline-text-5" id="text-1-2-6-1">
<div class="org-src-container">
<pre class="src src-C"><span class="org-comment-delimiter">// </span><span class="org-comment">2022-02-25 19:31</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">void</span> <span class="org-function-name">bubble_sort</span>(<span class="org-type">int</span> *<span class="org-variable-name">data</span>, <span class="org-type">int</span> <span class="org-variable-name">start</span>, <span class="org-type">int</span> <span class="org-variable-name">end</span>) {
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = start; i &lt; end; i++) {
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span> = i; j &lt; end; j++) {
            <span class="org-keyword">if</span> (data[j] &lt; data[i]) {
                <span class="org-comment-delimiter">/* </span><span class="org-comment">swap i, j</span><span class="org-comment-delimiter"> */</span>
                <span class="org-type">int</span> <span class="org-variable-name">tmp</span> = data[i];
                data[i] = data[j];
                data[j] = tmp;
            }
        }
    }
}

<span class="org-type">void</span> <span class="org-function-name">dump</span>(<span class="org-type">int</span> *<span class="org-variable-name">data</span>, <span class="org-type">int</span> <span class="org-variable-name">len</span>) {
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; len; i++) {
        printf(<span class="org-string">"%d "</span>, data[i]);
    }
    printf(<span class="org-string">"\n"</span>);
}

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
    <span class="org-type">int</span> <span class="org-variable-name">data</span>[] = {1, 1, 4, 3, 10, 5};
    <span class="org-type">int</span> <span class="org-variable-name">len</span> = <span class="org-keyword">sizeof</span>(data) / <span class="org-keyword">sizeof</span>(data[0]);
    dump(data, len);

    bubble_sort(data, 0, len);

    dump(data, len);
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<pre class="example" id="org0000071">
1 1 4 3 10 5 
1 1 3 4 5 10 
</pre>

<div class="org-src-container">
<pre class="src src-asm">    ## riscv64-linux-gnu-gcc test.s -static
    <span class="org-keyword">.global</span> main

    <span class="org-keyword">.text</span>
<span class="org-function-name">dump</span>:
    <span class="org-keyword">addi</span> sp, sp, -4
    <span class="org-keyword">sw</span> ra, 4(sp)

    <span class="org-keyword">la</span> s0, data
    <span class="org-keyword">la</span> s1, data_end
    <span class="org-keyword">addi</span> s0, s0, -8

<span class="org-function-name">.Lprint_loop</span>:
    <span class="org-keyword">addi</span> s0, s0, 8
    <span class="org-keyword">beq</span> s0, s1, .Lprint_end

    <span class="org-keyword">la</span> a0, print_fmt
    <span class="org-keyword">ld</span> a1, 0(s0)
    <span class="org-keyword">call</span> printf
    <span class="org-keyword">j</span> .Lprint_loop

<span class="org-function-name">.Lprint_end</span>:
    <span class="org-keyword">la</span> a0, print_fmt_new_line
    <span class="org-keyword">call</span> printf

    <span class="org-keyword">lw</span> ra, 4(sp)
    <span class="org-keyword">addi</span> sp, sp, 4
    <span class="org-keyword">ret</span>

<span class="org-function-name">main</span>:
    <span class="org-keyword">addi</span> sp, sp, -4
    <span class="org-keyword">sw</span> ra, 4(sp)

    <span class="org-keyword">call</span> dump

    <span class="org-keyword">la</span> t0, data
    <span class="org-keyword">addi</span> t0, t0, -8
    <span class="org-keyword">la</span> t2, data_end

<span class="org-function-name">.Lmain_outer_loop</span>:
    <span class="org-keyword">addi</span> t0, t0, 8
    <span class="org-keyword">beq</span> t0, t2, .Lmain_end
    <span class="org-keyword">addi</span> t1, t0, -8

<span class="org-function-name">.Lmain_inner_loop</span>:
    <span class="org-keyword">addi</span> t1, t1, 8
    <span class="org-keyword">beq</span> t1, t2, .Lmain_outer_loop
    <span class="org-keyword">ld</span> s0, 0(t0)
    <span class="org-keyword">ld</span> s1, 0(t1)
    <span class="org-keyword">blt</span> s0, s1, .Lmain_continue
    ## swap
    <span class="org-keyword">sd</span> s1, 0(t0)
    <span class="org-keyword">sd</span> s0, 0(t1)
<span class="org-function-name">.Lmain_continue</span>:
    <span class="org-keyword">j</span> .Lmain_inner_loop

<span class="org-function-name">.Lmain_end</span>:
    <span class="org-keyword">call</span> dump
    <span class="org-keyword">lw</span> ra, 4(sp)
    <span class="org-keyword">addi</span> sp, sp, 4
    <span class="org-keyword">move</span> a0, zero
    <span class="org-keyword">ret</span>

    <span class="org-keyword">.data</span>
<span class="org-function-name">data</span>:
    <span class="org-keyword">.dword</span> 1
    <span class="org-keyword">.dword</span> 1
    <span class="org-keyword">.dword</span> 4
    <span class="org-keyword">.dword</span> 3
    <span class="org-keyword">.dword</span> 10
    <span class="org-keyword">.dword</span> 5
<span class="org-function-name">data_end</span>:

<span class="org-function-name">print_fmt_new_line</span>:
    <span class="org-keyword">.asciz</span> <span class="org-string">"\n"</span>

<span class="org-function-name">print_fmt</span>:
    <span class="org-keyword">.asciz</span> <span class="org-string">"%ld "</span>

</pre>
</div>

<pre class="example" id="org0000072">
1 1 4 3 10 5 
1 1 3 4 5 10
</pre>
</div>
</div>

<div id="outline-container-org0000066" class="outline-5">
<h5 id="org0000066"><span class="section-number-5">1.2.6.2</span> Quick Sort</h5>
<div class="outline-text-5" id="text-1-2-6-2">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">void</span> <span class="org-function-name">swap</span>(<span class="org-type">int</span> *<span class="org-variable-name">data</span>, <span class="org-type">int</span> <span class="org-variable-name">a</span>, <span class="org-type">int</span> <span class="org-variable-name">b</span>) {
    <span class="org-type">int</span> <span class="org-variable-name">temp</span> = data[a];
    data[a] = data[b];
    data[b] = temp;
}

<span class="org-type">void</span> <span class="org-function-name">quick_sort</span>(<span class="org-type">int</span> *<span class="org-variable-name">data</span>, <span class="org-type">int</span> <span class="org-variable-name">start</span>, <span class="org-type">int</span> <span class="org-variable-name">end</span>) {
    <span class="org-type">int</span> <span class="org-variable-name">pivort</span> = start;
    <span class="org-type">int</span> <span class="org-variable-name">curr</span> = start + 1;
    <span class="org-keyword">if</span> (curr &gt;= end) {
        <span class="org-keyword">return</span>;
    }
    <span class="org-keyword">while</span> (curr &lt; end) {
        <span class="org-keyword">if</span> (data[curr] &lt; data[pivort]) {
            swap(data, curr, pivort + 1);
            swap(data, pivort, pivort + 1);
            pivort += 1;
        }
        curr += 1;
    }
    quick_sort(data, start, pivort);
    quick_sort(data, pivort + 1, end);
}

<span class="org-type">void</span> <span class="org-function-name">dump</span> (<span class="org-type">int</span>* <span class="org-variable-name">data</span>, <span class="org-type">int</span> <span class="org-variable-name">len</span>) {
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; len; i++) {
        printf(<span class="org-string">"%d "</span>, data[i]);
    }
    printf(<span class="org-string">"\n"</span>);
}

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
    <span class="org-type">int</span> <span class="org-variable-name">data</span>[] = {1, 1, 4, 3, 10, 5};
    <span class="org-type">int</span> <span class="org-variable-name">len</span> = <span class="org-keyword">sizeof</span>(data) / <span class="org-keyword">sizeof</span>(data[0]);
    dump(data, len);

    quick_sort(data, 0, len);

    dump(data, len);
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<pre class="example" id="org0000076">
1 1 4 3 10 5 
1 1 3 4 5 10 
</pre>

<div class="org-src-container">
<pre class="src src-asm">    ## riscv64-linux-gnu-gcc test.s -static
    <span class="org-keyword">.global</span> main

    <span class="org-keyword">.text</span>

<span class="org-keyword">.macro</span> enter
    <span class="org-keyword">addi</span> sp, sp, -4
    <span class="org-keyword">sw</span> ra, 4(sp)
<span class="org-keyword">.endm</span>

<span class="org-keyword">.macro</span> leave
    <span class="org-keyword">lw</span> ra, 4(sp)
    <span class="org-keyword">addi</span> sp, sp, 4
    <span class="org-keyword">move</span> a0, zero
    <span class="org-keyword">ret</span>
<span class="org-keyword">.endm</span>

<span class="org-function-name">print_data</span>:
    <span class="org-keyword">enter</span>

    <span class="org-keyword">la</span> s0, .Ldata_start
    <span class="org-keyword">la</span> s1, .Ldata_end
    <span class="org-keyword">addi</span> s0, s0, -8

    <span class="org-keyword">.Lprint_loop</span>:
    <span class="org-keyword">addi</span> s0, s0, 8
    <span class="org-keyword">beq</span> s0, s1, .Lprint_end

    <span class="org-keyword">la</span> a0, .Lprint_fmt
    <span class="org-keyword">ld</span> a1, 0(s0)
    <span class="org-keyword">call</span> printf
    <span class="org-keyword">j</span> .Lprint_loop

    <span class="org-keyword">.Lprint_end</span>:
    <span class="org-keyword">la</span> a0, .Lprint_fmt_new_line
    <span class="org-keyword">call</span> printf

    <span class="org-keyword">leave</span>

<span class="org-function-name">quick_sort</span>:
    <span class="org-keyword">addi</span> sp, sp, -64
    <span class="org-keyword">sw</span> ra, 8(sp)
    <span class="org-keyword">sw</span> s0, 16(sp)
    <span class="org-keyword">sw</span> s1, 24(sp)
    <span class="org-keyword">sw</span> s2, 32(sp)
    <span class="org-keyword">sw</span> s3, 40(sp)
    <span class="org-keyword">sw</span> s4, 48(sp)
    <span class="org-keyword">sw</span> s5, 56(sp)
    <span class="org-keyword">sw</span> s6, 64(sp)

    ## gnu as &#26412;&#36523;&#24182;&#19981;&#25903;&#25345; define, &#36825;&#37324;&#20381;&#36182; gcc &#30340; preprocessor
    ## &#26469;&#22788;&#29702; define, &#25152;&#20197;&#38656;&#35201;&#29992; gcc &#32534;&#35793;&#32780;&#19981;&#33021;&#29992; as
    ## 
    #define end s6
    #define start s0
    #define loop s1
    #define pivort s2
    #define loop_v s3
    #define pivort_v s4
    #define tmp s5

    <span class="org-keyword">move</span> start, a0
    <span class="org-keyword">move</span> end, a1
    <span class="org-keyword">move</span> pivort, start 
    <span class="org-keyword">addi</span> loop, a0, 8 
    <span class="org-keyword">bge</span> loop, end, .Lquick_sort_end

    <span class="org-keyword">addi</span> loop, loop,-8
<span class="org-function-name">1</span>:  
    <span class="org-keyword">addi</span> loop, loop, 8
    <span class="org-keyword">bge</span> loop, end, 1f

    <span class="org-keyword">ld</span> loop_v, 0(loop)
    <span class="org-keyword">ld</span> pivort_v, 0(pivort)
    <span class="org-keyword">bge</span> loop_v, pivort_v, 1b
    ## swap
    <span class="org-keyword">ld</span> tmp, 8(pivort)
    <span class="org-keyword">sd</span> loop_v, 8(pivort)
    <span class="org-keyword">sd</span> tmp, 0(loop)
    ## swap
    <span class="org-keyword">ld</span> tmp, 8(pivort)
    <span class="org-keyword">sd</span> pivort_v, 8(pivort)
    <span class="org-keyword">sd</span> tmp, 0(pivort)
    ## inc pivort
    <span class="org-keyword">addi</span> pivort, pivort, 8
    <span class="org-keyword">j</span> 1b

<span class="org-function-name">1</span>:  
    <span class="org-keyword">move</span> a0, start
    <span class="org-keyword">move</span> a1, pivort
    <span class="org-keyword">call</span> quick_sort

    <span class="org-keyword">addi</span> a0, pivort, 8
    <span class="org-keyword">move</span> a1, end
    <span class="org-keyword">call</span> quick_sort

    <span class="org-keyword">.Lquick_sort_end</span>:
    <span class="org-keyword">lw</span> ra, 8(sp)
    <span class="org-keyword">lw</span> s0, 16(sp)
    <span class="org-keyword">lw</span> s1, 24(sp)
    <span class="org-keyword">lw</span> s2, 32(sp)
    <span class="org-keyword">lw</span> s3, 40(sp)
    <span class="org-keyword">lw</span> s4, 48(sp)
    <span class="org-keyword">lw</span> s5, 56(sp)
    <span class="org-keyword">lw</span> s6, 64(sp)

    <span class="org-keyword">addi</span> sp, sp, 64
    <span class="org-keyword">ret</span>

<span class="org-function-name">main</span>:
    <span class="org-keyword">enter</span>

    <span class="org-keyword">call</span> print_data

    <span class="org-keyword">la</span> a0, .Ldata_start
    <span class="org-keyword">la</span> a1, .Ldata_end

    <span class="org-keyword">call</span> quick_sort
    <span class="org-keyword">call</span> print_data

    <span class="org-keyword">leave</span>

    <span class="org-keyword">.data</span>
    <span class="org-keyword">.Ldata_start</span>:
    <span class="org-keyword">.dword</span> 4
    <span class="org-keyword">.dword</span> 3
    <span class="org-keyword">.dword</span> 10
    <span class="org-keyword">.dword</span> 5
    <span class="org-keyword">.rep</span> 2
    <span class="org-keyword">.dword</span> 3
    <span class="org-keyword">.endr</span>
    <span class="org-keyword">.fill</span> 2, 8, 1
    <span class="org-keyword">.space</span> 8, 0xff
    <span class="org-keyword">.Ldata_end</span>:

<span class="org-function-name">.Lprint_fmt_new_line</span>:
    <span class="org-keyword">.asciz</span> <span class="org-string">"\n"</span>

<span class="org-function-name">.Lprint_fmt</span>:
    <span class="org-keyword">.asciz</span> <span class="org-string">"%ld "</span>
</pre>
</div>

<pre class="example" id="org0000077">
4 3 10 5 3 3 1 1 -1 
-1 1 1 3 3 3 4 5 10
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org0000070" class="outline-3">
<h3 id="org0000070"><span class="section-number-3">1.3</span> GNU Assembler</h3>
<div class="outline-text-3" id="text-1-3">
<p>
<a href="https://sourceware.org/binutils/docs/as/index.html#SEC_Contents">using as</a>
</p>
</div>

<div id="outline-container-org0000081" class="outline-4">
<h4 id="org0000081"><span class="section-number-4">1.3.1</span> label</h4>
<div class="outline-text-4" id="text-1-3-1">
<ul class="org-ul">
<li>.L 开头的 label, 不会出现在符号表中</li>

<li>数字形式的 label 如 1:, 2: 是 local label, 它们可以重复定义, 通过 1b, 1f 的形式去引用当前位置后面或前面的 label. as 内部会让它们有唯一的名字</li>
</ul>
</div>
</div>

<div id="outline-container-org0000085" class="outline-4">
<h4 id="org0000085"><span class="section-number-4">1.3.2</span> directive</h4>
<div class="outline-text-4" id="text-1-3-2">
<ul class="org-ul">
<li>`.lcomm test_data, 1024` 相当于 static char test_data[1024]={0}; `.comm
test_data, 1024` 相当于 char test_data[1024]={0}, 即两者可以在 .bss 上分配空间, 但 .lcomm 产生 local 符号, .comm 产生 global 符号</li>

<li>`.space 10, 1` 相当于连接 10 个 .byte 1</li>

<li>`.fill 10, 8, 2 ` 相当于 10 个 .dword 2</li>

<li><p>
.rep N, endr
</p>

<pre class="example" id="org0000084">
.rept   3
.word   10
.endr

相当于

.word 10
.word 10
.word 10
</pre></li>

<li>.word, .dword, .half, .byte, .float</li>

<li>.ascii "hello", .asciz "hello"</li>

<li>.global main</li>

<li>.include "header.S"</li>

<li>.macro, .endm</li>

<li>.section</li>

<li>.equ constant 0x1234</li>

<li>align/balign</li>
</ul>
</div>
</div>

<div id="outline-container-org0000052" class="outline-4">
<h4 id="org0000052"><span class="section-number-4">1.3.3</span> risc-v modifiers</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
<a href="https://sourceware.org/binutils/docs/as/RISC_002dV_002dModifiers.html">https://sourceware.org/binutils/docs/as/RISC_002dV_002dModifiers.html</a>
</p>

<p>
symbol 是一个 32 bit 地址, 并没有直接操作 32bit imm 的指令, 需要用 lui, auipc
去操作 symbol 的高 20 位,再用 addi 操作低 12 位, 所以需要 %hi, %lo 等
modifier. 这些 modifier 的作用实际上是设置目标文件中的 .rela section 的
relocation type, link editor 在链接时会根据这个 type 决定重定位时在什么位置写入什么数据
</p>

<ol class="org-ol">
<li>%lo(symbol), %hi(symbol)</li>

<li>%pcrel_hi(symbol), %pcrel_lo(label)

<ul class="org-ul">
<li>pcrel_hi 会计算 (symbol)&gt;&gt;12-(pc&gt;&gt;12)</li>

<li>pcrel_lo 会计算 (symbol&amp;0xfff)-(pc&amp;0xfff)</li>
</ul></li>

<li>%got_pcrel_hi(symbol)</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org00000b2" class="outline-3">
<h3 id="org00000b2"><span class="section-number-3">1.4</span> Standard Extention</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-org0000074" class="outline-4">
<h4 id="org0000074"><span class="section-number-4">1.4.1</span> RV32M</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
RV32M 有 8 条 R 指令:
</p>

<ul class="org-ul">
<li><p>
mul, mulh, mulhu, mulhsu
</p>

<p>
mul 用来获得两个 32 bit 数乘法的低 32 bit
</p>

<p>
mulh (mul high) 用来获得两个 32 bit 数乘法的高 32 bit
</p>

<p>
mulhu (mul hight unsigned) 用来获得两个 unsigned 32 bit 数乘法的高 32 bit
</p>

<p>
mulhsu (mul hight signed unsigned) 用来获得一个 unsigned 32 bit 数和一个
signed 32 bit 数相乘的高 32 bit
</p></li>

<li><p>
div, divu, rem, remu
</p>

<p>
div 获得商, rem 获得余数, 这里的除法是整数除法
</p></li>
</ul>

<div class="org-src-container">
<pre class="src src-asm">    ## riscv64-linux-gnu-gcc test.s -static
    <span class="org-keyword">.global</span> main

    <span class="org-keyword">.text</span>

<span class="org-function-name">main</span>:
    <span class="org-keyword">addi</span> sp, sp, -8
    <span class="org-keyword">sd</span> ra, 8(sp)

    <span class="org-keyword">li</span> t0, 3
    <span class="org-keyword">li</span> t1, 2
    <span class="org-keyword">mul</span> a1, t0, t1
    <span class="org-keyword">div</span> a2, t0, t1
    <span class="org-keyword">rem</span> a3, t0, t1    
    <span class="org-keyword">la</span> a0, .Lprint_fmt
    <span class="org-keyword">call</span> printf

    <span class="org-keyword">ld</span> ra, 8(sp)
    <span class="org-keyword">addi</span> sp, sp, 8
    <span class="org-keyword">move</span> a0, zero
    <span class="org-keyword">ret</span>

<span class="org-function-name">.Lprint_fmt</span>:
    <span class="org-keyword">.asciz</span> <span class="org-string">"%lx %lx %lx\n"</span>

</pre>
</div>

<pre class="example" id="org000008b">
6 1 1
</pre>
</div>
</div>


<div id="outline-container-org0000089" class="outline-4">
<h4 id="org0000089"><span class="section-number-4">1.4.2</span> RV32F and RV32D</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
RV32{F,D} 是针对浮点数的指令, 浮点数的格式是 <a href="ieee754.html#ID-e140d23d-9ff9-4005-bb96-a6d419fa92e4">IEEE754</a>
</p>

<p>
除了用于 load/store 的:
</p>

<ul class="org-ul">
<li>flw (float load word)</li>
<li>fsw (float store word)</li>
<li>fld (float load double word)</li>
<li>fsd (float store double word)</li>
</ul>

<p>
其它都是 R 指令, 且都通过 .{s,d} 后缀区别 single precision 和 double precision,
例如:
</p>
</div>

<div id="outline-container-org000008f" class="outline-5">
<h5 id="org000008f"><span class="section-number-5">1.4.2.1</span> 算术运算</h5>
<div class="outline-text-5" id="text-1-4-2-1">
<ul class="org-ul">
<li>fadd.{s,d}</li>
<li>fsub.{s,d}</li>
<li>fmul.{s,d}</li>
<li>fdiv.{s,d}</li>
<li>fsqrt.{s,d}</li>
<li>fmin.{s,d}</li>
<li>fmax.{s,d}</li>
</ul>
</div>
</div>

<div id="outline-container-org0000093" class="outline-5">
<h5 id="org0000093"><span class="section-number-5">1.4.2.2</span> 比较运算</h5>
<div class="outline-text-5" id="text-1-4-2-2">
<p>
rv32f 没有提供 v32i 的 bne 类似条件跳转的指令, 但提供了浮点比较指令, 比较的结果放在 rd 中, 再使用 x 寄存器上的条件跳转指令进行跳转, 例如:
</p>

<pre class="example" id="org0000092">
flt x5，f1，f2
bne x5，x0，exit
</pre>

<ul class="org-ul">
<li>feq.{s,d}</li>
<li>flt.{s,d}</li>
<li>fle.{s,d}</li>
</ul>
</div>
</div>


<div id="outline-container-org000007e" class="outline-5">
<h5 id="org000007e"><span class="section-number-5">1.4.2.3</span> 浮点与定点互相搬运</h5>
<div class="outline-text-5" id="text-1-4-2-3">
<p>
f 寄存器与 x 寄存器互相复制
</p>

<ul class="org-ul">
<li><p>
fmv.x.{w,d}
</p>

<p>
w 表示单精度, d 表示双精度
</p>

<p>
fmv.x.w a0, fa0
</p></li>

<li><p>
fmv.{w,d}.x
</p>

<p>
fmv.w.x fa0, a0
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org0000099" class="outline-5">
<h5 id="org0000099"><span class="section-number-5">1.4.2.4</span> 寄存器</h5>
<div class="outline-text-5" id="text-1-4-2-4">
<p>
所有浮点操作使用独立的 f0~f31 寄存器, 和 rv32i 使用的 x 寄存器有类似的别名, 例如:
</p>

<ol class="org-ol">
<li>ft0~ft11 是 caller saved temp register</li>
<li>fs0~fs11 是 callee saved register</li>
<li>fa0~fa7 用来保存 argument 和 return value, 同样是 caller saved</li>
</ol>
</div>
</div>

<div id="outline-container-org0000086" class="outline-5">
<h5 id="org0000086"><span class="section-number-5">1.4.2.5</span> 调用约定</h5>
<div class="outline-text-5" id="text-1-4-2-5">
<p>
与 rv32i 类似, rv32{f,d} 也使用 fa0~fa7 传递参数, 例如, foo(int a, float b) 会使用 a0 读取 a, fa0 读取 b.
</p>

<div class="org-src-container">
<pre class="src src-asm">    ## riscv64-linux-gnu-gcc test.s -static
    <span class="org-keyword">.global</span> main

    <span class="org-keyword">.text</span>

<span class="org-function-name">foo</span>:    
    <span class="org-keyword">addi</span>    sp,sp,-16
    <span class="org-keyword">sd</span>      ra,8(sp)

    ## &#36825;&#37324;&#26159; gcc &#29983;&#25104;&#30340;&#20195;&#30721;, &#23454;&#38469;&#19978;&#21487;&#20197;&#29992; fmv.x.d a2, fa0 &#20195;&#26367; fsd/ld
    ## fmv.x.d a2, fa0     
    <span class="org-keyword">fsd</span>     fa0,16(sp)
    <span class="org-keyword">ld</span>      a2,16(sp)

    <span class="org-keyword">mv</span>      a1,a0
    <span class="org-keyword">la</span>      a0,.Lprint_fmt
    <span class="org-keyword">call</span>    printf

    <span class="org-keyword">ld</span>      ra,8(sp)
    <span class="org-keyword">addi</span>    sp,sp,16
    <span class="org-keyword">ret</span>

<span class="org-function-name">main</span>:
    <span class="org-keyword">addi</span> sp, sp, -8
    <span class="org-keyword">sd</span> ra, 8(sp)

    <span class="org-keyword">li</span> a0, 0x1234
    <span class="org-keyword">la</span> t0, 1f
    <span class="org-keyword">fld</span> fa0, 0(t0)

    <span class="org-keyword">call</span> foo

    <span class="org-keyword">ld</span> ra, 8(sp)
    <span class="org-keyword">addi</span> sp, sp, 8
    <span class="org-keyword">move</span> a0, zero
    <span class="org-keyword">ret</span>

<span class="org-function-name">1</span>:
    <span class="org-keyword">.double</span> 1.1

    <span class="org-keyword">.Lprint_fmt</span>:
    <span class="org-keyword">.asciz</span> <span class="org-string">"%x %f\n"</span>
</pre>
</div>

<pre class="example" id="org000009c">
1234 1.100000
</pre>

<p>
关于 printf 这种 variadic function, 有特殊的处理: 使用 a0, a1, a2 &#x2026; 而不使用
fa0, fa1, &#x2026;, 需要调用者用 fmv.x.{w,d} 把浮点搬运到整数寄存器.
</p>

<div class="org-src-container">
<pre class="src src-asm">    ## riscv64-linux-gnu-gcc test.s -static
    <span class="org-keyword">.global</span> main

    <span class="org-keyword">.text</span>

<span class="org-function-name">main</span>:
    <span class="org-keyword">addi</span> sp, sp, -8
    <span class="org-keyword">sd</span> ra, 8(sp)

    <span class="org-keyword">la</span> a0, .Lprint_fmt
    <span class="org-keyword">li</span> a1, 0x1234
    <span class="org-keyword">la</span> t0, 1f
    ## &#30452;&#25509;&#20570;&#20026;&#25972;&#25968; load
    <span class="org-keyword">ld</span> a2, 0(t0)
    ## &#25110;&#32773;&#20351;&#29992; fmv.x.d &#25644;&#36816;&#19968;&#27425;
    ## fld fa0, 0(t0)
    ## fmv.x.d a2, fa0

    <span class="org-keyword">call</span> printf

    <span class="org-keyword">ld</span> ra, 8(sp)
    <span class="org-keyword">addi</span> sp, sp, 8
    <span class="org-keyword">move</span> a0, zero
    <span class="org-keyword">ret</span>

<span class="org-function-name">1</span>:
    <span class="org-keyword">.double</span> 1.1

<span class="org-function-name">.Lprint_fmt</span>:
    <span class="org-keyword">.asciz</span> <span class="org-string">"0x%x %f\n"</span>

</pre>
</div>

<pre class="example" id="org000009d">
0x1234 1.100000
</pre>
</div>
</div>
</div>

<div id="outline-container-org0000097" class="outline-4">
<h4 id="org0000097"><span class="section-number-4">1.4.3</span> RV32A</h4>
<div class="outline-text-4" id="text-1-4-3">
<p>
RV32A 定义了原子操作 (atomic operation)
</p>
</div>

<div id="outline-container-ID-69861e6c-ed76-4e86-ab9d-24f98e5334f4" class="outline-5">
<h5 id="ID-69861e6c-ed76-4e86-ab9d-24f98e5334f4"><span class="section-number-5">1.4.3.1</span> CAS</h5>
<div class="outline-text-5" id="text-1-4-3-1">
<p>
其它平台例如 x86 提供了 compare and swap (CAS) 类操作实现 read-modify-write 做为原子操作的原语, 以 cmpxchg 指令为例, 实现一个 atomic_inc 的代码大约是:
</p>

<p>
<a href="https://www.felixcloutier.com/x86/cmpxchg">https://www.felixcloutier.com/x86/cmpxchg</a>
</p>

<div class="org-src-container">
<pre class="src src-asm">    ## &#36825;&#27573;&#20195;&#30721;&#23454;&#29616;&#30340;&#21151;&#33021;&#26159; *mem += 1
    <span class="org-keyword">la</span> t2, mem
    <span class="org-keyword">lw</span> t0, 0(t2)
<span class="org-function-name">retry</span>:  
    <span class="org-keyword">addi</span> t1, t0, 1
    <span class="org-keyword">cmpxchg</span> t0, t2, t1
    <span class="org-keyword">beqz</span> zf, retry
</pre>
</div>

<ol class="org-ol">
<li>load mem 到 t0</li>
<li>t1=t0+1</li>
<li>比较 t0 和 mem 的值
<ol class="org-ol">
<li>若相等, 表示没有 race, 把 t1 写入 mem, 标志寄存器 zf 置位</li>
<li>若不相等, 表示有 race, 把 mem 写入 t0, 标志寄存器 zf 复位</li>
</ol></li>
</ol>

<p>
所以 cmpxchg 共需要操作四个寄存器:
</p>

<ol class="org-ol">
<li>cmp 的两个寄存器</li>
<li>要写入的新值的寄存器</li>
<li>标志寄存器</li>
</ol>

<p>
RV32A 没有提供 CAS, 因为它的指令无法编码 4 个寄存器, 做为替代, 它提供了 Atomic
Memory Operation (AMO) 和 Load Reserved/Store Condition (LR/SC)
</p>
</div>



<div id="outline-container-org00000a4" class="outline-6 references">
<h6 id="org00000a4">Backlinks</h6>
<div class="outline-text-6" id="text-org00000a4">
<p>
<a href="retargeting_gcc_to_riscv.html#ID-303d0f7f-03c2-4f31-ad7e-064162e3af10">Retargeting GCC To RISC-V</a>
(<i>Retargeting GCC To RISC-V &gt; newlib/glibc &gt; atomic 相关</i>):  例如 riscv 可以用 <a href="#ID-8c466f7a-a7ee-4c3b-b473-f939126eb191">LR/SC</a> 实现 libc 要求的 atomic_compare_and_exchange_bool_acq 做 <a href="#ID-69861e6c-ed76-4e86-ab9d-24f98e5334f4">CAS</a>.
</p>
</div>
</div>
</div>


<div id="outline-container-ID-c1ffdfa0-c15c-47ae-a7b2-5fdca4e3a53a" class="outline-5">
<h5 id="ID-c1ffdfa0-c15c-47ae-a7b2-5fdca4e3a53a"><span class="section-number-5">1.4.3.2</span> AMO</h5>
<div class="outline-text-5" id="text-1-4-3-2">
<p>
amo 是 R 指令, 包括: amo{add, and, or, swap, xor, max, maxu, min, minu}.w
</p>

<p>
amo 指令不像 cmpxchg 或 lr/sc 一样会失败.
</p>

<p>
lr/sc 会失败是因为它们需要先 read &amp; update, 然后 write 时会有可能因为内存数据已经被修改导致 read &amp; update 得到的结果无效, 从而导致失败.
</p>

<p>
amo 不需要 read, 因为它是直接在原数据基础上 update, 所以它不会失败. 但限制是它能做的 update 是预定好的: add, and, or, &#x2026;, 想实现一个没有定义的 update 例如
`mem[x]=mem[x]*2` 是不可能的.
</p>

<div class="org-src-container">
<pre class="src src-asm">    <span class="org-keyword">.global</span> main
    <span class="org-keyword">.text</span>
<span class="org-function-name">main</span>:
    <span class="org-keyword">addi</span> sp, sp, -8
    <span class="org-keyword">sd</span> ra, 8(sp)

    ## amoadd.w &#30456;&#24403;&#20110; rd=offset(rs2)=rs1+offset(rs2) 
    <span class="org-keyword">la</span> a0, print_fmt
    <span class="org-keyword">la</span> t0, data
    <span class="org-keyword">li</span> t2, 10
    <span class="org-keyword">amoadd.w</span> a1, t2, 0(t0)
    <span class="org-keyword">call</span> printf

    ## amoswap &#30456;&#24403;&#20110; rd=offset(rs1)<span class="org-comment-delimiter">; </span><span class="org-comment">offset(rs1)=rs2</span>
    <span class="org-keyword">la</span> a0, print_fmt
    <span class="org-keyword">la</span> t0, data
    <span class="org-keyword">addi</span> t2, zero, 1
    <span class="org-keyword">amoswap.w</span> a1, t2, 0(t0)
    <span class="org-keyword">call</span> printf

    <span class="org-keyword">la</span> a0, print_fmt
    <span class="org-keyword">la</span> t0, data
    <span class="org-keyword">lw</span> a1, 0(t0)
    <span class="org-keyword">call</span> printf

    <span class="org-keyword">ld</span> ra, 8(sp)
    <span class="org-keyword">addi</span> sp, sp, 8
    <span class="org-keyword">move</span> a0, zero
    <span class="org-keyword">ret</span>

    <span class="org-keyword">.data</span>
<span class="org-function-name">print_fmt</span>:
    <span class="org-keyword">.asciz</span> <span class="org-string">"%d\n"</span>

<span class="org-function-name">data</span>:
    <span class="org-keyword">.word</span> 10
</pre>
</div>

<pre class="example" id="org00000a7">
10
20
1
</pre>

<p>
使用 amoswap 实现的 spinlock:
</p>

<div class="org-src-container">
<pre class="src src-asm">    ## a0 &#22320;&#22336;&#20026; 1 &#26102;&#34920;&#31034; locked, &#20026; 0 &#34920;&#31034; unlocked
    <span class="org-keyword">li</span> t0, 1
<span class="org-function-name">1</span>:  <span class="org-keyword">amoswap.w.aq</span> t1, t0, (a0)
    <span class="org-keyword">bnez</span> t1, 1b
    ## acquired
    ## ...
    <span class="org-keyword">amoswap.w.rl</span> zero, zero, (a0)
</pre>
</div>
</div>


<div id="outline-container-org00000a8" class="outline-6 references">
<h6 id="org00000a8">Backlinks</h6>
<div class="outline-text-6" id="text-org00000a8">
<p>
<a href="retargeting_gcc_to_riscv.html#ID-303d0f7f-03c2-4f31-ad7e-064162e3af10">Retargeting GCC To RISC-V</a>
(<i>Retargeting GCC To RISC-V &gt; newlib/glibc &gt; atomic 相关</i>):  另外, libc 会使用 CAS 实现 atomic<sub>max, min, &#x2026;</sub>, 但 riscv 可以提供自己的基于 <a href="#ID-c1ffdfa0-c15c-47ae-a7b2-5fdca4e3a53a">AMO</a> 的实现
</p>
</div>
</div>
</div>


<div id="outline-container-ID-8c466f7a-a7ee-4c3b-b473-f939126eb191" class="outline-5">
<h5 id="ID-8c466f7a-a7ee-4c3b-b473-f939126eb191"><span class="section-number-5">1.4.3.3</span> LR/SC</h5>
<div class="outline-text-5" id="text-1-4-3-3">
<p>
LR/SC 成对出现, 且需要操作相同的地址, 有点类似于把 cmpxchg 拆成两条指令
</p>

<div class="org-src-container">
<pre class="src src-asm">    <span class="org-keyword">.global</span> main
    <span class="org-keyword">.text</span>
<span class="org-function-name">main</span>:
    <span class="org-keyword">addi</span> sp, sp, -8
    <span class="org-keyword">sd</span> ra, 8(sp)
    <span class="org-keyword">la</span> t0, data

    ## &#25104;&#23545;&#30340; lr/sc &#38656;&#35201;&#25805;&#20316;&#30456;&#21516;&#30340;&#22320;&#22336; t0
    ## &#35835;&#21462; t0 &#30340;&#26087;&#25968;&#25454;
<span class="org-function-name">1</span>:  <span class="org-keyword">lr.w</span> t2, 0(t0)
    ## &#35201;&#20889;&#20837; t0 &#30340;&#26032;&#25968;&#25454;
    <span class="org-keyword">addi</span> t2, t2, 10
    ## &#33509; t0 &#20013;&#36884;&#34987;&#20462;&#25913;, &#21017;&#19981;&#20250;&#20889;&#20837;&#26032;&#25968;&#25454;, &#19988; t3 &#20250;&#36820;&#22238; 0
    ## &#21542;&#21017;&#20889;&#20837;&#26032;&#25968;&#25454;, &#19988; t3 &#36820;&#22238; 1
    <span class="org-keyword">sc.w</span> t3, t2, 0(t0)
    <span class="org-keyword">bnez</span> t3, 1b

    <span class="org-keyword">la</span> a0, print_fmt
    <span class="org-keyword">lw</span> a1, data
    <span class="org-keyword">call</span> printf

    <span class="org-keyword">ld</span> ra, 8(sp)
    <span class="org-keyword">addi</span> sp, sp, 8
    <span class="org-keyword">move</span> a0, zero
    <span class="org-keyword">ret</span>

    <span class="org-keyword">.data</span>
<span class="org-function-name">print_fmt</span>:
    <span class="org-keyword">.asciz</span> <span class="org-string">"%d\n"</span>
<span class="org-function-name">data</span>:
    <span class="org-keyword">.word</span> 10

</pre>
</div>

<pre class="example" id="org00000ab">
20
</pre>

<p>
使用 lr/sc 实现的 spinlock:
</p>

<div class="org-src-container">
<pre class="src src-asm">    ## lock
<span class="org-function-name">1</span>:  <span class="org-keyword">lr.w</span> t0, (a0)
    <span class="org-keyword">bnez</span> 1b
    <span class="org-keyword">li</span> t0, 1
    <span class="org-keyword">sc.w</span> t1, t0, (t0)
    <span class="org-keyword">bnez</span> t1, 1b

    ## unlock
<span class="org-function-name">1</span>:  <span class="org-keyword">lr.w</span> zero, (a0)
    <span class="org-keyword">sc.w</span> t1, zero, (t0)
    <span class="org-keyword">bnez</span> t1, 1b
</pre>
</div>
</div>


<div id="outline-container-org00000ad" class="outline-6 references">
<h6 id="org00000ad">Backlinks</h6>
<div class="outline-text-6" id="text-org00000ad">
<p>
<a href="retargeting_gcc_to_riscv.html#ID-303d0f7f-03c2-4f31-ad7e-064162e3af10">Retargeting GCC To RISC-V</a>
(<i>Retargeting GCC To RISC-V &gt; newlib/glibc &gt; atomic 相关</i>):  例如 riscv 可以用 <a href="#ID-8c466f7a-a7ee-4c3b-b473-f939126eb191">LR/SC</a> 实现 libc 要求的 atomic_compare_and_exchange_bool_acq 做 <a href="#ID-69861e6c-ed76-4e86-ab9d-24f98e5334f4">CAS</a>.
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org000009a" class="outline-4">
<h4 id="org000009a"><span class="section-number-4">1.4.4</span> RV32C</h4>
<div class="outline-text-4" id="text-1-4-4">
<p>
RV32C 代表 compat, 即把一部分指指令替换为 16 bit 的形式, 之所以有些指令可以压缩,
是因为:
</p>

<ol class="org-ol">
<li>只是 10 个寄存器是经常访问的 (a0~a5, s0, s1, sp, ra), 所以不需要用 5 bit 来
encode 寄存器</li>
<li>有些指令的 rs, rd 是相同的, 例如 addi s0, s0, 1</li>
<li>imm 有时很小, 不需要 12 bit 编码</li>
</ol>

<p>
C 指令命名为 c.xxx,
</p>

<ol class="org-ol">
<li>c.mv rd, rs &lt;=&gt; addi rd, rs, 0</li>
<li>c.addi rd, imm &lt;=&gt; addi rd, rd, imm</li>
<li>c.ldsp ra, 8(sp) &lt;=&gt; ld ra, 8(sp)</li>
<li>c.jr ra &lt;=&gt; jalr zero, 0(ra)</li>
<li>&#x2026;</li>
</ol>

<p>
assember 会自动将伪指令或某些指令替换成 C 指令, 除非通过编译器参数例如
`-march=rv64g` 禁用 RV32C
</p>
</div>
</div>

<div id="outline-container-org00000b5" class="outline-4">
<h4 id="org00000b5"><span class="section-number-4">1.4.5</span> RV32V</h4>
<div class="outline-text-4" id="text-1-4-5">
<p>
RV32V 定义了向量操作, 和 SIMD 不同的是, 它定义向量寄存器 v0, v1 &#x2026;, 且通过setvl
指定要操作的向量的长度, 而不是像 SIMD 那样把长度嵌入在指令中.
</p>

<p>
目前 (2022/2) gcc 的 rivc-v 扩展还不支持 RV32V
</p>
</div>
</div>

<div id="outline-container-org00000af" class="outline-4">
<h4 id="org00000af"><span class="section-number-4">1.4.6</span> RV64G</h4>
<div class="outline-text-4" id="text-1-4-6">
<p>
针对 64 bit 的扩展. RV32G 的指令可以直接在 RV64G 使用, 指令格式都没有变, 只是
XLEN 变成 64. 
</p>

<p>
为了在 RV64G 中支持 32 bit 的计算, 提供了带 w 后缀的指令, 例如 `addiw a0,x0,1`,
它会把 32 bit 截断的结果写入 a0.
</p>

<p>
另外, RV64G 还添加了几个带 d 后缀的指令, 用来支持 double word
</p>
</div>

<div id="outline-container-org00000a0" class="outline-5">
<h5 id="org00000a0"><span class="section-number-5">1.4.6.1</span> rv64i</h5>
<div class="outline-text-5" id="text-1-4-6-1">
<ul class="org-ul">
<li>add{i}.w, sub{i}.w</li>
<li>sll{i}.w, srl{i}.w, sra{i}.w</li>
<li>ld (load double word), 加载 64 bit double word (和 lb, lh, lw 对应)</li>
<li>lwu</li>
</ul>
</div>
</div>

<div id="outline-container-org00000a3" class="outline-5">
<h5 id="org00000a3"><span class="section-number-5">1.4.6.2</span> rv64m</h5>
<div class="outline-text-5" id="text-1-4-6-2">
<ul class="org-ul">
<li>mulw</li>
<li>div{u}.w, rem{u}.w</li>
</ul>
</div>
</div>

<div id="outline-container-org00000a6" class="outline-5">
<h5 id="org00000a6"><span class="section-number-5">1.4.6.3</span> rv64f/rv64d</h5>
<div class="outline-text-5" id="text-1-4-6-3">
<ul class="org-ul">
<li>fmv.d.x, fmv.x.d</li>
</ul>
</div>
</div>


<div id="outline-container-org00000a9" class="outline-5">
<h5 id="org00000a9"><span class="section-number-5">1.4.6.4</span> rv64c</h5>
<div class="outline-text-5" id="text-1-4-6-4">
<ul class="org-ul">
<li>c.add{i}.w</li>
</ul>
</div>
</div>

<div id="outline-container-org00000c4" class="outline-5">
<h5 id="org00000c4"><span class="section-number-5">1.4.6.5</span> rv64a</h5>
<div class="outline-text-5" id="text-1-4-6-5">
<p>
xxx.d 与 xxx.w 对应, 例如 amoadd.d
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org00000c1" class="outline-3">
<h3 id="org00000c1"><span class="section-number-3">1.5</span> Privileged ISA</h3>
<div class="outline-text-3" id="text-1-5">
</div>
<div id="outline-container-org00000ce" class="outline-4">
<h4 id="org00000ce"><span class="section-number-4">1.5.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
<a href="https://riscv.org/wp-content/uploads/2017/05/riscv-privileged-v1.10.pdf">https://riscv.org/wp-content/uploads/2017/05/riscv-privileged-v1.10.pdf</a>
</p>

<p>
<a href="https://danielmangum.com/posts/risc-v-bytes-privilege-levels/">https://danielmangum.com/posts/risc-v-bytes-privilege-levels/</a>
</p>

<p>
RISC-V 主要有 M (machine), S (supervisor), U (user) 三种模式.
</p>

<ul class="org-ul">
<li>M 是最基础的, 权限最高的模式, 适用于裸系统</li>

<li>S 用来运行 OS</li>

<li>U 用来运行应用程序</li>
</ul>

<p>
通过 ecall 和 {m,s}ret 指令可以在模式之间转换:
</p>

<ol class="org-ol">
<li>mret

<ul class="org-ul">
<li>M -&gt; S</li>

<li>jump to mepc (machine excepiton pc)</li>
</ul></li>

<li>sret

<ul class="org-ul">
<li>S -&gt; U</li>

<li>jump to sepc (supervisor exception pc)</li>
</ul></li>

<li>ecall 

<ul class="org-ul">
<li>U -&gt; S 或 S -&gt; M</li>

<li>jump to stvec (supervisor trap vector) (或 mtvec (machine trap vector))</li>
</ul></li>
</ol>

<p>
通过 ecall 进入 S (或 M 模式) 前, sepc (或 mepc) 自动被设置为当前 pc, 然后跳转到
stvec (或 mtvec), 后者称为中断向量, stvec 执行完以后需要调用 sret (或 mret) 返回到之前模式, 同时更新 pc 为 sepc (或 mepc). 需要注意的是由于 ecall 保存的 sepc 为当前 pc (而不是 pc+4), 所以针对 ecall 的 stvec 里需要把 sepc+4 避免死循环.
</p>

<p>
低权限模式无法设置高权限模式的 vec, 所以提升权限后只能执行高权限预设的动作, 例如
syscall
</p>

<p>
前面提到的 mepc, sepc, stvec, mtvec 都是 CSR (control status register),
Privileged ISA 给 CSR 预留了 12 bit 的命名空间 (普通的 x 寄存器只有 5 bit 命名空间)
</p>
</div>
</div>

<div id="outline-container-org00000b8" class="outline-4">
<h4 id="org00000b8"><span class="section-number-4">1.5.2</span> Machine-Level CSRs</h4>
<div class="outline-text-4" id="text-1-5-2">
<ul class="org-ul">
<li><p>
misa
</p>

<p>
Machine ISA, 用来读取硬件对 I, F, D, M, A, C, V&#x2026;等扩展的支持情况
</p></li>

<li><p>
mvendorid
</p>

<p>
Machine Vendor ID
</p></li>

<li><p>
marchid
</p>

<p>
Machine Architecture ID
</p></li>

<li><p>
mimpid
</p>

<p>
Machine Implementation ID
</p></li>

<li><p>
mhartid
</p>

<p>
Hart ID, hardware thread ID, 相当于当前 core id
</p></li>

<li><p>
mstatus
</p>

<p>
Machine Status
</p>

<ul class="org-ul">
<li>MIE, SIE, UIE 是 interrupt-enable bits</li>
</ul></li>

<li><p>
mtvec
</p>

<p>
Machine Trap-Vector Base-Address
</p></li>

<li><p>
medeleg
</p>

<p>
Machine Trap Delegation
</p></li>

<li><p>
mie
</p>

<p>
Machine Interrupt Enable
</p></li>

<li><p>
mtime
</p>

<p>
Machine Timer
</p></li>

<li><p>
mcycle, minstret, &#x2026;
</p>

<p>
Hardware Performance Monitor
</p></li>

<li><p>
mcounteren
</p>

<p>
counter-enable register
</p></li>

<li><p>
mepc
</p>

<p>
Machine Exception Program Counter
</p></li>

<li><p>
mcause
</p>

<p>
Machine Cause Register
</p></li>
</ul>
</div>
</div>


<div id="outline-container-org00000bb" class="outline-4">
<h4 id="org00000bb"><span class="section-number-4">1.5.3</span> Supervisor-Level CSRs</h4>
<div class="outline-text-4" id="text-1-5-3">
<ul class="org-ul">
<li>status</li>

<li>stvec</li>

<li>sie</li>

<li>cycle,instret</li>

<li>scounteren</li>

<li>sepc</li>

<li>scause</li>

<li><p>
satp
</p>

<p>
Supervisor Address Translation and Protection
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org00000d7" class="outline-4">
<h4 id="org00000d7"><span class="section-number-4">1.5.4</span> Sample</h4>
<div class="outline-text-4" id="text-1-5-4">
<div class="org-src-container">
<pre class="src src-asm"><span class="org-keyword">.section</span> .text
<span class="org-keyword">.global</span> start

## &#21021;&#22987;&#36816;&#34892;&#22312; M &#27169;&#24335;
<span class="org-function-name">start</span>:
    ## &#19968;&#33324;&#24773;&#20917;&#19979; mepc &#30001; S &#27169;&#24335;&#19979;&#30340; ecall &#35774;&#32622;, &#36825;&#37324;&#30452;&#25509;&#35774;&#32622;&#20102;
    ## mepc. 
    <span class="org-keyword">la</span>      t0, supervisor    
    <span class="org-keyword">csrw</span>    mepc, t0
    ## &#35774;&#32622; mtvec &#20026; m_trap
    <span class="org-keyword">la</span>      t1, m_trap
    <span class="org-keyword">csrw</span>    mtvec, t1
    <span class="org-keyword">li</span>      t2, 0x1800
    <span class="org-keyword">csrc</span>    mstatus, t2
    <span class="org-keyword">li</span>      t3, 0x800
    <span class="org-keyword">csrs</span>    mstatus, t3
    <span class="org-keyword">li</span>      t4, 0x100
    ## 0x100 &#35774;&#32622;&#20026; mdeleg &#34920;&#31034; ecall &#34987; delegate &#32473; S &#27169;&#24335;
    <span class="org-keyword">csrs</span>    medeleg, t4
    ## mret &#20250;&#38477;&#26435;&#20026; M, &#21516;&#26102;&#36339;&#36716;&#21040; mepc &#21363; supervisor
    <span class="org-keyword">mret</span>

<span class="org-function-name">m_trap</span>:
    ## mepc &#20250;&#33258;&#21160;&#34987;&#35774;&#32622;&#20026;&#21518;&#38754; s_trap::ecall+4 &#30340;&#22320;&#22336;, &#20197;&#20415; ecall &#33021;&#36820;&#22238;
    <span class="org-keyword">csrr</span>    t0, mepc
    ## mcause &#20026; 9, &#34920;&#31034; Environment call from S-mode
    <span class="org-keyword">csrr</span>    t1, mcause
    ## &#36825;&#37324;&#25163;&#21160;&#35774;&#32622; mepc &#20026; supervisor
    <span class="org-keyword">la</span>      t2, supervisor
    <span class="org-keyword">csrw</span>    mepc, t2
    ## mret &#38477;&#26435;&#20026; S &#24182;&#36339;&#36716;&#21040; supervisor
    <span class="org-keyword">mret</span>

<span class="org-function-name">supervisor</span>:
    ## &#35774;&#32622; sepc &#20026; user
    <span class="org-keyword">la</span>      t0, user
    <span class="org-keyword">csrw</span>    sepc, t0
    ## &#35774;&#32622; stvec &#20026; s_trap
    <span class="org-keyword">la</span>      t1, s_trap
    <span class="org-keyword">csrw</span>    stvec, t1
    ## sret &#20250;&#38477;&#26435;&#20026; U &#24182;&#36339;&#36716;&#21040; sepc &#21363; user
    <span class="org-keyword">sret</span>

<span class="org-function-name">s_trap</span>:
    <span class="org-keyword">csrr</span>    t0, sepc
    ## scause &#20026; 8, &#34920;&#31034; Environment call from U-mode
    <span class="org-keyword">csrr</span>    t1, scause
    ## ecall &#25552;&#26435;&#21040; M &#24182;&#35843;&#29992; mtvec &#21363; m_trap
    <span class="org-keyword">ecall</span>

<span class="org-function-name">user</span>:
    <span class="org-keyword">csrr</span>    t0, instret
    ## ecall &#20250;&#25552;&#26435;&#21040; S &#24182;&#35843;&#29992; stvec &#21363; s_trap
    <span class="org-keyword">ecall</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org00000ca" class="outline-3">
<h3 id="org00000ca"><span class="section-number-3">1.6</span> Misc</h3>
<div class="outline-text-3" id="text-1-6">
</div>
<div id="outline-container-org00000dc" class="outline-4">
<h4 id="org00000dc"><span class="section-number-4">1.6.1</span> RISC-V vs. MIPS</h4>
<div class="outline-text-4" id="text-1-6-1">
<p>
risc-v 与 mips 有许多相同的地方, 实际上 riscv gnu toolchain 主要是在 mips 的基础上修改的.
</p>

<p>
riscv 与 mips 相似的地方:
</p>

<ol class="org-ol">
<li>指令长度都是 32 bits</li>
<li>都有 32 个通用寄存器, 都有 zero 寄存器</li>
<li>只能用 load/store 访存</li>
<li>都有 bnez/beqz</li>
</ol>

<p>
不同的地方:
</p>

<ul class="org-ul">
<li><p>
主要一个不同的地方是 mips 的 branch 指令不能直接比较并跳转, 而是需要两条指令, 例如:
</p>

<div class="org-src-container">
<pre class="src src-asm">## riscv
<span class="org-function-name">blt</span> <span class="org-keyword">t1</span>, t2, target
## mips
<span class="org-function-name">slt</span> <span class="org-keyword">$at</span>, $t1, $t2
<span class="org-function-name">beqz</span> <span class="org-keyword">$at</span>, target
</pre>
</div></li>

<li>riscv 没有 <a href="mips_tutorial.html#ID-61299f0f-f240-4a41-8ce6-18e29276ed46">Delay Slot</a></li>

<li>riscv word 不需要对齐</li>

<li><p>
riscv 是 little-endian, mips 两种都支持. mips-gcc 通过 `-EB`, `-EL` 指定
endian.
</p>

<p>
之前碰到过一个问题是 tflite 在 mips 上默认用 `-EB` 编译, x86 用 od 转换 binary
model 为 c header 时默认使用 little-endian, 导致 tflite 启动时会进行一个
endian 转换,又因为 model 放在 .rodata, 所以程序会出错
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org00000c7" class="outline-4">
<h4 id="org00000c7"><span class="section-number-4">1.6.2</span> Arithmetic Overflow</h4>
<div class="outline-text-4" id="text-1-6-2">
<p>
riscv 进行整数计算时不会进行 overflow check, 需要用户代码自己去检查, 例如:
</p>

<div class="org-src-container">
<pre class="src src-asm"><span class="org-function-name">add</span> <span class="org-keyword">t0</span>, t1, t2
## &#22914;&#26524; t2 &lt; 0, &#21017; t0 &gt; t1 &#34920;&#31034; overflow
## &#22914;&#26524; t2 &gt; 0, &#21017; t0 &lt; t1 &#34920;&#31034; overflow
<span class="org-function-name">slti</span> <span class="org-keyword">t3</span>, t2, 0
<span class="org-function-name">slt</span> <span class="org-keyword">t4</span>, t0, t1
<span class="org-function-name">bne</span> <span class="org-keyword">t3</span>, t4, overflow
</pre>
</div>

<p>
riscv 进行浮点计算时会通过 fcsr 指示 overflow 和 underflow (underflow 是指浮点数过于接近 0 (例如 \(1.0*2^{-127}\)), 而 <a href="ieee754.html#ID-2a46abf6-aba8-410d-b547-90295e086d52">float</a> 的 exponent 最小是 -126, 无法精确表示)
</p>

<p>
无论是整数运算还是浮点运算, riscv 都不会触发 overflow exception
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

<p class="author">Author: sunway (sunwayforever@gmail.com)<br />
Date: 2022-02-08 Tue 15:30<br />
Last updated: 2022-04-08 Fri 12:25</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。
<br />

<div id="disqus_thread"></div>
<script>

(function() { // DON'T EDIT BELOW THIS LINE
         var d = document, s = d.createElement('script');
         s.src = '//sunwayforever-github-io.disqus.com/embed.js';
         s.setAttribute('data-timestamp', +new Date());
         (d.head || d.body).appendChild(s);
         })();
</script>
</div>
</body>
</html>
