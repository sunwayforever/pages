<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>GCC Backend</title>


           <link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
           <link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
           <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
           <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
           <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
           <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
           <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
           <link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
           <link rel="stylesheet" type="text/css" href="../main.css" media="screen" />
           <link rel="stylesheet" type="text/css" href="./main.css" media="screen" />
           <link rel = "icon" href = "/icon.png"  type = "image/x-icon">
</head>
<body>
<div id="content" class="content">
<h1 class="title">GCC Backend</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org00000dd">1. GCC Backend</a>
<ul>
<li><a href="#org00000a9">1.1. insn selection</a>
<ul>
<li><a href="#org0000004">1.1.1. gimple tree code</a></li>
<li><a href="#ID-cc581233-c9a4-47c9-b392-64e03af4b454">1.1.2. optab</a></li>
<li><a href="#ID-5304f835-9c6a-49bc-89a5-ca01e2520167">1.1.3. machine desc</a></li>
<li><a href="#ID-a354364f-e048-4d6f-b780-0271f16dfd6a">1.1.4. rtl</a></li>
<li><a href="#org00000c8">1.1.5. example</a></li>
</ul>
</li>
<li><a href="#org00000aa">1.2. rtl optimization</a></li>
<li><a href="#org00000ac">1.3. insn schedule</a></li>
<li><a href="#org00000af">1.4. register allocation</a></li>
<li><a href="#org00000b2">1.5. code emission</a>
<ul>
<li><a href="#org000009f">1.5.1. backtrace</a></li>
<li><a href="#org000008a">1.5.2. final_scan_insn_1</a></li>
<li><a href="#org00000a8">1.5.3. recog_memoized</a></li>
<li><a href="#org00000b1">1.5.4. get_insn_template</a></li>
<li><a href="#org00000b0">1.5.5. output_asm_insn</a></li>
</ul>
</li>
<li><a href="#org00000d0">1.6. misc</a>
<ul>
<li><a href="#org00000b5">1.6.1. target hook</a></li>
<li><a href="#org00000b8">1.6.2. intrinsic</a></li>
<li><a href="#org00000d7">1.6.3. mcpu/mtune/march</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org00000dd" class="outline-2">
<h2 id="org00000dd"><span class="section-number-2">1.</span> GCC Backend</h2>
<div class="outline-text-2" id="text-1">
<p>
<a href="https://splichal.eu/scripts/sphinx/gccint/_build/html/index.html">GNU Compiler Collection (GCC) Internals</a>
</p>

<p>
<a href="https://github.com/sunwayforever/riscv-gnu-toolchain/tree/initial">GCC RISC-V backend 的最初提交</a>
</p>

<p>
gcc backend 的功能主要包括:
</p>

<ol class="org-ol">
<li><b>instruction (insn) selection</b></li>

<li><b>rtl optimization</b></li>

<li>insn schedule</li>

<li>register allocation</li>

<li><b>code emission</b></li>
</ol>

<p>
其中 backend 开发的工作主要有:
</p>

<ol class="org-ol">
<li><p>
完成 machine desc 文件, 用来声明:
</p>

<ol class="org-ol">
<li>backend 支持的 optab</li>

<li>optab 对应的 rtl (Register TransferLanguage)</li>

<li>optab 对应的汇编模板</li>
</ol>

<p>
md 文件主要用来支持 insn selection 和 code emission
</p></li>

<li>实现一些 rtl 优化, 例如 combine 和 peephole</li>

<li>实现一些 target hook 和 target macro, 给通用算法 (register allocation,
optimization 等) 提供必要的 backend 相关信息</li>

<li>如果有需要, 再实现一些 intrinsic</li>
</ol>
</div>


<div id="outline-container-org00000a9" class="outline-3">
<h3 id="org00000a9"><span class="section-number-3">1.1.</span> insn selection</h3>
<div class="outline-text-3" id="text-1-1">
<p>
insn selection 通过 `pass_expand` 完成, 目的是生成 gimple 对应的 rtl, 基本过程是:
</p>

<ol class="org-ol">
<li>根据 gimple 的 tree code (例如 PLUS_EXPR) 找到 optab (例如 add_optab)</li>

<li>根据 optab 找到 insn_code (例如 CODE_FOR_addsf3)</li>

<li>根据 insn_code 找到对应的 rtl</li>
</ol>
</div>

<div id="outline-container-org0000004" class="outline-4">
<h4 id="org0000004"><span class="section-number-4">1.1.1.</span> gimple tree code</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
<a href="retargeting_gcc_to_riscv.html#ID-93add5bb-995d-4276-94fa-c344283d3f53">gimple</a> 定义的 tree code 在 `tree.def` 中, 例如:
</p>

<pre class="example" id="org0000000">
DEFTREECODE (PLUS_EXPR, "plus_expr", tcc_binary, 2)
DEFTREECODE (MINUS_EXPR, "minus_expr", tcc_binary, 2)
DEFTREECODE (MULT_EXPR, "mult_expr", tcc_binary, 2)
DEFTREECODE (LSHIFT_EXPR, "lshift_expr", tcc_binary, 2)
DEFTREECODE (ABS_EXPR, "abs_expr", tcc_unary, 1)
</pre>

<p>
有些 tree code 并没有直接对应的 C 语法 (例如 ABS_EXPR, MAX_EXPR), 这些 tree code
要么通过 gimple 的 `Match-and-simplify patterns` 或其它一些 gimple optimization
来生成的, 要么通过 builtin 来使用, 例如:
</p>

<ul class="org-ul">
<li><p>
MAX_EXPR
</p>

<p>
MAX_EXPR 可以通过优化 `a&gt;b?a:b` 或 `if (a&gt;b) {return a; } return b;` 得到:
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#define</span> <span class="org-function-name">A</span>(<span class="org-variable-name">a</span>, <span class="org-variable-name">b</span>) ((a) &gt; (b) ? (a) : (b))

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
    <span class="org-type">int</span> <span class="org-variable-name">x</span> = argc;
    <span class="org-type">int</span> <span class="org-variable-name">y</span> = -argc;    
    <span class="org-type">int</span> <span class="org-variable-name">z</span> = A(x, y);
    <span class="org-keyword">return</span> z;
}
</pre>
</div>

<p>
生成的 gimple 为:
</p>

<pre class="example" id="org0000001">
main (int argc, char * * argv)
{
  int D.1506;

  {
    int x;
    int y;
    int z;

    x = argc;
    y = -argc;
    z = MAX_EXPR &lt;y, x&gt;;
    D.1506 = z;
    return D.1506;
  }
  D.1506 = 0;
  return D.1506;
}
</pre></li>

<li><p>
ABS_EXPR
</p>

<p>
abs 可以通过 `__builtin_fabs` 生成, 也可以通过优化 max(a,-a) 来生成:
</p>

<pre class="example" id="org0000002">
match.pd:

/* max(a,-a) -&gt; abs(a).  */
(simplify
 (max:c @0 (negate @0))
 (if (TREE_CODE (type) != COMPLEX_TYPE
      &amp;&amp; (! ANY_INTEGRAL_TYPE_P (type)
      || TYPE_OVERFLOW_UNDEFINED (type)))
  (abs @0)))
</pre>

<p>
以前面的代码为例, 优化后的 gimple 会变成:
</p>

<pre class="example" id="org0000003">
main (int argc, char * * argv)
{
  int z;

  &lt;bb 2&gt; [local count: 1073741824]:
  z_2 = ABS_EXPR &lt;argc_1(D)&gt;;
  return z_2;

}
</pre></li>
</ul>
</div>
</div>


<div id="outline-container-ID-cc581233-c9a4-47c9-b392-64e03af4b454" class="outline-4">
<h4 id="ID-cc581233-c9a4-47c9-b392-64e03af4b454"><span class="section-number-4">1.1.2.</span> optab</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
optab 的定义在 optabs.def, 它是 gimple 与 rtl 之间的桥梁:
</p>

<ul class="org-ul">
<li>gimple 的 tree code (例如 PLUS_EXPR) 通过 `optab_for_tree_code` 映射到 optab
(例如 add_optab)</li>

<li>optabl 通过 optab_handler 映射到 rtl 的 insn_code (例如 CODE_FOR_addsf3)</li>
</ul>

<p>
optabs.def 的部分内容:
</p>

<pre class="example" id="org0000007">
OPTAB_NL(add_optab, "add$P$a3", PLUS, "add", '3', gen_int_fp_fixed_libfunc)
OPTAB_NL(sub_optab, "sub$P$a3", MINUS, "sub", '3', gen_int_fp_fixed_libfunc)
OPTAB_NL(smul_optab, "mul$Q$a3", MULT, "mul", '3', gen_int_fp_fixed_libfunc)
OPTAB_NL(sdiv_optab, "div$a3", DIV, "div", '3', gen_int_fp_signed_fixed_libfunc)

OPTAB_NL(and_optab, "and$a3", AND, "and", '3', gen_int_libfunc)
OPTAB_NL(xor_optab, "xor$a3", XOR, "xor", '3', gen_int_libfunc)

OPTAB_NL(ashl_optab, "ashl$a3", ASHIFT, "ashl", '3', gen_int_fixed_libfunc)

OPTAB_NL(eq_optab, NULL, EQ, "eq", '2', gen_fp_libfunc)
OPTAB_DC(cbranch_optab, "cbranch$a4", COMPARE)

OPTAB_NL(neg_optab, "neg$P$a2", NEG, "neg", '2', gen_int_fp_fixed_libfunc)
OPTAB_NC(abs_optab, "abs$P$a2", ABS)

OPTAB_NL(clz_optab, "clz$a2", CLZ, "clz", '2', gen_int_libfunc)
OPTAB_NC(sqrt_optab, "sqrt$a2", SQRT)

OPTAB_DC(mov_optab, "mov$a", SET)
OPTAB_D (atomic_add_fetch_optab, "atomic_add_fetch$I$a")
</pre>

<p>
有些 optab 与 gimple 的 tree code 是对应的 (例如 add, sub, mul, shift 等), 另一些 optab (例如 clz, sqrt) 在 C 的语法中并不存在对应的东西, 这些 optab 主要是给
builtin (intrinsic) 或 tree optimizer 使用.
</p>

<p>
以 sqrt_optab 为例, 如果 backend 支持 sqrt_optab (通过
TARGET_OPTAB_SUPPORTED_P), 则 gimple 优化阶段会把 `pow (x, 0.5)` 替换成对
`__builtin_sqrt` 的调用, 后者在 insn selection 阶段会找到 sqrt_optab.
</p>
</div>

<div id="outline-container-org0000009" class="outline-5">
<h5 id="org0000009"><span class="section-number-5">1.1.2.1.</span> 构造 optab_handler</h5>
<div class="outline-text-5" id="text-1-1-2-1">
<p>
optab_handler 相当于一个注册表, 保存着 optab 与 insn_code 的对应关系
</p>

<p>
out/gcc/insn-opinit.c:
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">inline</span> <span class="org-keyword">enum</span> <span class="org-type">insn_code</span> <span class="org-function-name">optab_handler</span>(<span class="org-type">optab</span> <span class="org-variable-name">op</span>, <span class="org-type">machine_mode</span> <span class="org-variable-name">mode</span>) {
    <span class="org-type">unsigned</span> <span class="org-variable-name">scode</span> = (op &lt;&lt; 16) | mode;
    <span class="org-keyword">return</span> raw_optab_handler(scode);
}

<span class="org-keyword">enum</span> <span class="org-type">insn_code</span> <span class="org-function-name">raw_optab_handler</span>(<span class="org-type">unsigned</span> <span class="org-variable-name">scode</span>) {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = lookup_handler(scode);
    <span class="org-keyword">return</span> (
        i &gt;= 0 &amp;&amp; this_fn_optabs-&gt;pat_enable[i] ? pats[i].icode
                                                : CODE_FOR_nothing);
}

<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">optab_pat</span> <span class="org-variable-name">pats</span>[NUM_OPTAB_PATTERNS] = {
  { 0x010405, CODE_FOR_extendqihi2 },
  { 0x010406, CODE_FOR_extendqisi2 },
  { 0x010407, CODE_FOR_extendqidi2 },
  { 0x010505, CODE_FOR_extendhihi2 },
  { 0x010506, CODE_FOR_extendhisi2 },
  { 0x010507, CODE_FOR_extendhidi2 },
  <span class="org-comment-delimiter">/* </span><span class="org-comment">...</span><span class="org-comment-delimiter"> */</span>
}
</pre>
</div>

<p>
这个 insn-opinit.c 是 genopinit.c 通过扫描 optab.def 和 md 生成的
</p>
</div>

<div id="outline-container-org0000008" class="outline-6">
<h6 id="org0000008"><span class="section-number-6">1.1.2.1.1.</span> genopinit</h6>
<div class="outline-text-6" id="text-1-1-2-1-1">
<div class="org-src-container">
<pre class="src src-C">genopinit.<span class="org-constant">c</span>:

<span class="org-comment-delimiter">/* </span><span class="org-comment">read_md_rtx &#26159;&#20174; md &#20013;&#20381;&#27425;&#35835;&#20837; rtx, &#20363;&#22914;</span>
<span class="org-comment"> * addsf3, adddf3, addsi3, ...</span>
<span class="org-comment"> * &#38656;&#35201;&#27880;&#24847;&#30340;&#26159; md &#20013;&#36890;&#36807; define_mode_iterator &#23450;&#20041;&#30340; insn (&#20363;&#22914; add&lt;mode&gt;3)</span>
<span class="org-comment"> * &#20250;&#34987;&#23637;&#24320;&#25104;&#22810;&#20010; rtx: addsf3 &#21644; adddf3</span>
<span class="org-comment"> *</span><span class="org-comment-delimiter"> */</span>
<span class="org-keyword">while</span> (read_md_rtx(&amp;info)):
    <span class="org-keyword">switch</span> (GET_CODE(info.def)):
        <span class="org-keyword">case</span> DEFINE_INSN:
        <span class="org-keyword">case</span> DEFINE_EXPAND:
            gen_insn(&amp;info);
            <span class="org-keyword">break</span>;

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">gen_insn</span> (<span class="org-type">md_rtx_info</span> *<span class="org-variable-name">info</span>) {
  <span class="org-type">optab_pattern</span> <span class="org-variable-name">p</span>;
  <span class="org-keyword">if</span> (find_optab (&amp;p, XSTR (info-&gt;def, 0))) {
      patterns.safe_push (p);
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org000004a" class="outline-6">
<h6 id="org000004a"><span class="section-number-6">1.1.2.1.2.</span> find_optab</h6>
<div class="outline-text-6" id="text-1-1-2-1-2">
<p>
find_optab 是针对每一个 rtx 去查找 optab.def 中是否有对应的 optab, 目的是为了给
optab 找到底层的 rtx 实现.
</p>

<p>
例如:
</p>

<p>
addsf3 这个 rtx 会找到它对应 add_optab 且 mode 为 sf (single float)
fadddf3 这个 rtx 会找到它也对应 add_optab 且 mode 为 df (double float)
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="org-type">bool</span> <span class="org-function-name">find_optab</span>(<span class="org-type">optab_pattern</span> *<span class="org-variable-name">p</span>, <span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">name</span>) {
    <span class="org-keyword">if</span> (*name == 0 || *name == <span class="org-string">'*'</span>) <span class="org-keyword">return</span> <span class="org-constant">false</span>;

    <span class="org-comment-delimiter">/* </span><span class="org-comment">&#38024;&#23545; name &#36941;&#21382;&#25152;&#26377;&#30340; optab</span><span class="org-comment-delimiter"> */</span>
    <span class="org-keyword">for</span> (<span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">pindex</span> = 0; pindex &lt; ARRAY_SIZE(optabs); pindex++) {
        p-&gt;m1 = 0;
        <span class="org-comment-delimiter">/* </span><span class="org-comment">&#25152;&#35859;&#30340; match_pattern, &#26159;&#25351; rtx &#33021;&#21542;&#28385;&#36275; optab pattern &#30340;&#35201;&#27714;</span>
<span class="org-comment">         * &#20363;&#22914; add_optab &#26377;&#19968;&#20010; patten &#26159; `add$F$a3`, &#34920;&#31034;&#19977;&#20010;&#25805;&#20316;&#25968;&#30340;&#28014;&#28857;&#21152;&#27861;,</span>
<span class="org-comment">         * &#21017; addsf3 &#21644; adddf3 &#37117;&#20250;&#21644; add_optab match. &#21363; add_optab &#38024;&#23545;&#28014;&#28857;&#27169;&#24335; sf/df &#25214;&#21040;&#20102; rtx &#23454;&#29616;</span>
<span class="org-comment">         * &#23454;&#38469;&#19978;, &#19978;&#23618;&#20195;&#30721;&#20363;&#22914;&#29983;&#25104; gimple &#26102;&#20063;&#20250;&#36890;&#36807; optab_handler &#21435;&#30830;&#35748;&#30456;&#24212;&#30340; optab &#22312;&#24213;&#23618;&#26159;&#21542;&#25903;&#25345;.</span>
<span class="org-comment">         *</span><span class="org-comment-delimiter"> */</span>
        <span class="org-keyword">if</span> (match_pattern(p, name, optabs[pindex].pattern)) {
            p-&gt;name = name;
            p-&gt;op = optabs[pindex].op;
            p-&gt;sort_num = (p-&gt;op &lt;&lt; 16) | p-&gt;m1;
            <span class="org-comment-delimiter">/* </span><span class="org-comment">p-&gt;sort_num &#21363;&#26159; pats &#20013;&#21069;&#38754;&#30340;&#25968;:</span>
<span class="org-comment">             * { 0x010405, CODE_FOR_extendqihi2 },</span>
<span class="org-comment">             *</span><span class="org-comment-delimiter"> */</span>
            <span class="org-keyword">return</span> <span class="org-constant">true</span>;
        }
    }
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org000000e" class="outline-6">
<h6 id="org000000e"><span class="section-number-6">1.1.2.1.3.</span> match_pattern</h6>
<div class="outline-text-6" id="text-1-1-2-1-3">
<p>
optabs.def 中的 <code>add$P$a3</code> 是一个 pattern, genopinit 的 match_pattern 函数会根据这个 pattern 来决定 md 中的哪些 insn 对应这个 optab. pattern 中的 <code>$</code>, <code>P</code>, <code>I</code>,
<code>a</code> 等都有特定的含义
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">static</span> <span class="org-type">bool</span> <span class="org-function-name">match_pattern</span>(<span class="org-type">optab_pattern</span> *<span class="org-variable-name">p</span>, <span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">name</span>, <span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">pat</span>) {
    <span class="org-type">bool</span> <span class="org-variable-name">force_float</span> = <span class="org-constant">false</span>;
    <span class="org-type">bool</span> <span class="org-variable-name">force_int</span> = <span class="org-constant">false</span>;
    <span class="org-type">bool</span> <span class="org-variable-name">force_partial_int</span> = <span class="org-constant">false</span>;
    <span class="org-type">bool</span> <span class="org-variable-name">force_fixed</span> = <span class="org-constant">false</span>;

    <span class="org-keyword">if</span> (pat == <span class="org-constant">NULL</span>) <span class="org-keyword">return</span> <span class="org-constant">false</span>;
    <span class="org-keyword">for</span> (;; ++pat) {
        <span class="org-keyword">if</span> (*pat != <span class="org-string">'$'</span>) {
            <span class="org-keyword">if</span> (*pat != *name++) <span class="org-keyword">return</span> <span class="org-constant">false</span>;
            <span class="org-keyword">if</span> (*pat == <span class="org-string">'\0'</span>) <span class="org-keyword">return</span> <span class="org-constant">true</span>;
            <span class="org-keyword">continue</span>;
        }
        <span class="org-comment-delimiter">/* </span><span class="org-comment">IPFQ &#26159; optab.def &#20013;&#34920;&#31034;&#26684;&#24335;&#30340;&#29305;&#27530;&#23383;&#31526;</span>
<span class="org-comment">         * I &#34920;&#31034; int</span>
<span class="org-comment">         * F &#34920;&#31034; float</span>
<span class="org-comment">         * ...</span>
<span class="org-comment">         *</span><span class="org-comment-delimiter"> */</span>
        <span class="org-keyword">switch</span> (*++pat) {
            <span class="org-keyword">case</span> <span class="org-string">'I'</span>:
                force_int = 1;
                <span class="org-keyword">break</span>;
            <span class="org-keyword">case</span> <span class="org-string">'P'</span>:
                force_partial_int = 1;
                <span class="org-keyword">break</span>;
            <span class="org-keyword">case</span> <span class="org-string">'F'</span>:
                force_float = 1;
                <span class="org-keyword">break</span>;
            <span class="org-keyword">case</span> <span class="org-string">'Q'</span>:
                force_fixed = 1;
                <span class="org-keyword">break</span>;

            <span class="org-keyword">case</span> <span class="org-string">'a'</span>:
            <span class="org-keyword">case</span> <span class="org-string">'b'</span>: {
                <span class="org-type">int</span> <span class="org-variable-name">i</span>;
                <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: &#36941;&#21382; target &#25903;&#25345;&#30340;&#25152;&#26377;&#30340; machine_mode: sf, df, si, di,</span>
<span class="org-comment">                 * ...</span><span class="org-comment-delimiter"> */</span>
                <span class="org-keyword">for</span> (i = (MAX_MACHINE_MODE)-1; i &gt;= 0; i--) {
                    <span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">p</span>, *<span class="org-variable-name">q</span>;
                    <span class="org-keyword">for</span> (p = GET_MODE_NAME(i), q = name; *p; p++, q++)
                        <span class="org-keyword">if</span> (TOLOWER(*p) != *q) <span class="org-keyword">break</span>;
                    <span class="org-keyword">if</span> (*p == 0 &amp;&amp;
                        (<span class="org-negation-char">!</span>force_int || mode_class[i] == MODE_INT ||
                         mode_class[i] == MODE_VECTOR_INT) &amp;&amp;
                        (<span class="org-negation-char">!</span>force_float || mode_class[i] == MODE_FLOAT ||
                         mode_class[i] == MODE_DECIMAL_FLOAT ||
                         mode_class[i] == MODE_COMPLEX_FLOAT ||
                         mode_class[i] == MODE_VECTOR_FLOAT) &amp;&amp;
                        ) || (...);
                        <span class="org-keyword">break</span>;
                }

                <span class="org-keyword">if</span> (i &lt; 0) <span class="org-keyword">return</span> <span class="org-constant">false</span>;

                <span class="org-comment-delimiter">/* </span><span class="org-comment">&#20197; optab.def &#20013;&#30340; OPTAB_NX(add_optab, "add$F$a3") &#20026;&#20363;</span>
<span class="org-comment">                 * addsf3 &#20250; match &#21040; "add$F$a3" &#36825;&#20010; pat</span>
<span class="org-comment-delimiter">                 */</span>
                name += strlen(GET_MODE_NAME(i));
                p-&gt;m1 = i;                
            } <span class="org-keyword">break</span>;
        }
    }
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-ID-c1ff5b55-a6cd-41c5-aab9-248f52262030" class="outline-5">
<h5 id="ID-c1ff5b55-a6cd-41c5-aab9-248f52262030"><span class="section-number-5">1.1.2.2.</span> optab_libfunc</h5>
<div class="outline-text-5" id="text-1-1-2-2">
<p>
gcc 通过 optab_handler 查找 optab 对应的 insn_code, 当它找不到 `optab+machmode`
对应的 insn 时, 对于某些简单的 optab (例如 smax_optab), 会在代码中直接生成 rtl
来代替 (例如 cbranch), 例如:
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="org-constant">expand_binop</span>:
  <span class="org-keyword">case</span> MAX_EXPR:
  <span class="org-keyword">case</span> MIN_EXPR:
    <span class="org-function-name">expand_operands</span> (treeop0, treeop1,
             target, &amp;op0, &amp;op1, EXPAND_NORMAL);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">First try to do it with a special MIN or MAX instruction.</span>
<span class="org-comment">   If that does not win, use a conditional jump to select the proper</span>
<span class="org-comment">   value.</span><span class="org-comment-delimiter">  */</span>
    this_optab = optab_for_tree_code (code, type, optab_default);
    temp = expand_binop (mode, this_optab, op0, op1, target, unsignedp,
             OPTAB_WIDEN);
</pre>
</div>

<p>
对于复杂的功能, 会通过 optab_libfunc 生成对某个外部函数的调用, 例如 __divsf3. 这些函数是在 <a href="bare_metal.html#ID-27a07646-18c6-4504-b36e-a5d63871a0d2">libgcc</a> 中实现的.
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="org-type">rtx</span> <span class="org-function-name">optab_libfunc</span>(<span class="org-type">optab</span> <span class="org-variable-name">optab</span>, <span class="org-type">machine_mode</span> <span class="org-variable-name">mode</span>) {
    <span class="org-keyword">struct</span> <span class="org-type">libfunc_entry</span> <span class="org-variable-name">e</span>;
    <span class="org-keyword">struct</span> <span class="org-type">libfunc_entry</span> **<span class="org-variable-name">slot</span>;

    e.op = optab;
    e.mode1 = mode;
    e.mode2 = VOIDmode;
    slot = libfunc_hash-&gt;find_slot(&amp;e, NO_INSERT);
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>slot) {
        <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">optab_libcall_d</span> *<span class="org-variable-name">d</span> =
            &amp;normlib_def[optab - FIRST_NORM_OPTAB];

        <span class="org-keyword">if</span> (d-&gt;libcall_gen == <span class="org-constant">NULL</span>) <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;

        <span class="org-comment-delimiter">/* </span><span class="org-comment">d-&gt;libcall_gen &#20013;&#20449;&#24687;&#26469;&#33258; optabs.def, &#20363;&#22914;</span>
<span class="org-comment">         * OPTAB_NL(add_optab, "add$P$a3", PLUS, "add", '3', gen_int_fp_fixed_libfunc)</span>
<span class="org-comment">         * &#34920;&#31034; add_optab &#30340; libcall_basename &#20026; "add", libcall_gen &#20026; gen_int_fp_fixed_libfunc,</span>
<span class="org-comment">         * &#21518;&#32773;&#20250;&#26681;&#25454; libcall_basename(add) &#21644; mode (sf) &#29983;&#25104;&#19968;&#20010;&#21517;&#20026; __addsf3 &#30340; libfunc_entry</span>
<span class="org-comment">         * &#21518;&#36890;&#36807; set_optab_libfunc &#35774;&#32622;&#21040; libfunc_hash, &#21518;&#32493;&#23601;&#21487;&#20197;&#29983;&#25104;&#23545; __addsf3 &#30340;&#35843;&#29992;</span>
<span class="org-comment">         *</span><span class="org-comment-delimiter"> */</span>

        d-&gt;libcall_gen(optab, d-&gt;libcall_basename, d-&gt;libcall_suffix, mode);
        slot = libfunc_hash-&gt;find_slot(&amp;e, NO_INSERT);
        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>slot) <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
    }
    <span class="org-keyword">return</span> (*slot)-&gt;libfunc;
}
</pre>
</div>

<p>
实际上 soft-float 与 hard-float 的区别就是是通过 optab_libfunc 机制来体现的:
</p>

<pre class="example" id="org0000014">
(define_insn "div&lt;mode&gt;3"
  [(set (match_operand:ANYF           0 "register_operand" "=f")
    (div:ANYF (match_operand:ANYF 1 "register_operand" " f")
          (match_operand:ANYF 2 "register_operand" " f")))]
  "TARGET_HARD_FLOAT &amp;&amp; TARGET_FDIV"
  "fdiv.&lt;fmt&gt;\t%0,%1,%2"
  [(set_attr "type" "fdiv")
   (set_attr "mode" "&lt;UNITMODE&gt;")])
</pre>

<p>
当 TARGET_HARD_FLOAT 时, optab_handler 会找到这里会产生的 divsf3/divdf3 两条
insn. 否则就会通过 optab_libfunc 产生对 __divsf3/__divdf3 的调用
</p>
</div>
</div>


<div id="outline-container-org00000e0" class="outline-5 references">
<h5 id="org00000e0">Backlinks</h5>
<div class="outline-text-5" id="text-org00000e0">
<p>
<a href="llvm_backend.html#ID-e60ce82f-6f66-44e0-adb5-cef752145625">LLVM Backend</a>
(<i>LLVM Backend &gt; instruction selection &gt; SelectionDAGBuilder</i>):  其中 DAG 中 node 的类型例如 fadd 定义在 ISDOpcodes.h, 和 gcc <a href="#ID-cc581233-c9a4-47c9-b392-64e03af4b454">optab</a> 有些类似
</p>
</div>



<div id="outline-container-org0000018" class="outline-6 references">
<h6 id="org0000018">Backlinks</h6>
<div class="outline-text-6" id="text-org0000018">
<p>
<a href="llvm_backend.html#ID-e60ce82f-6f66-44e0-adb5-cef752145625">LLVM Backend</a>
(<i>LLVM Backend &gt; instruction selection &gt; SelectionDAGLegalize</i>):  如果 target 不支持 DAG 的某个 node, 需要在 legalize 时转换成和 target 支持的 node, 或者生成对 libcall 的调用 (类似于 gcc <a href="#ID-c1ff5b55-a6cd-41c5-aab9-248f52262030">optab_libfunc</a>), 这个过程是 target 相 关的.
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-ID-5304f835-9c6a-49bc-89a5-ca01e2520167" class="outline-4">
<h4 id="ID-5304f835-9c6a-49bc-89a5-ca01e2520167"><span class="section-number-4">1.1.3.</span> machine desc</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
<a href="https://www.cse.iitb.ac.in/grc/slides/cgotut-gcc/topic5-md-intro.pdf">https://www.cse.iitb.ac.in/grc/slides/cgotut-gcc/topic5-md-intro.pdf</a>
</p>

<p>
<a href="https://splichal.eu/scripts/sphinx/gccint/_build/html/machine-descriptions.html">https://splichal.eu/scripts/sphinx/gccint/_build/html/machine-descriptions.html</a>
</p>

<p>
optab 要找到 insn_code 和 rtl 需要 machine desc 文件.
</p>

<p>
写 machine desc(md) 文件是开发 backend 的第一步: 它指明了前端的操作 (例如 PLUS)
需要映射到 backend 的什么操作 (例如 fadd.s), 但它并不是直接由前端的 gimple 翻译成汇编, 而是先翻译成 rtl 代码再翻译成汇编.
</p>

<p>
md 有两个作用:
</p>

<ol class="org-ol">
<li><p>
生成 rtl
</p>

<p>
insn selection 阶段找到 gimple 对应的 rtl
</p></li>

<li><p>
匹配 rtl
</p>

<p>
code emission 阶段找到 rtl 对应的汇编
</p></li>
</ol>
</div>

<div id="outline-container-org000006e" class="outline-5">
<h5 id="org000006e"><span class="section-number-5">1.1.3.1.</span> md 语法</h5>
<div class="outline-text-5" id="text-1-1-3-1">
</div>
<div id="outline-container-org000002d" class="outline-6">
<h6 id="org000002d"><span class="section-number-6">1.1.3.1.1.</span> define_insn</h6>
<div class="outline-text-6" id="text-1-1-3-1-1">
<p>
md (例如 riscv.md) 是 backend 最核心的部分, 其中最重要的部分是 define_insn, 例如:
</p>

<pre class="example" id="org000001b">
(define_insn "add&lt;mode&gt;3"
  [
  ;; -----------------------------
  ;; rtl 模板
  ;; 这个模板会匹配 (set rd (plus rs1 rs2) 形式的 rtl expression
  ;; 其中 register_operand 是指参数需要是一个寄存器, 在
  ;; predicates.md 中有定义
  (set (match_operand:ANYF 0 "register_operand" "=f")
    (plus:ANYF (match_operand:ANYF 1 "register_operand" "f")
           (match_operand:ANYF 2 "register_operand" "f")))]

  ;; -----------------------------
  ;; 匹配该模板需要的额外条件, 这里要求支持 hard float
  "TARGET_HARD_FLOAT"

  ;; -----------------------------
  ;; 汇编模板
  ;; 表示 rtl 模板匹配后输出的汇编, 可以是一个汇编的 string,
  ;; 也可以是一段产生 string 的 C 代码  
  "fadd.&lt;fmt&gt;\t%0,%1,%2"

  ;; -----------------------------
  ;; 这些 attr 和 insn schedule 有关
  [(set_attr "type" "fadd")
   (set_attr "mode" "&lt;UNITMODE&gt;")])

</pre>

<p>
由于 ANYF 是一个包含 `sf`, `df` 的 mode_iterator, 所以上面的模板实际上会被展开成两个: addsf3, adddf3
</p>

<p>
define_insn 有两个用法:
</p>

<ol class="org-ol">
<li>从 gimple 生成 rtl 时会根据 insn code (例如 CODE_FOR_addsf3) 选择对应的 rtl
模板来生成 rtl. addsf3 这个名字是 gcc 提前定义好的标准名字, 表示一个标准的操作 (更多的标准操作:
<a href="https://gcc.gnu.org/onlinedocs/gccint/Standard-Names.html#Standard-Names">https://gcc.gnu.org/onlinedocs/gccint/Standard-Names.html#Standard-Names</a>)</li>

<li>经过各种 rtl pass 之后, 最后 code emission 会通过与 rtl 模板匹配确定对应的汇编</li>
</ol>

<p>
例如 test.c 中的 `float y = x + x` 会先通过 addsf3 转换为下面的 rtl 代码:
</p>

<pre class="example" id="org000001c">
(insn# 0 0 (set (reg:SF 48 f16)
        (plus:SF (reg:SF 48 f16)
            (reg:SF 49 f17))) test.c:5# {addsf3}
     (nil))
</pre>

<p>
假设这段代码没有被优化修改, 最终在 final 阶段会匹配前面的 `addsf3` 模板, 最终输出汇编 `fadd.s f16,f16,f17`
</p>
</div>
</div>

<div id="outline-container-org0000031" class="outline-6">
<h6 id="org0000031"><span class="section-number-6">1.1.3.1.2.</span> define_expand</h6>
<div class="outline-text-6" id="text-1-1-3-1-2">
<p>
与 define_insn 不同, 有些 insn 的功能是通过组合其它 insn 来完成的.
</p>

<pre class="example" id="org0000020">
(define_expand "addsi3"
       [(match_operand:SI 0 "register_operand" "")
        (match_operand:SI 1 "register_operand" "")
        (match_operand:SI 2 "register_operand" "")]
       ""
       "
     {
       handle_add (operands[0], operands[1], operands[2]);
       DONE;
     }")
</pre>

<p>
define_expand 的 templte 部分只需要声明 operand, 后面嵌入的 c 代码 (preparation
statement) 负责通过 rtx 的 api (例如 emit_insn, gen_xxx) 生成 rtx
</p>
</div>
</div>

<div id="outline-container-org0000034" class="outline-6">
<h6 id="org0000034"><span class="section-number-6">1.1.3.1.3.</span> define_split</h6>
</div>

<div id="outline-container-org0000037" class="outline-6">
<h6 id="org0000037"><span class="section-number-6">1.1.3.1.4.</span> define_mode_iterator</h6>
</div>

<div id="outline-container-org000003a" class="outline-6">
<h6 id="org000003a"><span class="section-number-6">1.1.3.1.5.</span> define_mode_attr</h6>
</div>

<div id="outline-container-org000003d" class="outline-6">
<h6 id="org000003d"><span class="section-number-6">1.1.3.1.6.</span> define_code_iterator</h6>
</div>

<div id="outline-container-org0000040" class="outline-6">
<h6 id="org0000040"><span class="section-number-6">1.1.3.1.7.</span> define_code_attr</h6>
</div>

<div id="outline-container-org0000043" class="outline-6">
<h6 id="org0000043"><span class="section-number-6">1.1.3.1.8.</span> define_c_enum</h6>
</div>

<div id="outline-container-org0000046" class="outline-6">
<h6 id="org0000046"><span class="section-number-6">1.1.3.1.9.</span> define_constants</h6>
</div>

<div id="outline-container-org0000049" class="outline-6">
<h6 id="org0000049"><span class="section-number-6">1.1.3.1.10.</span> define_attr</h6>
</div>

<div id="outline-container-org000004e" class="outline-6">
<h6 id="org000004e"><span class="section-number-6">1.1.3.1.11.</span> define_predicate</h6>
<div class="outline-text-6" id="text-1-1-3-1-11">
<p>
predicate 是指 match_operand/match_operator 时可以指定的条件, 例如
</p>

<pre class="example" id="org000003c">
(define_insn "adddi3"
  [(set (match_operand:DI 0 "register_operand" "=r,r")
    (plus:DI (match_operand:DI 1 "register_operand" " r,r")
         (match_operand:DI 2 "arith_operand"    " r,I")))]
  ...         
)
</pre>

<p>
arith_operand 就是通过 define_predicate 指定的 predicate:
</p>

<pre class="example" id="org000003e">
(define_predicate "arith_operand"
  (ior (match_operand 0 "const_arith_operand")
       (match_operand 0 "register_operand")))
</pre>

<p>
另外, register_operand 是 gcc 自带的 predicate, 定义在 recog.c 中, 除了
register_operand, gcc 还定义了:
</p>

<ol class="org-ol">
<li>address_operand</li>
<li>immediate_operand</li>
<li>scratch_operand</li>
<li>const_int_operand</li>
<li>const_double_operand</li>
<li>memory_operand</li>
<li>&#x2026;</li>
</ol>
</div>
</div>

<div id="outline-container-org0000051" class="outline-6">
<h6 id="org0000051"><span class="section-number-6">1.1.3.1.12.</span> <a href="gcc_peephole2.html#ID-ce833dca-50ab-44fc-bdc7-357c729cd4ab">define_peephole2</a></h6>
</div>

<div id="outline-container-org0000065" class="outline-6">
<h6 id="org0000065"><span class="section-number-6">1.1.3.1.13.</span> match</h6>
<div class="outline-text-6" id="text-1-1-3-1-13">
<p>
rtl 生成汇编时需要通过 recog 来找到 rtl 匹配的 insn_code, genrecog 通过扫描
match_xxx 生成各种 pattern 函数, 用来检测 rtl 是否 define_insn 匹配
</p>

<p>
<a href="https://splichal.eu/scripts/sphinx/gccint/_build/html/machine-descriptions/predicates.html">https://splichal.eu/scripts/sphinx/gccint/_build/html/machine-descriptions/predicates.html</a>
</p>
</div>

<ol class="org-ol">
<li><a id="org0000055"></a>match_operand<br />
<div class="outline-text-7" id="text-1-1-3-1-13-1">
<p>
match_operand 用来 match operand, 例如:
</p>

<pre class="example" id="org0000044">
(match_operand:SI      0           "register_operand"    "r")
----------------------------------------------------------------------
               &lt;mode&gt;  &lt;operand&gt;   &lt;predicate&gt;           &lt;constraints&gt;
</pre>

<p>
其中 constraints 是针对 predicate 的补充, 例如 r 表示寄存器, m 表示 memory, &#x2026;
</p>

<p>
<a href="https://splichal.eu/scripts/sphinx/gccint/_build/html/machine-descriptions/operand-constraints.html">https://splichal.eu/scripts/sphinx/gccint/_build/html/machine-descriptions/operand-constraints.html</a>
</p>
</div>
</li>

<li><a id="org0000058"></a>match_operator<br /></li>

<li><a id="org000005c"></a>match_scratch<br />
<div class="outline-text-7" id="text-1-1-3-1-13-3">
<p>
match_scratch 在生成 rtl 时可以用来分配一个 scratch 寄存器, 在匹配 rtl 时和
`(match_operand &#x2026; "register_operand")` 差不多.
</p>

<p>
match_scratch 的典型用法类似这样:
</p>

<pre class="example" id="org000004b">
(define_insn "swapsi3"
[
 (swap (match_operand:si 1 "register_operand")
   (match_operand:si 2 "register_operand"))
 (clobber (match_scratch:si 0 "=r")
]
""
mov %0, %1\nmov %1, %2\nmov %2, %0
""
)
</pre>

<p>
即通过 match_scratch 给 swap 分配一个临时寄存器
</p>
</div>
</li>

<li><a id="org000005f"></a>match_code<br /></li>

<li><a id="org0000062"></a>match_test<br /></li>
</ol>
</div>

<div id="outline-container-org0000068" class="outline-6">
<h6 id="org0000068"><span class="section-number-6">1.1.3.1.14.</span> <a href="gcc_scheduler.html#ID-d4860186-25a5-4f42-931d-335dff58a84d">define_insn_reservation</a></h6>
</div>

<div id="outline-container-org000006b" class="outline-6">
<h6 id="org000006b"><span class="section-number-6">1.1.3.1.15.</span> <a href="gcc_scheduler.html#ID-0326b3de-673f-403c-a927-d38c7eaf3b9c">define_bypass</a></h6>
</div>
</div>


<div id="outline-container-org0000061" class="outline-5 references">
<h5 id="org0000061">Backlinks</h5>
<div class="outline-text-5" id="text-org0000061">
<p>
<a href="llvm_tablegen.html#ID-5e67daa8-ff56-4a3c-ac3c-de840f1abe46">LLVM TableGen</a>
(<i>LLVM TableGen</i>):  target description 和 gcc <a href="#ID-5304f835-9c6a-49bc-89a5-ca01e2520167">machine description</a> 基本是类似, 它们都包含:
</p>
</div>
</div>
</div>


<div id="outline-container-ID-a354364f-e048-4d6f-b780-0271f16dfd6a" class="outline-4">
<h4 id="ID-a354364f-e048-4d6f-b780-0271f16dfd6a"><span class="section-number-4">1.1.4.</span> rtl</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
<a href="https://splichal.eu/scripts/sphinx/gccint/_build/html/rtl-representation.html">https://splichal.eu/scripts/sphinx/gccint/_build/html/rtl-representation.html</a>
</p>

<p>
rtl (Register Transfer Language) 相当于 gcc LIR, 主要涉及到寄存器分配, 汇编代码生成和底层优化.
</p>

<p>
例如下面的 rtl:
</p>

<pre class="example" id="org0000064">
(insn/f 40 39 41 (set (mem/c:DI (plus:DI (reg/f:DI 2 sp)
                    (const_int 24 [0x18])) [2  S8 A64])
            (reg/f:DI 8 s0)) "test.c":1:21)
</pre>

<p>
表示 `把 24(sp) 的值为 s0`
</p>
</div>

<div id="outline-container-org0000060" class="outline-5">
<h5 id="org0000060"><span class="section-number-5">1.1.4.1.</span> rtl.def</h5>
<div class="outline-text-5" id="text-1-1-4-1">
<p>
和 optab 一样, rtl 也定义了一些基本操作, rtl.def 相当于 rtl 语言的词汇表, 前面提到的 `set`, `const_int`, `reg` 等都定义在 rtl.def 中.
</p>

<p>
例如:
</p>

<pre class="example" id="org0000066">
DEF_RTL_EXPR(PLUS, "plus", "ee", RTX_COMM_ARITH)
</pre>

<p>
表示:
</p>

<ol class="org-ol">
<li>rtx_code 为 PLUS</li>
<li>name 为 "plus"</li>
<li>format 为 "ee", 表示两个 operand 都是 `expression`</li>
<li>class 为 RTX_COMM_ARITH</li>
</ol>

<p>
多个 rtx 可嵌套, 例如 `(set x (plus a b))`, 其中:
</p>

<ol class="org-ol">
<li>`set`, `plus` 是 rtx_code</li>

<li>`(plus&#x2026;)` 是 `(set &#x2026;)` 的 operand, operand 类型可以是 expression, int,
string 等, 通过 XEXP, XINT, XWINT 和 XSTR 宏可以访问, 例如XEXP(x, 2) 是获得 x
的 operand[2] (假设它是一个 expression)</li>
</ol>

<p>
可以使用两种方式来写 rtl:
</p>

<ol class="org-ol">
<li>直接在 md 中用纯文本来构造, 然后通过 genemit 生成 rtx, 例如 md 中
`define_insn` 的做法,</li>

<li>通过 gengenrtl 工具扫描 rtl.def 生成权举类型 (例如 PLUS) 和函数 (例如
gen_rtx_PLUS), 然后通过 c 代码来构造 rtx, 参考 md 中 `define_expand` 的做法</li>
</ol>
</div>
</div>


<div id="outline-container-org000006a" class="outline-5">
<h5 id="org000006a"><span class="section-number-5">1.1.4.2.</span> constant expression</h5>
<div class="outline-text-5" id="text-1-1-4-2">
<ul class="org-ul">
<li>const_int</li>

<li>const_string</li>

<li><p>
label_ref
</p>

<pre class="example" id="org0000069">
(define_insn "*branch&lt;mode&gt;"
  [(set (pc)
    (if_then_else
     (match_operator 1 "order_operator"
             [(match_operand:X 2 "register_operand" "r")
              (match_operand:X 3 "reg_or_0_operand" "rJ")])
     (label_ref (match_operand 0 "" ""))
     (pc)))]
  ""
  "b%C1\t%2,%z3,%0")
</pre></li>

<li>code_label</li>

<li>&#x2026;</li>
</ul>
</div>
</div>

<div id="outline-container-org0000067" class="outline-5">
<h5 id="org0000067"><span class="section-number-5">1.1.4.3.</span> register memory expression</h5>
<div class="outline-text-5" id="text-1-1-4-3">
<ul class="org-ul">
<li>reg</li>
<li>scratch</li>
<li>pc</li>
<li>mem</li>
<li>&#x2026;</li>
</ul>
</div>
</div>


<div id="outline-container-org0000070" class="outline-5">
<h5 id="org0000070"><span class="section-number-5">1.1.4.4.</span> arithmetic expression</h5>
<div class="outline-text-5" id="text-1-1-4-4">
<ul class="org-ul">
<li>plus/minus/mult/div/mod</li>
<li>compare</li>
<li>neg</li>
<li>not/and/or/xor/ior</li>
<li>ashift</li>
<li>ss_abs/sqrt</li>
<li>clz/ctz</li>
<li>eq/ne/gt/gtu/lt</li>
<li>if_then_else</li>
<li>cond</li>
<li>&#x2026;</li>
</ul>
</div>
</div>

<div id="outline-container-org0000074" class="outline-5">
<h5 id="org0000074"><span class="section-number-5">1.1.4.5.</span> conversion expression</h5>
<div class="outline-text-5" id="text-1-1-4-5">
<ul class="org-ul">
<li>sign_extend/zero_extend</li>
<li>float_extend</li>
<li><p>
float_truncate
</p>

<p>
把 df truncate 成 sf:
</p>

<pre class="example" id="org0000073">
(define_insn "truncdfsf2"
  [(set (match_operand:SF     0 "register_operand" "=f")
    (float_truncate:SF
        (match_operand:DF 1 "register_operand" " f")))]
  "TARGET_DOUBLE_FLOAT"
  "fcvt.s.d\t%0,%1")
</pre></li>

<li>truncate</li>
<li>float</li>
<li>&#x2026;</li>
</ul>
</div>
</div>

<div id="outline-container-org0000079" class="outline-5">
<h5 id="org0000079"><span class="section-number-5">1.1.4.6.</span> side effect expression</h5>
<div class="outline-text-5" id="text-1-1-4-6">
<ul class="org-ul">
<li>set</li>
<li>call</li>
<li><p>
clobber
</p>

<p>
clobber 是指 rtl 会隐式的修改这个寄存器, 例如:
</p>

<pre class="example" id="org0000077">
(define_insn "call_internal"
  [(call (mem:SI (match_operand 0 "call_insn_operand" "l,S,U"))
     (match_operand 1 "" ""))
   (clobber (reg:SI RETURN_ADDR_REGNUM))]
  ""
  "@
   jalr\t%0
   call\t%0
   call\t%0@plt"
)
</pre>

<p>
call 会隐式给 ra 赋值, 所以用 `(clobber (reg:SI ra))`.
</p>

<p>
clobber 与 CALL_USED_REGISTERS 的意义类似.
</p></li>

<li><p>
use
</p>

<p>
use 是指 rtl 会隐式的读取这个寄存器, 防止前面针对这个寄存器的写操作被优化掉,例如:
</p>

<pre class="example" id="org0000078">
(define_insn "simple_return_internal"
  [(simple_return)
   (use (match_operand 0 "pmode_register_operand" ""))]
  ""
  "jr\t%0"
)
</pre>

<p>
表示 simple_return_internal 的第一个 operand 需要被隐式使用.
</p></li>

<li><p>
parallel
</p>

<p>
parallel 比较像 lisp 的 prog?
</p></li>

<li>&#x2026;</li>
</ul>
</div>
</div>


<div id="outline-container-org000007c" class="outline-5 references">
<h5 id="org000007c">Backlinks</h5>
<div class="outline-text-5" id="text-org000007c">
<p>
<a href="llvm_backend.html#ID-e60ce82f-6f66-44e0-adb5-cef752145625">LLVM Backend</a>
(<i>LLVM Backend &gt; instruction selection &gt; DoInstructionSelection</i>):  把 SelectionDAG 看做 gcc <a href="#ID-a354364f-e048-4d6f-b780-0271f16dfd6a">rtl</a>, 则 isel 和 gcc 的 recog 过程非常类似. DoInstructionSelection 的作用是根据 target description (td) 中定义的 pattern 和 predicate 去匹配对应的target instruction
</p>
</div>
</div>
</div>


<div id="outline-container-org00000c8" class="outline-4">
<h4 id="org00000c8"><span class="section-number-4">1.1.5.</span> example</h4>
<div class="outline-text-4" id="text-1-1-5">
<div class="org-src-container">
<pre class="src src-C"><span class="org-type">float</span> <span class="org-function-name">foo</span>(<span class="org-type">float</span> <span class="org-variable-name">x</span>) {
    <span class="org-keyword">if</span> (x &gt; 0.0) {
        <span class="org-keyword">return</span> x + 1.0;
    }
    <span class="org-keyword">return</span> 0.0;
}
</pre>
</div>

<p>
rtl 的 `pass_expand` 用来把 gimple 转换为 rtl, 以 `两个浮点数相加` 为例:
</p>

<ol class="org-ol">
<li>add 对应的 gimple subcode (tree code) 为 PLUS_EXPR, 定义在 tree.def 中</li>

<li>通过 `optab_for_tree_code` 查找 optab, PLUS_EXPR 对应的 optab 为 add_optab,
定义在 optabs.def. PLUS_EXPR 与 add_optab 的对应关系是预设好的. 除了
`optab_for_tree_code`, 有时也会直接在代码中指定 tree code 与 optab 的映射关系</li>

<li>通过 `optab_handler` 查找 (add_optab, E_SFmode) 对应的 insn_code 为
CODE_FOR_addsf3, 定义在 md 中. add_optab 与 CODE_FOR_addsf3 的对应关系由
genopinit 根据 optabs.def 生成 (gen_insn@genopinit.c)</li>

<li>用 insn_code 做索引在 insn_data 中查找到 `gen_addsf3` 函数. insn_data 由
genoutput 扫描 md 生成. gen_addsf3 由 genemit 生成</li>

<li>gen_addsf3 函数会返回 addsf3 对应的 rtl</li>
</ol>
</div>

<div id="outline-container-org000009e" class="outline-5">
<h5 id="org000009e"><span class="section-number-5">1.1.5.1.</span> backtrace</h5>
<div class="outline-text-5" id="text-1-1-5-1">
<div class="org-src-container">
<pre class="src src-rust">#0  gen_addsf3 (operand0=0x7fffffffb250, operand1=0x7ffff7786bb8, 
    operand2=0xf8360d &lt;maybe_legitimize_operands(insn_code, unsigned int, unsigned int, expand_operand*)+46&gt;) at insn-emit.<span class="org-variable-name">c</span>:45
#1  0x0000000000ef17fa <span class="org-keyword">in</span> <span class="org-constant">insn_gen_fn</span>::operator()&lt;rtx_def*, rtx_def*, rtx_def*&gt; (this=0x1ecacb8 &lt;insn_data+56&gt;) at ../.././riscv-gcc/gcc/recog.<span class="org-variable-name">h</span>:407
#2  0x0000000000f83a1e <span class="org-keyword">in</span> maybe_gen_insn (icode=CODE_FOR_addsf3, nops=3, ops=0x7fffffffb250) at ../.././riscv-gcc/gcc/optabs.<span class="org-variable-name">c</span>:7787
#3  0x0000000000f6ef4a <span class="org-keyword">in</span> expand_binop_directly (icode=CODE_FOR_addsf3, mode=E_SFmode, binoptab=add_optab, op0=0x7ffff7786be8, op1=0x7ffff7786c18, 
    target=0x7ffff7786bb8, unsignedp=0, methods=OPTAB_LIB_WIDEN, last=0x7ffff7676540) at ../.././riscv-gcc/gcc/optabs.<span class="org-variable-name">c</span>:1409
#4  0x0000000000f6f417 <span class="org-keyword">in</span> expand_binop (mode=E_SFmode, binoptab=add_optab, op0=0x7ffff7786be8, op1=0x7ffff7786c18, target=0x7ffff7786bb8, unsignedp=0, 
    methods=OPTAB_LIB_WIDEN) at ../.././riscv-gcc/gcc/optabs.<span class="org-variable-name">c</span>:1496
#5  0x0000000000c9079a <span class="org-keyword">in</span> expand_expr_real_2 (ops=0x7fffffffbb80, target=0x7ffff7786bb8, tmode=E_SFmode, modifier=EXPAND_NORMAL)
    at ../.././riscv-gcc/gcc/expr.<span class="org-variable-name">c</span>:10007
#6  0x0000000000b197f4 <span class="org-keyword">in</span> expand_gimple_stmt_1 (stmt=0x7ffff7784000) at ../.././riscv-gcc/gcc/cfgexpand.<span class="org-variable-name">c</span>:3947
#7  0x0000000000b199f1 <span class="org-keyword">in</span> expand_gimple_stmt (stmt=0x7ffff7784000) at ../.././riscv-gcc/gcc/cfgexpand.<span class="org-variable-name">c</span>:4008
#8  0x0000000000b20b17 <span class="org-keyword">in</span> expand_gimple_basic_block (bb=0x7ffff7761138, disable_tail_calls=false) at ../.././riscv-gcc/gcc/cfgexpand.<span class="org-variable-name">c</span>:6045
#9  0x0000000000b223d3 <span class="org-keyword">in</span> (anonymous namespace)::<span class="org-constant">pass_expand</span>::execute (this=0x23401c0, fun=0x7ffff777e000) at ../.././riscv-gcc/gcc/cfgexpand.<span class="org-variable-name">c</span>:6729
#10 0x0000000000fdd7d1 <span class="org-keyword">in</span> execute_one_pass (pass=0x23401c0) at ../.././riscv-gcc/gcc/passes.<span class="org-variable-name">c</span>:2567
#11 0x0000000000fddb1e <span class="org-keyword">in</span> execute_pass_list_1 (pass=0x23401c0) at ../.././riscv-gcc/gcc/passes.<span class="org-variable-name">c</span>:2656
#12 0x0000000000fddbab <span class="org-keyword">in</span> execute_pass_list (fn=0x7ffff777e000, pass=0x233c270) at ../.././riscv-gcc/gcc/passes.<span class="org-variable-name">c</span>:2667
#13 0x0000000000b6f617 <span class="org-keyword">in</span> <span class="org-constant">cgraph_node</span>::expand (this=0x7ffff7780000) at ../.././riscv-gcc/gcc/cgraphunit.<span class="org-variable-name">c</span>:1830
#14 0x0000000000b6fd15 <span class="org-keyword">in</span> <span class="org-constant">cgraph_order_sort</span>::process (this=0x2333788) at ../.././riscv-gcc/gcc/cgraphunit.<span class="org-variable-name">c</span>:2069
#15 0x0000000000b6ffce <span class="org-keyword">in</span> output_in_order () at ../.././riscv-gcc/gcc/cgraphunit.<span class="org-variable-name">c</span>:2137
#16 0x0000000000b705a6 <span class="org-keyword">in</span> <span class="org-constant">symbol_table</span>::compile (this=0x7ffff7670000) at ../.././riscv-gcc/gcc/cgraphunit.<span class="org-variable-name">c</span>:2355
#17 0x0000000000b709d2 <span class="org-keyword">in</span> <span class="org-constant">symbol_table</span>::finalize_compilation_unit (this=0x7ffff7670000) at ../.././riscv-gcc/gcc/cgraphunit.<span class="org-variable-name">c</span>:2539
#18 0x000000000110d05f <span class="org-keyword">in</span> compile_file () at ../.././riscv-gcc/gcc/toplev.<span class="org-variable-name">c</span>:482
#19 0x00000000011100c6 <span class="org-keyword">in</span> do_compile () at ../.././riscv-gcc/gcc/toplev.<span class="org-variable-name">c</span>:2201
#20 0x00000000011103e8 <span class="org-keyword">in</span> <span class="org-constant">toplev</span>::main (this=0x7fffffffc176, argc=14, argv=0x7fffffffc288) at ../.././riscv-gcc/gcc/toplev.<span class="org-variable-name">c</span>:2340
#21 0x0000000001bf4bf5 <span class="org-keyword">in</span> main (argc=14, argv=0x7fffffffc288) at ../.././riscv-gcc/gcc/main.<span class="org-variable-name">c</span>:39
</pre>
</div>
</div>
</div>

<div id="outline-container-org0000083" class="outline-5">
<h5 id="org0000083"><span class="section-number-5">1.1.5.2.</span> gimple code</h5>
<div class="outline-text-5" id="text-1-1-5-2">
<pre class="example" id="org0000082">
float foo (float x)
{ 
  float D.1491;
  float _1;
  float _3;
  float _4;

  &lt;bb 2&gt; :
  if (x_2(D) &gt; 0.0)
    goto &lt;bb 3&gt;; [INV]
  else
    goto &lt;bb 4&gt;; [INV]

  &lt;bb 3&gt; :
  _4 = x_2(D) + 1.0e+0;
  // predicted unlikely by early return (on trees) predictor.
  goto &lt;bb 5&gt;; [INV]

  &lt;bb 4&gt; :
  _3 = 0.0;

  &lt;bb 5&gt; :
  # _1 = PHI &lt;_4(3), _3(4)&gt;
&lt;L2&gt;:
  return _1;


</pre>
</div>
</div>

<div id="outline-container-org000007e" class="outline-5">
<h5 id="org000007e"><span class="section-number-5">1.1.5.3.</span> cbranch_optab</h5>
<div class="outline-text-5" id="text-1-1-5-3">
<p>
bb2 的第一个 stmt `if (x_2(D) &gt; 0.0)` 的处理过程:
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="org-function-name">expand_gimple_basic_block</span>()
    <span class="org-keyword">if</span> (gimple_code (stmt) == GIMPLE_COND):
        new_bb = expand_gimple_cond (bb, as_a &lt;gcond *&gt; (stmt));

<span class="org-constant">expand_gimple_cond</span>:
   <span class="org-comment-delimiter">/* </span><span class="org-comment">tree code &#20026; GT_EXPR, &#23450;&#20041;&#22312; tree.def</span><span class="org-comment-delimiter"> */</span>
    code = gimple_cond_code (stmt);
    <span class="org-keyword">if</span> (true_edge-&gt;dest == bb-&gt;next_bb):
        jumpifnot_1 (code, op0, op1, label_rtx_for_bb (false_edge-&gt;dest), false_edge-&gt;probability);

<span class="org-constant">label_rtx_for_bb</span>:
    <span class="org-type">rtx_code_label</span> *<span class="org-variable-name">l</span> = gen_label_rtx ();
        <span class="org-comment-delimiter">/* </span><span class="org-comment">gen_rtx_CODE_LABEL &#29983;&#25104;&#19968;&#20010; `code_label` rtx</span><span class="org-comment-delimiter"> */</span>
        <span class="org-keyword">return</span> as_a &lt;rtx_code_label *&gt; (gen_rtx_CODE_LABEL (VOIDmode, NULL_RTX, NULL_RTX,<span class="org-constant">NULL</span>, label_num++, <span class="org-constant">NULL</span>));

<span class="org-constant">jumpifnot_1</span>:
    <span class="org-comment-delimiter">/* </span><span class="org-comment">code &#20026; GT</span><span class="org-comment-delimiter"> */</span>
    <span class="org-function-name">do_compare_rtx_and_jump</span> (op0, op1, code, unsignedp, mode,((mode == BLKmode) ? expr_size (treeop0) : NULL_RTX),
               if_false_label, if_true_label, prob);
        <span class="org-function-name">emit_cmp_and_jump_insns</span> (op0, op1, code, size, mode, unsignedp, if_true_label, prob);
            <span class="org-function-name">prepare_cmp_insn</span> (op0, op1, comparison, size, unsignedp, OPTAB_LIB_WIDEN, &amp;test, &amp;mode);
                <span class="org-comment-delimiter">/* </span><span class="org-comment">cbranchsf4 &#35201;&#27714; 3 &#20010;&#21442;&#25968;, operand0 &#26159;&#35201; test &#30340;&#26465;&#20214;, comparison &#26159; GT</span><span class="org-comment-delimiter"> */</span>
                test = gen_rtx_fmt_ee (comparison, VOIDmode, x, y);
                <span class="org-keyword">enum</span> <span class="org-type">insn_code</span> <span class="org-variable-name">icode</span>;
                <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: &#26144;&#23556;&#21040; cbranch_optab, &#21518;&#32773;&#21448;&#26144;&#23556;&#20026; CODE_FOR_cbranchsf4</span><span class="org-comment-delimiter"> */</span>
                icode = optab_handler (cbranch_optab, cmp_mode);
                <span class="org-type">rtx</span> <span class="org-variable-name">op0</span> = prepare_operand (icode, x, 1, mode, cmp_mode, unsignedp);
                <span class="org-type">rtx</span> <span class="org-variable-name">op1</span> = prepare_operand (icode, y, 2, mode, cmp_mode, unsignedp);
                <span class="org-function-name">XEXP</span> (test, 0) = op0;
                <span class="org-function-name">XEXP</span> (test, 1) = op1;
                <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: test &#26159;&#35201;&#36820;&#22238;&#30340; rtx</span><span class="org-comment-delimiter">  */</span>
                *ptest = test;
        <span class="org-type">emit_cmp_and_jump_insn_1</span>
            <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: GEN_FCN(icode) &#21363; gen_cbranchsf4</span><span class="org-comment-delimiter"> */</span>
            <span class="org-variable-name">insn</span> = emit_jump_insn (GEN_FCN (icode) (test, XEXP (test, 0), XEXP (test, 1), label));        
</pre>
</div>
</div>
</div>

<div id="outline-container-org0000081" class="outline-5">
<h5 id="org0000081"><span class="section-number-5">1.1.5.4.</span> add_optab</h5>
<div class="outline-text-5" id="text-1-1-5-4">
<p>
bb3 的第一个 stmt `_4 = x_2(D) + 1.0e+0` 的处理过程:
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="org-constant">expand_gimple_basic_block</span>:
    <span class="org-function-name">expand_gimple_stmt</span>(stmt);
       <span class="org-comment-delimiter">/* </span><span class="org-comment">stmt-&gt;code &#20026; GIMPLE_ASSIGN, stmt-&gt;subcode (tree code) &#20026; PLUS_EXPR</span><span class="org-comment-delimiter"> */</span>
       <span class="org-comment-delimiter">/* </span><span class="org-comment">target &#26159;&#38656;&#35201;&#34987; assign &#30340; rtx (&#20363;&#22914; reg)</span><span class="org-comment-delimiter"> */</span>
       temp = expand_expr_real_2 (&amp;ops, target, GET_MODE (target), EXPAND_NORMAL);
           <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: code &#20026; PLUS_EXPR, &#36820;&#22238;&#30340; this_optab &#20026; add_optab</span><span class="org-comment-delimiter"> */</span>
           this_optab = optab_for_tree_code (code, type, optab_default);
           <span class="org-comment-delimiter">/* </span><span class="org-comment">mode &#20026; E_SFmode</span><span class="org-comment-delimiter"> */</span>
           temp = expand_binop (mode, this_optab, op0, op1, target, unsignedp, OPTAB_LIB_WIDEN);
               <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: icode &#20026; CODE_FOR_addsf3</span><span class="org-comment-delimiter"> */</span>
               icode = optab_handler (binoptab, mode);
               create_output_operand (&amp;ops[0], target, tmp_mode);
               create_input_operand (&amp;ops[1], xop0, mode0);
               create_input_operand (&amp;ops[2], xop1, mode1);
               pat = maybe_gen_insn (icode, 3, ops);
                   <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: &#29983;&#25104; rtx</span><span class="org-comment-delimiter"> */</span>
                   <span class="org-function-name">gen_addsf3</span>(); 
</pre>
</div>
</div>
</div>

<div id="outline-container-org0000084" class="outline-5">
<h5 id="org0000084"><span class="section-number-5">1.1.5.5.</span> mov_optab</h5>
<div class="outline-text-5" id="text-1-1-5-5">
<p>
bb4 的第一个 stmt `_3 = 0.0` 的处理过程:
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="org-constant">expand_gimple_stmt</span>:
    <span class="org-comment-delimiter">/* </span><span class="org-comment">stmt-&gt;code &#20026; GIMPLE_ASSIGN, stmt-&gt;subcode &#20026; REAL_CST (real constant)</span><span class="org-comment-delimiter"> */</span>
    <span class="org-function-name">expand_assignment</span> (lhs, rhs, ...)
      result = store_expr (from, to_rtx, 0, nontemporal, <span class="org-constant">false</span>);
          <span class="org-function-name">emit_move_insn</span> (target, temp);
              <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: mov_optab &#23545;&#24212; CODE_FOR_movsf</span><span class="org-comment-delimiter"> */</span>
              code = optab_handler (mov_optab, mode);
              <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: gen_movesf</span><span class="org-comment-delimiter"> */</span>
              <span class="org-function-name">emit_insn</span> (<span class="org-type">GEN_FCN</span> (<span class="org-function-name">code</span>) (x, y));
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org00000aa" class="outline-3">
<h3 id="org00000aa"><span class="section-number-3">1.2.</span> rtl optimization</h3>
<div class="outline-text-3" id="text-1-2">
<p>
<a href="https://gcc.gnu.org/onlinedocs/gccint/RTL-passes.html">https://gcc.gnu.org/onlinedocs/gccint/RTL-passes.html</a>
</p>

<ul class="org-ul">
<li><a href="gcc_pass.html#ID-69585bb2-1dff-4676-adbc-aa90f70e030d">pass_combine</a></li>

<li><a href="gcc_peephole2.html#ID-5f849222-e2fa-426b-ad5d-bce729e0605e">pass_peephole2</a></li>

<li>pass_cse</li>

<li>pass_fast_rtl_dce</li>
</ul>
</div>
</div>

<div id="outline-container-org00000ac" class="outline-3">
<h3 id="org00000ac"><span class="section-number-3">1.3.</span> insn schedule</h3>
<div class="outline-text-3" id="text-1-3">
<p>
<a href="gcc_scheduler.html#ID-aa30d0cc-966e-407b-9ad3-a0b0fbad7c49">pass_sched</a>
</p>
</div>
</div>

<div id="outline-container-org00000af" class="outline-3">
<h3 id="org00000af"><span class="section-number-3">1.4.</span> register allocation</h3>
<div class="outline-text-3" id="text-1-4">
<p>
<a href="gcc_pass.html#ID-48b544df-f83e-41b6-8cba-fc2e23d188a9">pass_ira</a> 和 pass_reload
</p>
</div>
</div>

<div id="outline-container-org00000b2" class="outline-3">
<h3 id="org00000b2"><span class="section-number-3">1.5.</span> code emission</h3>
<div class="outline-text-3" id="text-1-5">
<p>
rtl 最终由 <a href="gcc_pass.html#ID-813e2003-85c7-4b59-b221-541240951e12">pass_final</a> 生成 assembly
</p>

<ol class="org-ol">
<li>通过 recog 函数查找 rtl 对应的 insn_code. recog 由 genrecog 扫描 md 生成. 整个 recog 相当于一个根据 md 生成的巨大的 switch-case</li>

<li>通过 `get_insn_template` 从 insn_data 以 insn_code 为索引查找汇编模板</li>
</ol>
</div>

<div id="outline-container-org000009f" class="outline-4">
<h4 id="org000009f"><span class="section-number-4">1.5.1.</span> backtrace</h4>
<div class="outline-text-4" id="text-1-5-1">
<div class="org-src-container">
<pre class="src src-rust">#0  get_insn_template (code=0, insn=0x7fffffffbc00) at ../.././riscv-gcc/gcc/final.<span class="org-variable-name">c</span>:2063
#1  0x0000000000ca46cb <span class="org-keyword">in</span> final_scan_insn_1 (insn=0x7ffff7676880, file=0x2352480, optimize_p=0, nopeepholes=0, seen=0x7fffffffbdbc)
    at ../.././riscv-gcc/gcc/final.<span class="org-variable-name">c</span>:3062
#2  0x0000000000ca4b06 <span class="org-keyword">in</span> final_scan_insn (insn=0x7ffff7676880, file=0x2352480, optimize_p=0, nopeepholes=0, seen=0x7fffffffbdbc)
    at ../.././riscv-gcc/gcc/final.<span class="org-variable-name">c</span>:3175
#3  0x0000000000ca2a44 <span class="org-keyword">in</span> final_1 (first=0x7ffff77870a8, file=0x2352480, seen=0, optimize_p=0) at ../.././riscv-gcc/gcc/final.<span class="org-variable-name">c</span>:2022
#4  0x0000000000ca76c5 <span class="org-keyword">in</span> rest_of_handle_final () at ../.././riscv-gcc/gcc/final.<span class="org-variable-name">c</span>:4680
#5  0x0000000000ca792f <span class="org-keyword">in</span> (anonymous namespace)::<span class="org-constant">pass_final</span>::execute (this=0x2342260) at ../.././riscv-gcc/gcc/final.<span class="org-variable-name">c</span>:4758
#6  0x0000000000fdd7d1 <span class="org-keyword">in</span> execute_one_pass (pass=0x2342260) at ../.././riscv-gcc/gcc/passes.<span class="org-variable-name">c</span>:2567
#7  0x0000000000fddb1e <span class="org-keyword">in</span> execute_pass_list_1 (pass=0x2342260) at ../.././riscv-gcc/gcc/passes.<span class="org-variable-name">c</span>:2656
#8  0x0000000000fddb4f <span class="org-keyword">in</span> execute_pass_list_1 (pass=0x2341d80) at ../.././riscv-gcc/gcc/passes.<span class="org-variable-name">c</span>:2657
#9  0x0000000000fddb4f <span class="org-keyword">in</span> execute_pass_list_1 (pass=0x2340220) at ../.././riscv-gcc/gcc/passes.<span class="org-variable-name">c</span>:2657
#10 0x0000000000fddbab <span class="org-keyword">in</span> execute_pass_list (fn=0x7ffff777e000, pass=0x233c270) at ../.././riscv-gcc/gcc/passes.<span class="org-variable-name">c</span>:2667
#11 0x0000000000b6f617 <span class="org-keyword">in</span> <span class="org-constant">cgraph_node</span>::expand (this=0x7ffff7780000) at ../.././riscv-gcc/gcc/cgraphunit.<span class="org-variable-name">c</span>:1830
#12 0x0000000000b6fd15 <span class="org-keyword">in</span> <span class="org-constant">cgraph_order_sort</span>::process (this=0x2333788) at ../.././riscv-gcc/gcc/cgraphunit.<span class="org-variable-name">c</span>:2069
#13 0x0000000000b6ffce <span class="org-keyword">in</span> output_in_order () at ../.././riscv-gcc/gcc/cgraphunit.<span class="org-variable-name">c</span>:2137
#14 0x0000000000b705a6 <span class="org-keyword">in</span> <span class="org-constant">symbol_table</span>::compile (this=0x7ffff7670000) at ../.././riscv-gcc/gcc/cgraphunit.<span class="org-variable-name">c</span>:2355
#15 0x0000000000b709d2 <span class="org-keyword">in</span> <span class="org-constant">symbol_table</span>::finalize_compilation_unit (this=0x7ffff7670000) at ../.././riscv-gcc/gcc/cgraphunit.<span class="org-variable-name">c</span>:2539
#16 0x000000000110d05f <span class="org-keyword">in</span> compile_file () at ../.././riscv-gcc/gcc/toplev.<span class="org-variable-name">c</span>:482
#17 0x00000000011100c6 <span class="org-keyword">in</span> do_compile () at ../.././riscv-gcc/gcc/toplev.<span class="org-variable-name">c</span>:2201
#18 0x00000000011103e8 <span class="org-keyword">in</span> <span class="org-constant">toplev</span>::main (this=0x7fffffffc176, argc=14, argv=0x7fffffffc288) at ../.././riscv-gcc/gcc/toplev.<span class="org-variable-name">c</span>:2340
#19 0x0000000001bf4bf5 <span class="org-keyword">in</span> main (argc=14, argv=0x7fffffffc288) at ../.././riscv-gcc/gcc/main.<span class="org-variable-name">c</span>:39
</pre>
</div>
</div>
</div>

<div id="outline-container-org000008a" class="outline-4">
<h4 id="org000008a"><span class="section-number-4">1.5.2.</span> final_scan_insn_1</h4>
<div class="outline-text-4" id="text-1-5-2">
<div class="org-src-container">
<pre class="src src-C"><span class="org-constant">final_scan_insn_1</span>:
    <span class="org-comment-delimiter">/* </span><span class="org-comment">insn code &#22312; rtl.def &#20013;&#23450;&#20041;</span><span class="org-comment-delimiter"> */</span>
    <span class="org-keyword">switch</span> (GET_CODE (insn)):
        <span class="org-keyword">case</span> CODE_LABEL:
            <span class="org-comment-delimiter">/* </span><span class="org-comment">internal_label &#25351;&#21521; default_internal_label, &#20135;&#29983; .L6: &#24418;&#24335;&#30340; label</span><span class="org-comment-delimiter"> */</span>
            targetm.asm_out.internal_label (file, <span class="org-string">"L"</span>, CODE_LABEL_NUMBER (insn));
                <span class="org-type">char</span> *<span class="org-keyword">const</span> <span class="org-variable-name">buf</span> = (<span class="org-type">char</span> *) alloca (40 + strlen (prefix));
                <span class="org-function-name">ASM_GENERATE_INTERNAL_LABEL</span> (buf, prefix, labelno);
                <span class="org-function-name">ASM_OUTPUT_INTERNAL_LABEL</span> (stream, buf);

        <span class="org-keyword">default</span>:
            insn_code_number = recog_memoized (insn);
            templ = get_insn_template (insn_code_number, insn);
            <span class="org-function-name">output_asm_insn</span> (templ, recog_data.operand);
</pre>
</div>
</div>
</div>

<div id="outline-container-org00000a8" class="outline-4">
<h4 id="org00000a8"><span class="section-number-4">1.5.3.</span> recog_memoized</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
recog_memoized 的作用是根据 rtl 查找它对应的 insn_code, 查找的依据是 md 中声明的
predicate.
</p>

<p>
最简单的 recog 实现可以这样:
</p>

<p>
针对一条 rtl, 与 md 中所有 insn 的 rtl 模板比较, 看哪一条 insn 匹配.
</p>

<p>
但实际实现上 recog 采用的是类似于字典树 (<a href="https://en.wikipedia.org/wiki/Trie">trie</a>) 的方式:
</p>

<p>
genrecog 工具会扫描 md 中所有的 insn, 根据 insn 声明的 predicate 构造一棵树, 例如:
</p>

<ul class="org-ul">
<li>A 指令的 predicate 为 x, y, z</li>
<li>B 指令的 predicate 为 x, y, k</li>
</ul>

<p>
则 genrecog 会生成一棵这样的树:
</p>

<pre class="example" id="org00000a4">
x---&gt;y---&gt;z
     |
     +---&gt;k
</pre>

<p>
genrecog 生成的 recog 函数会在这棵树上遍历来匹配 insn
</p>
</div>

<div id="outline-container-org000008f" class="outline-5">
<h5 id="org000008f"><span class="section-number-5">1.5.3.1.</span> movdi_64bit</h5>
<div class="outline-text-5" id="text-1-5-3-1">
<p>
以 movdi_64bit 为例, 要匹配的 insn 为:
</p>

<pre class="example" id="org00000a5">
(insn/f 40 39 41
        (set (mem/c:DI (plus:DI (reg/f:DI 2 sp) (const_int 24 [0x18])) [2  S8 A64])
        (reg/f:DI 8 s0)) "test.c":1:21 
)
</pre>

<p>
recog 的过程为:
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">static</span> <span class="org-keyword">inline</span> <span class="org-type">int</span> <span class="org-function-name">recog_memoized</span>(<span class="org-type">rtx_insn</span> *<span class="org-variable-name">insn</span>) {
    <span class="org-keyword">if</span> (INSN_CODE(insn) &lt; 0) INSN_CODE(insn) = recog(PATTERN(insn), insn, 0);
    <span class="org-keyword">return</span> INSN_CODE(insn);
}

<span class="org-comment-delimiter">/* </span><span class="org-comment">x1 &#20026; PATTERN(insn):</span>
<span class="org-comment"> * </span>
<span class="org-comment"> * (set (mem/c:DI (plus:DI (reg/f:DI 2 sp)</span>
<span class="org-comment"> *             (const_int 24 [0x18])) [2  S8 A64])</span>
<span class="org-comment"> *     (reg/f:DI 8 s0))</span>
<span class="org-comment"> *     </span>
<span class="org-comment-delimiter"> */</span>
<span class="org-function-name">recog</span>(x1, insn):
    <span class="org-keyword">switch</span> (GET_CODE (x1)):
        <span class="org-comment-delimiter">/* </span><span class="org-comment">x1-&gt;code=SET</span><span class="org-comment-delimiter"> */</span>
        <span class="org-keyword">case</span> SET:
            <span class="org-keyword">return</span> recog_19 (x1, insn, pnum_clobbers);

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">recog_19</span>(
    rtx <span class="org-type">x1</span> <span class="org-variable-name">ATTRIBUTE_UNUSED</span>, <span class="org-type">rtx_insn</span> *<span class="org-variable-name">insn</span> ATTRIBUTE_UNUSED,
    <span class="org-type">int</span> *<span class="org-variable-name">pnum_clobbers</span> ATTRIBUTE_UNUSED) {
    rtx *<span class="org-keyword">const</span> operands ATTRIBUTE_UNUSED = &amp;recog_data.operand[0];
    <span class="org-type">rtx</span> <span class="org-variable-name">x2</span>, <span class="org-variable-name">x3</span>, <span class="org-variable-name">x4</span>, <span class="org-variable-name">x5</span>, <span class="org-variable-name">x6</span>, <span class="org-variable-name">x7</span>;
    <span class="org-type">int</span> <span class="org-variable-name">res</span> ATTRIBUTE_UNUSED;
    x2 = XEXP(x1, 1);
    <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: x2 &#20026; (reg/f:DI 8 s0)</span><span class="org-comment-delimiter"> */</span>
    <span class="org-keyword">switch</span> (GET_CODE(x2)) {
        <span class="org-keyword">case</span> REG:
        <span class="org-keyword">case</span> SUBREG:
        <span class="org-keyword">case</span> MEM:
        <span class="org-keyword">case</span> LABEL_REF:
        <span class="org-keyword">case</span> SYMBOL_REF:
        <span class="org-keyword">case</span> HIGH:
            <span class="org-keyword">return</span> recog_7(x1, insn, pnum_clobbers);

    }


<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">recog_7</span> (<span class="org-type">rtx</span> <span class="org-type">x1</span> <span class="org-variable-name">ATTRIBUTE_UNUSED</span>, <span class="org-type">rtx_insn</span> *<span class="org-variable-name">insn</span> ATTRIBUTE_UNUSED, <span class="org-type">int</span> *<span class="org-variable-name">pnum_clobbers</span> ATTRIBUTE_UNUSED):
    <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: x2 &#20026;</span>
<span class="org-comment">     *  (mem/c:DI (plus:DI (reg/f:DI 2 sp)</span>
<span class="org-comment">     *   (const_int 24 [0x18])) [2  S8 A64])</span>
<span class="org-comment">     *</span><span class="org-comment-delimiter"> */</span>
    x2 = XEXP (x1, 0);
    <span class="org-keyword">switch</span> (GET_CODE (x2)) {
        <span class="org-keyword">case</span> MEM:
            res = recog_2 (x1, insn, pnum_clobbers);
    }

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">recog_2</span> (<span class="org-type">rtx</span> <span class="org-type">x1</span> <span class="org-variable-name">ATTRIBUTE_UNUSED</span>, <span class="org-type">rtx_insn</span> *<span class="org-variable-name">insn</span> ATTRIBUTE_UNUSED, <span class="org-type">int</span> *<span class="org-variable-name">pnum_clobbers</span> ATTRIBUTE_UNUSED):
    x2 = XEXP (x1, 0);
    operands[0] = x2;
    x3 = XEXP (x1, 1);
    operands[1] = x3;
    <span class="org-keyword">switch</span> (GET_MODE (operands[0])):
        <span class="org-keyword">case</span> E_DImode:
            <span class="org-keyword">if</span> ((TARGET_64BIT
                   &amp;&amp; (register_operand (operands[0], DImode)
                      || reg_or_0_operand (operands[1], DImode))))
                <span class="org-keyword">return</span> 135; <span class="org-comment-delimiter">/* </span><span class="org-comment">*movdi_64bit</span><span class="org-comment-delimiter"> */</span>
            <span class="org-keyword">break</span>;

</pre>
</div>

<p>
最终匹配的 insn_code 为 135, 对应 riscv.md 中的:
</p>

<pre class="example" id="org00000a6">
(define_insn "*movdi_64bit"
  [(set (match_operand:DI 0 "nonimmediate_operand" "=r,r,r, m,  *f,*f,*r,*f,*m")
    (match_operand:DI 1 "move_operand"         " r,T,m,rJ,*r*J,*m,*f,*f,*f"))]
  "TARGET_64BIT
   &amp;&amp; (register_operand (operands[0], DImode)
       || reg_or_0_operand (operands[1], DImode))"
  { return riscv_output_move (operands[0], operands[1]); }
  [(set_attr "move_type" "move,const,load,store,mtc,fpload,mfc,fmove,fpstore")
   (set_attr "mode" "DI")])
</pre>
</div>
</div>

<div id="outline-container-org00000ab" class="outline-5">
<h5 id="org00000ab"><span class="section-number-5">1.5.3.2.</span> addsf3 vs. adddi3</h5>
<div class="outline-text-5" id="text-1-5-3-2">
<p>
recog 可以看做是一棵决策树, 以 addsf3 和addi3 为例:
</p>

<pre class="example" id="org00000ab">
(define_insn "addsf3"
  [(set (match_operand:SF            0 "register_operand" "=f")
    (plus:SF (match_operand:SF 1 "register_operand" " f")
           (match_operand:SF 2 "register_operand" " f")))]
  "TARGET_HARD_FLOAT"
  "fadd.s\t%0,%1,%2"
)

(define_insn "addsi3"
  [(set (match_operand:SI          0 "register_operand" "=r,r")
    (plus:SI (match_operand:SI 1 "register_operand" " r,r")
         (match_operand:SI 2 "arith_operand"    " r,I")))]
  ""
  { return TARGET_64BIT ? "add%i2w\t%0,%1,%2" : "add%i2\t%0,%1,%2"; }
)
</pre>

<p>
recog 针对 addsf3 的决策树是: set-&gt;plus-&gt;GET_MODE(operand[0])==SF
recog 针对 adddi3 的决策树是: set-&gt;plus-&gt;GET_MODE(operand[0])==DI
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="org-type">int</span> <span class="org-function-name">recog</span>(
    rtx <span class="org-type">x1</span> <span class="org-variable-name">ATTRIBUTE_UNUSED</span>, <span class="org-type">rtx_insn</span> *<span class="org-variable-name">insn</span> ATTRIBUTE_UNUSED,
    <span class="org-type">int</span> *<span class="org-variable-name">pnum_clobbers</span> ATTRIBUTE_UNUSED) {
    <span class="org-keyword">switch</span> (GET_CODE(x1)):
        <span class="org-keyword">case</span> SET:
            <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: set</span><span class="org-comment-delimiter"> */</span>
            <span class="org-keyword">return</span> recog_19(x1, insn, pnum_clobbers);

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">recog_19</span>(
    rtx <span class="org-type">x1</span> <span class="org-variable-name">ATTRIBUTE_UNUSED</span>, <span class="org-type">rtx_insn</span> *<span class="org-variable-name">insn</span> ATTRIBUTE_UNUSED,
    <span class="org-type">int</span> *<span class="org-variable-name">pnum_clobbers</span> ATTRIBUTE_UNUSED) {
    x2 = XEXP(x1, 1);
    <span class="org-keyword">switch</span> (GET_CODE(x2)) {
        <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: plus</span><span class="org-comment-delimiter"> */</span>
        <span class="org-keyword">case</span> PLUS:
            x3 = XEXP(x1, 0);
            operands[0] = x3;

            <span class="org-comment-delimiter">/* </span><span class="org-comment">&#34429;&#28982; addsf3 &#36890;&#36807; match_oprand &#32473; plus &#30340; src &#21644; target &#37117;&#25351;&#23450;&#20102;</span>
<span class="org-comment">             * mode, &#20294;&#36825;&#37324;&#21482;&#20351;&#29992;&#20102; target &#30340; mode, &#21518;&#32493;&#20250;&#36890;&#36807;</span>
<span class="org-comment">             * pattern0/pattern10 &#31561;&#26816;&#26597;&#25152;&#26377;&#30340; mode &#37117;&#21305;&#37197;, &#36825;&#37324;&#30340; switch mode &#30456;&#24403;&#20110;&#19968;&#20010;</span><span class="org-comment-delimiter"> */</span>
            <span class="org-keyword">switch</span> (GET_MODE(operands[0])) {
                <span class="org-keyword">case</span> E_SFmode:
                    <span class="org-keyword">if</span> (pattern0(x2, E_SFmode) != 0 || <span class="org-negation-char">!</span>(TARGET_HARD_FLOAT))
                        <span class="org-keyword">return</span> -1;
                    <span class="org-keyword">return</span> 1; <span class="org-comment-delimiter">/* </span><span class="org-comment">addsf3</span><span class="org-comment-delimiter"> */</span>

                <span class="org-keyword">case</span> E_DImode:
                    <span class="org-keyword">if</span> (pattern10(x2, E_DImode) != 0 || <span class="org-negation-char">!</span>(TARGET_64BIT))
                        <span class="org-keyword">return</span> -1;
                    <span class="org-keyword">return</span> 4; <span class="org-comment-delimiter">/* </span><span class="org-comment">adddi3</span><span class="org-comment-delimiter"> */</span>

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">pattern0</span> (<span class="org-type">rtx</span> <span class="org-variable-name">x1</span>, <span class="org-type">machine_mode</span> <span class="org-variable-name">i1</span>) {
  rtx * <span class="org-keyword">const</span> operands ATTRIBUTE_UNUSED = &amp;recog_data.operand[0];
  <span class="org-type">int</span> <span class="org-variable-name">res</span> ATTRIBUTE_UNUSED;
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>register_operand (operands[0], i1)
      || GET_MODE (x1) != i1
      || <span class="org-negation-char">!</span>register_operand (operands[1], i1)
      || <span class="org-negation-char">!</span>register_operand (operands[2], i1))
    <span class="org-keyword">return</span> -1;
  <span class="org-keyword">return</span> 0;
}

</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org00000b1" class="outline-4">
<h4 id="org00000b1"><span class="section-number-4">1.5.4.</span> get_insn_template</h4>
<div class="outline-text-4" id="text-1-5-4">
<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-function-name">get_insn_template</span>(<span class="org-type">int</span> <span class="org-variable-name">code</span>, <span class="org-type">rtx_insn</span> *<span class="org-variable-name">insn</span>) {
    <span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">ret</span>;
    <span class="org-keyword">switch</span> (insn_data[code].output_format) {
        <span class="org-keyword">case</span> INSN_OUTPUT_FORMAT_SINGLE:
            ret = insn_data[code].output.single;
            <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> INSN_OUTPUT_FORMAT_MULTI:
            ret = insn_data[code].output.multi[which_alternative];
            <span class="org-keyword">break</span>;
        <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: 135 &#23545;&#24212;&#30340; insn_data &#30340; output_format &#20026; INSN_OUTPUT_FORMAT_FUNCTION, &#22240;&#20026; md &#25991;&#20214;&#20013;&#25351;&#23450;&#20102;</span>
<span class="org-comment">         *   { return riscv_output_move (operands[0], operands[1]); }</span>
<span class="org-comment">         *</span><span class="org-comment-delimiter"> */</span>
        <span class="org-keyword">case</span> INSN_OUTPUT_FORMAT_FUNCTION:
            gcc_assert(insn);
            <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: &#36825;&#37324;&#30340; output.function &#23601;&#26159;  riscv_output_move</span><span class="org-comment-delimiter"> */</span>
            ret = (*insn_data[code].output.function)(recog_data.operand, insn);
            <span class="org-keyword">break</span>;
    }
    <span class="org-keyword">return</span> ret;
}

<span class="org-constant">riscv_output_move</span>:
    <span class="org-comment-delimiter">/* </span><span class="org-comment">dest_code &#20026; MEM</span><span class="org-comment-delimiter"> */</span>
    dest_code = GET_CODE (dest);
    <span class="org-comment-delimiter">/* </span><span class="org-comment">src_code &#20026; REG</span><span class="org-comment-delimiter"> */</span>
    src_code = GET_CODE (src);
    <span class="org-keyword">if</span> ((src_code == REG &amp;&amp; GP_REG_P (REGNO (src))) || (src == CONST0_RTX (mode))):
        <span class="org-keyword">if</span> (dest_code == MEM):
            <span class="org-keyword">switch</span> (GET_MODE_SIZE (mode))
            {
                <span class="org-keyword">case</span> 1: <span class="org-keyword">return</span> <span class="org-string">"sb\t%z1,%0"</span>;
                <span class="org-keyword">case</span> 2: <span class="org-keyword">return</span> <span class="org-string">"sh\t%z1,%0"</span>;
                <span class="org-keyword">case</span> 4: <span class="org-keyword">return</span> <span class="org-string">"sw\t%z1,%0"</span>;
                <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: &#26368;&#21518; match &#30340;&#26159;&#36825;&#19968;&#21477;:</span><span class="org-comment-delimiter"> */</span>
                <span class="org-keyword">case</span> 8: <span class="org-keyword">return</span> <span class="org-string">"sd\t%z1,%0"</span>;
            }
</pre>
</div>
</div>
</div>

<div id="outline-container-org00000b0" class="outline-4">
<h4 id="org00000b0"><span class="section-number-4">1.5.5.</span> output_asm_insn</h4>
<div class="outline-text-4" id="text-1-5-5">
<div class="org-src-container">
<pre class="src src-C"><span class="org-type">void</span> <span class="org-function-name">output_asm_insn</span> (<span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">templ</span>, <span class="org-type">rtx</span> *<span class="org-variable-name">operands</span>):
    <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: templ &#20026; sd\t%z1,%0</span><span class="org-comment-delimiter"> */</span>
    <span class="org-comment-delimiter">/* </span><span class="org-comment">output_asm_insn &#20250;&#36941;&#21382;&#24182;&#25171;&#21360;&#20986; templ, &#30896;&#21040; % &#20250;&#29305;&#27530;&#22788;&#29702;, </span>
<span class="org-comment">     * % &#21518;&#38754;&#30340;&#29305;&#27530;&#23383;&#31526;&#20363;&#22914; z &#20915;&#23450;&#20102; operand &#20363;&#22914; 1 &#22914;&#20309;&#22788;&#29702;</span>
<span class="org-comment">     * gcc &#26412;&#36523;&#25903;&#25345;&#30340;&#29305;&#27530;&#23383;&#31526;&#21253;&#25324;:</span>
<span class="org-comment">     * a : address</span>
<span class="org-comment">     * c : const address</span>
<span class="org-comment">     * l : label</span>
<span class="org-comment">     * n : int</span>
<span class="org-comment">     * &#38500;&#27492;&#20197;&#22806;, target &#21487;&#20197;&#23454;&#29616;&#33258;&#24049;&#30340; TARGET_PRINT_OPERAND &#26469;&#23450;&#20041;</span>
<span class="org-comment">     * &#33258;&#24049;&#30340;&#29305;&#27530;&#23383;&#31526;, &#20363;&#22914;&#36825;&#37324;&#30340; c &#23601;&#26159; riscv &#33258;&#24049;&#23450;&#20041;&#30340;&#23383;&#31526;</span>
<span class="org-comment">     * %0 &#36825;&#31181;&#27809;&#26377;&#25351;&#23450;&#29305;&#27530;&#23383;&#31526;&#30340; operand &#20250;&#20351;&#29992;&#40664;&#35748;&#30340;&#26041;&#24335;&#22788;&#29702;</span>
<span class="org-comment">     *</span><span class="org-comment-delimiter"> */</span>

     <span class="org-comment-delimiter">/* </span><span class="org-comment">%z1 &#36890;&#36807; riscv_print_operand &#26469;&#22788;&#29702;, &#36820;&#22238; s0</span><span class="org-comment-delimiter"> */</span>
     <span class="org-comment-delimiter">/* </span><span class="org-comment">%0 &#36890;&#36807; output_operand &#22788;&#29702;</span><span class="org-comment-delimiter">*/</span> 
     output_operand (operands[opnum], letter);
         <span class="org-comment-delimiter">/* </span><span class="org-comment">x &#26159; (mem (plus ...)) &#36825;&#20010; rtx, code &#20026; 0, &#22240;&#20026;&#27809;&#26377; format letter</span><span class="org-comment-delimiter">*/</span>
         targetm.asm_out.print_operand (asm_out_file, x, code);

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">riscv_print_operand</span> (<span class="org-type">FILE</span> *<span class="org-variable-name">file</span>, <span class="org-type">rtx</span> <span class="org-variable-name">op</span>, <span class="org-type">int</span> <span class="org-variable-name">letter</span>):
    machine_mode mode = GET_MODE (op);
    <span class="org-keyword">enum</span> <span class="org-type">rtx_code</span> <span class="org-variable-name">code</span> = GET_CODE (op);

    <span class="org-keyword">switch</span> (letter):
        <span class="org-comment-delimiter">/*</span>
<span class="org-comment">         * ...</span>
<span class="org-comment-delimiter">         */</span>
        <span class="org-keyword">default</span>:

        <span class="org-keyword">switch</span> (code):
          <span class="org-keyword">case</span> MEM:
            <span class="org-comment-delimiter">/* </span><span class="org-comment">XEXP(op,0) &#20026;</span>
<span class="org-comment">             * (plus:DI (reg/f:DI 2 sp)</span>
<span class="org-comment">             *   (const_int 24 [0x18]))</span>
<span class="org-comment">             *</span><span class="org-comment-delimiter"> */</span>
            output_address (mode, XEXP (op, 0));
          <span class="org-keyword">break</span>;

<span class="org-type">void</span> <span class="org-function-name">output_address</span> (<span class="org-type">machine_mode</span> <span class="org-variable-name">mode</span>, <span class="org-type">rtx</span> <span class="org-variable-name">x</span>) {
  <span class="org-type">bool</span> <span class="org-variable-name">changed</span> = <span class="org-constant">false</span>;
  walk_alter_subreg (&amp;x, &amp;changed);
  <span class="org-comment-delimiter">/* </span><span class="org-comment">TARGET_PRINT_OPERAND_ADDRESS</span><span class="org-comment-delimiter"> */</span>
  targetm.asm_out.print_operand_address (asm_out_file, mode, x);
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">riscv_print_operand_address</span> (<span class="org-type">FILE</span> *<span class="org-variable-name">file</span>, <span class="org-type">machine_mode</span> <span class="org-variable-name">mode</span>, <span class="org-type">rtx</span> <span class="org-variable-name">x</span>):
    <span class="org-keyword">struct</span> riscv_address_info addr;        
    <span class="org-keyword">if</span> (riscv_classify_address (&amp;addr, x, word_mode, <span class="org-constant">true</span>))
        <span class="org-keyword">switch</span> (addr.type) {
            <span class="org-keyword">case</span> ADDRESS_REG:
                <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: &#36825;&#37324;&#20250;&#36755;&#20986; 24</span><span class="org-comment-delimiter"> */</span>
                riscv_print_operand (file, addr.offset, 0);
                <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: &#36825;&#37324;&#20250;&#25509;&#30528;&#36755;&#20986; (sp), &#25152;&#20197; (mem ...) &#26368;&#32456;&#25171;&#21360;&#20986; `24(sp)`</span><span class="org-comment-delimiter"> */</span>
                fprintf (file, <span class="org-string">"(%s)"</span>, reg_names[REGNO (addr.reg)]);
                <span class="org-keyword">return</span>;


</pre>
</div>

<p>
所以下面的 rtl:
</p>

<pre class="example" id="org00000b4">
(insn/f 40 39 41 (set (mem/c:DI (plus:DI (reg/f:DI 2 sp)
                (const_int 24 [0x18])) [2  S8 A64])
        (reg/f:DI 8 s0)) "test.c":1:21)
</pre>

<p>
对应的汇编为:
</p>

<div class="org-src-container">
<pre class="src src-asm"><span class="org-function-name">sd</span>  <span class="org-keyword">s0</span>,24(sp)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org00000d0" class="outline-3">
<h3 id="org00000d0"><span class="section-number-3">1.6.</span> misc</h3>
<div class="outline-text-3" id="text-1-6">
</div>
<div id="outline-container-org00000b5" class="outline-4">
<h4 id="org00000b5"><span class="section-number-4">1.6.1.</span> <a href="gcc_target_hook.html#ID-ecd308f9-413b-467a-8d55-10bd7485a2bc">target hook</a></h4>
<div class="outline-text-4" id="text-1-6-1">
<p>
理想情况下 backend 相关代码会依赖 md 文件获得需要的信息, 但实际情况是有些信息无法放在 md 中, 这些信息会放在 target hook 和 target macro 中.
</p>

<p>
另外, 虽然理论上编译器的前中后端应该是独立的, 但实际上有时前中端也需要 target
hook 和 target macro 提供的信息才能工作, 例如:
</p>

<ul class="org-ul">
<li>后端是否支持某种指令 (例如 pass_loop_prefetch 优化依赖 TARGET_HAVE_PREFETCH 这个 target macro 决定是否进行 <a href="gcc_prefetch.html#ID-f4a56dc8-fd25-4150-bb48-c7a247cb933b">prefetch</a>)</li>

<li>后端是否支持某个 optab (例如 pass_cse_sincos 优化会依赖
TARGET_OPTAB_SUPPORTED_P 把 pow(x,0.5) 优化成 sqrt(x))</li>
</ul>
</div>
</div>

<div id="outline-container-org00000b8" class="outline-4">
<h4 id="org00000b8"><span class="section-number-4">1.6.2.</span> <a href="gcc_builtin.html#ID-b9dd7f04-f7f7-4a70-8f00-9e446df3339e">intrinsic</a></h4>
<div class="outline-text-4" id="text-1-6-2">
<p>
通过 intrinsic 可以扩展 gcc 以支持 backend 自定义指令. 例如, 假设 backend 包含许多 dsp 指令 (例如 <a href="../riscv/riscv_vector_extension.html#ID-a05733ad-d9ce-4fc4-b76c-9f15770c0c4b">RISC-V P Extension</a>), 那么支持它有两种方式:
</p>

<ol class="org-ol">
<li>使用 pass_combine 和 pass_peephole2 等让 gcc 自动生成 dsp 指令</li>

<li>定义 intrinsic 让用户直接调用这些指令</li>
</ol>

<p>
参考 P Extension 的提交:
</p>

<p>
<a href="https://github.com/riscv-collab/riscv-gcc/pull/258">https://github.com/riscv-collab/riscv-gcc/pull/258</a>
</p>
</div>
</div>

<div id="outline-container-org00000d7" class="outline-4">
<h4 id="org00000d7"><span class="section-number-4">1.6.3.</span> mcpu/mtune/march</h4>
<div class="outline-text-4" id="text-1-6-3">
</div>
<div id="outline-container-org00000bb" class="outline-5">
<h5 id="org00000bb"><span class="section-number-5">1.6.3.1.</span> mcpu</h5>
<div class="outline-text-5" id="text-1-6-3-1">
<p>
`-mcpu` 参数是 mtune 和 march 的结合体, 例如
</p>

<div class="org-src-container">
<pre class="src src-C">RISCV_CORE(<span class="org-string">"sifive-e31"</span>,      <span class="org-string">"rv32imac"</span>,   <span class="org-string">"sifive-3-series"</span>)
</pre>
</div>

<p>
表示 `-mcpu=sifive-e31` 等价于 `-march=rv32imac -mtune=sifive-3-series`
</p>
</div>
</div>

<div id="outline-container-org00000be" class="outline-5">
<h5 id="org00000be"><span class="section-number-5">1.6.3.2.</span> <a href="gcc_cost.html#ID-2c365cee-bb91-4b01-a9b2-e2aff0c3e475">mtune</a></h5>
</div>

<div id="outline-container-org00000cf" class="outline-5">
<h5 id="org00000cf"><span class="section-number-5">1.6.3.3.</span> march vs. mabi</h5>
<div class="outline-text-5" id="text-1-6-3-3">
<p>
<a href="https://www.sifive.com/blog/all-aboard-part-1-compiler-args">https://www.sifive.com/blog/all-aboard-part-1-compiler-args</a>
</p>

<ul class="org-ul">
<li>riscv 的 march 可以指定 rv{32,64}{i,f,d,m,a,g,v,c}, 用来指定产生什么样的硬件指令, 例如 `gcc -march=rv32ifd`</li>

<li>riscv 的 mabi 是指在与 march 不冲突的基础上, 函数调用时使用什么样的指令/寄存器.
riscv mabi 包括:

<ol class="org-ol">
<li><p>
ilp32{"",f,d}
</p>

<p>
ilp32 指 int, long, pointer 是 32 bit, f 指支持 hard single float, d 指支持
hard double float
</p></li>

<li>lp64{"",f,d}</li>
</ol></li>
</ul>
</div>

<div id="outline-container-org00000c9" class="outline-6">
<h6 id="org00000c9"><span class="section-number-6">1.6.3.3.1.</span> example</h6>
<div class="outline-text-6" id="text-1-6-3-3-1">
<pre class="example" id="org00000c7">
$&gt; cat test.c

extern float hello(float x);

float foo(float x) {
    return x + hello(x);
}

$&gt; /opt/riscv/bin/riscv64-unknown-linux-gnu-gcc test.c -c -O0 -march=rv64i -mabi=lp64 -S -o-

foo:
        addi    sp,sp,-32
        sd      ra,24(sp)
        sd      s0,16(sp)
        addi    s0,sp,32
        sw      a0,-20(s0)
        lw      a0,-20(s0)
        # hello 的参数和返回值通过 gpr (a0)
        call    hello
        mv      a5,a0
        lw      a1,-20(s0)
        mv      a0,a5
        # 使用软浮点
        call    __addsf3 
        mv      a5,a0
        mv      a0,a5
        ld      ra,24(sp)
        ld      s0,16(sp)
        addi    sp,sp,32
        jr      ra

$&gt; /opt/riscv/bin/riscv64-unknown-linux-gnu-gcc test.c -c -O0 -march=rv64if -mabi=lp64 -S -o-

foo:
        addi    sp,sp,-32
        sd      ra,24(sp)
        sd      s0,16(sp)
        addi    s0,sp,32
        sw      a0,-20(s0)
        lw      a0,-20(s0)
        # hello 的参数还是用的 gpr
        call    hello
        mv      a4,a0
        lw      a5,-20(s0)
        # 使用 hard float
        fadd.s  a5,a4,a5
        fmv.w.x fa5,a5
        fmv.x.w a0,fa5
        ld      ra,24(sp)
        ld      s0,16(sp)
        addi    sp,sp,32
        jr      ra

$&gt; /opt/riscv/bin/riscv64-unknown-linux-gnu-gcc test.c -c -O0 -march=rv64if -mabi=lp64f -S -o-

foo:
        addi    sp,sp,-32
        sd      ra,24(sp)
        sd      s0,16(sp)
        addi    s0,sp,32
        fsw     fa0,-20(s0)
        flw     fa0,-20(s0)
        # heloo 的参数和返回值使用 fpr (fa0)
        call    hello
        fmv.x.w a4,fa0
        lw      a5,-20(s0)
        # 使用 hard float
        fadd.s  a5,a4,a5
        fmv.w.x fa5,a5
        fmv.s   fa0,fa5
        ld      ra,24(sp)
        ld      s0,16(sp)
        addi    sp,sp,32
        jr      ra

$&gt; /opt/riscv/bin/riscv64-unknown-linux-gnu-gcc test.c -c -O0 -march=rv64i -mabi=lp64f -S -o-
cc1: error: requested ABI requires '-march' to subsume the 'F' extension

$&gt; /opt/riscv/bin/riscv64-unknown-linux-gnu-gcc test.c -c -O0 -march=rv32i -mabi=lp64 -S -o-
cc1: error: ABI requires '-march=rv64'
</pre>
</div>
</div>

<div id="outline-container-org00000d1" class="outline-6">
<h6 id="org00000d1"><span class="section-number-6">1.6.3.3.2.</span> impls</h6>
<div class="outline-text-6" id="text-1-6-3-3-2">
</div>
<ol class="org-ol">
<li><a id="ID-f7666ebb-599a-4b96-b629-7868f9487023"></a>march<br />
<div class="outline-text-7" id="text-1-6-3-3-2-1">
<p>
解析 march 的函数主要是 riscv_parse_arch_string, 通过一些宏可以访问解析的结果:
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">riscv_ext_flag_table_t</span> <span class="org-variable-name">riscv_ext_flag_table</span>[] = {
    {<span class="org-string">"e"</span>, &amp;gcc_options::x_target_flags, MASK_RVE},
    {<span class="org-string">"m"</span>, &amp;gcc_options::x_target_flags, MASK_MUL},
    {<span class="org-string">"a"</span>, &amp;gcc_options::x_target_flags, MASK_ATOMIC},
    {<span class="org-string">"f"</span>, &amp;gcc_options::x_target_flags, MASK_HARD_FLOAT},
    {<span class="org-string">"d"</span>, &amp;gcc_options::x_target_flags, MASK_DOUBLE_FLOAT},
    {<span class="org-string">"c"</span>, &amp;gcc_options::x_target_flags, MASK_RVC},

    {<span class="org-string">"zicsr"</span>, &amp;gcc_options::x_riscv_zi_subext, MASK_ZICSR},
    {<span class="org-string">"zifencei"</span>, &amp;gcc_options::x_riscv_zi_subext, MASK_ZIFENCEI},

    {<span class="org-constant">NULL</span>, <span class="org-constant">NULL</span>, 0}};

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * target_flags &#20026; global_options.x_target_flags</span>
<span class="org-comment-delimiter"> */</span>
<span class="org-preprocessor">#define</span> <span class="org-variable-name">TARGET_64BIT</span> ((target_flags &amp; MASK_64BIT) != 0)
<span class="org-preprocessor">#define</span> <span class="org-variable-name">TARGET_ATOMIC</span> ((target_flags &amp; MASK_ATOMIC) != 0)
<span class="org-preprocessor">#define</span> <span class="org-variable-name">TARGET_DOUBLE_FLOAT</span> ((target_flags &amp; MASK_DOUBLE_FLOAT) != 0)
<span class="org-preprocessor">#define</span> <span class="org-variable-name">TARGET_HARD_FLOAT</span> ((target_flags &amp; MASK_HARD_FLOAT) != 0)
<span class="org-preprocessor">#define</span> <span class="org-variable-name">TARGET_MUL</span> ((target_flags &amp; MASK_MUL) != 0)
<span class="org-preprocessor">#define</span> <span class="org-variable-name">TARGET_RVC</span> ((target_flags &amp; MASK_RVC) != 0)
<span class="org-preprocessor">#define</span> <span class="org-variable-name">TARGET_RVE</span> ((target_flags &amp; MASK_RVE) != 0)

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#24212;&#29992; march &#35774;&#32622;&#30340;&#20027;&#35201;&#36884;&#24452;&#26159; md &#20013;&#20250;&#22823;&#37327;&#20351;&#29992;&#36825;&#20123;&#23439;&#20570;&#20026; match &#30340; predicate</span><span class="org-comment-delimiter"> */</span>

(define_insn <span class="org-string">"mul&lt;mode&gt;3"</span>
  [(set (match_operand:ANYF               0 <span class="org-string">"register_operand"</span> <span class="org-string">"=f"</span>)
    (mult:ANYF (match_operand:ANYF    1 <span class="org-string">"register_operand"</span> <span class="org-string">" f"</span>)
              (match_operand:ANYF 2 <span class="org-string">"register_operand"</span> <span class="org-string">" f"</span>)))]
  <span class="org-string">"TARGET_HARD_FLOAT"</span>
  <span class="org-string">"fmul.&lt;fmt&gt;\t%0,%1,%2"</span>
 )

(define_insn <span class="org-string">"mulsi3"</span>
  [(set (match_operand:SI          0 <span class="org-string">"register_operand"</span> <span class="org-string">"=r"</span>)
    (mult:SI (match_operand:SI 1 <span class="org-string">"register_operand"</span> <span class="org-string">" r"</span>)
         (match_operand:SI 2 <span class="org-string">"register_operand"</span> <span class="org-string">" r"</span>)))]
  <span class="org-string">"TARGET_MUL"</span>
  { <span class="org-keyword">return</span> TARGET_64BIT ? <span class="org-string">"mulw\t%0,%1,%2"</span> : <span class="org-string">"mul\t%0,%1,%2"</span>; }
 )

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#20854;&#20013;&#22312;&#20195;&#30721;&#20013;&#20063;&#20250;&#26377;&#19968;&#20123;&#38024;&#23545; TARGET_XXX &#30340;&#35774;&#32622;, &#20363;&#22914; soft-float &#26102;&#26080;&#27861;&#20351;&#29992; fpr</span><span class="org-comment-delimiter"> */</span>
<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">riscv_conditional_register_usage</span> (<span class="org-type">void</span>) {
    <span class="org-comment-delimiter">/* </span><span class="org-comment">...</span><span class="org-comment-delimiter"> */</span>
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>TARGET_HARD_FLOAT) {
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">regno</span> = FP_REG_FIRST; regno &lt;= FP_REG_LAST; regno++)
            fixed_regs[regno] = call_used_regs[regno] = 1;
    }
    <span class="org-comment-delimiter">/* </span><span class="org-comment">...</span><span class="org-comment-delimiter"> */</span>
}
</pre>
</div>
</div>


<ul class="org-ul">
<li><a id="org00000cb"></a>Backlinks<br />
<div class="outline-text-8" id="text-org00000cb">
<p>
<a href="gcc_target_hook.html#ID-348daca9-594f-412e-ade1-cb27386a7bcc">TARGET_CPU_CPP_BUILTINS</a>
(<i>GCC Target Hook &gt; runtime target 相关 &gt; TARGET_CPU_CPP_BUILTINS</i>):  gcc 通过 <a href="#ID-f7666ebb-599a-4b96-b629-7868f9487023">march</a> 定义了 TARGET_MUL 等 macro, 但它们是给 gcc 使用的. 应用代码如果要 得到 TARGET_MUL 类似的功能, 需要使用 TARGET_CPU_CPP_BUILTINS 通过 builtin_define 定义的 __riscv_mul
</p>
</div>
</li>
</ul>
</li>


<li><a id="org00000ce"></a>mabi<br />
<div class="outline-text-7" id="text-1-6-3-3-2-2">
<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">cl_enum_arg</span> <span class="org-variable-name">cl_enum_abi_type_data</span>[] = {
    {<span class="org-string">"ilp32"</span>, ABI_ILP32, 0},   {<span class="org-string">"ilp32d"</span>, ABI_ILP32D, 0},
    {<span class="org-string">"ilp32e"</span>, ABI_ILP32E, 0}, {<span class="org-string">"ilp32f"</span>, ABI_ILP32F, 0},
    {<span class="org-string">"lp64"</span>, ABI_LP64, 0},     {<span class="org-string">"lp64d"</span>, ABI_LP64D, 0},
    {<span class="org-string">"lp64f"</span>, ABI_LP64F, 0},   {<span class="org-constant">NULL</span>, 0, 0}};

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#36890;&#36807;&#36825;&#20010; define &#38480;&#21046; ILP32/LP64 &#26080;&#27861;&#20351;&#29992; fpr &#20256;&#36882;&#21442;&#25968;</span><span class="org-comment-delimiter"> */</span>
<span class="org-preprocessor">#define</span> <span class="org-variable-name">UNITS_PER_FP_ARG</span>                                                \
  ((riscv_abi == ABI_ILP32 || riscv_abi == ABI_ILP32E                   \
    || riscv_abi == ABI_LP64)                                           \
   ? 0                                                                  \
   : ((riscv_abi == ABI_ILP32F || riscv_abi == ABI_LP64F) ? 4 : 8))

</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>



<div id="outline-container-org00000e1" class="outline-2 references">
<h2 id="org00000e1">Backlinks</h2>
<div class="outline-text-2" id="text-org00000e1">
<p>
<a href="gcc.html#ID-19df5597-4fd4-47a1-9534-f6e0c327e8d5">GCC</a>
(<i>GCC &gt; Backend</i>):   <a href="gcc_backend.html#ID-02e7f924-9cf7-4e3d-8ceb-1765fd3a2bed">Backend</a>
</p>

<p>
<a href="gcc_target_hook.html#ID-ecd308f9-413b-467a-8d55-10bd7485a2bc">GCC Target Hook</a>
(<i>GCC Target Hook</i>):  <a href="gcc_backend.html#ID-02e7f924-9cf7-4e3d-8ceb-1765fd3a2bed">GCC Backend</a> 的 example 里看到的
</p>

<p>
<a href="retargeting_gcc_to_riscv.html#ID-303d0f7f-03c2-4f31-ad7e-064162e3af10">Retargeting GCC To RISC-V</a>
(<i>Retargeting GCC To RISC-V &gt; gcc &gt; gcc backend</i>):   <a href="gcc_backend.html#ID-02e7f924-9cf7-4e3d-8ceb-1765fd3a2bed">gcc backend</a>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">

<p class="author">Author: sunway@dogdog.run<br />
Date: 2022-03-24 Thu 12:17<br />
Last updated: 2023-01-09 Mon 20:04</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
</div>
</body>
</html>
