<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>LLVM Toy RISC-V Backend</title>


<link rel="stylesheet" type="text/css" href="/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="./htmlize.css"/>
<link rel="stylesheet" type="text/css" href="../htmlize.css"/>
<link rel="stylesheet" type="text/css" href="../../htmlize.css"/>
<link rel="stylesheet" type="text/css" href="/readtheorg.css"/>
<link rel="stylesheet" type="text/css" href="./readtheorg.css"/>
<link rel="stylesheet" type="text/css" href="../readtheorg.css"/>
<link rel="stylesheet" type="text/css" href="../../readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
<link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
<link rel="stylesheet" type="text/css" href="../main.css" media="screen" />
<link rel="stylesheet" type="text/css" href="../../main.css" media="screen" />
<link rel="stylesheet" type="text/css" href="./main.css" media="screen" />
<link rel = "icon" href = "/icon.png"  type = "image/x-icon">
</head>
<body>
<div id="content" class="content">
<h1 class="title">LLVM Toy RISC-V Backend</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org00000fa">1. LLVM Toy RISC-V Backend</a>
<ul>
<li><a href="#org000000c">1.1. toy-1: llc 识别 target</a>
<ul>
<li><a href="#org0000001">1.1.1. 目标</a></li>
<li><a href="#org0000005">1.1.2. 需要的修改</a></li>
<li><a href="#org0000009">1.1.3. 测试</a></li>
</ul>
</li>
<li><a href="#org0000013">1.2. toy-2: LLVMInitializeToyTarget</a>
<ul>
<li><a href="#org0000010">1.2.1. 测试</a></li>
</ul>
</li>
<li><a href="#org000001b">1.3. toy-3: LLVMInitializeToyTargetMC</a>
<ul>
<li><a href="#org0000018">1.3.1. 测试</a></li>
</ul>
</li>
<li><a href="#org0000022">1.4. toy-4: ToyDAGToDAGISel</a>
<ul>
<li><a href="#org000001f">1.4.1. 测试</a></li>
</ul>
</li>
<li><a href="#org000002a">1.5. toy-5: ToyInstPrinter</a>
<ul>
<li><a href="#org0000027">1.5.1. 测试</a></li>
</ul>
</li>
<li><a href="#org0000031">1.6. toy-6: ToyAsmPrinter</a>
<ul>
<li><a href="#org000002e">1.6.1. 测试</a></li>
</ul>
</li>
<li><a href="#org0000038">1.7. toy-7: ToyTargetObjectFile</a>
<ul>
<li><a href="#org0000035">1.7.1. 测试</a></li>
</ul>
</li>
<li><a href="#org000003f">1.8. toy-8: ToySubtarget</a>
<ul>
<li><a href="#org000003c">1.8.1. 测试</a></li>
</ul>
</li>
<li><a href="#org0000046">1.9. toy-9: ToyTargetLowering</a>
<ul>
<li><a href="#org0000043">1.9.1. 测试</a></li>
</ul>
</li>
<li><a href="#org000004d">1.10. toy-10: ToyFrameLowering</a>
<ul>
<li><a href="#org000004a">1.10.1. 测试</a></li>
</ul>
</li>
<li><a href="#org0000055">1.11. toy-11: isel</a>
<ul>
<li><a href="#org0000052">1.11.1. 测试</a></li>
</ul>
</li>
<li><a href="#org000005c">1.12. toy-12: ToyRegisterInfo</a>
<ul>
<li><a href="#org0000059">1.12.1. 测试</a></li>
</ul>
</li>
<li><a href="#org0000063">1.13. toy-13: storeRegToStackSlot</a>
<ul>
<li><a href="#org0000060">1.13.1. 测试</a></li>
</ul>
</li>
<li><a href="#org000006a">1.14. toy-14: eliminateFrameIndex</a>
<ul>
<li><a href="#org0000067">1.14.1. 测试</a></li>
</ul>
</li>
<li><a href="#org0000071">1.15. toy-15: emitInstruction</a>
<ul>
<li><a href="#org000006e">1.15.1. 测试</a></li>
</ul>
</li>
<li><a href="#org0000078">1.16. toy-16: printInst</a>
<ul>
<li><a href="#org0000075">1.16.1. 测试</a></li>
</ul>
</li>
<li><a href="#org000007f">1.17. toy-17: add registers</a>
<ul>
<li><a href="#org000007c">1.17.1. 测试</a></li>
</ul>
</li>
<li><a href="#org0000084">1.18. toy-18: add more insns</a></li>
<li><a href="#org0000087">1.19. toy-19: simplify insn definition</a></li>
<li><a href="#org000008f">1.20. toy-20: global address</a>
<ul>
<li><a href="#org000008c">1.20.1. 测试</a></li>
</ul>
</li>
<li><a href="#org0000092">1.21. toy-21: directly lower to machine code</a></li>
<li><a href="#org0000095">1.22. toy-22: lower MachineOperand to MCOperand</a></li>
<li><a href="#org0000098">1.23. toy-23: store global variable</a></li>
<li><a href="#org000009b">1.24. toy-24: LowerReturn</a></li>
<li><a href="#org000009f">1.25. toy-25: emitPrologue and emitEpilogue</a></li>
<li><a href="#org00000a6">1.26. toy-26: LowerCall Pt. 1</a>
<ul>
<li><a href="#org00000a3">1.26.1. 测试</a></li>
</ul>
</li>
<li><a href="#org00000a9">1.27. toy-27: LowerCall Pt. 2</a></li>
<li><a href="#org00000ad">1.28. toy-28: LowerFormalArguments</a></li>
<li><a href="#org00000b0">1.29. toy-29: LowerCall Pt. 3</a></li>
<li><a href="#org00000b3">1.30. toy-30: LowerReturn Pt. 2</a></li>
<li><a href="#org00000b6">1.31. toy-31: LowerCall Pt. 4</a></li>
<li><a href="#org00000b9">1.32. toy-32: frameindex with constant offset</a></li>
<li><a href="#org00000bc">1.33. toy-33: global address with constant offset</a></li>
<li><a href="#org00000bf">1.34. toy-34: setcc</a></li>
<li><a href="#org00000c2">1.35. toy-35: br_cc</a></li>
<li><a href="#org00000c5">1.36. toy-36: type promotion</a></li>
<li><a href="#org00000c9">1.37. toy-37: LowerCall Pt. 5</a></li>
<li><a href="#org00000cc">1.38. toy-38: glue</a></li>
<li><a href="#org00000cf">1.39. toy-39: soft float</a></li>
<li><a href="#org00000d2">1.40. toy-40: return struct</a></li>
<li><a href="#org00000d5">1.41. toy-41: hard float Pt. 1</a></li>
<li><a href="#org00000d8">1.42. toy-42: hard float Pt. 2</a></li>
<li><a href="#org00000e3">1.43. toy-43: builtin Pt. 1</a>
<ul>
<li><a href="#org00000dd">1.43.1. fma</a></li>
<li><a href="#org00000e0">1.43.2. fmaxf</a></li>
</ul>
</li>
<li><a href="#org00000e6">1.44. toy-44: write object file Pt. 1</a></li>
<li><a href="#org00000e9">1.45. toy-45: write object file Pt. 2</a></li>
<li><a href="#org00000ec">1.46. toy-46: write object file Pt. 3</a></li>
<li><a href="#org00000ef">1.47. toy-47: write object file Pt. 4</a></li>
<li><a href="#org00000f2">1.48. toy-48: li</a></li>
<li><a href="#org00000f7">1.49. toy-49: intrinsics</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org00000fa" class="outline-2">
<h2 id="org00000fa"><span class="section-number-2">1.</span> LLVM Toy RISC-V Backend</h2>
<div class="outline-text-2" id="text-1">
<p>
<a href="https://github.com/sunwayforever/llvm-toy">https://github.com/sunwayforever/llvm-toy</a>
</p>
</div>

<div id="outline-container-org000000c" class="outline-3">
<h3 id="org000000c"><span class="section-number-3">1.1.</span> toy-1: llc 识别 target</h3>
<div class="outline-text-3" id="text-1-1">
</div>
<div id="outline-container-org0000001" class="outline-4">
<h4 id="org0000001"><span class="section-number-4">1.1.1.</span> 目标</h4>
<div class="outline-text-4" id="text-1-1-1">
<pre class="example" id="org0000000">
$&gt; ./build/bin/llc --version
LLVM (http://llvm.org/):
  LLVM version 15.0.0git
  DEBUG build with assertions.
  Default target: x86_64-unknown-linux-gnu
  Host CPU: skylake

  Registered Targets:
    toy - TOY
</pre>
</div>
</div>

<div id="outline-container-org0000005" class="outline-4">
<h4 id="org0000005"><span class="section-number-4">1.1.2.</span> 需要的修改</h4>
<div class="outline-text-4" id="text-1-1-2">
<ol class="org-ol">
<li><p>
添加 target 到 cmake
</p>

<pre class="example" id="org0000004">
set(LLVM_ALL_TARGETS
...
Toy
...
)
</pre>

<p>
这个 `Toy` 与 build 时指定的 `LLVM_TARGETS_TO_BUILD=Toy` 一致, 且 cmake 会根据这个名字找到 `llvm/lib/Target/Toy` 目录来编译
</p></li>

<li><p>
添加 Triple::ArchType
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">Triple</span> {
  <span class="org-keyword">public</span>:
    <span class="org-keyword">enum</span> <span class="org-type">ArchType</span> {
        <span class="org-variable-name">UnknownArch</span>,
        ...
        <span class="org-variable-name">toy</span>,
        ...
    };
</pre>
</div>

<p>
后面提到的 LLVMInitializeToyTargetInfo 函数会使 llc 的命令行参数 `-march toy`
会对应到 ArchType::toy, 同时 LLVMInitializeToyTargetInfo 还会注册
ArchType::toy 对应的 TheToyTarget, 从而让 llc 找到 TheToyTarget. 后续实现的
Toy 的其它初始化的信息都会与 TheToyTarget 关联
</p></li>

<li>添加 llvm/lib/Target/Toy 目录

<ol class="org-ol">
<li>需要实现一个名为 LLVMToyCodeGen 的库 (这个名字是由 cmake 要求的), 并实现
LLVMInitializeToyTarget 函数, 目前实现为空</li>

<li>需要实现一个名为 LLVMToyDesc 的库, 实现 LLVMInitializeToyTargetMC 函数, 目前实现为空</li>

<li>需要实现一个名为 LLVMToyInfo 的库, 实现 LLVMInitializeToyTargetInfo 函数.
为了 llc 的 `Registered Targets` 能列出 toy, 这里必须实现该函数, 以便把
`toy`, `Triple::toy` 以及 `TheToyTarget` 关联起来</li>
</ol></li>
</ol>
</div>
</div>

<div id="outline-container-org0000009" class="outline-4">
<h4 id="org0000009"><span class="section-number-4">1.1.3.</span> 测试</h4>
<div class="outline-text-4" id="text-1-1-3">
<pre class="example" id="org0000008">
$&gt; ./build/bin/llc --version
LLVM (http://llvm.org/):
  LLVM version 15.0.0git
  DEBUG build with assertions.
  Default target: x86_64-unknown-linux-gnu
  Host CPU: skylake

  Registered Targets:
    toy - Toy RISC-V backend

$&gt; clang toy_test/test.c -c -emit-llvm -O0 -o /tmp/test.bc
$&gt; ./build/bin/llc /tmp/test.bc -march=toy

llc: /home/sunway/source/llvm-toy/llvm/tools/llc/llc.cpp:559: auto
compileModule(char **, llvm::LLVMContext &amp;)::(anonymous
class)::operator()(llvm::StringRef) const: Assertion `Target &amp;&amp; "Could not
allocate target machine!"' failed.
</pre>

<p>
报错的原因是:
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: &#30001;&#20110; LLVMInitializeToyTarget &#27809;&#26377;&#23454;&#29616;, &#23548;&#33268;</span>
<span class="org-comment"> * TheTarget.TargetMachineCtorFn &#27809;&#26377;&#23450;&#20041;, TheTarget-&gt;createTargetMachine &#36820;&#22238;</span>
<span class="org-comment"> * NULL</span><span class="org-comment-delimiter"> */</span>
Target = std::unique_ptr&lt;TargetMachine&gt;(TheTarget-&gt;createTargetMachine(
    TheTriple.getTriple(), CPUStr, FeaturesStr, Options, RM,
    codegen::getExplicitCodeModel(), OLvl));
<span class="org-function-name">assert</span>(Target &amp;&amp; <span class="org-string">"Could not allocate target machine!"</span>);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org0000013" class="outline-3">
<h3 id="org0000013"><span class="section-number-3">1.2.</span> toy-2: LLVMInitializeToyTarget</h3>
<div class="outline-text-3" id="text-1-2">
<p>
实现 LLVMInitializeToyTarget.
</p>

<p>
RegisterTargetMachine 会设置 TheTarget 的 TargetMachineCtorFn, 使得
TheTarget-&gt;createTargetMachine 返回 ToyTargetMachine 实例.
</p>
</div>

<div id="outline-container-org0000010" class="outline-4">
<h4 id="org0000010"><span class="section-number-4">1.2.1.</span> 测试</h4>
<div class="outline-text-4" id="text-1-2-1">
<pre class="example" id="org000000f">
$&gt; toy_test.sh
llc: /home/sunway/source/llvm-toy/llvm/lib/CodeGen/LLVMTargetMachine.cpp:42:
void llvm::LLVMTargetMachine::initAsmInfo(): Assertion `MRI &amp;&amp; "Unable to create
reg info"' failed.
</pre>

<p>
出错的原因是没有调用 RegisterMCRegInfo, 导致 initAsmInfo 时出错.
</p>
</div>
</div>
</div>

<div id="outline-container-org000001b" class="outline-3">
<h3 id="org000001b"><span class="section-number-3">1.3.</span> toy-3: LLVMInitializeToyTargetMC</h3>
<div class="outline-text-3" id="text-1-3">
<p>
LLVMInitializeToyTargetMC 会设置一个回调函数, 这些回调会由 initAsm 时通过
TheTargt 的 createXXX 调用以初始化 TheTarget 的 MRI, MII, STI, AsmInfo 等.
</p>

<ul class="org-ul">
<li><p>
MRI
</p>

<p>
MCRegisterInfo
</p>

<p>
寄存器的编号, 名字等, 主要信息由 td 生成
</p></li>

<li><p>
MII
</p>

<p>
MCInstrInfo
</p>

<p>
指令的编码, 名字等, 主要信息由 td 生成
</p></li>

<li><p>
STI
</p>

<p>
MCSubtargetInfo
</p>

<p>
subtarget 对应调用 llc 时指定的 `-mcpu`, `-mattr` 等信息. llc 会用这些信息调用
STI 对应的回调函数以初始化 STI.
</p>

<p>
subtarget 的信息是由 td 生成的
</p></li>

<li><p>
AsmInfo
</p>

<p>
MCAsmInfo
</p>

<p>
需要包含一些 asm 文件的格式信息, 例如 comment 对应的 `#` 符号
</p></li>
</ul>

<p>
在定义 STI 时使用了 td 文件, td 文件需要在 cmake 中指定 tablegen 命令的参数以及生成头文件的名字, 例如
</p>

<pre class="example" id="org0000016">
set(LLVM_TARGET_DEFINITIONS Toy.td)
tablegen(LLVM ToyGenSubtargetInfo.inc -gen-subtarget)
add_public_tablegen_target(ToyCommonTableGen)
</pre>

<p>
表示 td 的入口是 Toy.td, 使用 `-gen-subtarget` 生成 ToyGenSubtargetInfo.inc
</p>
</div>

<div id="outline-container-org0000018" class="outline-4">
<h4 id="org0000018"><span class="section-number-4">1.3.1.</span> 测试</h4>
<div class="outline-text-4" id="text-1-3-1">
<pre class="example" id="org0000017">
~/source/llvm-toy#toy[17:43:49]@sunway-t14&gt; ./toy_test.sh
; ModuleID = '/tmp/test.bc'
source_filename = "toy_test/test.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

; Function Attrs: noinline nounwind optnone uwtable
define dso_local void @foo() #0 {
  %1 = alloca i32, align 4
  store i32 255, i32* %1, align 4
  ret void
}

...
!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 10.0.0-4ubuntu1 "}
llc: error: target does not support generation of this file type
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</pre>

<p>
报错的原因是 Toy 没有指定一个 SelectionDAGISel 实例. SelectionDAGISel 是整个 isel
(instruction selection) 的入口
</p>
</div>
</div>
</div>

<div id="outline-container-org0000022" class="outline-3">
<h3 id="org0000022"><span class="section-number-3">1.4.</span> toy-4: ToyDAGToDAGISel</h3>
<div class="outline-text-3" id="text-1-4">
<p>
通过 ToyTargetMachine 的 createPassConfig 函数, 注册一个 ToyDAGToDAGISel pass,
后者继承自 SelectionDAGISel, 需要实现一个 `Select` 函数做为 isel 的入口. 这里的
Select 函数直接调用了 td 根据 patten 生成的 SelectCode 函数. tablegen 的
`gen-dag-isel` 需要 td 中定义一个 RegisterClass
</p>
</div>

<div id="outline-container-org000001f" class="outline-4">
<h4 id="org000001f"><span class="section-number-4">1.4.1.</span> 测试</h4>
<div class="outline-text-4" id="text-1-4-1">
<pre class="example" id="org000001e">
$&gt; ./toy_test.sh

llc: /home/sunway/source/llvm-toy/llvm/lib/MC/MCAsmStreamer.cpp:85: (anonymous
namespace)::MCAsmStreamer::MCAsmStreamer(llvm::MCContext &amp;,
std::unique_ptr&lt;formatted_raw_ostream&gt;, bool, bool, llvm::MCInstPrinter *,
std::unique_ptr&lt;MCCodeEmitter&gt;, std::unique_ptr&lt;MCAsmBackend&gt;, bool): Assertion
`InstPrinter' failed.
</pre>

<p>
出错的原因是没有实现 InstPrinter
</p>
</div>
</div>
</div>

<div id="outline-container-org000002a" class="outline-3">
<h3 id="org000002a"><span class="section-number-3">1.5.</span> toy-5: ToyInstPrinter</h3>
<div class="outline-text-3" id="text-1-5">
<p>
ToyInstPrinter 继承自 MCInstPrinter, 需要实现 printInst, printRegName,
printOperand 等函数. 它会使用 tablegen 的 `-gen-asm-writer` 生成的函数例如
printInstruction, getRegisterName 等
</p>
</div>

<div id="outline-container-org0000027" class="outline-4">
<h4 id="org0000027"><span class="section-number-4">1.5.1.</span> 测试</h4>
<div class="outline-text-4" id="text-1-5-1">
<pre class="example" id="org0000025">
$&gt; ./toy_test.sh
llc: error: target does not support generation of this file type
</pre>

<p>
出错的原因是没有实现 ToyAsmPrinter.
</p>

<p>
cmake 通过提供 target 目录是否存在 `*AsmPrinter.cpp` 来决定 llc 是否调用
LLVMInitializeToyAsmPrinter 来初始化到 asm printer.
</p>

<pre class="example" id="org0000026">
llvm/CMakeLists.txt:
====================
file(GLOB asmp_file "${td}/*AsmPrinter.cpp")
  if( asmp_file )
    set(LLVM_ENUM_ASM_PRINTERS
      "${LLVM_ENUM_ASM_PRINTERS}LLVM_ASM_PRINTER(${t})\n")
endif()

AsmPrinters.def.in:
====================
@LLVM_ENUM_ASM_PRINTERS@

如果前面找到 AsmPrinter.cpp, 则这里会展开成:

LLVM_ASM_PRINTER(Toy)

llc:
====================
inline void InitializeAllAsmPrinters() {
#define LLVM_ASM_PRINTER(TargetName) LLVMInitialize##TargetName##AsmPrinter();
#include "llvm/Config/AsmPrinters.def"
}
</pre>

<p>
所以需要定义一个 ToyAsmPrinter.cpp, 并实现 LLVMInitializeToyAsmPrinter 函数
</p>
</div>
</div>
</div>

<div id="outline-container-org0000031" class="outline-3">
<h3 id="org0000031"><span class="section-number-3">1.6.</span> toy-6: ToyAsmPrinter</h3>
<div class="outline-text-3" id="text-1-6">
<p>
ToyAsmPrinter 操作的是 MachineInstr, 它需要实现 emitStartOfAsmFile,
emitFunctionBodyStart, emitInstruction 等, 其中 emitInstruction 需要转换
MachineInstr 到 MCInstr, 然后通过 MC 调用到 ToyInstPrinter
</p>
</div>

<div id="outline-container-org000002e" class="outline-4">
<h4 id="org000002e"><span class="section-number-4">1.6.1.</span> 测试</h4>
<div class="outline-text-4" id="text-1-6-1">
<pre class="example" id="org000002d">
$&gt; ./toy_test.sh

llc: /home/sunway/source/llvm-toy/llvm/tools/llc/llc.cpp:733: int
compileModule(char **, llvm::LLVMContext &amp;): Assertion
`LLVMTM.getObjFileLowering() &amp;&amp; "getObjFileLowering"' failed.
</pre>

<p>
报错的原因是 ToyTargetMachine 没有实现 getObjFileLowering 函数
</p>
</div>
</div>
</div>

<div id="outline-container-org0000038" class="outline-3">
<h3 id="org0000038"><span class="section-number-3">1.7.</span> toy-7: ToyTargetObjectFile</h3>
<div class="outline-text-3" id="text-1-7">
<p>
AsmPrinter 会使用 TargetLoweringObjectFile 决定各种数据所在的 section
</p>
</div>

<div id="outline-container-org0000035" class="outline-4">
<h4 id="org0000035"><span class="section-number-4">1.7.1.</span> 测试</h4>
<div class="outline-text-4" id="text-1-7-1">
<pre class="example" id="org0000034">
$&gt; ./toy_test.sh

llc: /home/sunway/source/llvm-toy/llvm/lib/CodeGen/ExpandLargeDivRem.cpp:119:
virtual bool (anonymous
namespace)::ExpandLargeDivRemLegacyPass::runOnFunction(llvm::Function &amp;):
Assertion `TM-&gt;getSubtargetImpl(F)' failed.
</pre>

<p>
出错的原因是不支持 subtarget
</p>
</div>
</div>
</div>

<div id="outline-container-org000003f" class="outline-3">
<h3 id="org000003f"><span class="section-number-3">1.8.</span> toy-8: ToySubtarget</h3>
<div class="outline-text-3" id="text-1-8">
<p>
ToyTargetMachine 需要实现 getSubtargetImpl 返回一个 ToySubtaget, 后续 isel 相关的功能例如 getRegisterInfo, getInstrInfo, getFrameLowering, getTargetLowering 都需要由
subtarget 提供
</p>
</div>

<div id="outline-container-org000003c" class="outline-4">
<h4 id="org000003c"><span class="section-number-4">1.8.1.</span> 测试</h4>
<div class="outline-text-4" id="text-1-8-1">
<pre class="example" id="org000003b">
$&gt; ./toy_test.sh

llc: /home/sunway/source/llvm-toy/llvm/lib/CodeGen/ExpandLargeDivRem.cpp:121:
virtual bool (anonymous
namespace)::ExpandLargeDivRemLegacyPass::runOnFunction(llvm::Function &amp;):
Assertion `TLI &amp;&amp; "getTargetLowering is null"' failed.
</pre>

<p>
出错的原因是 ToySubtarget 没有实现 getTargetLowering.
</p>
</div>
</div>
</div>

<div id="outline-container-org0000046" class="outline-3">
<h3 id="org0000046"><span class="section-number-3">1.9.</span> toy-9: ToyTargetLowering</h3>
<div class="outline-text-3" id="text-1-9">
<p>
TargetLowering 在 SelectionDAGBuilder 阶段会被调用, 用来生成最初的
SelectionDAG. 虽然最初的 SelectionDAG 基本是 target 无关, 但涉及到函数调用及其参数, 返回值的处理时需要 target 提供 TargetLowering 类, 并实现 LowerReturn 等函数
</p>
</div>

<div id="outline-container-org0000043" class="outline-4">
<h4 id="org0000043"><span class="section-number-4">1.9.1.</span> 测试</h4>
<div class="outline-text-4" id="text-1-9-1">
<pre class="example" id="org0000042">
$&gt; ./toy_test.sh

llc: /home/sunway/source/llvm-toy/llvm/lib/CodeGen/MachineFunction.cpp:193: void
llvm::MachineFunction::init(): Assertion `STI-&gt;getFrameLowering()' failed.
</pre>

<p>
出错的原因是 ToySubtarget 没有实现 getFrameLowering
</p>
</div>
</div>
</div>

<div id="outline-container-org000004d" class="outline-3">
<h3 id="org000004d"><span class="section-number-3">1.10.</span> toy-10: ToyFrameLowering</h3>
<div class="outline-text-3" id="text-1-10">
<p>
ToyFrameLowering 需要实现 emitPrologue 和 emitEpilogue, 它们由 PEI (prologue
epilogue insertion) 这个 pass 调用.
</p>

<p>
emitPrologue 会获取 stack size, 然后通过 BuildMI 生成 MachineInstr 来调整 sp. 另外它还会生成 dwarf cfi directive.
</p>

<p>
PEI 操作的是 MachineInstr, 它发生成 scheduling 之后.
</p>
</div>

<div id="outline-container-org000004a" class="outline-4">
<h4 id="org000004a"><span class="section-number-4">1.10.1.</span> 测试</h4>
<div class="outline-text-4" id="text-1-10-1">
<pre class="example" id="org0000049">
$&gt; ./toy_test.sh

llc:
/home/sunway/source/llvm-toy/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:3058:
void llvm::SelectionDAGISel::SelectCodeCommon(llvm::SDNode *, const unsigned
char *, unsigned int): Assertion `MatcherIndex &lt; TableSize &amp;&amp; "Invalid index"'
failed.
</pre>

<p>
出错的原因是 td 还没有定义 load pattern 对应的指令
</p>
</div>
</div>
</div>

<div id="outline-container-org0000055" class="outline-3">
<h3 id="org0000055"><span class="section-number-3">1.11.</span> toy-11: isel</h3>
<div class="outline-text-3" id="text-1-11">
<p>
写一个最简单的 ToyInstrInfo.td, 它会把 immediate 这个 pattern 转换为 Toy::ADDI,
并且把用于访问局部变量的 frameindex 转换为 Toy::STORE
</p>

<pre class="example" id="org0000050">
===== Instruction selection begins: %bb.0 ''

ISEL: Starting selection on root node: t5: ch = store&lt;(store (s32) into %ir.1)&gt; t0, Constant:i32&lt;255&gt;, FrameIndex:i32&lt;0&gt;, undef:i32
ISEL: Starting pattern match
Creating constant: t7: i32 = TargetConstant&lt;0&gt;
  Morphed node: t5: ch = STORE&lt;Mem:(store (s32) into %ir.1)&gt; Constant:i32&lt;255&gt;, TargetFrameIndex:i32&lt;0&gt;, TargetConstant:i32&lt;0&gt;, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t1: i32 = Constant&lt;255&gt;
ISEL: Starting pattern match
  Initial Opcode index to 51
Creating constant: t9: i32 = TargetConstant&lt;255&gt;
  Morphed node: t1: i32 = ADDI Register:i32 $physreg1, TargetConstant:i32&lt;255&gt;
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch,glue = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.0 'foo:'
SelectionDAG has 7 nodes:
    t1: i32 = ADDI Register:i32 $physreg1, TargetConstant:i32&lt;255&gt;
    t0: ch,glue = EntryToken
  t5: ch = STORE&lt;Mem:(store (s32) into %ir.1)&gt; t1, TargetFrameIndex:i32&lt;0&gt;, TargetConstant:i32&lt;0&gt;, t0
</pre>
</div>

<div id="outline-container-org0000052" class="outline-4">
<h4 id="org0000052"><span class="section-number-4">1.11.1.</span> 测试</h4>
<div class="outline-text-4" id="text-1-11-1">
<pre class="example" id="org0000051">
$&gt; ./toy_test.sh

llc:
/home/sunway/source/llvm-toy/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:368:
virtual void (anonymous namespace)::ScheduleDAGRRList::Schedule(): Assertion
`TRI' failed.
</pre>

<p>
出错的原因是 schedule 时需要 subtarget 实现 getRegisterInfo
</p>
</div>
</div>
</div>

<div id="outline-container-org000005c" class="outline-3">
<h3 id="org000005c"><span class="section-number-3">1.12.</span> toy-12: ToyRegisterInfo</h3>
<div class="outline-text-3" id="text-1-12">
<p>
ToyRegisterInfo 需要实现 `getCalleeSavedRegs` 等函数, 后续 RA, PEI 等会使用它
</p>
</div>

<div id="outline-container-org0000059" class="outline-4">
<h4 id="org0000059"><span class="section-number-4">1.12.1.</span> 测试</h4>
<div class="outline-text-4" id="text-1-12-1">
<pre class="example" id="org0000058">
$&gt; ./toy_test.sh

*** Final schedule ***
SU(1): t1: i32 = ADDI Register:i32 $zero, TargetConstant:i32&lt;255&gt;

SU(0): t5: ch = STORE&lt;Mem:(store (s32) into %ir.1)&gt; t1, TargetFrameIndex:i32&lt;0&gt;,
TargetConstant:i32&lt;0&gt;, t0
...
Target didn't implement TargetInstrInfo::storeRegToStackSlot!

Stack dump:
0.      Program arguments: ./build/bin/llc /tmp/test.bc -march=toy --debug
1.      Running pass 'Function Pass Manager' on module '/tmp/test.bc'.
2.      Running pass 'Prologue/Epilogue Insertion &amp; Frame Finalization' on function '@foo'
 ...

#9 0x000000000134b9d2 insertCSRSaves(llvm::MachineBasicBlock&amp;,
 llvm::ArrayRef&lt;llvm::CalleeSavedInfo&gt;)
 /home/sunway/source/llvm-toy/llvm/lib/CodeGen/PrologEpilogInserter.cpp:602:5

#10 0x0000000001348994 (anonymous
namespace)::PEI::spillCalleeSavedRegs(llvm::MachineFunction&amp;)
/home/sunway/source/llvm-toy/llvm/lib/CodeGen/PrologEpilogInserter.cpp:681:41

#11 0x000000000134768a (anonymous
namespace)::PEI::runOnMachineFunction(llvm::MachineFunction&amp;)
/home/sunway/source/llvm-toy/llvm/lib/CodeGen/PrologEpilogInserter.cpp:252:3

</pre>

<p>
出错的原因是 PEI 生成 prologue 时为了把 CSR 保存到栈上, 需要实现 storeRegToStackSlot
</p>
</div>
</div>
</div>

<div id="outline-container-org0000063" class="outline-3">
<h3 id="org0000063"><span class="section-number-3">1.13.</span> toy-13: storeRegToStackSlot</h3>
<div class="outline-text-3" id="text-1-13">
<p>
storeRegToStackSlot 需要生成 MachineInstr, 把 reg (例如 RA) 保存到栈上
</p>
</div>

<div id="outline-container-org0000060" class="outline-4">
<h4 id="org0000060"><span class="section-number-4">1.13.1.</span> 测试</h4>
<div class="outline-text-4" id="text-1-13-1">
<pre class="example" id="org000005f">
$&gt; ./toy_test.sh

Found roots: %bb.0
Skipping pass 'Shrink Wrapping analysis' on function foo
alloc FI(1) at SP[-4]
alloc FI(0) at SP[-8]
STORE killed $ra, %stack.1, 0
STORE killed $ra, %stack.1, 0
STORE killed $ra, %stack.1, 0
STORE killed $ra, %stack.1, 0
....
</pre>

<p>
程序陷入死循环, 原因是 eliminateFrameIndex 目前实现为空.
</p>
</div>
</div>
</div>

<div id="outline-container-org000006a" class="outline-3">
<h3 id="org000006a"><span class="section-number-3">1.14.</span> toy-14: eliminateFrameIndex</h3>
<div class="outline-text-3" id="text-1-14">
<p>
PEI 会调用 eliminateFrameIndex 把使用了 frameindex 的 MachineInstr (例如 `STORE
ra, addr, 0`) 修改成 `STORE ra, sp, N`.
</p>

<p>
eliminateFrameIndex 需要根据 frameindex 的值以及 stack_size 计算出正确的偏移量,
然后修改 MI 的 operand, 把原来的 (addr, 0)替换成 (sp, offset)
</p>
</div>

<div id="outline-container-org0000067" class="outline-4">
<h4 id="org0000067"><span class="section-number-4">1.14.1.</span> 测试</h4>
<div class="outline-text-4" id="text-1-14-1">
<pre class="example" id="org0000066">
$&gt; ./toy_test.sh

EmitInstruction not implemented
UNREACHABLE executed at /home/sunway/source/llvm-toy/llvm/include/llvm/CodeGen/AsmPrinter.h:572!
Stack dump:
...
#9 0x0000000000c410f6 llvm::AsmPrinter::emitFunctionBody()
/home/sunway/source/llvm-toy/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:1725:13

#10 0x0000000000c10671
llvm::AsmPrinter::runOnMachineFunction(llvm::MachineFunction&amp;)
/home/sunway/source/llvm-toy/llvm/include/llvm/CodeGen/AsmPrinter.h:4
...
</pre>

<p>
出错的原因是没有实现 AsmPrinter 的 emitInstruction
</p>
</div>
</div>
</div>

<div id="outline-container-org0000071" class="outline-3">
<h3 id="org0000071"><span class="section-number-3">1.15.</span> toy-15: emitInstruction</h3>
<div class="outline-text-3" id="text-1-15">
<p>
AsmPrinter 可以重写许多 emit 函数, 例如 emitFunctionBodyStart 等, 但这些都为默认的实现. 但 emitInstruction 是 target 必需实现的.
</p>

<p>
emitInstruction 的功能是把 MachineInstr 转换为 MCInst, 然后交给 MCStream, 后者会调用到 MCInstPrinter 中的接口, 例如 printInst
</p>
</div>

<div id="outline-container-org000006e" class="outline-4">
<h4 id="org000006e"><span class="section-number-4">1.15.1.</span> 测试</h4>
<div class="outline-text-4" id="text-1-15-1">
<pre class="example" id="org000006d">
./toy_test.sh

Debug Range Extension: foo
        .globl  foo                             # -- Begin function foo
        .type   foo,@function
foo:                                    # @foo
# %bb.0:






Lfunc_end0:
        .size   foo, Lfunc_end0-foo
                                        # -- End function

</pre>

<p>
llc 能正常结束, 但输出的 asm 基本为空, 原因是 ToyInstPrinter 中 printInst 等目前的实现为空
</p>
</div>
</div>
</div>

<div id="outline-container-org0000078" class="outline-3">
<h3 id="org0000078"><span class="section-number-3">1.16.</span> toy-16: printInst</h3>
<div class="outline-text-3" id="text-1-16">
<p>
ToyInstPrinter 需要使用 td 生成的信息来实现 printInst, printRegName 等
</p>
</div>

<div id="outline-container-org0000075" class="outline-4">
<h4 id="org0000075"><span class="section-number-4">1.16.1.</span> 测试</h4>
<div class="outline-text-4" id="text-1-16-1">
<pre class="example" id="org0000074">
$&gt; ./toy_test.sh


Debug Range Extension: foo
        .globl  foo                             # -- Begin function foo
        .type   foo,@function
foo:                                    # @foo
# %bb.0:
        sw      ra, 4(sp)
        addi    ra, zero, 255
        sw      ra, 0(sp)
        addi    ra, zero, 255
        sw      ra, 0(sp)
        sw      ra, 0(sp)
Lfunc_end0:
        .size   foo, Lfunc_end0-foo
                                        # -- End function
</pre>

<p>
针对 mem operand 使用了自定义的 printMemOperand, 而不会调用默认的 printOperand.
</p>

<p>
现在的代码看起来有两个问题:
</p>

<ol class="org-ol">
<li>addi 不应用使用 ra, 需要定义更多的 register</li>
<li>最后两行 `sw ra, 0(sp)` 是什么</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org000007f" class="outline-3">
<h3 id="org000007f"><span class="section-number-3">1.17.</span> toy-17: add registers</h3>
<div class="outline-text-3" id="text-1-17">
</div>
<div id="outline-container-org000007c" class="outline-4">
<h4 id="org000007c"><span class="section-number-4">1.17.1.</span> 测试</h4>
<div class="outline-text-4" id="text-1-17-1">
<pre class="example" id="org000007b">
$&gt; ./toy_test.sh

Debug Range Extension: foo
        .globl  foo                             # -- Begin function foo
        .type   foo,@function
foo:                                    # @foo
# %bb.0:
        addi    t0, zero, 255
        sw      t0, 0(sp)
Lfunc_end0:
        .size   foo, Lfunc_end0-foo
                                        # -- End function
</pre>
</div>
</div>
</div>

<div id="outline-container-org0000084" class="outline-3">
<h3 id="org0000084"><span class="section-number-3">1.18.</span> toy-18: add more insns</h3>
<div class="outline-text-3" id="text-1-18">
<p>
添加 store/add/and/or/andi/ori 指令. 由于目前不涉及到 object 文件的生成, 所以去掉了 td 中关于指令格式的内容.
</p>

<p>
添加指令时 patten 可以有两种写法:
</p>

<ol class="org-ol">
<li><p>
写在 Instruct 的 patten 中, 例如:
</p>

<pre class="example" id="org0000082">
def LOAD : ToyInst&lt;(outs GPR:$ra), (ins mem:$addr), "lw \t$ra, $addr",
          [(set GPR:$ra, (load AddrFI:$addr))],
          IIAlu&gt;;
</pre></li>

<li><p>
使用 Pat, 例如:
</p>

<pre class="example" id="org0000083">
def LOAD : ToyInst&lt;(outs GPR:$ra), (ins mem:$addr), "lw \t$ra, $addr", [], IIAlu&gt;;

def : Pat&lt;(load AddrFI:$addr),
          (LOAD  AddrFI:$addr)&gt;;
</pre></li>
</ol>
</div>
</div>

<div id="outline-container-org0000087" class="outline-3">
<h3 id="org0000087"><span class="section-number-3">1.19.</span> toy-19: simplify insn definition</h3>
<div class="outline-text-3" id="text-1-19">
<p>
定义 ADD, DIV, REM, &#x2026; 时有许多重复的内容, 可以使用 td 的 class 简化这些指令的定义
</p>
</div>
</div>

<div id="outline-container-org000008f" class="outline-3">
<h3 id="org000008f"><span class="section-number-3">1.20.</span> toy-20: global address</h3>
<div class="outline-text-3" id="text-1-20">
<p>
目前 toy 还不支持 global address, 所以编译下面的程序会报错:
</p>

<pre class="example" id="org000008a">
$&gt; cat toy_test/test.c
int x = 0;
void foo() {
    int l = x;
}

$&gt; ./toy_test.sh

LLVM ERROR: Cannot select: t4: i32,ch = load&lt;(dereferenceable load (s32) from
@x)&gt; t0, GlobalAddress:i32&lt;ptr @x&gt; 0, undef:i32
</pre>

<p>
对于 global address 的处理发生成 legalize 阶段, ToyTargetLower 需要通过
`setOperationAction` 标记 ISD::GlobalAddress 的 action 为 custom, 同时实现
LowerOperation 来处理这个 node: 生成 `add (lui %hi(x)) %lo(x))` 对应的 node
</p>
</div>

<div id="outline-container-org000008c" class="outline-4">
<h4 id="org000008c"><span class="section-number-4">1.20.1.</span> 测试</h4>
<div class="outline-text-4" id="text-1-20-1">
<pre class="example" id="org000008b">
$&gt; ./toy_test.sh

===== Instruction selection ends:
Selected selection DAG: %bb.0 'foo:'
SelectionDAG has 9 nodes:
      t9: i32 = LUI TargetGlobalAddress:i32&lt;ptr @x&gt; 0 [TF=1]
    t10: i32 = ADDI t9, TargetGlobalAddress:i32&lt;ptr @x&gt; 0 [TF=2]
    t0: ch,glue = EntryToken
  t4: i32,ch = LOAD&lt;Mem:(dereferenceable load (s32) from @x)&gt; t10, t0
  t6: ch = STORE&lt;Mem:(store (s32) into %ir.1)&gt; t4, TargetFrameIndex:i32&lt;0&gt;, TargetConstant:i32&lt;0&gt;, t4:1
...
foo:                                    # @foo
# %bb.0:
unknown operand type
UNREACHABLE executed at /home/sunway/source/llvm-toy/llvm/lib/Target/Toy/ToyMCInstLower.cpp:25!

...

#8 0x0000000000c26775 llvm::ToyMCInstLower::LowerOperand(llvm::MachineOperand
const&amp;) const
/home/sunway/source/llvm-toy/llvm/lib/Target/Toy/ToyMCInstLower.cpp:27:33
</pre>

<p>
isel 成功, 但在 AsmPrinter 时出错, 因为 LUI 及 ADDI 的 operand 是 GlobalAddress,
当前的 LowerOperand 只支持 register 和 imm
</p>
</div>
</div>
</div>

<div id="outline-container-org0000092" class="outline-3">
<h3 id="org0000092"><span class="section-number-3">1.21.</span> toy-21: directly lower to machine code</h3>
<div class="outline-text-3" id="text-1-21">
<p>
前面的 LowerOperation 把 global address lower 成了 ISD:ADD, 实际上可以直接 lower
成 Toy::ADDI, 省略后续 isel 时 ISD::ADD 到 Toy::ADDI 的过程. 由于 isel 的输入可能是 machine code, 所以 ToyDAGToDAGISel 的 Select 需要忽略掉 SDNode 已经是
machine code 的情况
</p>
</div>
</div>

<div id="outline-container-org0000095" class="outline-3">
<h3 id="org0000095"><span class="section-number-3">1.22.</span> toy-22: lower MachineOperand to MCOperand</h3>
<div class="outline-text-3" id="text-1-22">
<p>
前面 LUI 转换成 MacineInstr 后它的 MachineOperand 是
MO_GlobalAddress. ToyMCInstLower 的 LowerOperand 需要把它 lower 成
MCOperand.
</p>

<p>
这个 MCOperand 的 kind 既不是 register, 也不是 immediate, 因此需要定义ToyMCExpr,
做为 MCOperand 的 expr.
</p>

<p>
ToyMCExpr 保存着原始的 imm 和 kind (hi/lo) 信息. ToyInstPrinter 会调用到
ToyMCExpr::printImpl 最终根据它保存的 kind 打印出 `%hi` 和 `%lo`
</p>
</div>
</div>

<div id="outline-container-org0000098" class="outline-3">
<h3 id="org0000098"><span class="section-number-3">1.23.</span> toy-23: store global variable</h3>
<div class="outline-text-3" id="text-1-23">
<p>
前面的代码不支持全局变量的赋值, 因为缺少 `store $rs1, $rs2` 这个 pattern
</p>
</div>
</div>

<div id="outline-container-org000009b" class="outline-3">
<h3 id="org000009b"><span class="section-number-3">1.24.</span> toy-24: LowerReturn</h3>
<div class="outline-text-3" id="text-1-24">
<p>
return 语句需要通过 ToyISelLowering::LowerReturn 处理. 这个过程发生在最初的
SelectionDAGBuilder 阶段.
</p>

<p>
LowerReturn 需要分析需要 return 的值, 生成一些指令把这些值按调用约定处理 (放在寄存器, 放在栈上), 最后还生成一个 ToyISD::Ret.
</p>

<p>
目前的 LowerReturn 只处理了 return void 的情况
</p>

<p>
ToyISD::Ret 使用了自带的 PseudoInstExpansion 机制, 后者会使用 tablegen 生成和
ToyMCInstLower 类似的代码, 把 Toy::Ret lower 成 JALR 对应的 MCInst.
</p>

<p>
如果不考虑生成 obj, 也可以直接 <code>def RET : InstI&lt;(outs),(ins), "jalr zero,0(ra)",
[(ToyRET)], IIAlu&gt;;</code>, 这样使用默认的 ToyMCInstLower 就可以处理.
</p>
</div>
</div>

<div id="outline-container-org000009f" class="outline-3">
<h3 id="org000009f"><span class="section-number-3">1.25.</span> toy-25: emitPrologue and emitEpilogue</h3>
<div class="outline-text-3" id="text-1-25">
<p>
当前生成的代码是错误的, 例如:
</p>

<pre class="example" id="org000009e">
$&gt; cat test.c
void foo() {
    int x = 1;
    int y = x;
    int z = y;
}

$&gt; ./toy_test.sh
foo:                                    # @foo
# %bb.0:
        addi    t0, zero, 1
        sw      t0, 8(sp)
        lw      t0, 8(sp)
        sw      t0, 4(sp)
        lw      t0, 4(sp)
        sw      t0, 0(sp)
        jalr zero, 0(ra)
</pre>

<p>
foo 的入口需要有 `addi sp, sp, -12`, 称为 prologue
foo 的返回前需要有 `addi sp, sp, 12`, 称为 epilogue
</p>

<p>
其中 `8` 是 stack size, 取决于:
</p>

<ol class="org-ol">
<li>是否保存 fp, 如果有 fp 且没有使用 omit-frame-pointer 则需要保存</li>

<li>是否保存 ra, 如果函数不是 leaf function 则需要保存</li>

<li>是否保存 callee saved reg (CSR), 如果函数使用了它们, 则需要保存和恢复</li>

<li>局部变量占用的栈空间</li>

<li>&#x2026;</li>
</ol>

<p>
emitPrologue 本身并不负责 CSR 的 spill 和 restore, 它们由 PEI 负责
(spillCalleeSavedRegs)
</p>

<p>
emitPrologue 发生在 schedule 及 RA 之后, 所以它们操作的是 MachineInstr 和物理寄存器
</p>

<p>
epilogue 与 prologue 对应, 但如果函数不需要返回, 则不需要 epilogue (参考
ToyInstrInfo.td 中的 `isReturn = 1`)
</p>
</div>
</div>

<div id="outline-container-org00000a6" class="outline-3">
<h3 id="org00000a6"><span class="section-number-3">1.26.</span> toy-26: LowerCall Pt. 1</h3>
<div class="outline-text-3" id="text-1-26">
<p>
call 需要 ToyISelLowering::LowerCall 来处理, 它负责按调用约定处理函数调用的参数
(例如放在特定物理寄存器或放在栈上), 然后生成跳转指令, 并处理函数返回的结果 (例如从特定物理寄存器或栈上获得结果)
</p>

<p>
当前的实现只生成了跳转指令, 所以只能支持 `void foo()` 类型的函数调用
</p>
</div>

<div id="outline-container-org00000a3" class="outline-4">
<h4 id="org00000a3"><span class="section-number-4">1.26.1.</span> 测试</h4>
<div class="outline-text-4" id="text-1-26-1">
<pre class="example" id="org00000a2">
#&gt; ./toy_test.sh

        .text
        .file   "test.c"
        .globl  foo                             # -- Begin function foo
        .type   foo,@function
foo:                                    # @foo
# %bb.0:
        lui t0, %hi(foo)
        addi    t0, t0, %lo(foo)
        jalr ra, 0(t0)
        jalr zero, 0(ra)
Lfunc_end0:
        .size   foo, Lfunc_end0-foo
                                        # -- End function
</pre>

<p>
能生成 `jalr ra, 0(t0)` , 但有一个问题: 没有针对 ra 做 CSR 的 spill 和 restore
</p>
</div>
</div>
</div>

<div id="outline-container-org00000a9" class="outline-3">
<h3 id="org00000a9"><span class="section-number-3">1.27.</span> toy-27: LowerCall Pt. 2</h3>
<div class="outline-text-3" id="text-1-27">
<p>
CSR 需要保存的前提是函数不是 leaf function, 通过设置 td 中 CALL 指令 `isCall =
1` 让 llvm 知道函数 `hasCalls()`
</p>

<p>
由于 RA 寄存器 并非由 register allocator 分配, 所以需要重写
determineCalleeSaves, 把 RA 加到 SavedRegs 里
</p>

<p>
最后需要实现 loadRegFromStackSlot, 以便生成 restore ra 的指令
</p>
</div>
</div>

<div id="outline-container-org00000ad" class="outline-3">
<h3 id="org00000ad"><span class="section-number-3">1.28.</span> toy-28: LowerFormalArguments</h3>
<div class="outline-text-3" id="text-1-28">
<p>
LowerFormalArguments 负责按调用约定从物理寄存器或栈上获得函数的参数,
ToyCallingConv.td 中的
</p>

<pre class="example" id="org00000ac">
def ToyCC : CallingConv&lt;[
    CCIfType&lt;[i32], CCAssignToReg&lt;[A0, A1]&gt;&gt;
]&gt;;
</pre>

<p>
会生成一个 ToyCC 函数, LowerFormalArguments 调用它获得参数使用的物理寄存器或栈上的位置, 然后生成一些 SDNode (例如 getCopyFromReg) 获得这些参数
</p>

<p>
目前的实现只支持通过寄存器传递最多两个 i32 类型的参数
</p>
</div>
</div>

<div id="outline-container-org00000b0" class="outline-3">
<h3 id="org00000b0"><span class="section-number-3">1.29.</span> toy-29: LowerCall Pt. 3</h3>
<div class="outline-text-3" id="text-1-29">
<p>
LowerCall 时除了生成跳转指令, 还需要按调用约定把参数放在物理寄存器或栈上, 它使用了和前面 LowerFormalArguments 类似的代码.
</p>

<p>
目前的实现只支持通过寄存器传递最多两个 i32 类型的参数
</p>
</div>
</div>

<div id="outline-container-org00000b3" class="outline-3">
<h3 id="org00000b3"><span class="section-number-3">1.30.</span> toy-30: LowerReturn Pt. 2</h3>
<div class="outline-text-3" id="text-1-30">
<p>
LowerReturn 不仅要生成跳转指令, 还需要按调用用约定把返回值放在物理寄存器或栈上.
</p>

<p>
目前的实现只支持通过寄存器返回一个 i32 类型的返回值
</p>
</div>
</div>

<div id="outline-container-org00000b6" class="outline-3">
<h3 id="org00000b6"><span class="section-number-3">1.31.</span> toy-31: LowerCall Pt. 4</h3>
<div class="outline-text-3" id="text-1-31">
<p>
LowerCall 最后还需要根据调用约定从物理寄存器或栈上获得函数的返回值
</p>
</div>
</div>

<div id="outline-container-org00000b9" class="outline-3">
<h3 id="org00000b9"><span class="section-number-3">1.32.</span> toy-32: frameindex with constant offset</h3>
<div class="outline-text-3" id="text-1-32">
<p>
访问栈上的 `a[1]` 时会使用带 offset 的 frameindex
</p>
</div>
</div>

<div id="outline-container-org00000bc" class="outline-3">
<h3 id="org00000bc"><span class="section-number-3">1.33.</span> toy-33: global address with constant offset</h3>
<div class="outline-text-3" id="text-1-33">
<p>
访问全局的 `a[1]` 时会使用带 offset 的 global address
</p>
</div>
</div>

<div id="outline-container-org00000bf" class="outline-3">
<h3 id="org00000bf"><span class="section-number-3">1.34.</span> toy-34: setcc</h3>
<div class="outline-text-3" id="text-1-34">
<p>
riscv 只支持 slt, 但 slt, sgt, seq, sne 都可以用 slt 实现
</p>
</div>
</div>

<div id="outline-container-org00000c2" class="outline-3">
<h3 id="org00000c2"><span class="section-number-3">1.35.</span> toy-35: br_cc</h3>
<div class="outline-text-3" id="text-1-35">
<p>
br_cc 是条件跳转. br_cc 先通过 expand 转换成 brcond, 然后再用 blt 等指令匹配
brcond
</p>
</div>
</div>

<div id="outline-container-org00000c5" class="outline-3">
<h3 id="org00000c5"><span class="section-number-3">1.36.</span> toy-36: type promotion</h3>
<div class="outline-text-3" id="text-1-36">
<p>
目前的实现里 add 指令只支持 32 位, 为了支持 8/16 位的加法, llvm 的
DAGTypeLegalizer 会在 load/store 时进行 type promotion, 例如 store 时通过
truncate 把 i32 变成 i8, 或 load 时通过 sext 把 i8 变成 i32.
</p>

<p>
这里的 truncate, sext 信息包含在 load/store 中, 后端需要匹配这些 patten 生成
lb/sb 等指令.
</p>
</div>
</div>

<div id="outline-container-org00000c9" class="outline-3">
<h3 id="org00000c9"><span class="section-number-3">1.37.</span> toy-37: LowerCall Pt. 5</h3>
<div class="outline-text-3" id="text-1-37">
<p>
LowerCall 需要按约定把多余的参数放在栈上, LowerFormalArguments 需要从栈上取这些参数
</p>

<p>
caller 与 callee 的栈布局为:
</p>

<pre class="example" id="org00000c8">
caller:                  callee:

local_1                  local_1
local_2                  local_2
...                      ...
arg1
arg2 &lt;-- [sp]
</pre>

<p>
即 caller 把参数放在栈顶, callee 直接从 caller 的栈帧取参数, 对应的代码为:
</p>

<div class="org-src-container">
<pre class="src src-asm"><span class="org-function-name">bar</span>:
    <span class="org-keyword">addi</span>    sp, sp, -12                 # NOTE: bar &#30340; stack size &#20026; 12, &#20294;&#23427;&#35775;&#38382;&#20102; sp+12 &#21644; sp+16, &#21363; foo &#30340;&#26632;&#24103;
    <span class="org-keyword">lw</span>      t0, 16(sp)
    <span class="org-keyword">lw</span>      t0, 12(sp)
    <span class="org-keyword">sw</span>      a0, 8(sp)
    ...
<span class="org-function-name">foo</span>:                                    # @foo
    <span class="org-keyword">addi</span>    sp, sp, -16
    <span class="org-keyword">sw</span>      ra, 12(sp)
    <span class="org-keyword">addi</span>    a0, zero, 1
    <span class="org-keyword">addi</span>    a1, zero, 2
    <span class="org-keyword">addi</span>    a2, zero, 3
    <span class="org-keyword">addi</span>    t0, zero, 4
    <span class="org-keyword">sw</span>      t0, 0(sp)           # NOTE: foo &#30340; stack size &#21407;&#26469;&#20026; 8, &#30001;&#20110;&#21442;&#25968;&#20250;&#20351;
                                # &#29992; sp+0, sp+4, ..., &#23548;&#33268;&#38656;&#35201;&#22312;
                                # emitPrologue/emitEpilogue &#26102;&#35843;&#25972; stack
                                # size. &#21478;&#22806;&#20026;&#20102;&#36991;&#20813;&#19982;&#21407;&#26377; local &#21464;&#37327;&#20914;&#31361;, &#20250;&#22312;
                                # eliminateFrameIndex &#21152;&#19978;&#19968;&#20010; offset
    <span class="org-keyword">addi</span>    t0, zero, 5
    <span class="org-keyword">sw</span>      t0, 4(sp)
    <span class="org-keyword">call</span>    bar
    <span class="org-keyword">sw</span>      a0, 8(sp)
    <span class="org-keyword">lw</span>      a0, 8(sp)
    <span class="org-keyword">lw</span>      ra, 12(sp)
    <span class="org-keyword">addi</span>    sp, sp, 16
    <span class="org-keyword">ret</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org00000cc" class="outline-3">
<h3 id="org00000cc"><span class="section-number-3">1.38.</span> toy-38: glue</h3>
<div class="outline-text-3" id="text-1-38">
<p>
由于 call, ret 隐含着使用 a0, a1 等寄存器, 为了避免寄存器分配时对这些寄存器的错误的优化, 需要把它们也放在指令中, 同时使用 glue 把这些寄存器 glue 在一起, 防止
scheduler 错误的优化. 例如:
</p>

<p>
测试代码为:
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="org-type">void</span> <span class="org-function-name">bar</span>(<span class="org-type">int</span> <span class="org-variable-name">a</span>, <span class="org-type">int</span> <span class="org-variable-name">b</span>, <span class="org-type">int</span> <span class="org-variable-name">c</span>) {}
<span class="org-type">int</span> <span class="org-function-name">foo</span>(<span class="org-type">int</span> <span class="org-variable-name">a</span>, <span class="org-type">int</span> <span class="org-variable-name">b</span>) {
  bar(1, 2, 3);
  <span class="org-keyword">return</span> 1;
}
</pre>
</div>

<p>
若 LowerReturn 时没有标记 ret 需要使用 a0, 则会生成下面的代码:
</p>

<div class="org-src-container">
<pre class="src src-asm"><span class="org-function-name">foo</span>:                                    # @foo
# <span class="org-variable-name">%bb</span>.0:
        <span class="org-keyword">addi</span>    sp, sp, -16
        <span class="org-keyword">sw</span>      ra, 12(sp)
        <span class="org-keyword">sw</span>      s0, 8(sp)
        <span class="org-keyword">sw</span>      a0, 4(sp)
        <span class="org-keyword">sw</span>      a1, 0(sp)
        <span class="org-keyword">addi</span>    s0, zero, 1
        <span class="org-keyword">addi</span>    a1, zero, 2
        <span class="org-keyword">addi</span>    a2, zero, 3
        <span class="org-keyword">add</span>     a0, zero, s0
        <span class="org-keyword">call</span>    bar
        # NOTE: ret &#21069;&#23545; a0 &#30340;&#36171;&#20540;&#28040;&#22833;&#20102;
        <span class="org-keyword">lw</span>      s0, 8(sp)
        <span class="org-keyword">lw</span>      ra, 12(sp)
        <span class="org-keyword">addi</span>    sp, sp, 16
        <span class="org-keyword">ret</span>
</pre>
</div>

<p>
若 LowerCall 时没有记录 call 使用了 a0, 则生成下面的代码:
</p>

<div class="org-src-container">
<pre class="src src-asm"><span class="org-function-name">foo</span>:
    <span class="org-keyword">addi</span>    sp, sp, -12
    <span class="org-keyword">sw</span>      ra, 8(sp)
    <span class="org-keyword">sw</span>      a0, 4(sp)
    <span class="org-keyword">sw</span>      a1, 0(sp)
    # NOTE: a2 &#30340;&#36171;&#20540;&#28040;&#22833;&#20102;
    <span class="org-keyword">call</span>    bar
    <span class="org-keyword">addi</span>    a0, zero, 1
    <span class="org-keyword">lw</span>      ra, 8(sp)
    <span class="org-keyword">addi</span>    sp, sp, 12
    <span class="org-keyword">ret</span>
</pre>
</div>

<p>
只记录寄存器的使用并不能完全正常工作, 还需要 glue 把 ret 和 a0 glue 在一起, 没有
glue 时, 可能会生成这样的代码:
</p>

<div class="org-src-container">
<pre class="src src-asm"><span class="org-function-name">foo</span>:
    # ...
    <span class="org-keyword">addi</span>    a0, zero, 1
    <span class="org-keyword">lw</span>      ra, 8(sp)
    <span class="org-keyword">addi</span>    sp, sp, 12
    # NOTE: call &#24212;&#35813;&#22312; addi &#20043;&#21069;, &#20294; ret &#21644; a0 &#38388;&#27809;&#26377; glue &#21487;&#33021;&#23548;&#33268;&#36825;&#31181;&#38169;&#35823;&#30340;&#32467;
    # &#26524;
    <span class="org-keyword">call</span>    bar
    <span class="org-keyword">ret</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org00000cf" class="outline-3">
<h3 id="org00000cf"><span class="section-number-3">1.39.</span> toy-39: soft float</h3>
<div class="outline-text-3" id="text-1-39">
<p>
toy 当前不支持 hard float, 导致 legalize 时会通过 libcall 的形式调用到 libgcc 中的函数
</p>
</div>
</div>

<div id="outline-container-org00000d2" class="outline-3">
<h3 id="org00000d2"><span class="section-number-3">1.40.</span> toy-40: return struct</h3>
<div class="outline-text-3" id="text-1-40">
<p>
返回结构体时有两种做法:
</p>

<ol class="org-ol">
<li>当结构体较小时使用多个寄存器返回</li>

<li>当结构体较大时会传入一个隐式的指向结构体的指针, 即 named return value 优化</li>
</ol>

<p>
clang 在生成 llir 时就会根据传入的 target 信息决定用哪种方法.
</p>

<p>
当使用第二种方法时, caller 需要实现 `set rd, frameindex` 这个 patten, 用来传递结构体指针 (而不是之前实现的 `set rd, (load frameindex)`
</p>
</div>
</div>

<div id="outline-container-org00000d5" class="outline-3">
<h3 id="org00000d5"><span class="section-number-3">1.41.</span> toy-41: hard float Pt. 1</h3>
<div class="outline-text-3" id="text-1-41">
<p>
支持硬浮点需要:
</p>

<ol class="org-ol">
<li>通过 `addRegisterClass(MVT::f32, &amp;Toy::FPRRegClass)` 告诉 llvm 在 legalize
type (LegalizeTypes.cpp) 时不要使用软浮点</li>

<li>添加浮点寄存器</li>

<li>在 isel lowering 时处理 constant pool, 因为浮点数常量是使用的 constant pool,
而不是像整数常量那样直接 encode 在指令中</li>

<li>添加指令及其 pattern, 当前的 `float.c` 中需要实现 fadd, load, store, brcond
及 setune. 由于 RISC-V 缺少 f32 br_cc (blt, beq, &#x2026;) 指令, 所以 f32 br_cc 会使用 f32 setcc 和 i32 br_cc 实现</li>
</ol>
</div>
</div>

<div id="outline-container-org00000d8" class="outline-3">
<h3 id="org00000d8"><span class="section-number-3">1.42.</span> toy-42: hard float Pt. 2</h3>
<div class="outline-text-3" id="text-1-42">
<p>
加入基本的 f64 寄存器和指令.
</p>

<p>
当处理 `float x=0.1` 时, 后端需要支持 truncstoref32. truncstoref32 实际做了两件事:
</p>

<ol class="org-ol">
<li>把 f64 truncate 成 f32</li>
<li>保存 f32 到内存</li>
</ol>

<p>
riscv 中没有对应的指令, 需要用到 `setTruncStoreAction(MVT::f64, MVT::f32,
Expand)`, 让 llvm 把它 expand 成 fround 和 store 两个指令, 分别对应 riscv 的
fcvt.s.d 和 fsw 指令
</p>
</div>
</div>

<div id="outline-container-org00000e3" class="outline-3">
<h3 id="org00000e3"><span class="section-number-3">1.43.</span> toy-43: builtin Pt. 1</h3>
<div class="outline-text-3" id="text-1-43">
<p>
以 fma 和 fmaxf 为例
</p>
</div>

<div id="outline-container-org00000dd" class="outline-4">
<h4 id="org00000dd"><span class="section-number-4">1.43.1.</span> fma</h4>
<div class="outline-text-4" id="text-1-43-1">
<p>
clang 会发现代码可以转换为 fma, 会把它转换为 fmuladd 的 instrinsic, 然后
SelectionDAGBuilder::visitIntrinsicCall 会负责把它转换为 fma 指令. 但如果
isFMAFasterThanFMulAndFAdd 为 false, 则会转换为 fmul 和 fadd, 而不是 fma 指令.
</p>

<p>
因为实现 fma 有两种做法:
</p>

<ol class="org-ol">
<li><p>
定义 isFMAFasterThanFMulAndFAdd 返回 true, 并实现 fma 指令
</p>

<pre class="example" id="org00000db">
def FMADDS : InstR&lt;(outs FPR:$rd), (ins FPR:$rs1, FPR:$rs2, FPR: $rs3),
      "fmadd.s\t$rd, $rs1, $rs2, $rs3",
      [(set FPR:$rd, (fma FPR:$rs1, FPR:$rs2, FPR:$rs3))],
      IIAlu&gt;;
</pre></li>

<li><p>
在 td 中直接匹配复杂的 pattern:
</p>

<pre class="example" id="org00000dc">
def FMADDS : InstR&lt;(outs FPR:$rd), (ins FPR:$rs1, FPR:$rs2, FPR:$rs3),
      "fmadd.s\t$rd, $rs1, $rs2, $rs3",
      [(set FPR:$rd, (fadd (fmul FPR:$rs1,FPR:$rs2), FPR:$rs3))],
      IIAlu&gt;;
</pre></li>
</ol>
</div>
</div>

<div id="outline-container-org00000e0" class="outline-4">
<h4 id="org00000e0"><span class="section-number-4">1.43.2.</span> fmaxf</h4>
<div class="outline-text-4" id="text-1-43-2">
<p>
__builtin_fmaxf 在 visitIntrinsicCall 会转换为 fmaxnum, 但 TargetLoweringBase 默认把 fmaxnum 的 action 设置为 expand, 因此需要 setOperationAction 为 Legal 后再实现 fmaxnum 指令
</p>
</div>
</div>
</div>

<div id="outline-container-org00000e6" class="outline-3">
<h3 id="org00000e6"><span class="section-number-3">1.44.</span> toy-44: write object file Pt. 1</h3>
<div class="outline-text-3" id="text-1-44">
<p>
<a href="https://blog.llvm.org/2010/04/intro-to-llvm-mc-project.html">https://blog.llvm.org/2010/04/intro-to-llvm-mc-project.html</a>
</p>

<p>
MCInst 在整个 MC 层处于中心的位置:
</p>

<p>
MCInstPrinter:     把 MCInst 转换为 asm
MCCodeEmitter:     把 MCInst 转换为 binary
MCTargetAsmParser: 把 asm    转换为 MCInst
MCDisassembler:    把 binary 转换为 MCInst
</p>

<p>
目前的实现都是 stub, `make xxx.o` 可以生成一个空的 obj 文件
</p>
</div>
</div>

<div id="outline-container-org00000e9" class="outline-3">
<h3 id="org00000e9"><span class="section-number-3">1.45.</span> toy-45: write object file Pt. 2</h3>
<div class="outline-text-3" id="text-1-45">
<p>
支持 I 指令 (addi, lw&#x2026;), S 指令 (sw, &#x2026;) 和 R 指令 (add, sub, &#x2026;) 的 encoding
</p>

<p>
去掉了针对 AddrFI 的 mem operand. 由于 I 指令中关于 imm 编码的特殊性, 目前无法实现其 EncoderMethod. 对于通过 ComplexPattern 匹配的 operand, 实际上可以通过
`[(load GPR:$rs2, (AddrFI GPR:$rs1, imm12:$imm))]` 的形式使用, 无需使用 mem 这种
operand
</p>

<p>
`make arith.o` 产生的 object 除了伪指令 ret, 其它都是正确的.
</p>
</div>
</div>

<div id="outline-container-org00000ec" class="outline-3">
<h3 id="org00000ec"><span class="section-number-3">1.46.</span> toy-46: write object file Pt. 3</h3>
<div class="outline-text-3" id="text-1-46">
<p>
目前使用伪指令实现 RET 和 CALL, 在输出 asm 比较容易, 但没有考虑 encoding 的问题.
</p>

<p>
RET 转换成 jalr 比较容易, 它直接对应了 `jalr zero, 0(ra)`.
</p>

<p>
CALL 转换 jalr 时由于涉及到 symbol 的问题, 需要转换为 `lui t0, %hi(addr); addi
t0, %lo(addr); jarl ra, 0(t0)`, 其中 hi/lo 需要转换为 fixup 信息 (类型, 原指令需要被 patch 的 offset 和长度) 保存在 object 中 <a href="linker_relocation.html#ID-4fabbae2-594b-4f7d-bcb9-756212cfbe9f">Linker Relocation</a>
</p>

<p>
`make run_arith BINARY=1` 可以正常运行, 但还剩几个伪指令 (j, lea, &#x2026;) 和 branch
没有处理
</p>
</div>
</div>

<div id="outline-container-org00000ef" class="outline-3">
<h3 id="org00000ef"><span class="section-number-3">1.47.</span> toy-47: write object file Pt. 4</h3>
<div class="outline-text-3" id="text-1-47">
<p>
j 指令需要使用 jal 实现, 并使用 jal 类型的 fixup
</p>

<p>
branch 指令和 jal 类似, 但使用 branch 的 fixup
</p>

<p>
`make run BINARY=1` 现在都能正常运行.
</p>
</div>
</div>

<div id="outline-container-org00000f2" class="outline-3">
<h3 id="org00000f2"><span class="section-number-3">1.48.</span> toy-48: li</h3>
<div class="outline-text-3" id="text-1-48">
<p>
li 伪指令用来把 imm 赋值给 gpr, 如果 imm 为 imm12, 可以用 `addi` 实现, 否则需要用 `lui` 和 `addi` 来实现.
</p>

<p>
需要注意的是针对 imm 获得 lui 需要的高 20 位并不能直接取高 20 位, 因为低 12 位送给 addi
时有可能被当做负数.
</p>

<p>
例如 imm = 0x1fff, RISCV_CONST_HIGH_PART(imm) 宏返回 0x2000, 而不是 0x1000, 因为低 12 位 0xfff 在 addi 时会 sext 成负数
</p>
</div>
</div>

<div id="outline-container-org00000f7" class="outline-3">
<h3 id="org00000f7"><span class="section-number-3">1.49.</span> toy-49: intrinsics</h3>
<div class="outline-text-3" id="text-1-49">
<p>
为了添加一个 intrinsic, 需要同时修改 clang 和 llvm
</p>

<ol class="org-ol">
<li><p>
clang
</p>

<p>
clang 需要把 c 代码中的 `__builtin_xxx` 转换成 llir 中的 `@llvm.xxx`
</p>

<p>
intrinsic 定义在 BUiltins{xxx}.def 中.
</p>

<p>
clang 的 CGBuiltin.cpp 在处理 intrinsic 时需要决定是否生成 @llvm.&lt;target&gt;.xxx
形式的 intrinsic 调用. c 代码中的 __builtin_xxx 并不一定都会转换为 llvm
instrinsic, 有的会转换为 libcall. 例如
</p>

<pre class="example" id="org00000f5">
# clang/Basic/Builtins.def
LIBBUILTIN(sqrt, "dd", "fne", MATH_H, ALL_LANGUAGES)
</pre>

<p>
中通过 `e` 表示 sqrt 可能会出错, 需要返回 errno (例如输入为负数), 这时只能交给 libcall 处理. 所以 c 代码中的 `__builtin_sqrtf` 或 `sqrtf` 不会转换为
`@llvm.sqrt.f32` (除非使用了 -fno-math-error 等 flag, 参考
CGBuiltin.cpp::ConstWithoutErrnoAndExceptions)
</p></li>

<li><p>
llvm
</p>

<p>
llvm 需要把 `@llvm.xxx` 形式的 llvm intrinsic lower 成最终的指令.
</p>

<p>
llvm 需要修改 Instrinsics.td, intrinsic 的名字有特定的要求, 例如 td 中定义的
intrinsic 为 int_&lt;target&gt;_xxx, llir 中对应的是 `@llvm.&lt;target&gt;.xxx`.
</p>

<p>
另外, intrinsic 可以重载, 例如:
</p>

<pre class="example" id="org00000f6">
def int_fabs : DefaultAttrsIntrinsic&lt;[llvm_anyfloat_ty], [LLVMMatchType&lt;0&gt;]&gt;;
</pre>

<p>
其中的 anyfloat 会导致 llir 中可以使用 `@llvm.fabs.f32`, `@llvm.fabs.f64`
</p>

<p>
最后需要添加 intrinsic 对应的 lowering, 可以直接在 td 中匹配
`int_toy_getsp`这种 patten, 也可以参考 LowerINTRINSIC_WO_CHAIN 使用 custom 的
lowering
</p></li>
</ol>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

<p class="author">Author: <a href="mailto:sunway@dogdog.run">sunway@dogdog.run</a><br />
Date: 2023-05-19 Fri 14:00<br />
Last updated: 2023-07-05 Wed 17:41</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
</div>
</body>
</html>
