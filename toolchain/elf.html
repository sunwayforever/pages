<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>ELF</title>

<link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
<link rel="stylesheet" type="text/css" href="../main.css" media="screen" />
<link rel="stylesheet" type="text/css" href="./main.css" media="screen" />
<link rel = "icon" href = "/icon.png"  type = "image/x-icon">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">ELF</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org0000112">1. ELF</a>
<ul>
<li><a href="#org0000002">1.1. ELF Format</a></li>
<li><a href="#org00000b1">1.2. ELF Section</a>
<ul>
<li><a href="#org0000005">1.2.1. Elf Section</a></li>
<li><a href="#org0000013">1.2.2. init</a></li>
<li><a href="#org0000016">1.2.3. finit</a></li>
<li><a href="#org0000023">1.2.4. init_array</a></li>
<li><a href="#org0000026">1.2.5. finit_array</a></li>
<li><a href="#org0000029">1.2.6. symtab</a></li>
<li><a href="#org000002c">1.2.7. dynsym</a></li>
<li><a href="#org0000030">1.2.8. strtab</a></li>
<li><a href="#org0000033">1.2.9. dynstr</a></li>
<li><a href="#org0000036">1.2.10. interp</a></li>
<li><a href="#org0000047">1.2.11. got</a></li>
<li><a href="#org0000051">1.2.12. plt</a></li>
<li><a href="#org0000054">1.2.13. got.plt</a></li>
<li><a href="#org000005b">1.2.14. rel.dyn</a></li>
<li><a href="#org000005f">1.2.15. rel.plt</a></li>
<li><a href="#org000006d">1.2.16. rela.dyn</a></li>
<li><a href="#org0000070">1.2.17. rela.plt</a></li>
<li><a href="#org0000073">1.2.18. eh_frame</a></li>
<li><a href="#org0000076">1.2.19. text</a></li>
<li><a href="#org0000079">1.2.20. data</a></li>
<li><a href="#org000007c">1.2.21. rodata</a></li>
<li><a href="#org000007f">1.2.22. bss</a></li>
<li><a href="#org0000082">1.2.23. data.rel.ro</a></li>
<li><a href="#org000008b">1.2.24. summary</a></li>
<li><a href="#org000009c">1.2.25. hash</a></li>
<li><a href="#org000009f">1.2.26. gnu.hash</a></li>
<li><a href="#org00000a3">1.2.27. gnu.version</a></li>
<li><a href="#org00000a7">1.2.28. gnu.version_d</a></li>
<li><a href="#org00000ab">1.2.29. gnu.version_r</a></li>
<li><a href="#org00000ae">1.2.30. dynamic</a></li>
</ul>
</li>
<li><a href="#org00000d3">1.3. ELF Segment</a>
<ul>
<li><a href="#org00000c0">1.3.1. Elf Segment</a></li>
<li><a href="#org00000c3">1.3.2. PT_LOAD</a></li>
<li><a href="#org00000c6">1.3.3. PT_DYNAMIC</a></li>
<li><a href="#org00000c9">1.3.4. PT_NOTE</a></li>
<li><a href="#org00000cd">1.3.5. PT_GNU_RELRO</a></li>
<li><a href="#org00000d0">1.3.6. PT_PHDR</a></li>
</ul>
</li>
<li><a href="#org000010c">1.4. .dynamic</a>
<ul>
<li><a href="#org00000d7">1.4.1. elf_dynamic</a></li>
<li><a href="#org00000dc">1.4.2. DT_SYMBOLIC</a></li>
<li><a href="#org00000df">1.4.3. DT_HASH</a></li>
<li><a href="#org00000e2">1.4.4. DT_GNU_HASH</a></li>
<li><a href="#org00000e5">1.4.5. DT_NEEDED</a></li>
<li><a href="#org00000e8">1.4.6. DT_INIT</a></li>
<li><a href="#org00000eb">1.4.7. DT_INIT_ARRAY</a></li>
<li><a href="#org00000ee">1.4.8. DT_REL</a></li>
<li><a href="#org00000f1">1.4.9. DT_JMPREL</a></li>
<li><a href="#org00000f4">1.4.10. DT_RUNPATH</a></li>
<li><a href="#org00000f7">1.4.11. DT_PLTGOT</a></li>
<li><a href="#org00000fa">1.4.12. DT_STRTAB</a></li>
<li><a href="#org00000fd">1.4.13. DT_SYMTAB</a></li>
<li><a href="#org0000100">1.4.14. DT_SONAME</a></li>
<li><a href="#org0000103">1.4.15. DT_FLAGS_1</a></li>
<li><a href="#org0000106">1.4.16. DF_1_GLOBAL</a></li>
<li><a href="#org0000109">1.4.17. DF_1_NOW</a></li>
</ul>
</li>
<li><a href="#org000010f">1.5. reference</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org0000112" class="outline-2">
<h2 id="org0000112"><span class="section-number-2">1</span> ELF</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org0000002" class="outline-3">
<h3 id="org0000002"><span class="section-number-3">1.1</span> ELF Format</h3>
<div class="outline-text-3" id="text-1-1">
<p>
ELF 格式的主要结构为:
</p>

<ol class="org-ol">
<li>ELF Header (ehdr)</li>
<li>Program Header (phdr)</li>
<li>segments / sections (content)</li>
<li>Section Header (shdr)</li>
</ol>

<p>
elf 文件在磁盘上的布局为:
</p>

<pre class="example" id="org0000000">

+-------------------------------+
| ELF File Header               |
+-------------------------------+
| Program Header for segment #1 |
+-------------------------------+
| Program Header for segment #2 |
+-------------------------------+
| ...                           |
+-------------------------------+
| Contents (Byte Stream)        |
| ...                           |
+-------------------------------+
| Section Header for section #1 |
+-------------------------------+
| Section Header for section #2 |
+-------------------------------+
| ...                           |
+-------------------------------+
| ".shstrtab" section           |
+-------------------------------+
| ".symtab"   section           |
+-------------------------------+
| ".strtab"   section           |
+-------------------------------+

</pre>

<p>
由于 elf 同时需要为 linker 和 loader 服务, 而两者关注的内容并不相同:
</p>

<ol class="org-ol">
<li>linker 关注 section header 和 section, 这些内容和 link 有关</li>
<li>loader 关注 segment header 和 segment, 这些内容需要加载到内存, 和
load 有关</li>
</ol>

<p>
section 和 segment 实际上对应的都是同一块 content 的内容, 所以从概念上,
elf 有 liner 和 loader 的角度有两种不同的 view:
</p>

<pre class="example" id="org0000001">
             +-----------------+
        +----| ELF File Header |----+
        |    +-----------------+    |
        v                           v
+-----------------+      +-----------------+
| Program Headers |      | Section Headers |
+-----------------+      +-----------------+
     ||                               ||
     ||                               ||
     ||                               ||
     ||   +------------------------+  ||
     +--&gt; | Contents (Byte Stream) |&lt;--+
          +------------------------+
</pre>
</div>
</div>

<div id="outline-container-org00000b1" class="outline-3">
<h3 id="org00000b1"><span class="section-number-3">1.2</span> ELF Section</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-org0000005" class="outline-4">
<h4 id="org0000005"><span class="section-number-4">1.2.1</span> Elf Section</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
section 的格式:
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-keyword">typedef</span> <span class="org-keyword">struct</span> <span class="org-type">elf32_shdr</span> {
  <span class="org-type">Elf32_Word</span> <span class="org-variable-name">sh_name</span>;           <span class="org-comment-delimiter">/* </span><span class="org-comment">&#30456;&#23545;&#20110; .shstrtab &#30340; offset</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">Elf32_Word</span> <span class="org-variable-name">sh_type</span>;
  <span class="org-type">Elf32_Word</span> <span class="org-variable-name">sh_flags</span>;
  <span class="org-type">Elf32_Addr</span> <span class="org-variable-name">sh_addr</span>;           <span class="org-comment-delimiter">/* </span><span class="org-comment">memory address</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">Elf32_Off</span> <span class="org-variable-name">sh_offset</span>;          <span class="org-comment-delimiter">/* </span><span class="org-comment">file offset</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">Elf32_Word</span> <span class="org-variable-name">sh_size</span>; 
  <span class="org-type">Elf32_Word</span> <span class="org-variable-name">sh_link</span>;
  <span class="org-type">Elf32_Word</span> <span class="org-variable-name">sh_info</span>;
  <span class="org-type">Elf32_Word</span> <span class="org-variable-name">sh_addralign</span>;
  <span class="org-type">Elf32_Word</span> <span class="org-variable-name">sh_entsize</span>;
} <span class="org-type">Elf32_Shdr</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-org0000013" class="outline-4">
<h4 id="org0000013"><span class="section-number-4">1.2.2</span> init</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
init section 保存的是 init 时要执行的函数 (而不是函数指针), 但现在看来
init section 应该慎重使用, 各种平台和编译器 (linker?) 对它的支持都不太相同. 例如:
</p>

<ol class="org-ol">
<li>glibc 定义了自己的 .init section, 代码再修改 .init 的话会有
segmentation fault.</li>

<li>arm 没有定义 .init section, 代码可以自由修改, 但 dynamic 里并没有
DT_INIT 项, 所以 .init 不会被调用</li>

<li>arm 通过 -Wl,-init 可以把 DT_INIT 指向 init 函数, 但它并没有把 init
函数放在 .init section 中</li>
</ol>
</div>

<div id="outline-container-org0000008" class="outline-5">
<h5 id="org0000008"><span class="section-number-5">1.2.2.1</span> sample code</h5>
<div class="outline-text-5" id="text-1-2-2-1">
<div class="org-src-container">
<pre class="src src-c"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-keyword">__attribute__</span>((section (<span class="org-string">".init"</span>))) <span class="org-type">void</span> <span class="org-function-name">test</span>() {
    printf(<span class="org-string">"hello world!\n"</span>);
}

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
    printf(<span class="org-string">"main: %p\n"</span>, &amp;main);
    <span class="org-keyword">return</span> 0;
}

</pre>
</div>
</div>
</div>

<div id="outline-container-org000000c" class="outline-5">
<h5 id="org000000c"><span class="section-number-5">1.2.2.2</span> arm_linux_androideabi-gcc</h5>
<div class="outline-text-5" id="text-1-2-2-2">
<pre class="example" id="org000000b">
$&gt; ./a.out
main: 0xb662e3b4

$&gt; arm-linux-androideabi-readelf -a ./a.out

Dynamic section at offset 0xec8 contains 28 entries:
  Tag        Type                         Name/Value
 0x00000003 (PLTGOT)                     0x1fe4
 0x00000002 (PLTRELSZ)                   32 (bytes)
 0x00000017 (JMPREL)                     0x340
 0x00000014 (PLTREL)                     REL
 0x00000011 (REL)                        0x318
 0x00000012 (RELSZ)                      40 (bytes)
 0x00000013 (RELENT)                     8 (bytes)
 0x6ffffffa (RELCOUNT)                   5
 0x00000015 (DEBUG)                      0x0
 0x00000006 (SYMTAB)                     0x1e0
 0x0000000b (SYMENT)                     16 (bytes)
 0x00000005 (STRTAB)                     0x260
 0x0000000a (STRSZ)                      84 (bytes)
 0x00000004 (HASH)                       0x2b4
 0x00000001 (NEEDED)                     Shared library: [libc.so]
 0x00000001 (NEEDED)                     Shared library: [libdl.so]
 0x0000001a (FINI_ARRAY)                 0x1ea8
 0x0000001c (FINI_ARRAYSZ)               8 (bytes)
 0x00000019 (INIT_ARRAY)                 0x1eb0
 0x0000001b (INIT_ARRAYSZ)               16 (bytes)
 0x00000020 (PREINIT_ARRAY)              0x1ec0
 0x00000021 (PREINIT_ARRAYSZ)            0x8
 0x0000001e (FLAGS)                      BIND_NOW
 0x6ffffffb (FLAGS_1)                    Flags: NOW
 0x6ffffff0 (VERSYM)                     0x2e8
 0x6ffffffe (VERNEED)                    0x2f8
 0x6fffffff (VERNEEDNUM)                 1
 0x00000000 (NULL)                       0x0

// 并不包含 DT_INIT, 所以 .init section 中的函数不会被 loader 调用
</pre>
</div>
</div>

<div id="outline-container-org0000010" class="outline-5">
<h5 id="org0000010"><span class="section-number-5">1.2.2.3</span> gcc on x86_64</h5>
<div class="outline-text-5" id="text-1-2-2-3">
<p>
gcc on x86_64 本身已经使用了 .init section 来做某种初始化动作, 应用自己再设置 .init 会有问题
</p>

<pre class="example" id="org000000f">
$&gt; ./a.out
hello world!
Segmentation fault (core dumped)

$&gt; objdump -D ./a.out
Disassembly of section .init:

0000000000400400 &lt;_init&gt;:
  400400:	48 83 ec 08          	sub    $0x8,%rsp
  400404:	48 8b 05 ed 0b 20 00 	mov    0x200bed(%rip),%rax        # 600ff8 &lt;__gmon_start__&gt;
  40040b:	48 85 c0             	test   %rax,%rax
  40040e:	74 02                	je     400412 &lt;test&gt;
  400410:	ff d0                	callq  *%rax

0000000000400412 &lt;test&gt;:
  400412:	55                   	push   %rbp
  400413:	48 89 e5             	mov    %rsp,%rbp
  400416:	bf f4 05 40 00       	mov    $0x4005f4,%edi
  40041b:	e8 20 00 00 00       	callq  400440 &lt;puts@plt&gt;
  400420:	90                   	nop
  400421:	5d                   	pop    %rbp
  400422:	c3                   	retq   
  400423:	48 83 c4 08          	add    $0x8,%rsp
  400427:	c3                   	retq   


</pre>
</div>
</div>
</div>

<div id="outline-container-org0000016" class="outline-4">
<h4 id="org0000016"><span class="section-number-4">1.2.3</span> finit</h4>
</div>

<div id="outline-container-org0000023" class="outline-4">
<h4 id="org0000023"><span class="section-number-4">1.2.4</span> init_array</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
init_array section 中保存的是函数指针.
</p>
</div>

<div id="outline-container-org000001b" class="outline-5">
<h5 id="org000001b"><span class="section-number-5">1.2.4.1</span> 使用 init_array</h5>
<div class="outline-text-5" id="text-1-2-4-1">
<div class="org-src-container">
<pre class="src src-c"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">void</span> <span class="org-function-name">test</span>() {
    printf(<span class="org-string">"hello world!\n"</span>);
}

<span class="org-type">void</span> (*<span class="org-function-name">x</span>) () <span class="org-keyword">__attribute__</span>((section (<span class="org-string">".init_array"</span>))) = test;
<span class="org-type">void</span> (*<span class="org-function-name">y</span>) () <span class="org-keyword">__attribute__</span>((section (<span class="org-string">".init_array"</span>))) = test;

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
    printf(<span class="org-string">"main: %p, %p\n"</span>, &amp;main, &amp;test);
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<pre class="example" id="org0000019">
$&gt; arm-linux-androideabi-gcc test.c -fPIE -pie -O3 -g3
$&gt; ./a.out
hello world!
hello world!
main: 0xb42933b4, 0xb4293490
</pre>

<pre class="example" id="org000001a">
$&gt; arm-linux-androideabi-objdump -D a.out

Disassembly of section .init_array:

00001ea8 &lt;__INIT_ARRAY__&gt;:
    1ea8:	ffffffff 			; &lt;UNDEFINED&gt; instruction: 0xffffffff

00001eac &lt;y&gt;:
    1eac:	00000490 	muleq	r0, r0, r4

00001eb0 &lt;x&gt;:
    1eb0:	00000490 	muleq	r0, r0, r4
    1eb4:	00000000 	andeq	r0, r0, r0


...

00000490 &lt;test&gt;:
 490:	e59f0004 	ldr	r0, [pc, #4]	; 49c &lt;test+0xc&gt;
 494:	e08f0000 	add	r0, pc, r0
 498:	eaffffbf 	b	39c &lt;puts@plt&gt;
 49c:	00000004 	andeq	r0, r0, r4
</pre>

<p>
另外, 使用 PIE 后 init_array 中的数据 (函数指针) 需要被 linker 重定位,
init_array 所处的 PT_LOAD segment 与 got, data, bss 等相同, 是可写的.
</p>
</div>
</div>

<div id="outline-container-ID-58a07f96-81c5-4c92-8e49-68bca0dfafb9" class="outline-5">
<h5 id="ID-58a07f96-81c5-4c92-8e49-68bca0dfafb9"><span class="section-number-5">1.2.4.2</span> constructor</h5>
<div class="outline-text-5" id="text-1-2-4-2">
<p>
gcc 的 constructor attribute 是通过 init_array 实现的
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-keyword">__attribute__</span>((constructor)) <span class="org-type">void</span> <span class="org-function-name">test</span>() {
    printf(<span class="org-string">"hello world!\n"</span>);
}

<span class="org-keyword">__attribute__</span>((constructor)) <span class="org-type">void</span> <span class="org-function-name">test2</span> () {
    printf(<span class="org-string">"hello world2!\n"</span>);
}

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
    printf(<span class="org-string">"main: %p, %p\n"</span>, &amp;main, &amp;test);
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<pre class="example" id="org000001e">
$&gt; ./a.out
hello world!
hello world2!
main: 0xba82c3c4, 0xba82c3b4

$&gt; arm-linux-androideabi-objdump -D ./a.out
Disassembly of section .init_array:

00001ea8 &lt;__INIT_ARRAY__&gt;:
    1ea8:	ffffffff 			; &lt;UNDEFINED&gt; instruction: 0xffffffff
    1eac:	000003b4 			; &lt;UNDEFINED&gt; instruction: 0x000003b4
    1eb0:	000003f8 	strdeq	r0, [r0], -r8
    1eb4:	00000000 	andeq	r0, r0, r0

000003f8 &lt;test2&gt;:
 3f8:	e59f0004 	ldr	r0, [pc, #4]	; 404 &lt;test2+0xc&gt;
 3fc:	e08f0000 	add	r0, pc, r0
 400:	eaffffe5 	b	39c &lt;puts@plt&gt;
 404:	000000cc 	andeq	r0, r0, ip, asr #1
</pre>
</div>
</div>

<div id="outline-container-org0000020" class="outline-5">
<h5 id="org0000020"><span class="section-number-5">1.2.4.3</span> init_array 如何被调用</h5>
<div class="outline-text-5" id="text-1-2-4-3">
<ol class="org-ol">
<li>so 中的 init_array 需要依赖 runtime linker <a href="android_linker.html#org0000001">linker_so.call_constructors</a></li>

<li><p>
主程序的 init_array 由 startfiles (crt0.o) 提供的 _start 去调用, 所以使用了
nostartfiles 编译的程序无法通过 init_array 完成 constructor 的动作 <a href="bare_metal.html#org000000c">crt0.o</a>
</p>

<pre class="example" id="org000001f">
#0  0x000055555555520c in A::A() ()
#1  0x00005555555551d8 in __static_initialization_and_destruction_0(int, int) ()
#2  0x000055555555520a in _GLOBAL__sub_I_a ()
#3  0x000055555555527d in __libc_csu_init ()
#4  0x00007ffff7dcf040 in __libc_start_main (main=0x555555555180 &lt;main&gt;, argc=1, argv=0x7fffffffc868, init=0x555555555230 &lt;__libc_csu_init&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, 
    stack_end=0x7fffffffc858) at ../csu/libc-start.c:264
#5  0x000055555555508e in _start ()
(gdb) 
</pre>

<p>
__libc_csu_init 的实现与下面的代码基本相同的:
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">void</span> <span class="org-function-name">call_init_array</span>() {
    <span class="org-keyword">typedef</span> <span class="org-type">void</span> (*<span class="org-type">FP</span>)();
    <span class="org-keyword">extern</span> <span class="org-type">FP</span> <span class="org-variable-name">__init_array_start</span>;
    <span class="org-keyword">extern</span> <span class="org-type">FP</span> <span class="org-variable-name">__init_array_end</span>;

    <span class="org-keyword">for</span> (<span class="org-type">FP</span> *<span class="org-variable-name">p</span> = &amp;__init_array_start; p &lt; &amp;__init_array_end; p++) {
        (*p)();
    }
}
</pre>
</div>

<p>
即它会依赖 __init_array_start 和 __init_array_end 符号, 如果在 linker script
中修改了这两个符号, 就可以影响 init_array 的执行
</p></li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org0000026" class="outline-4">
<h4 id="org0000026"><span class="section-number-4">1.2.5</span> finit_array</h4>
</div>

<div id="outline-container-org0000029" class="outline-4">
<h4 id="org0000029"><span class="section-number-4">1.2.6</span> symtab</h4>
<div class="outline-text-4" id="text-1-2-6">
<p>
<a href="https://blogs.oracle.com/ali/entry/inside_elf_symbol_tables">Inside ELF Symbol Tables</a>
</p>

<p>
symtab 与 dynsym 都是 symbol table, 格式相同:
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-keyword">struct</span> <span class="org-type">Elf32_Sym</span> {
  <span class="org-type">Elf32_Word</span>    <span class="org-variable-name">st_name</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">Symbol name (index into string table)</span>
  <span class="org-type">Elf32_Addr</span>    <span class="org-variable-name">st_value</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Value or address associated with the symbol</span>
  <span class="org-type">Elf32_Word</span>    <span class="org-variable-name">st_size</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">Size of the symbol</span>
  <span class="org-type">unsigned</span> <span class="org-type">char</span> <span class="org-variable-name">st_info</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">Symbol's type and binding attributes</span>
  <span class="org-type">unsigned</span> <span class="org-type">char</span> <span class="org-variable-name">st_other</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Must be zero; reserved</span>
  <span class="org-type">Elf32_Half</span>    <span class="org-variable-name">st_shndx</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Which section (header table index) it's defined in</span>
};
</pre>
</div>

<p>
elf 中和 symbol 相关的有四个 section:
</p>

<ol class="org-ol">
<li>dynsym</li>
<li>dynstr</li>
<li>symtab</li>
<li>strtab</li>
</ol>

<p>
其中 dynsym 和 dynstr 在运行阶段给 loader 使用, symtab 和 strtab 是链接阶段给 linker 使用的, 并且包含一些 debug 信息给 debugger 使用. 
</p>

<p>
symtab 中引用的名字位于 strtab 中, 而 dynsym 中引用的名字位于 dynstr 中.
</p>

<p>
strip 命令默认会删除掉 symtab 和 strtab 以及 dwarf 相关的 section. 但不会影响
dynsym 和 dynstr, 所以:
</p>

<ol class="org-ol">
<li>被 strip 了的 so 不影响它的 dynamic linking, 也不影响 gdb 看到它定义的 global symbol, 因为它们都定义在 dynsym 中.</li>

<li><p>
被 strip 了的 relocatable file 无法被 linker 使用, 例如:
</p>

<div class="org-src-container">
<pre class="src src-text">$gcc -c test.c
$strip test.o
$gcc main.c test.o
main.c:(.text+0x15): undefined reference to `foo'
</pre>
</div></li>

<li><p>
被 strip 了的 executable file 通过 gdb 无法看到那些非 so 中定义的
symbol, 例如:
</p>

<div class="org-src-container">
<pre class="src src-text">$gcc -shared -fPIC -o libtest.so
$gcc main.c -L. -ltest
$strip /a.out
$gdb /a.out
(gdb) b foo
Breakpoint 1 at 0x400500
(gdb) b main
Function "main" not defined.
</pre>
</div></li>
</ol>

<p>
dynsym 中既包含自己定义的符号, 也包括自己引用的其他 so 中的符号, 例如:
</p>

<div class="org-src-container">
<pre class="src src-text">Symbol table '.dynsym' contains 13 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 00000000000004c8     0 SECTION LOCAL  DEFAULT    9
     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND puts@GLIBC_2.2.5 (2)
     3: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
     4: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _Jv_RegisterClasses
     5: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@GLIBC_2.2.5 (2)
     6: 000000000020101c     0 NOTYPE  GLOBAL DEFAULT  ABS _edata
     7: 0000000000201018     4 OBJECT  GLOBAL DEFAULT   22 x
     8: 00000000000005dc    31 FUNC    GLOBAL DEFAULT   11 foo
     9: 0000000000201030     0 NOTYPE  GLOBAL DEFAULT  ABS _end
    10: 000000000020101c     0 NOTYPE  GLOBAL DEFAULT  ABS __bss_start
    11: 00000000000004c8     0 FUNC    GLOBAL DEFAULT    9 _init
    12: 0000000000000638     0 FUNC    GLOBAL DEFAULT   12 _fini
</pre>
</div>

<p>
其中 foo,x 等是 libfoo.so 中自己定义的符号, 其它 so 要调用 foo 时, rtld
可以通过 libfoo.so 的 dynsym 中的 foo 对应的表项获得 foo 函数真正的地址.
</p>

<p>
而 puts 的 Ndx 为 UND, 表示 libfoo.so 中引用了 puts, 但本身没有它的定义, libfoo.so 调用 puts 时, rtld 通过 rela.plt 会引用这个 dynsym 中的
puts 对应的表项, 以便知道 rtld 需要动态加载哪个符号.
</p>

<p>
即, 符号表会包含所有定义或引用的符号.
</p>
</div>
</div>

<div id="outline-container-org000002c" class="outline-4">
<h4 id="org000002c"><span class="section-number-4">1.2.7</span> dynsym</h4>
</div>

<div id="outline-container-org0000030" class="outline-4">
<h4 id="org0000030"><span class="section-number-4">1.2.8</span> strtab</h4>
<div class="outline-text-4" id="text-1-2-8">
<p>
strtab 与 dynstr 都是 string table, 格式相同. 它们包含是多个以 \0 结尾的字符串. 例如:
</p>

<pre class="example" id="org000002f">
$&gt; readelf -a ./a.out
  ...
  [ 4] .dynstr           STRTAB          00000270 000270 00005d 00   A  0   0  1
  ...
$&gt; od -c ./a.out +0x270 
// with space stripped
0001160  \0__libc_init\0LIB
0001200  C\0libc.so\0__cxa_
0001220  atexit\0printf\0x\0
0001240  y\0_edata\0_end\0__
0001260  bss_start\0libfoo
0001300  .so\0libdl.so\0

$&gt; readelf -p .dynstr ./a.out

String dump of section '.dynstr':
  [     1]  __libc_init
  [     d]  LIBC
  [    12]  libc.so
  [    1a]  __cxa_atexit
  [    27]  printf
  [    2e]  x
  [    30]  y
  [    32]  _edata
  [    39]  _end
  [    3e]  __bss_start
  [    4a]  libfoo.so
  [    54]  libdl.so
</pre>
</div>
</div>

<div id="outline-container-org0000033" class="outline-4">
<h4 id="org0000033"><span class="section-number-4">1.2.9</span> dynstr</h4>
</div>

<div id="outline-container-org0000036" class="outline-4">
<h4 id="org0000036"><span class="section-number-4">1.2.10</span> interp</h4>
<div class="outline-text-4" id="text-1-2-10">
<div class="org-src-container">
<pre class="src src-c"><span class="org-keyword">const</span> <span class="org-type">char</span> <span class="org-variable-name">interp_section</span>[] <span class="org-keyword">__attribute__</span>((section(<span class="org-string">".interp"</span>))) = <span class="org-string">"/path/to/dynamic/linker"</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-org0000047" class="outline-4">
<h4 id="org0000047"><span class="section-number-4">1.2.11</span> got</h4>
<div class="outline-text-4" id="text-1-2-11">
</div>
<div id="outline-container-org000003a" class="outline-5">
<h5 id="org000003a"><span class="section-number-5">1.2.11.1</span> got 的格式</h5>
<div class="outline-text-5" id="text-1-2-11-1">
<p>
got 的格式类似于 int[], 数组中保存的符号没有经过 patch 的地址, 例如:
</p>

<pre class="example" id="org0000039">
$&gt; readelf -a ./a.out
  ...                                    vaddr    offset
  [17] .got              PROGBITS        00001fd4 000fd4 00002c 00  WA  0   0  4

$&gt; arm-linux-androideabi-objdump -D ./a.out

Disassembly of section .got:

00001fd4 &lt;_GLOBAL_OFFSET_TABLE_-0x14&gt;:
    1fd4:	00001ebc 			; &lt;UNDEFINED&gt; instruction: 0x00001ebc
    1fd8:	00001eac 	andeq	r1, r0, ip, lsr #29
    1fdc:	00001ea4 	andeq	r1, r0, r4, lsr #29
    1fe0:	00001eb4 			; &lt;UNDEFINED&gt; instruction: 0x00001eb4
    1fe4:	00000454 	andeq	r0, r0, r4, asr r4

00001fe8 &lt;_GLOBAL_OFFSET_TABLE_&gt;:
        ...
    1ff4:	00000374 	andeq	r0, r0, r4, ror r3
    1ff8:	00000374 	andeq	r0, r0, r4, ror r3
    1ffc:	00000374 	andeq	r0, r0, r4, ror r3

$&gt; od -x ./a.out +0xfd4

0007724 1ebc 0000 1eac 0000 1ea4 0000 1eb4 0000
0007744 0454 0000 0000 0000 0000 0000 0000 0000
0007764 0374 0000 0374 0000 0374 0000 000c 0000
0010004 0000 0000 4700 4343 203a 4728 554e 2029
</pre>
</div>
</div>

<div id="outline-container-org000003e" class="outline-5">
<h5 id="org000003e"><span class="section-number-5">1.2.11.2</span> 全局变量与 got (arm)</h5>
<div class="outline-text-5" id="text-1-2-11-2">
<pre class="example" id="org000003d">
~/source/sharklj1@tj02433pcu&gt; d debug exec out/target/product/sp9850j_1h10/symbols/system/bin/linker /system/bin/linker
Remote debugging from host 127.0.0.1
__dl__start () at bionic/linker/arch/arm/begin.S:32
32        mov r0, sp
(gdb) b __dl___linker_init
Breakpoint 1 at 0xaaab6e38: __dl___linker_init. (2 locations)
(gdb) c
Continuing.

Breakpoint 1, __linker_init (raw_args=0xfffefa80) at bionic/linker/linker.cpp:4400
4400      KernelArgumentBlock args(raw_args);
(gdb) n
4402      ElfW(Addr) linker_addr = args.getauxval(AT_BASE);
(gdb) 
4403      ElfW(Addr) entry_point = args.getauxval(AT_ENTRY);
(gdb) 
4404      ElfW(Ehdr)* elf_hdr = reinterpret_cast&lt;ElfW(Ehdr)*&gt;(linker_addr);
(gdb) 
4405      ElfW(Phdr)* phdr = reinterpret_cast&lt;ElfW(Phdr)*&gt;(linker_addr + elf_hdr-&gt;e_phoff);
(gdb) 
4407      soinfo linker_so(nullptr, nullptr, nullptr, 0, 0);
(gdb) 
4416      if (reinterpret_cast&lt;ElfW(Addr)&gt;(&amp;_start) == entry_point) {
(gdb) ni
0xf7787e80      4416      if (reinterpret_cast&lt;ElfW(Addr)&gt;(&amp;_start) == entry_point) {
(gdb) disass
Dump of assembler code for function __linker_init(void*):
   ...
   0xf7787e7e &lt;+82&gt;:    ldr     r1, [sp, #544]  ; 0x220
=&gt; 0xf7787e80 &lt;+84&gt;:    ldr     r2, [pc, #316]  ; (0xf7787fc0 &lt;__linker_init(void*)+404&gt;)
   0xf7787e82 &lt;+86&gt;:    add     r2, pc
   0xf7787e84 &lt;+88&gt;:    ldr     r2, [r2, #0]
   0xf7787e86 &lt;+90&gt;:    cmp     r2, r1

(gdb) p /x $r2
$1 = 0x62f6a
// 0x62f6a 存储在 [pc,#316] 处, 这里是 __dl___linker_init 函数的 literal pool 区域, 表示 pc 与 GOT[__dl__start] 的偏移量
// 所以后面通过 pc+0x62f6a (0xf77eadf0) 可以得到 GOT[__dl__start]
(gdb) ni
0xf7787e84      4416      if (reinterpret_cast&lt;ElfW(Addr)&gt;(&amp;_start) == entry_point) {
(gdb) p /x $r2
$3 = 0xf77eadf0
(gdb) x 0xf77eadf0
0xf77eadf0:     0x000028fc
// 由于 linker 做为 interp map 在 0xf777b000, 所以 GOT 在原 elf 中的位置是 0xf77eadf0 - 0xf777b000 = 0x6fdf0
// Disassembly of section .got:
// 0006fddc &lt;__dl__GLOBAL_OFFSET_TABLE_-0x218&gt;:
//    6fddc:	000715b8 			; &lt;UNDEFINED&gt; instruction: 0x000715b8
//    6fde0:	000711d0 	ldrdeq	r1, [r7], -r0
//    6fde4:	000716bc 			; &lt;UNDEFINED&gt; instruction: 0x000716bc
//    6fde8:	0006eaf4 	strdeq	lr, [r6], -r4
//    6fdec:	00070174 	andeq	r0, r7, r4, ror r1
//    6fdf0:	000028fc 	strdeq	r2, [r0], -ip     &lt;--- 28fc
</pre>
</div>
</div>

<div id="outline-container-org0000044" class="outline-5">
<h5 id="org0000044"><span class="section-number-5">1.2.11.3</span> 全局变量与 got (x86)</h5>
<div class="outline-text-5" id="text-1-2-11-3">
<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">main.c</span><span class="org-comment-delimiter"> */</span>
<span class="org-keyword">extern</span> <span class="org-type">void</span> <span class="org-function-name">foo</span>();
<span class="org-keyword">extern</span> <span class="org-type">void</span> <span class="org-function-name">bar</span>();

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[])
{
    foo();
    bar();

    <span class="org-keyword">return</span> 0;
}

<span class="org-comment-delimiter">/* </span><span class="org-comment">foo.c</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-variable-name">x</span> = 0xab;

<span class="org-type">int</span> <span class="org-function-name">foo</span>() {
    printf(<span class="org-string">"foo\n"</span>);
    x = 0xcd;
}

<span class="org-comment-delimiter">/* </span><span class="org-comment">bar.c</span><span class="org-comment-delimiter"> */</span>
<span class="org-keyword">extern</span> <span class="org-type">int</span> <span class="org-variable-name">x</span>;
<span class="org-type">int</span> <span class="org-function-name">bar</span>() {
    printf(<span class="org-string">"bar\n"</span>);
    x = 0x12;
}

</pre>
</div>

<div class="org-src-container">
<pre class="src src-text">$ gdb ./a.out
(gdb) b main
Breakpoint 1 at 0x400648
(gdb) r
Starting program: /home/sunway/a.out 

Breakpoint 1, 0x0000000000400648 in main ()

(gdb) disass foo
Dump of assembler code for function foo:
   0x00007ffff7bd85dc &lt;+0&gt;:     push   %rbp
   0x00007ffff7bd85dd &lt;+1&gt;:     mov    %rsp,%rbp
   0x00007ffff7bd85e0 &lt;+4&gt;:     lea    0x5f(%rip),%rdi        # 0x7ffff7bd8646
   0x00007ffff7bd85e7 &lt;+11&gt;:    callq  0x7ffff7bd84f0 <a href="mailto:puts%40plt">&lt;puts@plt&gt;</a>
   0x00007ffff7bd85ec &lt;+16&gt;:    mov    0x2009d5(%rip),%rax        # 0x7ffff7dd8fc8
   0x00007ffff7bd85f3 &lt;+23&gt;:    movl   $0xcd,(%rax)
   0x00007ffff7bd85f9 &lt;+29&gt;:    pop    %rbp
   0x00007ffff7bd85fa &lt;+30&gt;:    retq   
End of assembler dump.

0x7ffff7dd8fc8 &#36825;&#20010;&#22320;&#22336;&#23454;&#38469;&#19978;&#20301;&#20110; foo.so &#30340; .got section. &#22240;&#20026;:

pmap &#26174;&#31034; libfoo.so &#34987;&#26144;&#23556;&#21040; 0x00007ffff7bd8000:
00007ffff7bd8000      4K r-x--  /home/sunway/libfoo.so
00007ffff7bd9000   2044K -----  /home/sunway/libfoo.so
00007ffff7dd8000      4K r----  /home/sunway/libfoo.so
00007ffff7dd9000      4K rw---  /home/sunway/libfoo.so

0x7ffff7dd8fc8 - 0x00007ffff7bd8000 = 0x200fc8

&#28982;&#21518;&#36890;&#36807; readelf -S libfoo.so | grep " .got " &#32467;&#26524;&#20026;:

[20] .got              PROGBITS         0000000000200fc8  00000fc8

&#25152;&#20197; 0x7ffff7dd8fc8 &#23454;&#38469;&#23601;&#26159; libfoo.so &#34987;&#21152;&#36733;&#21518;&#30340; GOT[0]

(gdb) x /xg 0x7ffff7dd8fc8
0x7ffff7dd8fc8: 0x00007ffff7dd9018

0x00007ffff7dd9018 &#36825;&#20010;&#22320;&#22336;&#26159; x &#21464;&#37327;&#30340;&#23454;&#38469;&#22320;&#22336;, &#21435;&#25481; libfoo.so &#26144;&#23556;&#30340;&#39318;&#22320;&#22336; 00007ffff7bd8000 &#21518;&#20026; 0x201018,
&#36890;&#36807; readelf -S libfoo.so:
 [22] .data             PROGBITS         0000000000201010  00001010
       000000000000000c  0000000000000000  WA       0     0     8
 [23] .bss              NOBITS           0000000000201020  0000101c
       0000000000000010  0000000000000000  WA       0     0     8

&#21487;&#20197;&#30830;&#23450;&#36825;&#20010;&#22320;&#22336;&#20301;&#20110; .data section.

(gdb) x 0x00007ffff7dd9018
0x7ffff7dd9018 &lt;x&gt;:     0x00000000000000ab

&#25152;&#20197;&#30495;&#27491;&#30340; x &#21464;&#37327;&#20301;&#20110; libfoo.so &#30340; .data &#20013;, &#19988;&#20854;&#22320;&#22336;&#34987;&#20889;&#22312; libfoo.so &#30340; GOT[0] &#20013;, libfoo.so &#20013;&#23545; x &#30340;&#24341;&#29992;&#37117;&#36890;&#36807; GOT[0] &#36827;&#34892;.

&#21516;&#29702;, &#35266;&#23519; libbar.so &#23545; x &#30340;&#24341;&#29992;:

(gdb) disass bar
Dump of assembler code for function bar:
   0x00007ffff79d65dc &lt;+0&gt;:     push   %rbp
   0x00007ffff79d65dd &lt;+1&gt;:     mov    %rsp,%rbp
   0x00007ffff79d65e0 &lt;+4&gt;:     lea    0x5f(%rip),%rdi        # 0x7ffff79d6646
   0x00007ffff79d65e7 &lt;+11&gt;:    callq  0x7ffff79d64f0 <a href="mailto:puts%40plt">&lt;puts@plt&gt;</a>
   0x00007ffff79d65ec &lt;+16&gt;:    mov    0x2009d5(%rip),%rax        # 0x7ffff7bd6fc8
   0x00007ffff79d65f3 &lt;+23&gt;:    movl   $0x12,(%rax)
   0x00007ffff79d65f9 &lt;+29&gt;:    pop    %rbp
   0x00007ffff79d65fa &lt;+30&gt;:    retq   
End of assembler dump.

0x7ffff7bd6fc8 &#36825;&#20010;&#22320;&#22336;&#20301;&#20110; libbar.so &#30340; GOT[0]

(gdb) x /gx 0x7ffff7bd6fc8
0x7ffff7bd6fc8: 0x00007ffff7dd9018

&#21487;&#35265; libbar.so &#30340; GOT[0] &#19982; libfoo.so &#30340; GOT[0] &#22343;&#25351;&#21521; libfoo.so &#30340; .data section &#20013; x &#30340;&#23454;&#38469;&#22320;&#22336;. 
</pre>
</div>

<p>
在使用 GOT 表时, so 的代码并不需要 `GOT 基址` 这样的数据, 因为 GOT 与代码的距离的在静态链接时就是可以确定的:
</p>

<p>
以 objdump -d libfoo.so 为例:
</p>

<div class="org-src-container">
<pre class="src src-asm"><span class="org-function-name">00000000000005dc</span> &lt;foo&gt;:
 <span class="org-keyword">5dc</span>:   55                      push   <span class="org-variable-name">%rbp</span>
 <span class="org-keyword">5dd</span>:   48 89 e5                mov    <span class="org-variable-name">%rsp</span>,<span class="org-variable-name">%rbp</span>
 <span class="org-keyword">5e0</span>:   48 8d 3d 5f 00 00 00    lea    0x5f(<span class="org-variable-name">%rip</span>),<span class="org-variable-name">%rdi</span>        # 646 &lt;_fini+0xe&gt;
 <span class="org-keyword">5e7</span>:   e8 04 ff ff ff          callq  4f0 <a href="mailto:puts%40plt">&lt;puts@plt&gt;</a>
 <span class="org-keyword">5ec</span>:   48 8b 05 d5 09 20 00    mov    0x2009d5(<span class="org-variable-name">%rip</span>),<span class="org-variable-name">%rax</span>        # 200fc8 &lt;_DYNAMIC+0x180&gt;
 <span class="org-keyword">5f3</span>:   c7 00 cd 00 00 00       movl   $0xcd,(<span class="org-variable-name">%rax</span>)
 <span class="org-keyword">5f9</span>:   5d                      pop    <span class="org-variable-name">%rbp</span>
 <span class="org-keyword">5fa</span>:   c3                      retq   
</pre>
</div>

<p>
这里的 0x2009d5 就是代码与 GOT 的偏移量, 当 so 被静态链接时, so 基址为
0, rip 为 5f3, 所以 GOT 位于 0x5f3 + 0x2009d5 = 0x200fc8, 当 so 被加载后,假设加载到 0x7ffff7bd8000, 则运行时 rip 会变为 0x7ffff7bd8000 +
0x5f3, 所以运行时 GOT 计算的结果为: 0x200fc8 + 0x7ffff7bd8000 =
0x7ffff7dd8fc8
</p>
</div>

<div id="outline-container-org0000041" class="outline-6">
<h6 id="org0000041"><span class="section-number-6">1.2.11.3.1</span> 总结</h6>
<div class="outline-text-6" id="text-1-2-11-3-1">
<p>
与 PLT 类似, 每个 so 均有其 GOT 表, so 中对非 static 的全局变量的引用都通过 GOT 来实现.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org0000051" class="outline-4">
<h4 id="org0000051"><span class="section-number-4">1.2.12</span> plt</h4>
<div class="outline-text-4" id="text-1-2-12">
</div>
<div id="outline-container-org000004b" class="outline-5">
<h5 id="org000004b"><span class="section-number-5">1.2.12.1</span> 函数与 plt</h5>
<div class="outline-text-5" id="text-1-2-12-1">
<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">gcc -shared -fPIC -o libfoo.so foo.c</span><span class="org-comment-delimiter"> */</span>
<span class="org-comment-delimiter">/* </span><span class="org-comment">gcc -shared -fPIC -o libbar.so bar.c</span><span class="org-comment-delimiter"> */</span>
<span class="org-comment-delimiter">/* </span><span class="org-comment">gcc main.c -L. -lfoo -lbar</span><span class="org-comment-delimiter"> */</span>

<span class="org-comment-delimiter">/* </span><span class="org-comment">main.c</span><span class="org-comment-delimiter"> */</span>
<span class="org-keyword">extern</span> <span class="org-type">void</span> <span class="org-function-name">foo</span>();
<span class="org-keyword">extern</span> <span class="org-type">void</span> <span class="org-function-name">bar</span>();

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[])
{
    foo();
    bar();
    <span class="org-keyword">return</span> 0;
}

<span class="org-comment-delimiter">/* </span><span class="org-comment">foo.c</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">foo</span>() {
    printf(<span class="org-string">"foo\n"</span>);
}

<span class="org-comment-delimiter">/* </span><span class="org-comment">bar.c</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-function-name">bar</span>() {
    printf(<span class="org-string">"bar\n"</span>);
}
</pre>
</div>

<pre class="example" id="org000004a">
$ LD_LIBRARY_PATH=. gdb a.out
(gdb) b main
(gdb) r
(gdb) disass
Dump of assembler code for function main:
0x0000000000400644 &lt;+0&gt;:     push   %rbp
   0x0000000000400645 &lt;+1&gt;:     mov    %rsp,%rbp
   0x0000000000400648 &lt;+4&gt;:     sub    $0x10,%rsp
   0x000000000040064c &lt;+8&gt;:     mov    %edi,-0x4(%rbp)
   0x000000000040064f &lt;+11&gt;:    mov    %rsi,-0x10(%rbp)
=&gt; 0x0000000000400653 &lt;+15&gt;:    mov    $0x0,%eax
   0x0000000000400658 &lt;+20&gt;:    callq  0x400550 &lt;foo@plt&gt;
   0x000000000040065d &lt;+25&gt;:    mov    $0x0,%eax
   0x0000000000400662 &lt;+30&gt;:    callq  0x400530 &lt;bar@plt&gt;
   0x0000000000400667 &lt;+35&gt;:    mov    $0x0,%eax
   0x000000000040066c &lt;+40&gt;:    leaveq 
   0x000000000040066d &lt;+41&gt;:    retq   
End of assembler dump.

foo 函数显示的地址为 0x400550, 这个并不是 foo.c 中定义的那个真正的
foo 函数的地址, 而只是 .plt 表中的地址: 这个 plt 表项位于 a.out 的
第一个 LOAD segment 中 (类型为 RE)

实际上, a.out 的 .plt 中一共有四项, 分别为 plt0 (__ld_runtime_resolve 的代码), bar@plt, __libc_start_main@plt 以及 foo@plt
比如:

0x400520 是 .plt 的起始地址:

~@sunway-work&gt; readelf -S ./a.out |grep " .plt"
  [12] .plt              PROGBITS         0000000000400520  00000520

(gdb) x /10g 0x400520
0x400520:       0x25ff00200aca35ff      0x00401f0f00200acc
0x400530 &lt;bar@plt&gt;:     0x006800200aca25ff      0xffffffe0e9000000
0x400540 &lt;__libc_start_main@plt&gt;:       0x016800200ac225ff      0xffffffd0e9000000
0x400550 &lt;foo@plt&gt;:     0x026800200aba25ff      0xffffffc0e9000000
0x400560 &lt;_start&gt;:      0x89485ed18949ed31      0x495450f0e48348e2


看一下 foo@plt (PLT[2]) 的具体代码:
(gdb) disass 0x400550
Dump of assembler code for function foo@plt:
   0x0000000000400550 &lt;+0&gt;:     jmpq   *0x200aba(%rip)        # 0x601010 &lt;foo@got.plt&gt;
   0x0000000000400556 &lt;+6&gt;:     pushq  $0x2
   0x000000000040055b &lt;+11&gt;:    jmpq   0x400520
End of assembler dump.

0x601010 对应于 .got.plt section 中的一项:

(gdb) x  0x601010
0x601010 &lt;foo@got.plt&gt;: 0x0000000000400556

当 .got.plt 表项第一次被使用时 (未经过 rtld 解析过), 其值均为相应的 plt 指令的下一条指令地址, 在这
里即 pushq $0x2 指令的地址, rtld 解析过后会修改 .got.plt 表项的值为真正的地址. 

pushq $0x2 指令将 0x2 入栈, 这里的 0x2 指的实际上是 foo 函数在 a.out 的 .rela.plt section 中的索引,

.rela.plt 的内容为:

Relocation section '.rela.plt' at offset 0x4b8 contains 3 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000601000  000100000007 R_X86_64_JUMP_SLO 0000000000000000 bar + 0
000000601008  000200000007 R_X86_64_JUMP_SLO 0000000000000000 __libc_start_main + 0
000000601010  000400000007 R_X86_64_JUMP_SLO 0000000000000000 foo + 0                                                                                            

rtld 通过 .rela.plt[2] 就可以解析到 dynsym 中对应的符号信息 (foo) 以及要写回的 .got.plt 表的位置 (0x601010)

jmpq 0x400520 是跳转到 rtld (__ld_runtime_resolve) 函数去动态加载 foo 函数. 0x400520 实际上就是 PLT[0]

(gdb) disass 0x400520,0x400530
Dump of assembler code from 0x400520 to 0x400530:
   0x0000000000400520:  pushq  0x200aca(%rip)        # 0x600ff0 &lt;_GLOBAL_OFFSET_TABLE_+8&gt;
   0x0000000000400526:  jmpq   *0x200acc(%rip)        # 0x600ff8 &lt;_GLOBAL_OFFSET_TABLE_+16&gt;
   0x000000000040052c:  nopl   0x0(%rax)
End of assembler dump.


0x600ff8 即 .got.plt[16] 保存着 __ld_runtime_resolve 函数的地址:

(gdb) x 0x600ff8
0x600ff8 &lt;_GLOBAL_OFFSET_TABLE_+16&gt;:    0x00007ffff7def200

(gdb) disass 0x00007ffff7def200
Dump of assembler code for function _dl_runtime_resolve:
   0x00007ffff7def200 &lt;+0&gt;:     sub    $0x38,%rsp
   0x00007ffff7def204 &lt;+4&gt;:     mov    %rax,(%rsp)
   0x00007ffff7def208 &lt;+8&gt;:     mov    %rcx,0x8(%rsp)
   0x00007ffff7def20d &lt;+13&gt;:    mov    %rdx,0x10(%rsp)
   0x00007ffff7def212 &lt;+18&gt;:    mov    %rsi,0x18(%rsp)
   0x00007ffff7def217 &lt;+23&gt;:    mov    %rdi,0x20(%rsp)
   0x00007ffff7def21c &lt;+28&gt;:    mov    %r8,0x28(%rsp)
   0x00007ffff7def221 &lt;+33&gt;:    mov    %r9,0x30(%rsp)
   0x00007ffff7def226 &lt;+38&gt;:    mov    0x40(%rsp),%rsi
   0x00007ffff7def22b &lt;+43&gt;:    mov    0x38(%rsp),%rdi
   0x00007ffff7def230 &lt;+48&gt;:    callq  0x7ffff7de8680 &lt;_dl_fixup&gt;
   0x00007ffff7def235 &lt;+53&gt;:    mov    %rax,%r11
   0x00007ffff7def238 &lt;+56&gt;:    mov    0x30(%rsp),%r9
   0x00007ffff7def23d &lt;+61&gt;:    mov    0x28(%rsp),%r8
   0x00007ffff7def242 &lt;+66&gt;:    mov    0x20(%rsp),%rdi
   0x00007ffff7def247 &lt;+71&gt;:    mov    0x18(%rsp),%rsi
   0x00007ffff7def24c &lt;+76&gt;:    mov    0x10(%rsp),%rdx
   0x00007ffff7def251 &lt;+81&gt;:    mov    0x8(%rsp),%rcx
   0x00007ffff7def256 &lt;+86&gt;:    mov    (%rsp),%rax
   0x00007ffff7def25a &lt;+90&gt;:    add    $0x48,%rsp
   0x00007ffff7def25e &lt;+94&gt;:    jmpq   *%r11
End of assembler dump.

(gdb) n
foo
7           bar();

foo 执行完毕, 此时再看一次 foo@plt 相关的信息:
(gdb) disass 0x400550
Dump of assembler code for function foo@plt:
   0x0000000000400550 &lt;+0&gt;:     jmpq   *0x200aba(%rip)        # 0x601010 &lt;foo@got.plt&gt;
   0x0000000000400556 &lt;+6&gt;:     pushq  $0x2
   0x000000000040055b &lt;+11&gt;:    jmpq   0x400520
End of assembler dump.

.plt[2] 的内容没有变化, 再看相应的 .got.plt 表项:

(gdb) x 0x601010
0x601010 &lt;foo@got.plt&gt;: 0x00007ffff7bd85ac

而执行前的结果为:

(gdb) x  0x601010
0x601010 &lt;foo@got.plt&gt;: 0x0000000000400556

可见, __ld_runtime_resolve 已经将 foo@got.plt 的值修改了, 这个 0x00007ffff7bd85ac 实际上就是 libfoo.so 中 foo 函数的真正地址:

(gdb) disass 0x00007ffff7bd85ac
Dump of assembler code for function foo:
   0x00007ffff7bd85ac &lt;+0&gt;:     push   %rbp
   0x00007ffff7bd85ad &lt;+1&gt;:     mov    %rsp,%rbp
   0x00007ffff7bd85b0 &lt;+4&gt;:     lea    0x4f(%rip),%rdi        # 0x7ffff7bd8606
   0x00007ffff7bd85b7 &lt;+11&gt;:    callq  0x7ffff7bd84c0 &lt;puts@plt&gt;
   0x00007ffff7bd85bc &lt;+16&gt;:    pop    %rbp
   0x00007ffff7bd85bd &lt;+17&gt;:    retq   
End of assembler dump.

</pre>
</div>
</div>

<div id="outline-container-org000004e" class="outline-5">
<h5 id="org000004e"><span class="section-number-5">1.2.12.2</span> 总结</h5>
<div class="outline-text-5" id="text-1-2-12-2">
<p>
每个 so 均有其 PLT 表, 所有非 static 的函数均通过 PLT 表引用. 
</p>

<p>
一个动态加载的函数符号的解析需要涉及到以下的 elf section:
</p>

<ol class="org-ol">
<li>.plt</li>

<li>.got.plt</li>

<li>.rela.plt</li>

<li>其他 so 的 .dynsym 和 .dynstr</li>
</ol>

<p>
plt[0] 保存着 __ld_runtime_resolve 的地址, 进行符号的动态加载.
</p>

<p>
.got.plt 与 .got 类似, 都是需要被 rtld 修改的, 不同的是 .got 主要是为了定位全局变量, 而 .got.plt 是为了定位函数.
</p>

<p>
这个 section 被加载到类型为 RW 的第二个 LOAD segment, 而 .plt 和
.rela.plt 是不变的, 所以它们被加载到类型 RE 的第一个 LOAD segment, 即:
</p>

<div class="org-src-container">
<pre class="src src-text">Section to Segment mapping:
 Segment Sections...
  00
  01     .interp
  02     .interp ... .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .text .fini .rodata ...
                                                                           ~~~~~~~~~~      ~~~~~
  03     .ctors .dtors .jcr .dynamic .got .got.plt .data .bss
                                          ~~~~~~~~
  04     .dynamic
  ... 
</pre>
</div>

<p>
__ld_runtime_resolve  通过 .rela.plt 获得要加载的符号的名字和要改写的
.got.plt 项的地址. 
</p>

<p>
最终 __ld_runtime_resolve 需要查找其它 so 的 .dynsym 和 .dynstr 来确定函数真正的地址.
</p>
</div>
</div>
</div>

<div id="outline-container-org0000054" class="outline-4">
<h4 id="org0000054"><span class="section-number-4">1.2.13</span> got.plt</h4>
<div class="outline-text-4" id="text-1-2-13">
<p>
got.plt 与 got 类似, 但它保存的是函数的地址 (而不是全局变量的地址), 参
</p>
</div>
</div>

<div id="outline-container-org000005b" class="outline-4">
<h4 id="org000005b"><span class="section-number-4">1.2.14</span> rel.dyn</h4>
<div class="outline-text-4" id="text-1-2-14">
<p>
rel.dyn 是用来指示哪些需要重定位的, 重定位一般是修改 GOT 表 (但也有例外, 比如后面的 rela.dyn, 重定位修改的是.data 部分的值), 通过rel.dyn,
loader 才知道 GOT 表中的各个项需要如何修改
</p>

<p>
rel.dyn 的格式为:
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-keyword">struct</span> <span class="org-type">Elf32_Rel</span> {
  <span class="org-type">Elf32_Addr</span> <span class="org-variable-name">r_offset</span>; 
  <span class="org-type">Elf32_Word</span> <span class="org-variable-name">r_info</span>;
}
</pre>
</div>

<p>
其中:
</p>
<ol class="org-ol">
<li>r_offset 是需要 patch 的 vaddr, 一般位于 got 表中</li>
<li>r_info 是一个 int, 包含了 rel 的类型和 dynsym 的索引</li>
</ol>
</div>

<div id="outline-container-org0000058" class="outline-5">
<h5 id="org0000058"><span class="section-number-5">1.2.14.1</span> 例子</h5>
<div class="outline-text-5" id="text-1-2-14-1">
<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">test.c</span><span class="org-comment-delimiter"> */</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>
<span class="org-keyword">extern</span> <span class="org-type">int</span> <span class="org-variable-name">x</span>;
<span class="org-keyword">extern</span> <span class="org-type">int</span> <span class="org-variable-name">y</span>;
<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
    printf(<span class="org-string">"main: %x\n"</span>, &amp;x, &amp;y);
    <span class="org-keyword">return</span> 0;
}

<span class="org-comment-delimiter">/* </span><span class="org-comment">foo.c</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">int</span> <span class="org-variable-name">x</span> = 10;
<span class="org-type">int</span> <span class="org-variable-name">y</span> = 11;
</pre>
</div>

<pre class="example" id="org0000057">
$&gt; arm-linux-androideabi-gcc foo.c -fPIC -shared -o libfoo.so -g3 -O0
$&gt; arm-linux-androideabi-gcc test.c -fPIE -pie -O0 -g3 -L. -lfoo
$&gt; arm-linux-androideabi-readelf -a ./a.out

Relocation section '.rel.dyn' at offset 0x33c contains 7 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
00001fcc  00000017 R_ARM_RELATIVE   
00001fd0  00000017 R_ARM_RELATIVE   
00001fd4  00000017 R_ARM_RELATIVE   
00001fd8  00000017 R_ARM_RELATIVE   
00001fdc  00000017 R_ARM_RELATIVE   
00001fe0  00000415 R_ARM_GLOB_DAT    00000000   x
00001fe4  00000515 R_ARM_GLOB_DAT    00000000   y

其中:
0x1fe0 位于 GOT 表中, 它存储的值是 x 的地址;
0x415 &lt;&lt; 8 = 4, 代表 x 在 dynsym 中的索引. 
0x415 &amp; 0xff = 0x15, 代表 rel 的类型: R_ARM_GLOB_DAT

Symbol table '.dynsym' contains 9 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 00000000     0 FUNC    GLOBAL DEFAULT  UND __libc_init@LIBC (2)
     2: 00000000     0 FUNC    GLOBAL DEFAULT  UND __cxa_atexit@LIBC (2)
     3: 00000000     0 FUNC    GLOBAL DEFAULT  UND printf@LIBC (2)
     4: 00000000     0 OBJECT  GLOBAL DEFAULT  UND x
     5: 00000000     0 OBJECT  GLOBAL DEFAULT  UND y
     6: 00002000     0 NOTYPE  GLOBAL DEFAULT  ABS _edata
     7: 00002004     0 NOTYPE  GLOBAL DEFAULT  ABS _end
     8: 00002000     0 NOTYPE  GLOBAL DEFAULT  ABS __bss_start

</pre>

<p>
这样 loader 在工作时, 就可以从 rel.dyn 和 dynsym (以及 dynstr) 中获得需要重定位的项的信息:
</p>

<ol class="org-ol">
<li>符号的名字</li>
<li>重定位类型</li>
<li>定位完成后需要 patch 的地址 (GOT 表项)</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org000005f" class="outline-4">
<h4 id="org000005f"><span class="section-number-4">1.2.15</span> rel.plt</h4>
<div class="outline-text-4" id="text-1-2-15">
<p>
rel.plt 与 got.plt 的关系, 类似于 rel.dyn 与 got 的关系:
</p>

<p>
rel.dyn 用来索引 got, 以便对数据进行重定位.
rel.plt 用来索引 got.plt, 以便对函数进行重定位.
</p>

<p>
rel.plt 的格式与 rel.dyn 是一样的, 都是 Elf32_Rel, 它的 r_offset 指示的 vaddr 位于 got.plt 表中
</p>

<p>
通过 r_info 中的 relocation type, 可以区分出 rel.plt 与 rel.dyn
</p>

<pre class="example" id="org000005e">
$&gt; cat main.c

extern void foo();

int main(int argc, char *argv[])
{
    foo();
    return 0;
}

$&gt; arm-linux-androideabi-gcc main.c -fPIE -pie -L. -lfoo
$&gt; arm-linux-androideabi-readelf -a ./a.out

Relocation section '.rel.plt' at offset 0x330 contains 3 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
00001ff4  00000116 R_ARM_JUMP_SLOT   00000000   __libc_init@LIBC
00001ff8  00000216 R_ARM_JUMP_SLOT   00000000   __cxa_atexit@LIBC
00001ffc  00000316 R_ARM_JUMP_SLOT   00000000   foo
~~~~~~~~

$&gt; arm-linux-androideabi-objdum -D ./a.out

00001fe8 &lt;_GLOBAL_OFFSET_TABLE_&gt;:
        ...
    1ff4:	00000348 	andeq	r0, r0, r8, asr #6
    1ff8:	00000348 	andeq	r0, r0, r8, asr #6
    1ffc:	00000348 	andeq	r0, r0, r8, asr #6

;; 所以 linker 将来需要修改 1ffc 处的值为重定位后的 plt[0] 的地址 (0x348 是没有经过重定位的 plt[0])

00000374 &lt;foo@plt&gt;:
 374:	e28fc600 	add	ip, pc, #0, 12                          &lt;--- ip = pc + 0&lt;&lt;12 = 37c
 378:	e28cca01 	add	ip, ip, #4096	; 0x1000                &lt;--- ip = 37c + 0x10000 = 0x137c 
 37c:	e5bcfc80 	ldr	pc, [ip, #3200]!	; 0xc80         &lt;--- pc= [0x137c+0xc80] = [0x1ffc] = 0x348

;; 0x348 实际就是 plt[0], 即 linker 的 resolver.

00000348 &lt;__libc_init@plt-0x14&gt;:
 348:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
 34c:	e59fe004 	ldr	lr, [pc, #4]	; 358 &lt;note_end+0x178&gt;
 350:	e08fe00e 	add	lr, pc, lr
 354:	e5bef008 	ldr	pc, [lr, #8]!
 358:	00001c90 	muleq	r0, r0, ip
</pre>
</div>
</div>

<div id="outline-container-org000006d" class="outline-4">
<h4 id="org000006d"><span class="section-number-4">1.2.16</span> rela.dyn</h4>
<div class="outline-text-4" id="text-1-2-16">
<p>
rela.dyn 与 rel.dyn 基本是一样的, 唯一的不同的 rela 比 rel 多了一个
addend 成员.
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-keyword">struct</span> <span class="org-type">Elf32_Rela</span> {
  <span class="org-type">Elf32_Addr</span>  <span class="org-variable-name">r_offset</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Location (file byte offset, or program virtual addr)</span>
  <span class="org-type">Elf32_Word</span>  <span class="org-variable-name">r_info</span>;   <span class="org-comment-delimiter">// </span><span class="org-comment">Symbol table index and type of relocation to apply</span>
  <span class="org-type">Elf32_Sword</span> <span class="org-variable-name">r_addend</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Compute value for relocatable field by adding this</span>
}
</pre>
</div>

<p>
新的平台如 arm64, x86_64 都使用 rela 代替了 rel. 因为使用 rel 需要比
rela 多访问一次内存.
</p>
</div>

<div id="outline-container-org0000063" class="outline-5">
<h5 id="org0000063"><span class="section-number-5">1.2.16.1</span> rela on arm64</h5>
<div class="outline-text-5" id="text-1-2-16-1">
<pre class="example" id="org0000062">
$&gt; cat foo.c
int xxx[4];

$&gt; aarch64-linux-gnu-gcc foo.c -shared -fPIC -o libfoo.so -O0 -g3
$&gt; cat main.c
#include &lt;stdio.h&gt;

extern int xxx[4];
int *j = xxx + 3;
int *k = xxx;

int main(int argc, char *argv[]) {
    printf("%p %p\n", j, k);
    return 0;
}

$&gt; aarch64-linux-gnu-gcc main.c -fPIE -pie -O0 -g3 libfoo.so
$&gt; readelf -a ./a.out
Relocation section '.rela.dyn' at offset 0x638 contains 13 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
...
000000010ce8  001400000401 R_AARCH64_GLOB_DA 0000000000000000 _ITM_registerTMCloneTa + 0
000000010d40  000a00000101 R_AARCH64_ABS64   0000000000000000 xxx + c
000000010d48  000a00000101 R_AARCH64_ABS64   0000000000000000 xxx + 0

;; 其中 10d40 位于 .data, 它存储的值是 j 的地址 (即 xxx + 3*4 = xxx +
;; c), 在 rela 中, c 会作为 addend 保存在 rela entry 中
</pre>
</div>
</div>

<div id="outline-container-org0000067" class="outline-5">
<h5 id="org0000067"><span class="section-number-5">1.2.16.2</span> rel on arm32</h5>
<div class="outline-text-5" id="text-1-2-16-2">
<pre class="example" id="org0000066">
$&gt; arm-linux-androideabi-gcc foo.c -fPIC -shared -o libfoo.so -g3 -O0
$&gt; arm-linux-androideabi-gcc main.c -fPIE -pie -L. -lfoo -O0 -g3
$&gt; readelf -a ./a.out
Relocation section '.rel.dyn' at offset 0x324 contains 7 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
...
00002000  00000402 R_ARM_ABS32       00000000   xxx
00002004  00000402 R_ARM_ABS32       00000000   xxx

;; 在 rel 中, i,j 对应的 entry 都和 xxx 符号有关, 由于没有 addend 值, 如
;; 何确定 i, j 相对 xxx 的偏移量? 实际上, 这个偏移量是做为初值保存在 .data 中的

$&gt; arm-linux-androideabi-objdump -D ./a.out

00001fe8 &lt;_GLOBAL_OFFSET_TABLE_&gt;:
        ...
    1ff4:       00000374        andeq   r0, r0, r4, ror r3
    1ff8:       00000374        andeq   r0, r0, r4, ror r3
    1ffc:       00000374        andeq   r0, r0, r4, ror r3

Disassembly of section .data:

00002000 &lt;j&gt;:
    2000:       0000000c        andeq   r0, r0, ip
                ~~~~~~~~
00002004 &lt;k&gt;:
    2004:       00000000        andeq   r0, r0, r0
                ~~~~~~~~

;; GOT 中对于 i,j 的初值是无用的, 刚好可以用来保存 addend, 但 linker
;; 显然需要多一次内存访问.
</pre>
</div>
</div>

<div id="outline-container-org000006a" class="outline-5">
<h5 id="org000006a"><span class="section-number-5">1.2.16.3</span> note</h5>
<div class="outline-text-5" id="text-1-2-16-3">
<p>
从前面 rel 及 rela 的实现方式可以看到, loader 可以通过重定位的方式给全局变量赋初值, 但仅限于 symbol_addr + addend 的方式, 所以考虑下面的代码能否编译通过:
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">1. false</span><span class="org-comment-delimiter"> */</span>
<span class="org-keyword">extern</span> <span class="org-type">int</span> <span class="org-variable-name">x</span>;
<span class="org-type">int</span> <span class="org-variable-name">y</span> = x;

<span class="org-comment-delimiter">/* </span><span class="org-comment">2. true</span><span class="org-comment-delimiter"> */</span>
<span class="org-keyword">extern</span> <span class="org-type">int</span> <span class="org-variable-name">x</span>;
<span class="org-type">int</span> *<span class="org-variable-name">y</span> = &amp;x + 1;

<span class="org-comment-delimiter">/* </span><span class="org-comment">3. true</span><span class="org-comment-delimiter"> */</span>

<span class="org-keyword">extern</span> <span class="org-type">int</span> <span class="org-variable-name">x</span>;
<span class="org-type">int</span> <span class="org-variable-name">y</span> = (<span class="org-type">int</span>)&amp;x;

<span class="org-comment-delimiter">/* </span><span class="org-comment">4. false</span><span class="org-comment-delimiter"> */</span>
<span class="org-keyword">extern</span> <span class="org-type">int</span> <span class="org-variable-name">x</span>;
<span class="org-type">int</span> <span class="org-variable-name">y</span> = (<span class="org-type">int</span>)(&amp;x) + <span class="org-type">int</span>(&amp;x);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org0000070" class="outline-4">
<h4 id="org0000070"><span class="section-number-4">1.2.17</span> rela.plt</h4>
</div>

<div id="outline-container-org0000073" class="outline-4">
<h4 id="org0000073"><span class="section-number-4">1.2.18</span> eh_frame</h4>
</div>

<div id="outline-container-org0000076" class="outline-4">
<h4 id="org0000076"><span class="section-number-4">1.2.19</span> text</h4>
</div>

<div id="outline-container-org0000079" class="outline-4">
<h4 id="org0000079"><span class="section-number-4">1.2.20</span> data</h4>
</div>

<div id="outline-container-org000007c" class="outline-4">
<h4 id="org000007c"><span class="section-number-4">1.2.21</span> rodata</h4>
</div>

<div id="outline-container-org000007f" class="outline-4">
<h4 id="org000007f"><span class="section-number-4">1.2.22</span> bss</h4>
</div>

<div id="outline-container-org0000082" class="outline-4">
<h4 id="org0000082"><span class="section-number-4">1.2.23</span> data.rel.ro</h4>
</div>

<div id="outline-container-org000008b" class="outline-4">
<h4 id="org000008b"><span class="section-number-4">1.2.24</span> summary</h4>
<div class="outline-text-4" id="text-1-2-24">
</div>
<div id="outline-container-org0000085" class="outline-5">
<h5 id="org0000085"><span class="section-number-5">1.2.24.1</span> loader 工作时的大致流程</h5>
<div class="outline-text-5" id="text-1-2-24-1">
<ol class="org-ol">
<li>先找到 dynamic segment</li>
<li>通过 dynamic segment 找到 rel(a).{dyn/plt}, 确定要重定位的项</li>
<li>对于外部的符号, 需要通过 dynsym/dynstr 找到符号的名字再到外部的 so
中去查找</li>
<li>修改 got/got.plt/.data, 完成重定位</li>
</ol>
</div>
</div>


<div id="outline-container-org0000088" class="outline-5">
<h5 id="org0000088"><span class="section-number-5">1.2.24.2</span> init</h5>
<div class="outline-text-5" id="text-1-2-24-2">
<p>
指定 init 函数有几种做法:
</p>

<ol class="org-ol">
<li>通过 DT_INIT

<ol class="org-ol">
<li>.init section</li>

<li>-Wl,-init</li>
</ol></li>

<li>通过 .init_array

<ol class="org-ol">
<li>.init_array section</li>

<li>constructor</li>
</ol></li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org000009c" class="outline-4">
<h4 id="org000009c"><span class="section-number-4">1.2.25</span> hash</h4>
<div class="outline-text-4" id="text-1-2-25">
<p>
<a href="android_linker.html#org0000002">find_symbol_by_name</a> 使用 .hash section 来查找 symbol
</p>

<p>
<a href="https://blogs.oracle.com/ali/gnu-hash-elf-sections">https://blogs.oracle.com/ali/gnu-hash-elf-sections</a>
<a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#hash">http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#hash</a>
</p>
</div>

<div id="outline-container-org000008f" class="outline-5">
<h5 id="org000008f"><span class="section-number-5">1.2.25.1</span> .hash section 的格式</h5>
<div class="outline-text-5" id="text-1-2-25-1">
<p>
.hash 使用链表来解决 hash 冲突
</p>

<pre class="example" id="org000008e">
nbucket
nchain
bucket[0]
. . .
bucket[nbucket-1]
chain[0]
. . .
chain[nchain-1]
</pre>
</div>
</div>

<div id="outline-container-org0000092" class="outline-5">
<h5 id="org0000092"><span class="section-number-5">1.2.25.2</span> hash 函数</h5>
<div class="outline-text-5" id="text-1-2-25-2">
<div class="org-src-container">
<pre class="src src-c"><span class="org-type">unsigned</span> <span class="org-type">long</span>
<span class="org-function-name">elf_Hash</span>(<span class="org-keyword">const</span> <span class="org-type">unsigned</span> <span class="org-type">char</span> *<span class="org-variable-name">name</span>)
{
    <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">h</span> = 0, <span class="org-variable-name">g</span>;

    <span class="org-keyword">while</span> (*name)
    {
        h = (h &lt;&lt; 4) + *name++;
        <span class="org-keyword">if</span> (g = h &amp; 0xf0000000)
            h ^= g &gt;&gt; 24;
        h &amp;= ~g;
    }
    <span class="org-keyword">return</span> h;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
    printf(<span class="org-string">"%x\n"</span>, elf_Hash(argv[1]));
    <span class="org-keyword">return</span> 0;
}

</pre>
</div>
</div>
</div>

<div id="outline-container-org0000096" class="outline-5">
<h5 id="org0000096"><span class="section-number-5">1.2.25.3</span> example</h5>
<div class="outline-text-5" id="text-1-2-25-3">
<p>
libfoo.so:
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-type">int</span> <span class="org-variable-name">xxx</span> = 0;
<span class="org-type">void</span> <span class="org-function-name">zzz</span>() {

}
</pre>
</div>

<pre class="example" id="org0000095">
$&gt; arm-linux-androideabi-gcc -O0 -g3 foo.c -shared -fPIC -o libfoo.so
$&gt; readelf -a ./libfoo.so

  [ 4] .hash             HASH            00000208 000208 000034 04   A  2   0  4
  ...
Symbol table '.dynsym' contains 8 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 00000000     0 FUNC    GLOBAL DEFAULT  UND __cxa_finalize@LIBC (2)
     2: 00000000     0 FUNC    GLOBAL DEFAULT  UND __cxa_atexit@LIBC (2)
     3: 00002004     4 OBJECT  GLOBAL DEFAULT   17 xxx
     4: 00000308    20 FUNC    GLOBAL DEFAULT   11 zzz
     5: 00002004     0 NOTYPE  GLOBAL DEFAULT  ABS _edata
     6: 00002008     0 NOTYPE  GLOBAL DEFAULT  ABS _end
     7: 00002004     0 NOTYPE  GLOBAL DEFAULT  ABS __bss_start

$&gt;  od -x ./libfoo.so +0x208|more
0001010 0003 0000 0008 0000 0005 0000 0006 0000
0001030 0007 0000 0000 0000 0000 0000 0000 0000
0001050 0000 0000 0003 0000 0004 0000 0002 0000
0001070 0001 0000 0000 0002 0002 0001 0001 0001
0001110 0001 0001 0001 0001 0001 0001 776f 08d6
0001130 0014 0000 0000 0000 001d 0000 0000 0000
0001150 0001 0001 0015 0000 0010 0000 0000 0000
0001170 0d63 0005 0000 0002 0010 0000 0000 0000
0001210 1ed8 0000 0017 0000 1ff8 0000 0216 0000
</pre>

<p>
按 .hash 的格式解析后为:
</p>

<ul class="org-ul">
<li>nbucket: 3</li>
<li>nchain: 8</li>

<li>bucket[0] = 5</li>
<li>bucket[1] = 6</li>
<li>bucket[2] = 7</li>

<li>chain[0] = 0</li>
<li>chain[1] = 0</li>
<li>chain[2] = 0</li>
<li>chain[3] = 0</li>
<li>chain[4] = 3</li>
<li>chain[5] = 4</li>
<li>chain[6] = 2</li>
<li>chain[7] = 1</li>
</ul>

<p>
以查找 __bss_start 为例:
</p>

<ol class="org-ol">
<li>elfhash __bss_start 为 0x90ff134</li>
<li>bucket 索引为 0x90ff134 % nbucket(3) = 2</li>
<li>检查 bucket[2] = dynsym[7] = __bss_start, 找到</li>
</ol>

<p>
以查找一个不存在的 hello 为例:
</p>

<ol class="org-ol">
<li>elfhash hello = 0x6ec32f % 3 = 1</li>
<li>bucket[1] = 6, dynsym[6] = _end, 不相等</li>
<li>chain[6] = 2, dynsym[2] = __cxa_atexit@LIBC (2), 不相等</li>
<li>chain[2] = 0, 查找结束, 因为 0 是一个占位符, dynsym[0] 不包含有效值</li>
</ol>
</div>
</div>

<div id="outline-container-org0000099" class="outline-5">
<h5 id="org0000099"><span class="section-number-5">1.2.25.4</span> 关于 bucket 和 chain:</h5>
<div class="outline-text-5" id="text-1-2-25-4">
<p>
bucket[x] 相当于所有 hash 为 x 的符号组成的链表的头, 而
chain[bucket[x]], chain[chain[bucket[x]]]&#x2026;构成链表.
</p>

<p>
所以,  dynsym 中的符号构成以下几条链表:
</p>

<p>
[5,4,3], [6,2] [7,1]
</p>
</div>
</div>
</div>

<div id="outline-container-org000009f" class="outline-4">
<h4 id="org000009f"><span class="section-number-4">1.2.26</span> gnu.hash</h4>
</div>


<div id="outline-container-org00000a3" class="outline-4">
<h4 id="org00000a3"><span class="section-number-4">1.2.27</span> gnu.version</h4>
<div class="outline-text-4" id="text-1-2-27">
<p>
gnu.version 是对 dynsym 的补充, 表示每个 dynsym 的符号的 version
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-keyword">typedef</span> <span class="org-type">Elf32_Half</span> <span class="org-type">Elf32_Versym</span>;
</pre>
</div>

<pre class="example" id="org00000a2">
$&gt; cat test.c

void foo() {
    printf("foo from LIBTEST_V1.0\n");
}

$&gt; cat v.map

LIBTEST_V1.0 {
             global:
                foo;
             local:
                *;
};

$&gt; gcc -shared test.c -o libtest.so -Wl,--version-script,v.map
$&gt; readelf -a ./libtest.so

Symbol table '.dynsym' contains 8 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterTMCloneTab
     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND puts@GLIBC_2.2.5 (3)
     3: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
     4: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable
     5: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@GLIBC_2.2.5 (3)
     6: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  ABS LIBTEST_V1.0
     7: 00000000000005ba    19 FUNC    GLOBAL DEFAULT   13 foo@@LIBTEST_V1.0

Version symbols section '.gnu.version' contains 8 entries:
 Addr: 0000000000000364  Offset: 0x000364  Link: 3 (.dynsym)
  000:   0 (*local*)       0 (*local*)       3 (GLIBC_2.2.5)   0 (*local*)    
  004:   0 (*local*)       3 (GLIBC_2.2.5)   2 (LIBTEST_V1.0)   2 (LIBTEST_V1.0)

$&gt; od -x libtest.so +0x364

0001544 0000 0000 0003 0000 0000 0003 0002 0002
...
</pre>
</div>
</div>

<div id="outline-container-org00000a7" class="outline-4">
<h4 id="org00000a7"><span class="section-number-4">1.2.28</span> gnu.version_d</h4>
<div class="outline-text-4" id="text-1-2-28">
<p>
version definition
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-keyword">typedef</span> <span class="org-keyword">struct</span> {
  <span class="org-type">Elf32_Half</span> <span class="org-variable-name">vd_version</span>;
  <span class="org-type">Elf32_Half</span> <span class="org-variable-name">vd_flags</span>;
  <span class="org-type">Elf32_Half</span> <span class="org-variable-name">vd_ndx</span>;
  <span class="org-type">Elf32_Half</span> <span class="org-variable-name">vd_cnt</span>;
  <span class="org-type">Elf32_Word</span> <span class="org-variable-name">vd_hash</span>;
  <span class="org-type">Elf32_Word</span> <span class="org-variable-name">vd_aux</span>;
  <span class="org-type">Elf32_Word</span> <span class="org-variable-name">vd_next</span>;
} <span class="org-type">Elf32_Verdef</span>;

</pre>
</div>

<pre class="example" id="org00000a6">
Version definition section '.gnu.version_d' contains 2 entries:
  Addr: 0x0000000000000378  Offset: 0x000378  Link: 4 (.dynstr)  000000: Rev: 1  Flags: BASE   Index: 1  Cnt: 1  Name: libtest.so
  0x001c: Rev: 1  Flags: none  Index: 2  Cnt: 1  Name: LIBTEST_V1.0
  Version definition past end of section
</pre>
</div>
</div>

<div id="outline-container-org00000ab" class="outline-4">
<h4 id="org00000ab"><span class="section-number-4">1.2.29</span> gnu.version_r</h4>
<div class="outline-text-4" id="text-1-2-29">
<p>
version needs
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-keyword">typedef</span> <span class="org-keyword">struct</span> {
  <span class="org-type">Elf32_Half</span> <span class="org-variable-name">vn_version</span>;
  <span class="org-type">Elf32_Half</span> <span class="org-variable-name">vn_cnt</span>;
  <span class="org-type">Elf32_Word</span> <span class="org-variable-name">vn_file</span>;
  <span class="org-type">Elf32_Word</span> <span class="org-variable-name">vn_aux</span>;
  <span class="org-type">Elf32_Word</span> <span class="org-variable-name">vn_next</span>;
} <span class="org-type">Elf32_Verneed</span>;
</pre>
</div>

<pre class="example" id="org00000aa">
$&gt; readelf -a libtest.so

// libtest.so 需要 GLIBC_2.2.5 版本的 libc.so.6

Version needs section '.gnu.version_r' contains 1 entries:
 Addr: 0x00000000000003b0  Offset: 0x0003b0  Link: 4 (.dynstr)
  000000: Version: 1  File: libc.so.6  Cnt: 1
  0x0010:   Name: GLIBC_2.2.5  Flags: none  Version: 3

$&gt; gcc main.c ./libtest.so
$&gt; readelf -a ./a.out

// a.out 需要 LIBTEST_V1.0 的 ./libtest.so
Version needs section '.gnu.version_r' contains 2 entries:
 Addr: 0x0000000000000438  Offset: 0x000438  Link: 6 (.dynstr)
  000000: Version: 1  File: ./libtest.so  Cnt: 1
  0x0010:   Name: LIBTEST_V1.0  Flags: none  Version: 3
  0x0020: Version: 1  File: libc.so.6  Cnt: 1
  0x0030:   Name: GLIBC_2.2.5  Flags: none  Version: 2
</pre>
</div>
</div>

<div id="outline-container-org00000ae" class="outline-4">
<h4 id="org00000ae"><span class="section-number-4">1.2.30</span> dynamic</h4>
</div>
</div>

<div id="outline-container-org00000d3" class="outline-3">
<h3 id="org00000d3"><span class="section-number-3">1.3</span> ELF Segment</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-org00000c0" class="outline-4">
<h4 id="org00000c0"><span class="section-number-4">1.3.1</span> Elf Segment</h4>
<div class="outline-text-4" id="text-1-3-1">
</div>
<div id="outline-container-org00000b4" class="outline-5">
<h5 id="org00000b4"><span class="section-number-5">1.3.1.1</span> PT_INTERP</h5>
<div class="outline-text-5" id="text-1-3-1-1">
<p>
PT_INTERP 指向 interp section, 包括 interpreter 的路径, 例如
/lib/ld-linux-x86-64.so.2.
</p>

<p>
只有 executable file 才有这一项.
</p>
</div>
</div>

<div id="outline-container-org00000b7" class="outline-5">
<h5 id="org00000b7"><span class="section-number-5">1.3.1.2</span> PT_NOTE</h5>
<div class="outline-text-5" id="text-1-3-1-2">
<p>
PT_NOTE 和 coredump 有关 
</p>
</div>
</div>

<div id="outline-container-org00000ba" class="outline-5">
<h5 id="org00000ba"><span class="section-number-5">1.3.1.3</span> PT_LOAD</h5>
<div class="outline-text-5" id="text-1-3-1-3">
<p>
PT_LOAD 是给 kernel 准备的.
一个 executable file 或 shared object file 一般会包含两个 LOAD 类型的
segment:
例如:
</p>

<p>
,-&#x2014;
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000</td>
</tr>

<tr>
<td class="org-left">0x00000000000006ac 0x00000000000006ac  R E    200000</td>
</tr>

<tr>
<td class="org-left">LOAD           0x0000000000000e28 0x0000000000200e28 0x0000000000200e28</td>
</tr>

<tr>
<td class="org-left">0x00000000000001f4 0x0000000000000208  RW     200000</td>
</tr>
</tbody>
</table>
<p>
`-&#x2014;
</p>

<p>
LOAD 类型的 segment 表示这个 segment 是需要从 elf 文件中映射进来的, 具体的, 第一个 LOAD segment 是 RE (只读可执行的), 主要包括 elf 中的一些代码段 (例如 text, init)和一些只读数据段 (例如 rodata, dynsym) 等.第二个 LOAD segment 是 RW, 包括一些可写的数据段(例如 got, data, bss,
dynamic 等).
</p>

<p>
PT_LOAD 是 elf 加载的第一步: kernel 会将所有 PT_LOAD 类型的数据 map 进来, 再调用 loader
</p>
</div>
</div>

<div id="outline-container-org00000bd" class="outline-5">
<h5 id="org00000bd"><span class="section-number-5">1.3.1.4</span> PT_DYNAMIC</h5>
<div class="outline-text-5" id="text-1-3-1-4">
<p>
PT_DYNAMIC 是给 loader 准备的, 是 loader 工作的起点.
PT_DYNAMIC 指向 dynamic section, loader 需要 dynamic section 中的数据来找到 got, plt, dynsym 等数据. 
</p>

<p>
需要注意的是 dynamic section 以及它包含的各个 DT_XXX 在前面已经通过
PT_LOAD 加载到内存中了, 所以 loader 可以放心的访问所有的 dynamic 信息,
dynamic 信息是特意给 loader 准备的.
</p>
</div>
</div>
</div>

<div id="outline-container-org00000c3" class="outline-4">
<h4 id="org00000c3"><span class="section-number-4">1.3.2</span> PT_LOAD</h4>
</div>

<div id="outline-container-org00000c6" class="outline-4">
<h4 id="org00000c6"><span class="section-number-4">1.3.3</span> PT_DYNAMIC</h4>
</div>

<div id="outline-container-org00000c9" class="outline-4">
<h4 id="org00000c9"><span class="section-number-4">1.3.4</span> PT_NOTE</h4>
</div>

<div id="outline-container-org00000cd" class="outline-4">
<h4 id="org00000cd"><span class="section-number-4">1.3.5</span> PT_GNU_RELRO</h4>
<div class="outline-text-4" id="text-1-3-5">
<p>
GNU_RELRO 要在 link relocations 完成后把一些 section 用 mprotect 修改为只读. 这些 section 主要包括: .init_array, .fini_array 以及 .got.
</p>

<p>
若使用了 RTLD_LAZY, 则不包括 .got.plt, 因为 LAZY 要求能在运行时修改 .got.plt
</p>

<pre class="example" id="org00000cc">
$&gt; cat test.c

int main(int argc, char *argv[]) {
    sleep(1000);
    return 0;
}

$&gt; gcc test.c -O0 -g3 -Wl,-z,relro -no-pie
$&gt; readelf -a ./a.out

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000400040 0x0000000000400040
                 0x00000000000001f8 0x00000000000001f8  R E    0x8
  INTERP         0x0000000000000238 0x0000000000400238 0x0000000000400238
                 0x000000000000001c 0x000000000000001c  R      0x1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x00000000000006ec 0x00000000000006ec  R E    0x200000
  LOAD           0x0000000000000e08 0x0000000000600e08 0x0000000000600e08
                 0x0000000000000228 0x0000000000000230  RW     0x200000
  DYNAMIC        0x0000000000000e18 0x0000000000600e18 0x0000000000600e18
                 0x00000000000001d0 0x00000000000001d0  RW     0x8
  ...
  GNU_RELRO      0x0000000000000e08 0x0000000000600e08 0x0000000000600e08
                 0x00000000000001f8 0x00000000000001f8  R      0x1
  ~~~~~~~~~               

 Section to Segment mapping:
  Segment Sections...
   00
   01     .interp
   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame
   03     .init_array .fini_array .dynamic .got .got.plt .data .bss
   ...
   08     .init_array .fini_array .dynamic .got
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Section Headers:
  ...
  [21] .got              PROGBITS         0000000000600fe8  00000fe8
       0000000000000018  0000000000000008  WA       0     0     8
  [22] .got.plt          PROGBITS         0000000000601000  00001000
                                          ~~~~~~~~~~~~~~~~
       0000000000000020  0000000000000008  WA       0     0     8
  [23] .data             PROGBITS         0000000000601020  00001020

$&gt; strace ./a.out

arch_prctl(ARCH_SET_FS, 0x7ff1d5243440) = 0
mprotect(0x7ff1d5056000, 16384, PROT_READ) = 0
mprotect(0x600000, 4096, PROT_READ)     = 0
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
mprotect(0x7ff1d5283000, 4096, PROT_READ) = 0
munmap(0x7ff1d5244000, 255800)          = 0

// 0x600000 是 GNU_RELRO 的地址 (0x600e08) 按 PAGE_SIZE round 后的结果,
所以实际 protect 的区域为 0x600000 ~ 0x601000, 而 0x601000 刚好是
.got.plt 的地址, 所以编译器已经考虑到 mprotect 需要 PAGE_SIZE 对齐的要
求.


$&gt; cat test.c

int main(int argc, char *argv[]) {
    sleep(1000);
    return 0;
}

$&gt; gcc test.c -O0 -g3 -Wl,-z,relro -z now

$&gt; readelf -a a.out
  GNU_RELRO      0x0000000000000de0 0x0000000000200de0 0x0000000000200de0
                 0x0000000000000220 0x0000000000000220  R      0x1

03     .init_array .fini_array .dynamic .got .data .bss
...                 
08     .init_array .fini_array .dynamic .got

// 0x200de0 + 0x220 = 0x201000, 这个地址刚好是 .data 的首地址, 所以使
// 用 -z now 后 plt 使用的 got 在包含在 relro 之内了
</pre>
</div>
</div>

<div id="outline-container-org00000d0" class="outline-4">
<h4 id="org00000d0"><span class="section-number-4">1.3.6</span> PT_PHDR</h4>
</div>
</div>

<div id="outline-container-org000010c" class="outline-3">
<h3 id="org000010c"><span class="section-number-3">1.4</span> .dynamic</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-org00000d7" class="outline-4">
<h4 id="org00000d7"><span class="section-number-4">1.4.1</span> elf_dynamic</h4>
<div class="outline-text-4" id="text-1-4-1">
<div class="org-src-container">
<pre class="src src-c"><span class="org-keyword">struct</span> <span class="org-type">Elf32_Dyn</span>
{
  <span class="org-type">Elf32_Sword</span> <span class="org-variable-name">d_tag</span>;            <span class="org-comment-delimiter">// </span><span class="org-comment">Type of dynamic table entry.</span>
  <span class="org-keyword">union</span>
  {
    <span class="org-type">Elf32_Word</span> <span class="org-variable-name">d_val</span>;         <span class="org-comment-delimiter">// </span><span class="org-comment">Integer value of entry.</span>
    <span class="org-type">Elf32_Addr</span> <span class="org-variable-name">d_ptr</span>;         <span class="org-comment-delimiter">// </span><span class="org-comment">Pointer value of entry.</span>
  } <span class="org-variable-name">d_un</span>;
};

</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">d_tag</th>
<th scope="col" class="org-right">tag_value</th>
<th scope="col" class="org-left">d_un</th>
<th scope="col" class="org-left">for exectuable</th>
<th scope="col" class="org-left">for so</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">DT_NULL</td>
<td class="org-right">0</td>
<td class="org-left">Ignored</td>
<td class="org-left">Mandatory</td>
<td class="org-left">Mandatory</td>
</tr>

<tr>
<td class="org-left">DT_NEEDED</td>
<td class="org-right">1</td>
<td class="org-left">d_val</td>
<td class="org-left">Optional</td>
<td class="org-left">Optional</td>
</tr>

<tr>
<td class="org-left">DT_PLTRELSZ</td>
<td class="org-right">2</td>
<td class="org-left">d_val</td>
<td class="org-left">Optional</td>
<td class="org-left">Optional</td>
</tr>

<tr>
<td class="org-left">DT_PLTGOT</td>
<td class="org-right">3</td>
<td class="org-left">d_ptr</td>
<td class="org-left">Optional</td>
<td class="org-left">Optional</td>
</tr>

<tr>
<td class="org-left">DT_HASH</td>
<td class="org-right">4</td>
<td class="org-left">d_ptr</td>
<td class="org-left">Mandatory</td>
<td class="org-left">Mandatory</td>
</tr>

<tr>
<td class="org-left">DT_STRTAB</td>
<td class="org-right">5</td>
<td class="org-left">d_ptr</td>
<td class="org-left">Mandatory</td>
<td class="org-left">Mandatory</td>
</tr>

<tr>
<td class="org-left">DT_SYMTAB</td>
<td class="org-right">6</td>
<td class="org-left">d_ptr</td>
<td class="org-left">Mandatory</td>
<td class="org-left">Mandatory</td>
</tr>

<tr>
<td class="org-left">DT_RELA</td>
<td class="org-right">7</td>
<td class="org-left">d_ptr</td>
<td class="org-left">Mandatory</td>
<td class="org-left">Optional</td>
</tr>

<tr>
<td class="org-left">DT_RELASZ</td>
<td class="org-right">8</td>
<td class="org-left">d_val</td>
<td class="org-left">Mandatory</td>
<td class="org-left">Optional</td>
</tr>

<tr>
<td class="org-left">DT_RELAENT</td>
<td class="org-right">9</td>
<td class="org-left">d_val</td>
<td class="org-left">Mandatory</td>
<td class="org-left">Optional</td>
</tr>

<tr>
<td class="org-left">DT_STRSZ</td>
<td class="org-right">10</td>
<td class="org-left">d_val</td>
<td class="org-left">Mandatory</td>
<td class="org-left">Mandatory</td>
</tr>

<tr>
<td class="org-left">DT_SYMENT</td>
<td class="org-right">11</td>
<td class="org-left">d_val</td>
<td class="org-left">Mandatory</td>
<td class="org-left">Mandatory</td>
</tr>

<tr>
<td class="org-left">DT_INIT</td>
<td class="org-right">12</td>
<td class="org-left">d_ptr</td>
<td class="org-left">Optional</td>
<td class="org-left">Optional</td>
</tr>

<tr>
<td class="org-left">DT_FINI</td>
<td class="org-right">13</td>
<td class="org-left">d_ptr</td>
<td class="org-left">Optional</td>
<td class="org-left">Optional</td>
</tr>

<tr>
<td class="org-left">DT_SONAME</td>
<td class="org-right">14</td>
<td class="org-left">d_val</td>
<td class="org-left">Ignored</td>
<td class="org-left">Optional</td>
</tr>

<tr>
<td class="org-left">DT_RPATH</td>
<td class="org-right">15</td>
<td class="org-left">d_val</td>
<td class="org-left">Optional</td>
<td class="org-left">Optional</td>
</tr>

<tr>
<td class="org-left">DT_REL</td>
<td class="org-right">17</td>
<td class="org-left">d_ptr</td>
<td class="org-left">Mandatory</td>
<td class="org-left">Optional</td>
</tr>

<tr>
<td class="org-left">DT_RELSZ</td>
<td class="org-right">18</td>
<td class="org-left">d_val</td>
<td class="org-left">Mandatory</td>
<td class="org-left">Optional</td>
</tr>

<tr>
<td class="org-left">DT_RELENT</td>
<td class="org-right">19</td>
<td class="org-left">d_val</td>
<td class="org-left">Mandatory</td>
<td class="org-left">Optional</td>
</tr>

<tr>
<td class="org-left">DT_JMPREL</td>
<td class="org-right">23</td>
<td class="org-left">d_ptr</td>
<td class="org-left">Optional</td>
<td class="org-left">Optional</td>
</tr>

<tr>
<td class="org-left">DT_BIND_NOW</td>
<td class="org-right">24</td>
<td class="org-left">Ignored</td>
<td class="org-left">Optional</td>
<td class="org-left">Optional</td>
</tr>

<tr>
<td class="org-left">DT_INIT_ARRAY</td>
<td class="org-right">25</td>
<td class="org-left">d_ptr</td>
<td class="org-left">Optional</td>
<td class="org-left">Optional</td>
</tr>

<tr>
<td class="org-left">DT_FINI_ARRAY</td>
<td class="org-right">26</td>
<td class="org-left">d_ptr</td>
<td class="org-left">Optional</td>
<td class="org-left">Optional</td>
</tr>

<tr>
<td class="org-left">DT_INIT_ARRAYSZ</td>
<td class="org-right">27</td>
<td class="org-left">d_val</td>
<td class="org-left">Optional</td>
<td class="org-left">Optional</td>
</tr>

<tr>
<td class="org-left">DT_FINI_ARRAYSZ</td>
<td class="org-right">28</td>
<td class="org-left">d_val</td>
<td class="org-left">Optional</td>
<td class="org-left">Optional</td>
</tr>

<tr>
<td class="org-left">DT_RUNPATH</td>
<td class="org-right">29</td>
<td class="org-left">d_val</td>
<td class="org-left">Optional</td>
<td class="org-left">Optional</td>
</tr>

<tr>
<td class="org-left">DT_FLAGS</td>
<td class="org-right">30</td>
<td class="org-left">d_val</td>
<td class="org-left">Optional</td>
<td class="org-left">Optional</td>
</tr>

<tr>
<td class="org-left">DT_PREINIT_ARRAY</td>
<td class="org-right">32</td>
<td class="org-left">d_ptr</td>
<td class="org-left">Optional</td>
<td class="org-left">Ignored</td>
</tr>

<tr>
<td class="org-left">DT_PREINIT_ARRAYSZ</td>
<td class="org-right">33</td>
<td class="org-left">d_val</td>
<td class="org-left">Optional</td>
<td class="org-left">Ignored</td>
</tr>

<tr>
<td class="org-left">&#x2026;</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<pre class="example" id="org00000d6">
$&gt; readelf -a ./a.out
  [16] .dynamic          DYNAMIC         00001ec4 000ec4 000110 08  WA  4   0  4

Dynamic section at offset 0xec4 contains 29 entries:
  Tag        Type                         Name/Value
 0x00000003 (PLTGOT)                     0x1fe8
 0x00000002 (PLTRELSZ)                   24 (bytes)
 0x00000017 (JMPREL)                     0x328
 0x00000014 (PLTREL)                     REL
 0x00000011 (REL)                        0x300
 0x00000012 (RELSZ)                      40 (bytes)
 0x00000013 (RELENT)                     8 (bytes)
 0x6ffffffa (RELCOUNT)                   5
 0x00000015 (DEBUG)                      0x0

$&gt; od -x ./a.out +0xec4
0007304 0003 0000 1fe8 0000 0002 0000 0018 0000
0007324 0017 0000 0328 0000 0014 0000 0011 0000
0007344 0011 0000 0300 0000 0012 0000 0028 0000
0007364 0013 0000 0008 0000 fffa 6fff 0005 0000
0007404 0015 0000 0000 0000 0006 0000 01e0 0000
0007424 000b 0000 0010 0000 0005 0000 0250 0000
0007444 000a 0000 004d 0000 0004 0000 02a0 0000
0007464 0001 0000 0012 0000 0001 0000 0044 0000
0007504 000c 0000 0420 0000 001a 0000 1ea4 0000
</pre>

<p>
其中需要注意的是:
</p>

<ol class="org-ol">
<li>DT_SYMTAB 和 DT_STRTAB 指向的是实际是 .dynsym 和 .dynstr (而不是
.symtab 和 .strtab), 因为 .dynamic 是给 linker 用的, 它只需要关注
.dynsym/.dynstr</li>

<li>DT_NEEDED, DT_RUNPATH, DT_SONAME 的 d_val 是对应 .dynstr 的 offset,
而不是对应 .dynsym 的 index.</li>

<li>DT_REL{A} 对应的实际上是 .rel{a}.dyn, DT_JMPREL{A} 对应的是 .rel{a}.plt</li>
</ol>
</div>
</div>

<div id="outline-container-org00000dc" class="outline-4">
<h4 id="org00000dc"><span class="section-number-4">1.4.2</span> DT_SYMBOLIC</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
<a href="https://stackoverflow.com/questions/1588915/whats-the-difference-between-the-symbolic-and-shared-gcc-flags">https://stackoverflow.com/questions/1588915/whats-the-difference-between-the-symbolic-and-shared-gcc-flags</a>
</p>

<p>
symbolic 会在一定程序上阻塞 so 上全局符号的 interposition
</p>

<pre class="example" id="org00000da">
$&gt; cat foo.c

void bar() {
    printf("%s\n", "bar");
}
void foo() {
    printf("%s\n", "foo");
    bar();
}

$&gt; cat main.c

#include &lt;stdio.h&gt;

extern void foo();
void bar() {
    printf("%s\n", "bar from main");
}
int main(int argc, char *argv[]) {
    foo();
    return 0;
}

$&gt; gcc -shared -fPIC -O0 -g3 foo.c -o libfoo.so -Wl,-Bsymbolic
$&gt; gcc mainc libfoo.so
$&gt; LD_LIBRARY_PATH=. ./a.out
foo
bar

$&gt; gcc -shared -fPIC -O0 -g3 foo.c -o libfoo.so
$&gt; LD_LIBRARY_PATH=. ./a.out
foo
bar from main
</pre>

<p>
比较两者的代码:
</p>

<pre class="example" id="org00000db">
$&gt; gcc -shared -O0 -g3 -fPIC foo.c -o libfoo.so -Wl,-Bsymbolic
$&gt; objdump -D libfoo.so

000000000000063d &lt;foo&gt;:
 63d:	55                   	push   %rbp
 63e:	48 89 e5             	mov    %rsp,%rbp
 641:	48 8d 3d 21 00 00 00 	lea    0x21(%rip),%rdi        # 669 &lt;_fini+0xd&gt;
 648:	e8 e3 fe ff ff       	callq  530 &lt;puts@plt&gt;
 64d:	b8 00 00 00 00       	mov    $0x0,%eax
 652:	e8 d3 ff ff ff       	callq  62a &lt;bar&gt;             &lt;------
 657:	90                   	nop
 658:	5d                   	pop    %rbp
 659:	c3                   	retq   


$&gt; gcc -shared -O0 -g3 -fPIC foo.c -o libfoo.so
$&gt; objdump -D libfoo.so

000000000000065d &lt;foo&gt;:
 65d:	55                   	push   %rbp
 65e:	48 89 e5             	mov    %rsp,%rbp
 661:	48 8d 3d 21 00 00 00 	lea    0x21(%rip),%rdi        # 689 &lt;_fini+0xd&gt;
 668:	e8 d3 fe ff ff       	callq  540 &lt;puts@plt&gt;
 66d:	b8 00 00 00 00       	mov    $0x0,%eax
 672:	e8 d9 fe ff ff       	callq  550 &lt;bar@plt&gt;          &lt;---- 通过 plt 查找, loader 会负责将 main 中的 bar 写到 got.plt 中
 677:	90                   	nop
 678:	5d                   	pop    %rbp
 679:	c3                   	retq   
</pre>

<p>
loader 在处理 DT_SYMBOLIC 时, 会优先从当前 so 中查找符号, 所以即使编译时针对 Bsymbolic 没有生成 callq &lt;bar&gt; 这样的代码而是生成了 callq
&lt;bar@plt&gt;, loader 也会保证在有 DT_SYMBOLIC 时将 libfoo.so 中的 bar 写到 got.plt 中以满足 symbolic 的要求.
</p>

<p>
linker 做为一个 DSO, 会使用 Bsymbolic 保证在完成自身的 link 之前也可以正确的进行函数调用, 因为 Bsymbolic 避免对函数进行重定位. 通过控制函数的visibility 也可以达到相同的效果, 但由于 linker 需要调用静态 libc 中的代码, 这部分公共代码是不能修改 visibility 的
</p>
</div>
</div>

<div id="outline-container-org00000df" class="outline-4">
<h4 id="org00000df"><span class="section-number-4">1.4.3</span> DT_HASH</h4>
</div>

<div id="outline-container-org00000e2" class="outline-4">
<h4 id="org00000e2"><span class="section-number-4">1.4.4</span> DT_GNU_HASH</h4>
</div>

<div id="outline-container-org00000e5" class="outline-4">
<h4 id="org00000e5"><span class="section-number-4">1.4.5</span> DT_NEEDED</h4>
</div>

<div id="outline-container-org00000e8" class="outline-4">
<h4 id="org00000e8"><span class="section-number-4">1.4.6</span> DT_INIT</h4>
</div>

<div id="outline-container-org00000eb" class="outline-4">
<h4 id="org00000eb"><span class="section-number-4">1.4.7</span> DT_INIT_ARRAY</h4>
</div>

<div id="outline-container-org00000ee" class="outline-4">
<h4 id="org00000ee"><span class="section-number-4">1.4.8</span> DT_REL</h4>
</div>

<div id="outline-container-org00000f1" class="outline-4">
<h4 id="org00000f1"><span class="section-number-4">1.4.9</span> DT_JMPREL</h4>
</div>

<div id="outline-container-org00000f4" class="outline-4">
<h4 id="org00000f4"><span class="section-number-4">1.4.10</span> DT_RUNPATH</h4>
</div>

<div id="outline-container-org00000f7" class="outline-4">
<h4 id="org00000f7"><span class="section-number-4">1.4.11</span> DT_PLTGOT</h4>
</div>

<div id="outline-container-org00000fa" class="outline-4">
<h4 id="org00000fa"><span class="section-number-4">1.4.12</span> DT_STRTAB</h4>
</div>

<div id="outline-container-org00000fd" class="outline-4">
<h4 id="org00000fd"><span class="section-number-4">1.4.13</span> DT_SYMTAB</h4>
</div>

<div id="outline-container-org0000100" class="outline-4">
<h4 id="org0000100"><span class="section-number-4">1.4.14</span> DT_SONAME</h4>
</div>

<div id="outline-container-org0000103" class="outline-4">
<h4 id="org0000103"><span class="section-number-4">1.4.15</span> DT_FLAGS_1</h4>
</div>

<div id="outline-container-org0000106" class="outline-4">
<h4 id="org0000106"><span class="section-number-4">1.4.16</span> DF_1_GLOBAL</h4>
</div>

<div id="outline-container-org0000109" class="outline-4">
<h4 id="org0000109"><span class="section-number-4">1.4.17</span> DF_1_NOW</h4>
</div>
</div>

<div id="outline-container-org000010f" class="outline-3">
<h3 id="org000010f"><span class="section-number-3">1.5</span> reference</h3>
<div class="outline-text-3" id="text-1-5">
<p>
<a href="http://web.archive.org/web/20161130000203/http://www.cs.stevens.edu:80/~jschauma/810/elf.html">http://web.archive.org/web/20161130000203/http://www.cs.stevens.edu:80/~jschauma/810/elf.html</a>
<a href="https://www.akkadia.org/drepper/dsohowto.pdf">https://www.akkadia.org/drepper/dsohowto.pdf</a>
<a href="http://www.cs.northwestern.edu/~pdinda/icsclass/doc/elf.pdf">http://www.cs.northwestern.edu/~pdinda/icsclass/doc/elf.pdf</a>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

<p class="author">Author: sunway (sunwayforever@gmail.com)<br />
Date: 2017-03-31 Fri 00:00<br />
Last updated: 2022-03-29 Tue 09:28</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。
<br />

<div id="disqus_thread"></div>
<script>

(function() { // DON'T EDIT BELOW THIS LINE
         var d = document, s = d.createElement('script');
         s.src = '//sunwayforever-github-io.disqus.com/embed.js';
         s.setAttribute('data-timestamp', +new Date());
         (d.head || d.body).appendChild(s);
         })();
</script>
</div>
</body>
</html>
