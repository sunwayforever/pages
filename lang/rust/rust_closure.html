<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-01-26 Wed 11:42 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Rust Closure</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wei Sun (孙伟)" />
<link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
<link rel = "icon" href = "/icon.png"  type = "image/x-icon">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">Rust Closure</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgfcf9151">1. Rust Closure</a>
<ul>
<li><a href="#org1b39aa6">1.1. function</a></li>
<li><a href="#org90c00e5">1.2. closure</a>
<ul>
<li><a href="#orgefefd8d">1.2.1. memory layout</a></li>
<li><a href="#orgf28d8d6">1.2.2. closure 的类型</a></li>
</ul>
</li>
<li><a href="#org21841b4">1.3. Fn trait</a></li>
<li><a href="#orgb953b66">1.4. move</a></li>
<li><a href="#org20eb63e">1.5. Fn, FnMut, FnOnce</a>
<ul>
<li><a href="#orgbc68790">1.5.1. FnOnce</a></li>
<li><a href="#org5e5a8e8">1.5.2. FnMut</a></li>
<li><a href="#org985d30c">1.5.3. Fn</a></li>
<li><a href="#orgfb98f4e">1.5.4. trait bound</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgfcf9151" class="outline-2">
<h2 id="orgfcf9151"><span class="section-number-2">1</span> Rust Closure</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org1b39aa6" class="outline-3">
<h3 id="org1b39aa6"><span class="section-number-3">1.1</span> function</h3>
<div class="outline-text-3" id="text-1-1">
<p>
function 是 first class object, 当函数作为参数, 返回值, 变量等情况下, 实际上使用
的是函数指针, 其类型为 fn(args)-&gt;(return).
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">test</span>() {}

<span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">call</span>(<span style="font-weight: bold; font-style: italic;">f</span>: <span style="font-weight: bold;">fn</span>()) {
    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"call:"</span>);
    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"f is at </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, &amp;f <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> _);
    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"which point to </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, f <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> ());
    <span style="font-weight: bold;">unsafe</span> {
        <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"also 0x</span><span style="font-style: italic;">{:x}</span><span style="font-style: italic;">"</span>, *(&amp;f <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> _ <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">i64</span>));
    }

    f();
}

<span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">main</span>() {
    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"main:"</span>);
    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"test is at </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, test <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> ());
    call(test);
}
</pre>
</div>

<p>
main:
test is at 0x55e8be0037b0
call:
f is at 0x7ffed8b99f40
which point to 0x55e8be0037b0
also 0x55e8be0037b0
</p>
</div>
</div>

<div id="outline-container-org90c00e5" class="outline-3">
<h3 id="org90c00e5"><span class="section-number-3">1.2</span> closure</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-orgefefd8d" class="outline-4">
<h4 id="orgefefd8d"><span class="section-number-4">1.2.1</span> memory layout</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
closure 分为两种情况:
</p>
<ol class="org-ol">
<li>当 closure 不需要 capture 时, 和普通函数相同.</li>
<li>当 closure 需要 capture 时, 需要占用额外的空间保存 capture 的数据</li>
</ol>

<div class="org-src-container">
<pre class="src src-rust"><span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">main</span>() {
    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"\nmove ---------------"</span>);
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">x</span> = 0xffi64;
    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"x is at </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, &amp;x <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> _);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">move</span>
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">foo_move</span> = <span style="font-weight: bold;">move</span> || {
        <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"</span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, x);
    };
    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"size of foo: </span><span style="font-style: italic;">{}</span><span style="font-style: italic;">"</span>, <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">mem</span>::size_of_val(&amp;foo_move));
    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"foo_move is at </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, &amp;foo_move <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> _);
    <span style="font-weight: bold;">unsafe</span> {
        <span style="font-weight: bold;">println!</span>(
            <span style="font-style: italic;">"foo_move val is </span><span style="font-style: italic;">{:x}</span><span style="font-style: italic;">"</span>,
            *(&amp;foo_move <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> _ <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">i64</span>)
        );
    }
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">borrow</span>
    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"\nborrow ---------------"</span>);
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">foo_borrow</span> = || {
        <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"</span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, x);
    };
    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"size of foo_borrow: </span><span style="font-style: italic;">{}</span><span style="font-style: italic;">"</span>, <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">mem</span>::size_of_val(&amp;foo_borrow));
    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"foo_borrow is at </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, &amp;foo_borrow <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> _);
    <span style="font-weight: bold;">unsafe</span> {
        <span style="font-weight: bold;">println!</span>(
            <span style="font-style: italic;">"foo_borrow val is </span><span style="font-style: italic;">{:x}</span><span style="font-style: italic;">, whic is &amp;x"</span>,
            *(&amp;foo_borrow <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> _ <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">i64</span>)
        );
    }
}
</pre>
</div>

<p>
move ----------&#x2013;&#x2014;
x is at 0x7ffeab13ce88
size of foo: 8
foo_move is at 0x7ffeab13cee8
foo_move val is ff
</p>

<p>
borrow ----------&#x2013;&#x2014;
size of foo_borrow: 8
foo_borrow is at 0x7ffeab13d020
foo_borrow val is 7ffeab13ce88, whic is &amp;x
</p>

<p>
closure 对应的 code 并不需要包含在 closure 中, 因为每个 closure 都是不同的类型,
编译器知道每个 closure 对应的 code 在哪里. 
</p>
</div>
</div>

<div id="outline-container-orgf28d8d6" class="outline-4">
<h4 id="orgf28d8d6"><span class="section-number-4">1.2.2</span> closure 的类型</h4>
<div class="outline-text-4" id="text-1-2-2">
<div class="org-src-container">
<pre class="src src-rust"><span style="font-weight: bold;">#![feature(core_intrinsics)]</span>
<span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">type_of</span>&lt;<span style="font-weight: bold; text-decoration: underline;">T</span>&gt;(<span style="font-weight: bold; font-style: italic;">_</span>: &amp;<span style="font-weight: bold; text-decoration: underline;">T</span>) -&gt; &amp;<span style="font-weight: bold; text-decoration: underline;">str</span> {
    <span style="font-weight: bold;">unsafe</span> { <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">intrinsics</span>::type_name::&lt;<span style="font-weight: bold; text-decoration: underline;">T</span>&gt;() }
}

<span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">test</span>() -&gt; () {}

<span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">main</span>() {
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">foo</span> = || {};
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">bar</span> = || {};
    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"type of foo: </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, type_of(&amp;foo));
    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"type of bar: </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, type_of(&amp;bar));
    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"type of test: </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, type_of(&amp;test));
}
</pre>
</div>

<p>
type of foo: "[closure@src/main.rs:10:15: 10:20]"
type of bar: "[closure@src/main.rs:11:15: 11:20]"
type of test: "fn() {test}"
</p>
</div>
</div>
</div>

<div id="outline-container-org21841b4" class="outline-3">
<h3 id="org21841b4"><span class="section-number-3">1.3</span> Fn trait</h3>
<div class="outline-text-3" id="text-1-3">
<p>
closure 无法做为函数的参数和返回值等, 因为:
</p>

<ol class="org-ol">
<li>closure 都是动态生成的类型, 无法写在函数的 signature 里, 只能依靠编译器的类型
推导 (c++ 的 auto 关键字解决类似的问题)</li>

<li>closure 的大小是不确定的, 同样 signature 的 closure, 会因为 capture 的不同导
致不同的大小, 所以无法通过类似 `fn()-&gt;()` 来指示 closure 的类型</li>
</ol>

<div class="org-src-container">
<pre class="src src-rust"><span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">call</span>(<span style="font-weight: bold; font-style: italic;">f</span>: <span style="font-weight: bold;">fn</span>()) {
    f();
}

<span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">test</span>() {}

<span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">main</span>() {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">OK, &#27809;&#26377; capture &#30340; closure &#21487;&#20197; coerce &#20026; fn()</span>
    call(|| {
        <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"hello"</span>);
    });
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">OK</span>
    call(test);

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">WRONG, &#38656;&#35201; capture &#30340; closure &#26080;&#27861; coerce &#20026; fn()</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">error[E0308]: mismatched types</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">--&gt; src/main.rs:19:10</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">|</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">19 |       call(|| {</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">|  __________^</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">20 | |         println!("{:?}", x);</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">21 | |     })</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">| |_____^ expected fn pointer, found closure</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">|</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">= note: expected type `fn()`</span>
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">x</span> = 1;
    call(|| {
        <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"</span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, x);
    })
}
</pre>
</div>

<p>
解决方法是使用 Fn trait, 因为 closure, fn 都会 impl Fn trait
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">call</span>(<span style="font-weight: bold; font-style: italic;">f</span>: &amp;<span style="font-weight: bold;">dyn</span> <span style="font-weight: bold; text-decoration: underline;">Fn</span>()) {
    f();
}

<span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">test</span>() {
    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"normal fn"</span>);
}

<span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">main</span>() {
    call(&amp;test);

    call(&amp;|| {
        <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"uncaptured closure"</span>);
    });

    <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">x</span> = 1;
    call(&amp;|| {
        <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"captured closure: </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, x);
    })
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb953b66" class="outline-3">
<h3 id="orgb953b66"><span class="section-number-3">1.4</span> move</h3>
<div class="outline-text-3" id="text-1-4">
<div class="org-src-container">
<pre class="src src-rust"><span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">call</span>(<span style="font-weight: bold; font-style: italic;">f</span>: <span style="font-weight: bold;">impl</span> <span style="font-weight: bold; text-decoration: underline;">Fn</span>()) {
    f()
}

<span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">main</span>() {
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">f</span> = {
        <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">x</span> = <span style="font-style: italic;">"hello"</span>.to_owned();
        <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">ret</span> = <span style="font-weight: bold;">move</span> || {
            <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"</span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, x);
        };
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">error[E0382]: borrow of moved value: `x`</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">println!("{:?}", x);</span>
        ret
    };

    call(f)
}
</pre>
</div>

<p>
默认情况下会使用 borrow 的方式 capture 环境变量, 若像上面的例子一样无法 borrow,
则需要显式的指定 move.
</p>

<p>
另外, move 是定义 closure 时 (而非执行时) 把环境变量一次性的 move 到 closure 内
的. 后面执行 closure 时不会再发生 move
</p>

<p>
另外, 若 closure 代码会 consume 环境变量, 编译器会自动的 move
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">call</span>(<span style="font-weight: bold; font-style: italic;">f</span>: <span style="font-weight: bold;">impl</span> <span style="font-weight: bold; text-decoration: underline;">FnOnce</span>()) {
    f()
}

<span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">main</span>() {
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">x</span> = <span style="font-style: italic;">"hello"</span>.to_owned();
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">f</span> = || {
        <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">y</span> = x;
        <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"</span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, y);
    };
    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"</span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, x);
    call(f)
}

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">error[E0382]: borrow of moved value: `x`</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">--&gt; quickrun:11:22</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">|</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">6  |     let x = "hello".to_owned();</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">|         - move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">7  |     let f = || {</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">|             -- value moved into closure here</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">8  |         let y = x;</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">|                 - variable moved due to use in closure</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">...</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">11 |     println!("{:?}", x);</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">|                      ^ value borrowed here after move</span>
<span style="font-weight: bold; font-style: italic;">//</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">error: aborting due to previous error</span>
<span style="font-weight: bold; font-style: italic;">//</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">For more information about this error, try `rustc --explain E0382`.</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org20eb63e" class="outline-3">
<h3 id="org20eb63e"><span class="section-number-3">1.5</span> Fn, FnMut, FnOnce</h3>
<div class="outline-text-3" id="text-1-5">
<p>
所有的 function 都 impl Fn.
</p>

<p>
但对于 closure 来说, 针对 capture 的不同, 编译器会自动 impl Fn, FnMut 或 FnOnce
中的一个.
</p>
</div>

<div id="outline-container-orgbc68790" class="outline-4">
<h4 id="orgbc68790"><span class="section-number-4">1.5.1</span> FnOnce</h4>
<div class="outline-text-4" id="text-1-5-1">
<div class="org-src-container">
<pre class="src src-rust"><span style="font-weight: bold;">move</span> || {
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">z</span> = x;
};
</pre>
</div>

<p>
这个 closure impl FnOnce, 因为 closure 每次执行时都会 move capture 到的变量, 但这
个 move 只能进行一次. 所以 FnOnce 表示 closure 只能执行一次. 
</p>

<p>
只有 move closure 才可能是 FnOnce
</p>
</div>
</div>

<div id="outline-container-org5e5a8e8" class="outline-4">
<h4 id="org5e5a8e8"><span class="section-number-4">1.5.2</span> FnMut</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
若 closure 会修改 capture variable, 则它会 impl FnMut
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">x</span> = 1;
|| {
    x += 1;
}
</pre>
</div>

<p>
上面的 closure 实际会持有 `&amp;mut x`
</p>
</div>
</div>

<div id="outline-container-org985d30c" class="outline-4">
<h4 id="org985d30c"><span class="section-number-4">1.5.3</span> Fn</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
Fn 表示 closure 不会修改 capture variable 且可以执行多次.
</p>
</div>
</div>

<div id="outline-container-orgfb98f4e" class="outline-4">
<h4 id="orgfb98f4e"><span class="section-number-4">1.5.4</span> trait bound</h4>
<div class="outline-text-4" id="text-1-5-4">
<p>
Fn 等作为 trait bound 时有不同的意义:
</p>

<ol class="org-ol">
<li>Fn trait bound 表示需要能执行多次且不修改 capture variable</li>

<li>FnMut trait bound 表示需要能执行多次且`可以`修改 (而不是一定要修改)</li>

<li>FnOnce trait bound 表示不需要能执行多次</li>
</ol>

<p>
所以, Fn -&gt; FnMut -&gt; FnOnce 的要求是依次降低的:
</p>

<ol class="org-ol">
<li>Fn trait bound 无法接受 FnMut 和 FnOnce, 因为它要求能执行多次且不修改</li>

<li>FnMut trait bound 无法接受 FnOnce</li>

<li>FnOnce trait bound 可以接受任何 Fn, FnMut 或 FnOnce</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

<p class="author">Author: sunway (sunwayforever@gmail.com)<br />
Date: 2019-02-27 Wed 00:00<br />
Last updated: 2021-09-16 Thu 11:06</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。
<br />

<div id="disqus_thread"></div>
<script>

(function() { // DON'T EDIT BELOW THIS LINE
         var d = document, s = d.createElement('script');
         s.src = '//sunwayforever-github-io.disqus.com/embed.js';
         s.setAttribute('data-timestamp', +new Date());
         (d.head || d.body).appendChild(s);
         })();
</script>
</div>
</body>
</html>
