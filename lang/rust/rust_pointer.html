<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-01-26 Wed 01:17 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Rust Pointer</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wei Sun (孙伟)" />
<link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
<link rel = "icon" href = "/icon.png"  type = "image/x-icon">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">Rust Pointer</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org19249ac">1. Rust Pointer</a>
<ul>
<li><a href="#org5e1df16">1.1. slice</a></li>
<li><a href="#org0a33e22">1.2. Box</a>
<ul>
<li><a href="#orge4c40d8">1.2.1. 内部原理</a></li>
<li><a href="#org736c77c">1.2.2. Box 使用</a></li>
<li><a href="#org5b14111">1.2.3. Box 的应用场景</a></li>
</ul>
</li>
<li><a href="#org3888497">1.3. Rc</a>
<ul>
<li><a href="#org011e530">1.3.1. 内部原理</a></li>
<li><a href="#org649fb20">1.3.2. 使用 Rc 实现链表</a></li>
</ul>
</li>
<li><a href="#org36093aa">1.4. RefCell</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org19249ac" class="outline-2">
<h2 id="org19249ac"><span class="section-number-2">1</span> Rust Pointer</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org5e1df16" class="outline-3">
<h3 id="org5e1df16"><span class="section-number-3">1.1</span> slice</h3>
<div class="outline-text-3" id="text-1-1">
<div class="org-src-container">
<pre class="src src-rust"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">Test</span>(<span style="font-weight: bold; text-decoration: underline;">i64</span>, <span style="font-weight: bold; text-decoration: underline;">i64</span>);

<span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">format_of_string</span>() -&gt; () {
    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"------\nformat of String:"</span>);
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">s</span> = <span style="font-style: italic;">"abcde"</span>.to_owned();
    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"size: </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">mem</span>::size_of_val(&amp;s));

    <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">pp</span> = &amp;s <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> _ <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> [<span style="font-weight: bold; text-decoration: underline;">i64</span>; 3];
    <span style="font-weight: bold;">unsafe</span> {
        <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"string addr is </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, pp);
        <span style="font-weight: bold;">println!</span>(
            <span style="font-style: italic;">"string value is 0x</span><span style="font-style: italic;">{:x}</span><span style="font-style: italic;"> 0x</span><span style="font-style: italic;">{:x}</span><span style="font-style: italic;"> 0x</span><span style="font-style: italic;">{:x}</span><span style="font-style: italic;">"</span>,
            (*pp)[0],
            (*pp)[1],
            (*pp)[2],
        );

        <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">p_heap</span> = (*pp)[0] <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> [<span style="font-weight: bold; text-decoration: underline;">u8</span>; 6];
        <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"heap value is </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, *p_heap);
    }
}

<span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">format_of_str</span>() -&gt; () {
    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"------\nformat of &amp;str:"</span>);
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">orig</span> = <span style="font-style: italic;">"abc"</span>.to_owned();


    <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">s</span> = &amp;orig[1..];
    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"size: </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">mem</span>::size_of_val(&amp;s));

    <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">pp</span> = &amp;s <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> _ <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> [<span style="font-weight: bold; text-decoration: underline;">i64</span>; 2];
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">pp_orig</span> = &amp;orig <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> _ <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> [<span style="font-weight: bold; text-decoration: underline;">i64</span>; 3];
    <span style="font-weight: bold;">unsafe</span> {
        <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"string addr is </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, pp_orig);
        <span style="font-weight: bold;">println!</span>(
            <span style="font-style: italic;">"string value is 0x</span><span style="font-style: italic;">{:x}</span><span style="font-style: italic;"> 0x</span><span style="font-style: italic;">{:x}</span><span style="font-style: italic;"> 0x</span><span style="font-style: italic;">{:x}</span><span style="font-style: italic;">"</span>,
            (*pp_orig)[0],
            (*pp_orig)[1],
            (*pp_orig)[2],
        );

        <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"str addr is </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, pp);
        <span style="font-weight: bold;">println!</span>(
            <span style="font-style: italic;">"str value is 0x</span><span style="font-style: italic;">{:x}</span><span style="font-style: italic;"> 0x</span><span style="font-style: italic;">{:x}</span><span style="font-style: italic;">"</span>,
            (*pp)[0],
            (*pp)[1],
        );        
    }
}

<span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">main</span>() {
    format_of_string();
    format_of_str();
}
</pre>
</div>

<hr />
<p>
format of String:
size: 24
string addr is 0x7ffc8543c5f8
string value is 0x56533d4d4c80 0x5 0x5
heap value is [97, 98, 99, 100, 101, 0]
</p>
<hr />
<p>
format of &amp;str:
size: 16
string addr is 0x7ffc8543c570
string value is 0x56533d4d4c80 0x3 0x3
str addr is 0x7ffc8543c588
str value is 0x56533d4d4c81 0x2
</p>

<ol class="org-ol">
<li>String 本身位于栈上, 格式为 `[pointer_to_heap, size, capacity]`,
pointer_to_heap 指向堆, 保存 String 真正的内容</li>

<li>&amp;str 格式为 `[pointer_to_heap, size]`, 它直接指向 heap + slice_offset, 而不是
指向栈上的 String 对象</li>
</ol>

<p>
所以 &amp;str 以及 &amp;slice 中的 &amp; 操作并非直接取地址, 它们`生成`一个 `fat pointer`,且
pointer 会指向真正的 payload 而不是栈上的 String 或 array.
</p>

<p>
另外, `fat pointer` 中的 size 用来确保运行时访问不越界
</p>
</div>
</div>

<div id="outline-container-org0a33e22" class="outline-3">
<h3 id="org0a33e22"><span class="section-number-3">1.2</span> Box</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-orge4c40d8" class="outline-4">
<h4 id="orge4c40d8"><span class="section-number-4">1.2.1</span> 内部原理</h4>
<div class="outline-text-4" id="text-1-2-1">
<div class="org-src-container">
<pre class="src src-rust"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">Test</span>(<span style="font-weight: bold; text-decoration: underline;">i64</span>, <span style="font-weight: bold; text-decoration: underline;">i64</span>);

<span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">main</span>() {
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold;">mut</span> <span style="font-weight: bold; font-style: italic;">p</span> = <span style="font-weight: bold; text-decoration: underline;">Box</span>::new(<span style="font-weight: bold; text-decoration: underline;">Test</span>(1234, 5678));
    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"size: </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">mem</span>::size_of_val(&amp;p));
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">pp</span> = &amp;p <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> _ <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> [<span style="font-weight: bold; text-decoration: underline;">i64</span>; 1];
    <span style="font-weight: bold;">unsafe</span> {
        <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"box addr is </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, pp);
        <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"box value is 0x</span><span style="font-style: italic;">{:x}</span><span style="font-style: italic;">"</span>, (*pp)[0]);

        <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">p_heap</span> = (*pp)[0] <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> [<span style="font-weight: bold; text-decoration: underline;">i64</span>; 2];
        <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"heap value is </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, *p_heap);
    }
}
</pre>
</div>

<p>
size: 8
box addr is 0x7ffefa5bde28
box value is 0x55d631c7ab40
heap value is [1234, 5678]
</p>

<p>
Box 自身分配在栈上, 它只包含一个指向堆的地址 (String 除了地址还包括 size 和
capacity), payload 实际在堆上.
</p>
</div>
</div>

<div id="outline-container-org736c77c" class="outline-4">
<h4 id="org736c77c"><span class="section-number-4">1.2.2</span> Box 使用</h4>
<div class="outline-text-4" id="text-1-2-2">
</div>
<div id="outline-container-org68f2996" class="outline-5">
<h5 id="org68f2996"><span class="section-number-5">1.2.2.1</span> 使用 reference 实现链表</h5>
<div class="outline-text-5" id="text-1-2-2-1">
<div class="org-src-container">
<pre class="src src-rust"><span style="font-weight: bold;">#[derive(Debug)]</span>
<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">ListNode</span>&lt;'<span style="font-weight: bold; font-style: italic;">a</span>&gt; {
    <span style="font-weight: bold; font-style: italic;">val</span>: <span style="font-weight: bold; text-decoration: underline;">i32</span>,
    <span style="font-weight: bold; font-style: italic;">next</span>: <span style="font-weight: bold; text-decoration: underline;">Option</span>&lt;&amp;'<span style="font-weight: bold; font-style: italic;">a</span> <span style="font-weight: bold; text-decoration: underline;">ListNode</span>&lt;'<span style="font-weight: bold; font-style: italic;">a</span>&gt;&gt;,
}
<span style="font-weight: bold;">impl</span>&lt;'<span style="font-weight: bold; font-style: italic;">a</span>&gt; <span style="font-weight: bold; text-decoration: underline;">ListNode</span>&lt;'<span style="font-weight: bold; font-style: italic;">a</span>&gt; {
    <span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">new</span>(<span style="font-weight: bold; font-style: italic;">val</span>: <span style="font-weight: bold; text-decoration: underline;">i32</span>) -&gt; (<span style="font-weight: bold; text-decoration: underline;">ListNode</span>&lt;'<span style="font-weight: bold; font-style: italic;">a</span>&gt;) {
        <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">ListNode</span> {
            <span style="font-weight: bold; font-style: italic;">val</span>: val,
            <span style="font-weight: bold; font-style: italic;">next</span>: <span style="font-weight: bold; text-decoration: underline;">None</span>,
        };
    }
}
<span style="font-weight: bold;">#[derive(Debug)]</span>
<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">LinkedList</span>&lt;'<span style="font-weight: bold; font-style: italic;">a</span>&gt; {
    <span style="font-weight: bold; font-style: italic;">root</span>: <span style="font-weight: bold; text-decoration: underline;">Option</span>&lt;&amp;'<span style="font-weight: bold; font-style: italic;">a</span> <span style="font-weight: bold; text-decoration: underline;">ListNode</span>&lt;'<span style="font-weight: bold; font-style: italic;">a</span>&gt;&gt;,
}

<span style="font-weight: bold;">impl</span>&lt;'<span style="font-weight: bold; font-style: italic;">a</span>&gt; <span style="font-weight: bold; text-decoration: underline;">LinkedList</span>&lt;'<span style="font-weight: bold; font-style: italic;">a</span>&gt; {
    <span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">new</span>() -&gt; <span style="font-weight: bold; text-decoration: underline;">LinkedList</span>&lt;'<span style="font-weight: bold; font-style: italic;">a</span>&gt; {
        <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">LinkedList</span> { <span style="font-weight: bold; font-style: italic;">root</span>: <span style="font-weight: bold; text-decoration: underline;">None</span> };
    }
    <span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">add_node</span>(&amp;<span style="font-weight: bold;">mut</span> <span style="font-weight: bold;">self</span>, <span style="font-weight: bold; font-style: italic;">node</span>: &amp;'<span style="font-weight: bold; font-style: italic;">a</span> <span style="font-weight: bold;">mut</span> <span style="font-weight: bold; text-decoration: underline;">ListNode</span>&lt;'<span style="font-weight: bold; font-style: italic;">a</span>&gt;) -&gt; () {
        node.next = <span style="font-weight: bold;">self</span>.root;
        <span style="font-weight: bold;">self</span>.root = <span style="font-weight: bold; text-decoration: underline;">Some</span>(node);
    }
}
<span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">main</span>() {
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold;">mut</span> <span style="font-weight: bold; font-style: italic;">list</span> = <span style="font-weight: bold; text-decoration: underline;">LinkedList</span>::new();

    <span style="font-weight: bold;">let</span> <span style="font-weight: bold;">mut</span> <span style="font-weight: bold; font-style: italic;">node1</span> = <span style="font-weight: bold; text-decoration: underline;">ListNode</span>::new(1);
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold;">mut</span> <span style="font-weight: bold; font-style: italic;">node2</span> = <span style="font-weight: bold; text-decoration: underline;">ListNode</span>::new(2);
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold;">mut</span> <span style="font-weight: bold; font-style: italic;">node3</span> = <span style="font-weight: bold; text-decoration: underline;">ListNode</span>::new(3);

    list.add_node(&amp;<span style="font-weight: bold;">mut</span> node1);
    list.add_node(&amp;<span style="font-weight: bold;">mut</span> node2);
    list.add_node(&amp;<span style="font-weight: bold;">mut</span> node3);

    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"</span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, list);
}
</pre>
</div>

<p>
LinkedList { root: Some(ListNode { val: 3, next: Some(ListNode { val: 2, next: Some(ListNode { val: 1, next: None }) }) }) }
</p>

<p>
这种实现的问题是:
</p>

<ol class="org-ol">
<li>由于 node 栈上分配的原因, struct ListNode 定义时无法指定 next 为 TreeNode, 因
为递归定义的结构体无法在编译时确定大小, 只能定义 next 为 reference</li>

<li>需要指定许多 lifetime annotation 确定 reference 有效</li>

<li>next 只是引用, 所以 parent 并不是 node 的 owner, 需要额外的 owner (node1,
node2, node3) 确保 reference 有效</li>

<li>由于栈上分配的原因, 无法把封装在一个函数中. 因为 shadow copy 时不会 copy
reference</li>
</ol>
</div>
</div>

<div id="outline-container-org9e594a2" class="outline-5">
<h5 id="org9e594a2"><span class="section-number-5">1.2.2.2</span> 使用 Box 实现链表</h5>
<div class="outline-text-5" id="text-1-2-2-2">
<div class="org-src-container">
<pre class="src src-rust"><span style="font-weight: bold;">#[derive(Debug)]</span>
<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">ListNode</span> {
    <span style="font-weight: bold; font-style: italic;">val</span>: <span style="font-weight: bold; text-decoration: underline;">i32</span>,
    <span style="font-weight: bold; font-style: italic;">next</span>: <span style="font-weight: bold; text-decoration: underline;">Option</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Box</span>&lt;<span style="font-weight: bold; text-decoration: underline;">ListNode</span>&gt;&gt;,
}

<span style="font-weight: bold;">impl</span> <span style="font-weight: bold; text-decoration: underline;">ListNode</span> {
    <span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">new</span>(<span style="font-weight: bold; font-style: italic;">val</span>: <span style="font-weight: bold; text-decoration: underline;">i32</span>) -&gt; <span style="font-weight: bold; text-decoration: underline;">Box</span>&lt;<span style="font-weight: bold; text-decoration: underline;">ListNode</span>&gt; {
        <span style="font-weight: bold; text-decoration: underline;">Box</span>::new(<span style="font-weight: bold; text-decoration: underline;">ListNode</span> {
            <span style="font-weight: bold; font-style: italic;">val</span>: val,
            <span style="font-weight: bold; font-style: italic;">next</span>: <span style="font-weight: bold; text-decoration: underline;">None</span>,
        })
    }
}

<span style="font-weight: bold;">#[derive(Debug)]</span>
<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">LinkedList</span> {
    <span style="font-weight: bold; font-style: italic;">root</span>: <span style="font-weight: bold; text-decoration: underline;">Option</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Box</span>&lt;<span style="font-weight: bold; text-decoration: underline;">ListNode</span>&gt;&gt;,
}

<span style="font-weight: bold;">impl</span> <span style="font-weight: bold; text-decoration: underline;">LinkedList</span> {
    <span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">new</span>() -&gt; <span style="font-weight: bold; text-decoration: underline;">LinkedList</span> {
        <span style="font-weight: bold; text-decoration: underline;">LinkedList</span> { <span style="font-weight: bold; font-style: italic;">root</span>: <span style="font-weight: bold; text-decoration: underline;">None</span> }
    }

    <span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">push_front</span>(&amp;<span style="font-weight: bold;">mut</span> <span style="font-weight: bold;">self</span>, <span style="font-weight: bold;">mut</span> <span style="font-weight: bold; font-style: italic;">node</span>: <span style="font-weight: bold; text-decoration: underline;">Box</span>&lt;<span style="font-weight: bold; text-decoration: underline;">ListNode</span>&gt;) -&gt; () {
        <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">t</span> = <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">mem</span>::replace(&amp;<span style="font-weight: bold;">mut</span> <span style="font-weight: bold;">self</span>.root, <span style="font-weight: bold; text-decoration: underline;">None</span>);
        node.next = t;
        <span style="font-weight: bold;">self</span>.root = <span style="font-weight: bold; text-decoration: underline;">Some</span>(node);
    }

    <span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">push_back</span>(&amp;<span style="font-weight: bold;">mut</span> <span style="font-weight: bold;">self</span>, <span style="font-weight: bold; font-style: italic;">node</span>: <span style="font-weight: bold; text-decoration: underline;">Box</span>&lt;<span style="font-weight: bold; text-decoration: underline;">ListNode</span>&gt;) -&gt; () {
        <span style="font-weight: bold;">let</span> <span style="font-weight: bold;">mut</span> <span style="font-weight: bold; font-style: italic;">fake_root</span> = <span style="font-weight: bold; text-decoration: underline;">ListNode</span>::new(0);
        <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">t</span> = <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">mem</span>::replace(&amp;<span style="font-weight: bold;">mut</span> <span style="font-weight: bold;">self</span>.root, <span style="font-weight: bold; text-decoration: underline;">None</span>);
        fake_root.next = t;
        <span style="font-weight: bold;">let</span> <span style="font-weight: bold;">mut</span> <span style="font-weight: bold; font-style: italic;">head</span> = &amp;<span style="font-weight: bold;">mut</span> fake_root;
        <span style="font-weight: bold;">while</span> <span style="font-weight: bold;">let</span> <span style="font-weight: bold; text-decoration: underline;">Some</span>(<span style="font-weight: bold;">ref</span> <span style="font-weight: bold;">mut</span> <span style="font-weight: bold; font-style: italic;">n</span>) = head.next {
            head = n
        }
        head.next = <span style="font-weight: bold; text-decoration: underline;">Some</span>(node);
        <span style="font-weight: bold;">self</span>.root = fake_root.next;
    }

    <span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">pop_front</span>(&amp;<span style="font-weight: bold;">mut</span> <span style="font-weight: bold;">self</span>) -&gt; () {
        <span style="font-weight: bold;">if</span> <span style="font-weight: bold;">let</span> <span style="font-weight: bold; text-decoration: underline;">Some</span>(<span style="font-weight: bold;">ref</span> <span style="font-weight: bold;">mut</span> <span style="font-weight: bold; font-style: italic;">node</span>) = <span style="font-weight: bold;">self</span>.root {
            <span style="font-weight: bold;">self</span>.root = <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">mem</span>::replace(&amp;<span style="font-weight: bold;">mut</span> node.next, <span style="font-weight: bold; text-decoration: underline;">None</span>);;
        }
    }
}

<span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">main</span>() {
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold;">mut</span> <span style="font-weight: bold; font-style: italic;">list</span> = <span style="font-weight: bold; text-decoration: underline;">LinkedList</span>::new();
    list.push_front(<span style="font-weight: bold; text-decoration: underline;">ListNode</span>::new(1));
    list.push_back(<span style="font-weight: bold; text-decoration: underline;">ListNode</span>::new(2));
    list.pop_front();
    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"</span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, list);
}
</pre>
</div>

<p>
LinkedList { root: Some(ListNode { val: 2, next: None }) }
</p>

<p>
使用 Box 无需考虑 owner 的问题, 但还是需要处理用 reference 和 mem::replace 来防
止 Box 被 move,
</p>
</div>
</div>
</div>

<div id="outline-container-org5b14111" class="outline-4">
<h4 id="org5b14111"><span class="section-number-4">1.2.3</span> Box 的应用场景</h4>
<div class="outline-text-4" id="text-1-2-3">
<ol class="org-ol">
<li>递归定义的数据结构</li>

<li>堆上分配</li>

<li><p>
单一 owner 可以搞定的问题, 例如单向链表 (双向链表和树, 图等可能难以用 Box 处
理)
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">node</span> = <span style="font-weight: bold; text-decoration: underline;">TreeNode</span>::new(1);
prev.next = node;
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">node &#24050;&#32463;&#34987; move &#21040; prev.next, &#26080;&#27861;&#20877;&#36171;&#20540;&#32473; next.prev</span>
next.prev = node;
</pre>
</div></li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org3888497" class="outline-3">
<h3 id="org3888497"><span class="section-number-3">1.3</span> Rc</h3>
<div class="outline-text-3" id="text-1-3">
<p>
rust 编译时只允许单一 owner, 通过 Rc 可以支持双向链表等需要多个 owner 的场景.
</p>

<p>
Rc 即 reference counting, 多个不同的 Rc 可以在内部 `own` 同一个资源, `运行时` 通
过引用计数的方式决定何时释放资源.
</p>

<p>
在编译时一个 Rc 还是只有一个 owner, 编译器并不知道多个 Rc `own` 同一个资源.
</p>
</div>

<div id="outline-container-org011e530" class="outline-4">
<h4 id="org011e530"><span class="section-number-4">1.3.1</span> 内部原理</h4>
<div class="outline-text-4" id="text-1-3-1">
<ol class="org-ol">
<li><p>
Box 的 clone 会复制所有数据, 包含堆上的数据
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="font-weight: bold;">#[derive(Clone)]</span>
<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">Test</span>(<span style="font-weight: bold; text-decoration: underline;">i64</span>, <span style="font-weight: bold; text-decoration: underline;">i64</span>);

<span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">main</span>() {
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">p</span> = <span style="font-weight: bold; text-decoration: underline;">Box</span>::new(<span style="font-weight: bold; text-decoration: underline;">Test</span>(1234, 5678));
    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"box size: </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">mem</span>::size_of_val(&amp;p));
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">pp</span> = &amp;p <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> _ <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> [<span style="font-weight: bold; text-decoration: underline;">i64</span>; 1];
    <span style="font-weight: bold;">unsafe</span> {
        <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"box addr is </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, pp);
        <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"box value is 0x</span><span style="font-style: italic;">{:x}</span><span style="font-style: italic;">"</span>, (*pp)[0]);

        <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">p_heap</span> = (*pp)[0] <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> [<span style="font-weight: bold; text-decoration: underline;">i64</span>; 2];
        <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"heap value is </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, *p_heap);
    }

    <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">p_cloned</span> = p.clone();
    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"rc size: </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">mem</span>::size_of_val(&amp;p_cloned));
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">pp_cloned</span> = &amp;p_cloned <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> _ <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> [<span style="font-weight: bold; text-decoration: underline;">i64</span>; 1];
    <span style="font-weight: bold;">unsafe</span> {
        <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"cloned box addr is </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, pp_cloned);
        <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"cloned box value is 0x</span><span style="font-style: italic;">{:x}</span><span style="font-style: italic;">"</span>, (*pp_cloned)[0]);

        <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">p_heap</span> = (*pp_cloned)[0] <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> [<span style="font-weight: bold; text-decoration: underline;">i64</span>; 2];
        <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"heap value is </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, *p_heap);
    }
}

</pre>
</div>

<p>
box addr is 0x7ffe9fcef808
box value is 0x7f456602a000
heap value is [1234, 5678]
cloned box addr is 0x7ffe9fcef920
cloned box value is 0x7f456602a020
heap value is [1234, 5678]
</p></li>

<li><p>
Rc 的 clone 只是 shadow copy
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="font-weight: bold;">#[derive(Clone)]</span>
<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">Test</span>(<span style="font-weight: bold; text-decoration: underline;">i64</span>, <span style="font-weight: bold; text-decoration: underline;">i64</span>);

<span style="font-weight: bold;">use</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">rc</span>::<span style="font-weight: bold; text-decoration: underline;">Rc</span>;

<span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">main</span>() {
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">p</span> = <span style="font-weight: bold; text-decoration: underline;">Rc</span>::new(<span style="font-weight: bold; text-decoration: underline;">Test</span>(1234, 5678));

    <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">pp</span> = &amp;p <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> _ <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> [<span style="font-weight: bold; text-decoration: underline;">i64</span>; 2];
    <span style="font-weight: bold;">unsafe</span> {
        <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"rc addr is </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, pp);
        <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"rc value is 0x</span><span style="font-style: italic;">{:x}</span><span style="font-style: italic;">"</span>, (*pp)[0]);

        <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">p_heap</span> = (*pp)[0] <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> [<span style="font-weight: bold; text-decoration: underline;">i64</span>; 4];
        <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"heap value is </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, *p_heap);
    }
    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"strong_count: </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, <span style="font-weight: bold; text-decoration: underline;">Rc</span>::strong_count(&amp;p));

    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">""</span>);
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">p_cloned</span> = p.clone();
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">pp_cloned</span> = &amp;p_cloned <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> _ <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> [<span style="font-weight: bold; text-decoration: underline;">i64</span>; 1];
    <span style="font-weight: bold;">unsafe</span> {
        <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"cloned box addr is </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, pp_cloned);
        <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"cloned box value is 0x</span><span style="font-style: italic;">{:x}</span><span style="font-style: italic;">"</span>, (*pp_cloned)[0]);

        <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">p_heap</span> = (*pp_cloned)[0] <span style="font-weight: bold;">as</span> *<span style="font-weight: bold;">const</span> [<span style="font-weight: bold; text-decoration: underline;">i64</span>; 4];
        <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"heap value is </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, *p_heap);
    }
    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"strong_count: </span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, <span style="font-weight: bold; text-decoration: underline;">Rc</span>::strong_count(&amp;p));
    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"</span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, <span style="font-weight: bold; text-decoration: underline;">Rc</span>::into_raw(p));
}

</pre>
</div>

<p>
rc addr is 0x7ffcb5afe7e8
rc value is 0x7f8d1f020020
heap value is [1, 1, 1234, 5678]
strong_count: 1
</p>

<p>
cloned box addr is 0x7ffcb5afe988
cloned box value is 0x7f8d1f020020
heap value is [2, 1, 1234, 5678]
strong_count: 2
0x7f8d1f020030
</p>

<p>
Rc 不是 fat pointer, 它只包含一个堆上的地址, 真正的数据以及引用计数等放在堆上.
</p></li>
</ol>
</div>
</div>


<div id="outline-container-org649fb20" class="outline-4">
<h4 id="org649fb20"><span class="section-number-4">1.3.2</span> 使用 Rc 实现链表</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
使用 Rc 实现链表并不比 Box 简单, 主要原因是, 在遍历 list 时, 可以这样:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="font-weight: bold;">let</span> <span style="font-weight: bold;">mut</span> <span style="font-weight: bold; font-style: italic;">head</span> = fake_root.clone();
<span style="font-weight: bold;">while</span> <span style="font-weight: bold;">let</span> <span style="font-weight: bold; text-decoration: underline;">Some</span>(n) = head.next.clone() {
    head = n;
}
<span style="font-weight: bold; text-decoration: underline;">Rc</span>::get_mut(&amp;<span style="font-weight: bold;">mut</span> head).unwrap().next = <span style="font-weight: bold; text-decoration: underline;">Some</span>(node);
<span style="font-weight: bold;">self</span>.root = fake_root.next.clone();
</pre>
</div>

<p>
问题是 Rc 只有在存在一个 owner 时才可以通过 get_mut 来修改, 类似于读写锁的限制,
导致我们在遍历时实际上无法修改, 因为至少有两个 owner 存在.
</p>
</div>
</div>
</div>

<div id="outline-container-org36093aa" class="outline-3">
<h3 id="org36093aa"><span class="section-number-3">1.4</span> RefCell</h3>
<div class="outline-text-3" id="text-1-4">
<p>
RefCell 并不是指针类型, 和 owner 机制无关. 它只是一个 wrapper, 使非 mutable 的变
量也可以在运行时被修改.
</p>

<p>
因为 Rc 使得可以有多个 owner, 但这时却难以对数据进行修改, 通过 RefCell, 可以方便
的修改数据.
</p>

<p>
RefCell 通过 borrow() 和 borrow_mut() 实现了运行时的 `读写锁` 而非 Rc 那种编译时
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="font-weight: bold;">use</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">cell</span>::<span style="font-weight: bold; text-decoration: underline;">RefCell</span>;
<span style="font-weight: bold;">use</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">rc</span>::<span style="font-weight: bold; text-decoration: underline;">Rc</span>;

<span style="font-weight: bold;">#[derive(Debug)]</span>
<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">ListNode</span> {
    <span style="font-weight: bold; font-style: italic;">val</span>: <span style="font-weight: bold; text-decoration: underline;">i32</span>,
    <span style="font-weight: bold; font-style: italic;">next</span>: <span style="font-weight: bold; text-decoration: underline;">Option</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Rc</span>&lt;<span style="font-weight: bold; text-decoration: underline;">RefCell</span>&lt;<span style="font-weight: bold; text-decoration: underline;">ListNode</span>&gt;&gt;&gt;,
}
<span style="font-weight: bold;">impl</span> <span style="font-weight: bold; text-decoration: underline;">ListNode</span> {
    <span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">new</span>(<span style="font-weight: bold; font-style: italic;">val</span>: <span style="font-weight: bold; text-decoration: underline;">i32</span>) -&gt; (<span style="font-weight: bold; text-decoration: underline;">Rc</span>&lt;<span style="font-weight: bold; text-decoration: underline;">RefCell</span>&lt;<span style="font-weight: bold; text-decoration: underline;">ListNode</span>&gt;&gt;) {
        <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">Rc</span>::new(<span style="font-weight: bold; text-decoration: underline;">RefCell</span>::new(<span style="font-weight: bold; text-decoration: underline;">ListNode</span> {
            <span style="font-weight: bold; font-style: italic;">val</span>: val,
            <span style="font-weight: bold; font-style: italic;">next</span>: <span style="font-weight: bold; text-decoration: underline;">None</span>,
        }));
    }
}
<span style="font-weight: bold;">#[derive(Debug)]</span>
<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">LinkedList</span> {
    <span style="font-weight: bold; font-style: italic;">root</span>: <span style="font-weight: bold; text-decoration: underline;">Option</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Rc</span>&lt;<span style="font-weight: bold; text-decoration: underline;">RefCell</span>&lt;<span style="font-weight: bold; text-decoration: underline;">ListNode</span>&gt;&gt;&gt;,
}

<span style="font-weight: bold;">impl</span> <span style="font-weight: bold; text-decoration: underline;">LinkedList</span> {
    <span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">new</span>() -&gt; <span style="font-weight: bold; text-decoration: underline;">LinkedList</span> {
        <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">LinkedList</span> { <span style="font-weight: bold; font-style: italic;">root</span>: <span style="font-weight: bold; text-decoration: underline;">None</span> };
    }
    <span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">push_front</span>(&amp;<span style="font-weight: bold;">mut</span> <span style="font-weight: bold;">self</span>, <span style="font-weight: bold; font-style: italic;">node</span>: <span style="font-weight: bold; text-decoration: underline;">Rc</span>&lt;<span style="font-weight: bold; text-decoration: underline;">RefCell</span>&lt;<span style="font-weight: bold; text-decoration: underline;">ListNode</span>&gt;&gt;) -&gt; () {
        node.borrow_mut().next = <span style="font-weight: bold;">self</span>.root.clone();
        <span style="font-weight: bold;">self</span>.root = <span style="font-weight: bold; text-decoration: underline;">Some</span>(node);
    }

    <span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">push_back</span>(&amp;<span style="font-weight: bold;">mut</span> <span style="font-weight: bold;">self</span>, <span style="font-weight: bold; font-style: italic;">node</span>: <span style="font-weight: bold; text-decoration: underline;">Rc</span>&lt;<span style="font-weight: bold; text-decoration: underline;">RefCell</span>&lt;<span style="font-weight: bold; text-decoration: underline;">ListNode</span>&gt;&gt;) -&gt; () {
        <span style="font-weight: bold;">let</span> <span style="font-weight: bold;">mut</span> <span style="font-weight: bold; font-style: italic;">fake_root</span> = <span style="font-weight: bold; text-decoration: underline;">ListNode</span>::new(0);
        fake_root.borrow_mut().next = <span style="font-weight: bold;">self</span>.root.clone();

        <span style="font-weight: bold;">let</span> <span style="font-weight: bold;">mut</span> <span style="font-weight: bold; font-style: italic;">head</span> = fake_root.clone();
        <span style="font-weight: bold;">while</span> <span style="font-weight: bold;">let</span> <span style="font-weight: bold; text-decoration: underline;">Some</span>(n) = head.clone().borrow().next.clone() {
            head = n;
        }
        head.borrow_mut().next = <span style="font-weight: bold; text-decoration: underline;">Some</span>(node);

        <span style="font-weight: bold;">self</span>.root = fake_root.borrow().next.clone();
    }
}

<span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">main</span>() {
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold;">mut</span> <span style="font-weight: bold; font-style: italic;">list</span> = <span style="font-weight: bold; text-decoration: underline;">LinkedList</span>::new();

    list.push_front(<span style="font-weight: bold; text-decoration: underline;">ListNode</span>::new(1));
    list.push_back(<span style="font-weight: bold; text-decoration: underline;">ListNode</span>::new(2));

    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"</span><span style="font-style: italic;">{:?}</span><span style="font-style: italic;">"</span>, list);
}
</pre>
</div>

<p>
LinkedList { root: Some(RefCell { value: ListNode { val: 1, next: Some(RefCell { value: ListNode { val: 2, next: None } }) } }) }
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

<p class="author">Author: sunway (sunwayforever@gmail.com)<br />
Date: 2018-12-28 Fri 00:00<br />
Last updated: 2021-08-28 Sat 23:12</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。
<br />

<div id="disqus_thread"></div>
<script>

(function() { // DON'T EDIT BELOW THIS LINE
         var d = document, s = d.createElement('script');
         s.src = '//sunwayforever-github-io.disqus.com/embed.js';
         s.setAttribute('data-timestamp', +new Date());
         (d.head || d.body).appendChild(s);
         })();
</script>
</div>
</body>
</html>
