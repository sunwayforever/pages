<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>Golang</title>

<link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
<link rel="stylesheet" type="text/css" href="../main.css" media="screen" />
<link rel="stylesheet" type="text/css" href="./main.css" media="screen" />
<link rel = "icon" href = "/icon.png"  type = "image/x-icon">
</head>
<body>
<div id="content" class="content">
<h1 class="title">Golang</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org000003f">1. Golang</a>
<ul>
<li><a href="#org0000000">1.1. 风格</a></li>
<li><a href="#org0000003">1.2. 变量</a></li>
<li><a href="#org0000006">1.3. 表达式</a></li>
<li><a href="#org0000009">1.4. 函数</a></li>
<li><a href="#org000000c">1.5. 输入输出</a></li>
<li><a href="#org000000f">1.6. 类型及转换</a></li>
<li><a href="#org0000012">1.7. 分配与释放</a></li>
<li><a href="#org0000015">1.8. string</a></li>
<li><a href="#org0000018">1.9. array 与 slice</a></li>
<li><a href="#org000001b">1.10. map</a></li>
<li><a href="#org000001e">1.11. 抽象数据类型</a></li>
<li><a href="#org0000021">1.12. 泛型</a></li>
<li><a href="#org0000024">1.13. 控制结构</a></li>
<li><a href="#org0000027">1.14. 排序</a></li>
<li><a href="#org000002a">1.15. 最大堆</a></li>
<li><a href="#org000002d">1.16. math</a></li>
<li><a href="#org0000030">1.17. random</a></li>
<li><a href="#org0000033">1.18. package</a></li>
<li><a href="#org0000036">1.19. 坑</a></li>
<li><a href="#org0000039">1.20. channel</a></li>
<li><a href="#org000003c">1.21. misc</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org000003f" class="outline-2">
<h2 id="org000003f"><span class="section-number-2">1.</span> Golang</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org0000000" class="outline-3">
<h3 id="org0000000"><span class="section-number-3">1.1.</span> 风格</h3>
<div class="outline-text-3" id="text-1-1">
<div class="org-src-container">
<pre class="src src-go"><span class="org-keyword">package</span> helloworld

<span class="org-keyword">type</span> <span class="org-type">HelloWorld</span> <span class="org-keyword">struct</span> {
    privMem   <span class="org-type">int</span>
    PubMember <span class="org-type">int</span>
}

<span class="org-keyword">func</span> (<span class="org-variable-name">this</span> <span class="org-type">HelloWorld</span>) <span class="org-function-name">PubMethod</span>()  {}
<span class="org-keyword">func</span> (<span class="org-variable-name">this</span> <span class="org-type">HelloWorld</span>) <span class="org-function-name">privMethod</span>() {}

<span class="org-keyword">func</span> <span class="org-function-name">main</span>() {
    <span class="org-variable-name">helloWorld</span> := <span class="org-type">HelloWorld</span>{1, 2}
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org0000003" class="outline-3">
<h3 id="org0000003"><span class="section-number-3">1.2.</span> 变量</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>var x int</li>
<li>var x int = 10</li>
<li>x := 10</li>
<li>可以通过 var x int = 10 定义全局变量</li>
<li>const x = 10</li>
</ul>
</div>
</div>

<div id="outline-container-org0000006" class="outline-3">
<h3 id="org0000006"><span class="section-number-3">1.3.</span> 表达式</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>bitwise
<ul class="org-ul">
<li>and &amp;</li>
<li>or |</li>
<li>not ^</li>
<li>xor ^</li>
<li>shift &lt;&lt;, &gt;&gt;, 其中 &gt;&gt; 和 c 一样区分算法与逻辑右移</li>
</ul></li>
<li>支持 +=, &amp;=, &gt;&gt;=,&#x2026;</li>
<li>支持 ++, &#x2013;,  是 stmt 而不是 expression</li>
<li>!expression</li>
<li>支持 a,b = b,a</li>
<li>if 与 switch 支持 initialization stmt: if x:=1+2; x&gt;3 {}</li>
<li>条件判断必须值为 bool 的表达式, if x:=1; x {} 不合法</li>
</ul>
</div>
</div>

<div id="outline-container-org0000009" class="outline-3">
<h3 id="org0000009"><span class="section-number-3">1.4.</span> 函数</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>不支持 overloading</li>
<li>不支持默认参数</li>
<li>支持多个函数值</li>
<li>支持变长参数, 实际就是一个 slice</li>
</ul>

<div class="org-src-container">
<pre class="src src-go"><span class="org-keyword">package</span> main
<span class="org-keyword">import</span> <span class="org-string">"fmt"</span>

<span class="org-keyword">func</span> <span class="org-function-name">echo</span> (i1, i2 <span class="org-type">int</span>, i3 <span class="org-type">int</span>) (<span class="org-type">int</span>, <span class="org-type">int</span>, <span class="org-type">int</span>) {
    <span class="org-keyword">return</span> i1, i2, i3
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#21464;&#38271;&#21442;&#25968;</span>
<span class="org-keyword">func</span> <span class="org-function-name">echo2</span>(<span class="org-variable-name">x</span> ...<span class="org-type">int</span>) ([]<span class="org-type">int</span>) {
    <span class="org-keyword">return</span> x
}

<span class="org-keyword">func</span> <span class="org-function-name">main</span> () {
    fmt.<span class="org-function-name">Println</span>(<span class="org-function-name">echo</span>(1, 2, 3))
    fmt.<span class="org-function-name">Println</span>(<span class="org-function-name">echo2</span>(1, 2, 3))
}
</pre>
</div>

<pre class="example">
1 2 3
[1 2 3]
</pre>
</div>
</div>

<div id="outline-container-org000000c" class="outline-3">
<h3 id="org000000c"><span class="section-number-3">1.5.</span> 输入输出</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li>fmt.Println</li>
<li>fmt.Printf</li>
<li>fmt.Scanln</li>
<li>fmt.Scanf</li>
</ul>
<div class="org-src-container">
<pre class="src src-go"><span class="org-keyword">package</span> main

<span class="org-keyword">func</span> <span class="org-function-name">main</span>() {
    fmt.<span class="org-function-name">Printf</span>(<span class="org-string">"%d,%s"</span>, 1, <span class="org-string">"abc"</span>)
    fmt.<span class="org-function-name">Println</span>(1, 2, 3, <span class="org-string">"ab"</span>)

    <span class="org-variable-name">i</span>, <span class="org-variable-name">j</span> := 0, 0
    <span class="org-comment-delimiter">// </span><span class="org-comment">stdin &#20026; 1 2</span>
    fmt.<span class="org-function-name">Scanln</span>(<span class="org-string">"%d %d"</span>, &amp;i, &amp;j)
    fmt.<span class="org-function-name">Println</span>(i, j)                   <span class="org-comment-delimiter">// </span><span class="org-comment">1 2</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">stdin &#20026; 1 2\n3 4</span>
    <span class="org-variable-name">x</span>, <span class="org-variable-name">y</span> := 0, 0
    fmt.<span class="org-function-name">Scanf</span>(<span class="org-string">"%d %d\n%d %d"</span>, &amp;i, &amp;j, &amp;x, &amp;y)
    fmt.<span class="org-function-name">Println</span>(i, j, x, y)             <span class="org-comment-delimiter">// </span><span class="org-comment">1 2 3 4</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org000000f" class="outline-3">
<h3 id="org000000f"><span class="section-number-3">1.6.</span> 类型及转换</h3>
<div class="outline-text-3" id="text-1-6">
<ol class="org-ol">
<li>基本类型
<ul class="org-ul">
<li>int, int32, int64, int8, float32, float64</li>
<li>uint, uint32, uint64</li>
<li>bool</li>
<li>rune (即 int32), byte (即 int8)</li>
</ul></li>

<li>复杂类型
<ul class="org-ul">
<li>string</li>
<li>array</li>
<li>slice</li>
<li>map</li>
<li>不支持 tuple</li>
<li>interface{}</li>
</ul></li>
</ol>

<p>
其中 slice 与 map 是仅有的两种指针类型:
</p>

<ol class="org-ol">
<li>可以与 nil 比较</li>
<li>做为参数或返回值时自动使用的传引用的语义</li>
<li>作为 struct 成员时需要显示的分配, 否则成员为 nil</li>
</ol>

<div class="org-src-container">
<pre class="src src-go"><span class="org-keyword">package</span> main

<span class="org-keyword">func</span> <span class="org-function-name">main</span>() {
    <span class="org-keyword">var</span> <span class="org-variable-name">x</span> <span class="org-type">int</span> = 1
    <span class="org-keyword">var</span> <span class="org-variable-name">y</span> <span class="org-type">int32</span> = 1
    <span class="org-keyword">var</span> <span class="org-variable-name">z</span> <span class="org-type">int64</span> = 1
    <span class="org-keyword">var</span> <span class="org-variable-name">a</span> <span class="org-type">byte</span> = <span class="org-string">'a'</span>
    <span class="org-keyword">var</span> <span class="org-variable-name">s</span> <span class="org-type">string</span> = <span class="org-string">"abc"</span>
    <span class="org-keyword">var</span> <span class="org-variable-name">z</span> <span class="org-type">rune</span> = <span class="org-string">'a'</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">rune &#21363; int32, byte &#21363; int8, &#20851;&#20110; byte, rune, string, &#21442;&#32771; golang::string</span>
    <span class="org-keyword">var</span> <span class="org-variable-name">b</span> <span class="org-type">bool</span> = <span class="org-constant">true</span>
    <span class="org-keyword">var</span> <span class="org-variable-name">f</span> <span class="org-type">float32</span> = 1.0
    <span class="org-keyword">var</span> <span class="org-variable-name">d</span> <span class="org-type">float64</span> = 1.0
    x = <span class="org-function-name">int</span>(d)
    d = <span class="org-function-name">float64</span>(x)
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org0000012" class="outline-3">
<h3 id="org0000012"><span class="section-number-3">1.7.</span> 分配与释放</h3>
<div class="outline-text-3" id="text-1-7">
<ol class="org-ol">
<li>golang 并不存在`返回局部变量的引用`这种问题, 编译器会根据逃逸分析的结果确定是否需要分配在堆上</li>
<li>可以显式的通过 new 要求分配在堆上</li>
<li>对于指针类型: slice 和 map, 可以通过 make 以`空值`初始化</li>
<li>chan 只能通过 make 初始化</li>
<li>go 有 gc, 不需要手动释放</li>
</ol>

<div class="org-src-container">
<pre class="src src-go"><span class="org-keyword">package</span> main

<span class="org-keyword">import</span> <span class="org-string">"fmt"</span>

<span class="org-keyword">type</span> <span class="org-type">Test</span> <span class="org-keyword">struct</span> {
    a <span class="org-type">int</span>
    b <span class="org-type">int</span>
}

<span class="org-keyword">func</span> <span class="org-function-name">getTest</span>() *<span class="org-type">Test</span> {
    <span class="org-keyword">return</span> &amp;<span class="org-type">Test</span>{1, 2}
}

<span class="org-keyword">func</span> <span class="org-function-name">getTest2</span>() *<span class="org-type">Test</span> {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#19981;&#25903;&#25345; new (Test{1,2}) &#36825;&#31181;&#20889;&#27861;</span>
    <span class="org-variable-name">t</span> := <span class="org-builtin">new</span>(<span class="org-type">Test</span>)
    t.a = 1
    t.b = 2
    <span class="org-keyword">return</span> t
}

<span class="org-keyword">func</span> <span class="org-function-name">main</span>() {
    <span class="org-variable-name">t</span> := <span class="org-function-name">getTest</span>()
    fmt.<span class="org-function-name">Println</span>(*t)
    t = <span class="org-function-name">getTest2</span>()
    fmt.<span class="org-function-name">Println</span>(*t)

    <span class="org-comment-delimiter">// </span><span class="org-comment">map init with make</span>
    <span class="org-variable-name">m</span> := <span class="org-builtin">make</span>(<span class="org-keyword">map</span>[<span class="org-type">int</span>]<span class="org-type">int</span>)
    fmt.<span class="org-function-name">Println</span>(m == <span class="org-constant">nil</span>)

    <span class="org-keyword">var</span> <span class="org-variable-name">m2</span> <span class="org-keyword">map</span>[<span class="org-type">int</span>]<span class="org-type">int</span>
    fmt.<span class="org-function-name">Println</span>(m2 == <span class="org-constant">nil</span>)

    <span class="org-variable-name">m3</span> := <span class="org-keyword">map</span>[<span class="org-type">int</span>]<span class="org-type">int</span>{}
    fmt.<span class="org-function-name">Println</span>(m3 == <span class="org-constant">nil</span>)

    <span class="org-keyword">var</span> <span class="org-variable-name">x</span> <span class="org-type">int</span>
    <span class="org-variable-name">x2</span> := 0
    fmt.<span class="org-function-name">Println</span>(x == x2)

    <span class="org-comment-delimiter">// </span><span class="org-comment">slice init with make</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">make slice &#26159;&#21487;&#20197;&#25351;&#23450;&#19968;&#20010;&#38271;&#24230;</span>
    <span class="org-variable-name">s</span> := <span class="org-builtin">make</span>([]<span class="org-type">int</span>, 5)
    <span class="org-variable-name">s2</span> := []<span class="org-type">int</span>{0, 0, 0, 0, 0}
    fmt.<span class="org-function-name">Println</span>(s, s2)
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org0000015" class="outline-3">
<h3 id="org0000015"><span class="section-number-3">1.8.</span> string</h3>
<div class="outline-text-3" id="text-1-8">
<ul class="org-ul">
<li>string 不可变</li>
<li>可以通过 []rune(s) 把 s 变为 rune slice, 以及通过 string([]rune{}) 转换回 string</li>
<li>for k,v :=range (str) 返回的 v 类型是 rune, 即 utf16 编码</li>
<li>str[i] 返回的数据为 byte</li>
<li>len 返回长度</li>
<li>支持 "a"+"b"</li>
<li>支持像 slice 的 s[i:j] 操作</li>
<li>string 不是指针类型, 无法与 nil 比较</li>
<li>strings 库相关的函数
<ul class="org-ul">
<li>HasPrefix, HasSurfix</li>
<li>Split, Join</li>
<li>Replace</li>
<li>Repeat</li>
<li>Contains</li>
<li>Index, LastIndex</li>
</ul></li>
<li>strconv 库的 Atoi, Itoa</li>
</ul>
<div class="org-src-container">
<pre class="src src-go"><span class="org-keyword">package</span> main
<span class="org-keyword">import</span> <span class="org-string">"fmt"</span>

<span class="org-keyword">func</span> <span class="org-function-name">main</span>() {
    <span class="org-variable-name">s</span> := <span class="org-string">"abc"</span>
    s += <span class="org-string">"def"</span>
    <span class="org-variable-name">x</span> := <span class="org-builtin">len</span>(s)
    fmt.<span class="org-function-name">Println</span>(x)
    s += <span class="org-string">"&#22823;&#23478;&#22909;"</span>
    <span class="org-keyword">for</span> <span class="org-variable-name">_</span>, <span class="org-variable-name">v</span> := <span class="org-keyword">range</span> s {
        fmt.<span class="org-function-name">Print</span>(v,<span class="org-string">" "</span>)
    }
    fmt.<span class="org-function-name">Println</span>()
    <span class="org-keyword">for</span> <span class="org-variable-name">i</span> := 0; i &lt; <span class="org-builtin">len</span>(s); i++ {
        fmt.<span class="org-function-name">Print</span>(s[i],<span class="org-string">" "</span>)
    }
    fmt.<span class="org-function-name">Println</span>()
    <span class="org-variable-name">v</span> := []<span class="org-function-name">rune</span>(s)
    fmt.<span class="org-function-name">Println</span>(v)
    fmt.<span class="org-function-name">Println</span>(<span class="org-function-name">string</span>(v))
}
</pre>
</div>

<p>
6
97 98 99 100 101 102 22823 23478 22909 
97 98 99 100 101 102 229 164 167 229 174 182 229 165 189 
[97 98 99 100 101 102 22823 23478 22909]
abcdef大家好
</p>
</div>
</div>

<div id="outline-container-org0000018" class="outline-3">
<h3 id="org0000018"><span class="section-number-3">1.9.</span> array 与 slice</h3>
<div class="outline-text-3" id="text-1-9">
<ol class="org-ol">
<li>与 map 一样, slice 是一个指针, 如果是结构体成员, 需要显式的给它分配空间, 但 array 不需要</li>
<li>[3]int 与 [2]int 并不是相同的 array 类型</li>
<li>array 可以直接比较大小, 例如 [2]int{1,2} == [2]int{1,2} 为 true, 所以 array 可以做为 map 的 key, 但 slice 并不可以</li>
<li>大部分情况下 slice 用的更频繁</li>
<li>需要使用 make 来生成特定大小的 slice</li>
<li>多维的 slice, x:=make([][]int,m); for i:=0;i&lt;m;i++ {x[i]=make([]int,n)}</li>
<li>copy 可以用来复制 slice</li>
</ol>

<div class="org-src-container">
<pre class="src src-go"><span class="org-keyword">package</span> main

<span class="org-keyword">func</span> <span class="org-function-name">main</span>() {
    <span class="org-variable-name">x</span> := [2]<span class="org-type">int</span>{1, 2}                   <span class="org-comment-delimiter">// </span><span class="org-comment">x &#26159;&#19968;&#20010; array</span>
    <span class="org-variable-name">y</span> := []<span class="org-type">int</span>{1, 2}                    <span class="org-comment-delimiter">// </span><span class="org-comment">y &#26159;&#19968;&#20010; slice</span>
    <span class="org-variable-name">z</span> := x[:]                                   <span class="org-comment-delimiter">// </span><span class="org-comment">array &#36716;&#25442;&#20026; slice</span>
    <span class="org-variable-name">k</span> := [2]<span class="org-type">int</span>{}
    <span class="org-builtin">copy</span>(k, z)                                  <span class="org-comment-delimiter">// </span><span class="org-comment">slice &#36716;&#25442;&#20026; array</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20351;&#29992; copy &#26469;&#22797;&#21046; slice</span>
    <span class="org-variable-name">f</span> := []<span class="org-type">int</span>{1, 2, 3}
    <span class="org-variable-name">t</span> := <span class="org-builtin">make</span>([]<span class="org-type">int</span>, 2)
    <span class="org-comment-delimiter">// </span><span class="org-comment">t &#21464;&#20026; []int{1,2}, f &#30340;&#21069;&#20004;&#20010;&#20803;&#32032;&#34987;&#22797;&#21046;</span>
    <span class="org-builtin">copy</span>(t, f)
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20351;&#29992; append &#26469;&#22797;&#21046; slice</span>
    <span class="org-variable-name">t2</span> := <span class="org-builtin">append</span>([]<span class="org-type">int</span>{}, f...)
}
</pre>
</div>

<p>
slice 最常用的操作:
</p>

<div class="org-src-container">
<pre class="src src-go"><span class="org-keyword">package</span> main

<span class="org-keyword">func</span> <span class="org-function-name">main</span>() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">append</span>
    <span class="org-variable-name">x</span> := []<span class="org-type">int</span>{1, 2, 3}
    x = <span class="org-builtin">append</span>(x, 4, 5)
    x = <span class="org-builtin">append</span>(x, []<span class="org-type">int</span>{6, 7, 8}...)
    <span class="org-comment-delimiter">// </span><span class="org-comment">slice</span>
    x = x[1:2]
    <span class="org-comment-delimiter">// </span><span class="org-comment">remove</span>
    x = x[:<span class="org-builtin">len</span>(x) - 1]                  <span class="org-comment-delimiter">// </span><span class="org-comment">&#27169;&#25311; stack &#30340; pop &#25805;&#20316;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">len</span>
    <span class="org-variable-name">l</span> := <span class="org-builtin">len</span>(x)
    <span class="org-comment-delimiter">// </span><span class="org-comment">range</span>
    <span class="org-keyword">for</span> <span class="org-variable-name">_</span>, <span class="org-variable-name">v</span> := <span class="org-keyword">range</span> x {
        fmt.<span class="org-function-name">Println</span>(v)
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">make</span>
    <span class="org-variable-name">y</span> := <span class="org-builtin">make</span>([]<span class="org-type">int</span>, 10)

    <span class="org-comment-delimiter">// </span><span class="org-comment">10x5 &#30340;&#20108;&#32500; slice</span>
    <span class="org-variable-name">v</span> := <span class="org-builtin">make</span>([][]<span class="org-type">int</span>, 10)
    <span class="org-keyword">for</span> <span class="org-variable-name">i</span> := 0; i &lt; 10; i++ {
        v[i] = <span class="org-builtin">make</span>([]<span class="org-type">int</span>, 5)
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org000001b" class="outline-3">
<h3 id="org000001b"><span class="section-number-3">1.10.</span> map</h3>
<div class="outline-text-3" id="text-1-10">
<ul class="org-ul">
<li>map 与 slice 一样是指针类型</li>
<li>对 map 中不存在的项取值时会返回默认值 (0, "", nil 等), 如果要确定
entry 是否存在, 需要使用 x, exist:=m[key] 后判断 exist 是否为 true</li>
<li>有一个 delete 关键字,只用来删除 map key</li>
<li>map 不支持 keys(), values(), items() 等方法</li>
<li>slice, map 无法做为 key, 其它基本类型例如 bool, int, [2]int, string, pointer,
channel 都可作为 key, 而且只包含这些类型的结构也可以作为 key</li>
<li>struct 无法通过定义类似 `eq` 来做为 key</li>
</ul>
<div class="org-src-container">
<pre class="src src-go"><span class="org-keyword">package</span> main

<span class="org-keyword">import</span> <span class="org-string">"fmt"</span>

<span class="org-keyword">func</span> <span class="org-function-name">main</span>() {
    <span class="org-variable-name">m</span> := <span class="org-keyword">map</span>[<span class="org-type">string</span>]<span class="org-type">int</span>{
        <span class="org-string">"abc"</span>: 1,
        <span class="org-string">"bcd"</span>: 2,
    }
    fmt.<span class="org-function-name">Println</span>(m[<span class="org-string">"abc"</span>])
    <span class="org-keyword">if</span> <span class="org-variable-name">t</span>, <span class="org-variable-name">ok</span> := m[<span class="org-string">"xxx"</span>]; ok {
        fmt.<span class="org-function-name">Println</span>(t)
    }
    m[<span class="org-string">"abc"</span>] = 3
    <span class="org-keyword">for</span> <span class="org-variable-name">k</span>, <span class="org-variable-name">v</span> := <span class="org-keyword">range</span> m {
        fmt.<span class="org-function-name">Println</span>(k, v)
    }
    <span class="org-builtin">delete</span>(m, <span class="org-string">"abc"</span>)
    fmt.<span class="org-function-name">Println</span>(m)
}
</pre>
</div>

<pre class="example">
1
abc 3
bcd 2
map[bcd:2]
</pre>
</div>
</div>

<div id="outline-container-org000001e" class="outline-3">
<h3 id="org000001e"><span class="section-number-3">1.11.</span> 抽象数据类型</h3>
<div class="outline-text-3" id="text-1-11">
<ul class="org-ul">
<li>type xxx struct {}</li>
<li>struct 中的指针类型需要初始化</li>
<li>没有构造函数, 可以自己提供一个 NewXXX 函数</li>
<li>struct 中只有首字母大写的成员可以被其它 package 访问</li>
<li>struct 不支持继承, 没有成员函数, 相关的功能通过给 func 添加 receiver
完成</li>
<li>若函数需要修改 receiver, 需要提供指针类型作为 receiver</li>
</ul>

<div class="org-src-container">
<pre class="src src-go"><span class="org-keyword">package</span> main

<span class="org-keyword">import</span> <span class="org-string">"fmt"</span>

<span class="org-keyword">type</span> <span class="org-type">Pair</span> <span class="org-keyword">struct</span> {
    x <span class="org-type">int</span>
    y <span class="org-type">int</span>
}

<span class="org-keyword">func</span> (<span class="org-variable-name">p</span> <span class="org-type">Pair</span>) <span class="org-function-name">Dump</span>() {
    fmt.<span class="org-function-name">Println</span>(p.x, p.y)
}

<span class="org-keyword">func</span> (<span class="org-variable-name">this</span> *<span class="org-type">Pair</span>) <span class="org-function-name">Swap</span>() {
    this.x, this.y = this.y, this.x
}

<span class="org-keyword">func</span> <span class="org-function-name">NewPair</span>(<span class="org-variable-name">x</span>, <span class="org-variable-name">y</span> <span class="org-type">int</span>) <span class="org-type">Pair</span> {
    <span class="org-keyword">return</span> <span class="org-type">Pair</span>{x, y}
}

<span class="org-keyword">func</span> <span class="org-function-name">main</span>() {
    <span class="org-variable-name">p</span> := <span class="org-function-name">NewPair</span>(1, 2)
    p.<span class="org-function-name">Dump</span>()
    p.<span class="org-function-name">Swap</span>()
    p.<span class="org-function-name">Dump</span>()
}
</pre>
</div>

<pre class="example">
1 2
2 1
</pre>


<ul class="org-ul">
<li><p>
golang 通过 duck typing 的方式支持 interface
</p>
<div class="org-src-container">
<pre class="src src-go"><span class="org-keyword">package</span> main

<span class="org-keyword">import</span> <span class="org-string">"fmt"</span>

<span class="org-keyword">type</span> <span class="org-type">Animal</span> <span class="org-keyword">interface</span> {
    <span class="org-function-name">speak</span>()
}
<span class="org-keyword">type</span> <span class="org-type">Dog</span> <span class="org-keyword">struct</span> {
}

<span class="org-keyword">func</span> (<span class="org-variable-name">dog</span> <span class="org-type">Dog</span>) <span class="org-function-name">speak</span>() {
    fmt.<span class="org-function-name">Println</span>(<span class="org-string">"bark"</span>)
}

<span class="org-keyword">func</span> <span class="org-function-name">speak</span>(<span class="org-variable-name">x</span> <span class="org-type">Animal</span>) {
    x.<span class="org-function-name">speak</span>()
}

<span class="org-keyword">func</span> <span class="org-function-name">main</span>() {
    <span class="org-function-name">speak</span>(<span class="org-type">Dog</span>{})
}
</pre>
</div>

<p>
bark
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org0000021" class="outline-3">
<h3 id="org0000021"><span class="section-number-3">1.12.</span> 泛型</h3>
<div class="outline-text-3" id="text-1-12">
<p>
go 不支持泛型, 但有一些折衷的方法:
</p>
<ol class="org-ol">
<li>slice, map 本身算泛型容器</li>
<li><p>
通过空的 interface{}
</p>
<div class="org-src-container">
<pre class="src src-go"><span class="org-keyword">func</span> <span class="org-function-name">foo</span>(<span class="org-variable-name">v</span> <span class="org-keyword">interface</span>{}) () {
    <span class="org-keyword">switch</span> v.(<span class="org-keyword">type</span>) {
    <span class="org-keyword">case</span> <span class="org-type">int</span>:
        fmt.<span class="org-function-name">Println</span>(v.(<span class="org-type">int</span>))
    <span class="org-keyword">default</span>:
        fmt.<span class="org-function-name">Println</span>(<span class="org-string">"unknow type"</span>)
    }
}
</pre>
</div></li>
<li>通过实现 interface, 例如 sort.Sort() 的实现方法</li>
</ol>
</div>
</div>

<div id="outline-container-org0000024" class="outline-3">
<h3 id="org0000024"><span class="section-number-3">1.13.</span> 控制结构</h3>
<div class="outline-text-3" id="text-1-13">
<ul class="org-ul">
<li>for
for 是唯一的循环结构, 没有 while, do</li>
<li>if
if 与 switch 支持 initialization stmt</li>
<li>switch
支持 switch {} 与 switch x {} 两种形式, 不支持 case fall throught,
但支持同一个 case 多个条件</li>
</ul>
<div class="org-src-container">
<pre class="src src-go"><span class="org-keyword">package</span> main

<span class="org-keyword">import</span> (
    <span class="org-string">"fmt"</span>
)

<span class="org-keyword">func</span> <span class="org-function-name">main</span>() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">for 1</span>
    <span class="org-keyword">for</span> <span class="org-variable-name">i</span> := 0; i &lt; 3; i++ {
        fmt.<span class="org-function-name">Println</span>(i)
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">for range</span>
    <span class="org-keyword">for</span> <span class="org-variable-name">i</span>, <span class="org-variable-name">v</span> := <span class="org-keyword">range</span> []<span class="org-type">int</span>{1, 2, 3} {
        fmt.<span class="org-function-name">Println</span>(i, v)
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">for range in map</span>
    <span class="org-keyword">for</span> <span class="org-variable-name">k</span>, <span class="org-variable-name">v</span> := <span class="org-keyword">range</span> <span class="org-keyword">map</span>[<span class="org-type">int</span>]<span class="org-type">int</span>{<span class="org-constant">1</span>: 1, <span class="org-constant">2</span>: 2} {
        fmt.<span class="org-function-name">Println</span>(k, v)
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">while true</span>
    <span class="org-keyword">for</span> {

    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">while ()</span>
    <span class="org-keyword">for</span> i &lt; 1 {

    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">if</span>
    <span class="org-variable-name">i</span> := 0
    <span class="org-keyword">if</span> i == 0 {

    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">if with initialization stmt</span>
    <span class="org-variable-name">m</span> := <span class="org-keyword">map</span>[<span class="org-type">int</span>]<span class="org-type">int</span>{<span class="org-constant">1</span>: 2}
    <span class="org-keyword">if</span> <span class="org-variable-name">t</span>, <span class="org-variable-name">ok</span> := m[1]; ok {
        fmt.<span class="org-function-name">Println</span>(t)
    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">switch x</span>
    <span class="org-variable-name">x</span> := 1
    <span class="org-keyword">switch</span> x {
    <span class="org-keyword">case</span> 1:
        fmt.<span class="org-function-name">Println</span>(1)
    <span class="org-keyword">case</span> 2, 3, 4:
        fmt.<span class="org-function-name">Println</span>(2, 3, 4)
    <span class="org-keyword">default</span>:
        fmt.<span class="org-function-name">Println</span>(<span class="org-string">"default"</span>)
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">switch</span>
    <span class="org-keyword">switch</span> {
    <span class="org-keyword">case</span> x == 1:
        fmt.<span class="org-function-name">Println</span>(1)
    <span class="org-keyword">case</span> x == 2 || x == 3 || x == 4:
        fmt.<span class="org-function-name">Println</span>(2, 3, 4)
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">swith with initialization stmt</span>
    <span class="org-keyword">switch</span> <span class="org-variable-name">t</span>, <span class="org-variable-name">_</span> := m[1]; t {
    <span class="org-keyword">case</span> 1:
        fmt.<span class="org-function-name">Println</span>(1)
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org0000027" class="outline-3">
<h3 id="org0000027"><span class="section-number-3">1.14.</span> 排序</h3>
<div class="outline-text-3" id="text-1-14">
<ul class="org-ul">
<li>sort.Ints</li>
<li>sort.Strings</li>
<li>sort.Slice</li>
<li>sort.Sort</li>
</ul>

<div class="org-src-container">
<pre class="src src-go"><span class="org-keyword">package</span> main

<span class="org-keyword">import</span> (
    <span class="org-string">"fmt"</span>
    <span class="org-string">"sort"</span>
)

<span class="org-keyword">type</span> <span class="org-type">Pair</span> <span class="org-keyword">struct</span> {
    x, y <span class="org-type">int</span>
}
<span class="org-keyword">func</span> <span class="org-function-name">main</span>() {
    <span class="org-variable-name">x</span> := []<span class="org-type">int</span>{4, 1, 2, 3}
    sort.<span class="org-function-name">Ints</span>(x)
    fmt.<span class="org-function-name">Println</span>(x)
    <span class="org-variable-name">s</span> := []<span class="org-type">string</span>{<span class="org-string">"c"</span>, <span class="org-string">"b"</span>, <span class="org-string">"a"</span>}
    sort.<span class="org-function-name">Strings</span>(s)
    fmt.<span class="org-function-name">Println</span>(s)

    <span class="org-comment-delimiter">// </span><span class="org-comment">sort.Slice &#36866;&#29992;&#20110;&#23545;&#25152;&#26377; slice &#25490;&#24207;</span>
    <span class="org-variable-name">pairs</span> := []<span class="org-type">Pair</span>{{3, 2}, {2, 4}}
    sort.<span class="org-function-name">Slice</span>(pairs, <span class="org-keyword">func</span>(<span class="org-variable-name">i</span>, <span class="org-variable-name">j</span> <span class="org-type">int</span>)bool {
        <span class="org-keyword">return</span> pairs[i].x &lt; pairs[j].x
    })
    fmt.<span class="org-function-name">Println</span>(pairs)

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#26356;&#36890;&#29992;&#30340; sort.Sort, &#20854;&#20013; sort.Reverse, sort.IntSlice &#36820;&#22238;&#30340;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#37117;&#26159;&#23454;&#38469;&#20102; sort.Interface &#30340;&#25509;&#21475;, &#20363;&#22914; IntSlice &#23454;&#38469;&#20026;:</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">type IntSlice []int</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">func (p IntSlice) Len() int           { return len(p) }</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">func (p IntSlice) Less(i, j int) bool { return p[i] &lt; p[j] }</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">func (p IntSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#19968;&#33324;&#24773;&#20917;&#19979;&#19981;&#38656;&#35201;&#20351;&#29992; sort.Sort &#25509;&#21475;</span>
    sort.<span class="org-function-name">Sort</span>(sort.<span class="org-function-name">Reverse</span>(sort.<span class="org-function-name">IntSlice</span>(x)))
    fmt.<span class="org-function-name">Println</span>(x)
}
</pre>
</div>

<pre class="example">
[1 2 3 4]
[a b c]
[{2 4} {3 2}]
[4 3 2 1]
</pre>
</div>
</div>

<div id="outline-container-org000002a" class="outline-3">
<h3 id="org000002a"><span class="section-number-3">1.15.</span> 最大堆</h3>
<div class="outline-text-3" id="text-1-15">
<ul class="org-ul">
<li>container/heap 包实现了堆</li>
<li>struct 需要自己实现 Len,Less, Swap, Pop, Push 方法</li>
<li>由于 golang 不支持泛型, 需要注意 Push, Pop 方法使用了 interface{} 做为参数和返回值, 导致 Pop 时需要手动将 interface{} 转换为需要的类型</li>
</ul>
<div class="org-src-container">
<pre class="src src-go"><span class="org-keyword">package</span> main

<span class="org-keyword">import</span> (
    <span class="org-string">"container/heap"</span>
    <span class="org-string">"fmt"</span>
)

<span class="org-keyword">type</span> <span class="org-type">MinHeap</span> []<span class="org-type">int</span>

<span class="org-keyword">func</span> (<span class="org-variable-name">h</span> <span class="org-type">MinHeap</span>) <span class="org-function-name">Len</span>() <span class="org-type">int</span> {
    <span class="org-keyword">return</span> <span class="org-builtin">len</span>(h)
}

<span class="org-keyword">func</span> (<span class="org-variable-name">h</span> <span class="org-type">MinHeap</span>) <span class="org-function-name">Less</span>(<span class="org-variable-name">i</span>, <span class="org-variable-name">j</span> <span class="org-type">int</span>) <span class="org-type">bool</span> {
    <span class="org-keyword">return</span> h[i] &lt; h[j]
}

<span class="org-keyword">func</span> (<span class="org-variable-name">h</span> <span class="org-type">MinHeap</span>) <span class="org-function-name">Swap</span>(<span class="org-variable-name">i</span>, <span class="org-variable-name">j</span> <span class="org-type">int</span>) {
    h[i], h[j] = h[j], h[i]
}

<span class="org-keyword">func</span> (<span class="org-variable-name">ph</span> *<span class="org-type">MinHeap</span>) <span class="org-function-name">Pop</span>() <span class="org-keyword">interface</span>{} {
    <span class="org-variable-name">t</span> := (*ph)[<span class="org-builtin">len</span>(*ph)-1]
    *ph = (*ph)[:<span class="org-builtin">len</span>(*ph)-1]
    <span class="org-keyword">return</span> t
}

<span class="org-keyword">func</span> (<span class="org-variable-name">ph</span> *<span class="org-type">MinHeap</span>) <span class="org-function-name">Push</span>(<span class="org-variable-name">x</span> <span class="org-keyword">interface</span>{}) {
    *ph = <span class="org-builtin">append</span>(*ph, x.(<span class="org-type">int</span>))
}

<span class="org-keyword">func</span> <span class="org-function-name">main</span>() {
    <span class="org-variable-name">h</span> := <span class="org-type">MinHeap</span>{p5, 4, 3, 2, 1}
    heap.<span class="org-function-name">Init</span>(&amp;h)
    heap.<span class="org-function-name">Push</span>(&amp;h, 10)
    fmt.<span class="org-function-name">Println</span>(heap.<span class="org-function-name">Pop</span>(&amp;h).(<span class="org-type">int</span>))
}
</pre>
</div>

<pre class="example">
1
</pre>
</div>
</div>

<div id="outline-container-org000002d" class="outline-3">
<h3 id="org000002d"><span class="section-number-3">1.16.</span> math</h3>
<div class="outline-text-3" id="text-1-16">
<p>
由于 golang 不支持泛型, math 库中许多函数无法像其它语言一样方便的使用,
因为 math 库大部分函数要求 float64 类型
</p>

<ul class="org-ul">
<li>Abs, Floor, Ceil</li>
<li>MinInt32, MaxInt32</li>
<li>Pow</li>
</ul>
</div>
</div>

<div id="outline-container-org0000030" class="outline-3">
<h3 id="org0000030"><span class="section-number-3">1.17.</span> random</h3>
<div class="outline-text-3" id="text-1-17">
<ul class="org-ul">
<li>rand.Intn(n)</li>
<li>rand.Seed</li>
</ul>

<div class="org-src-container">
<pre class="src src-go"><span class="org-keyword">package</span> main

<span class="org-keyword">import</span> (
    <span class="org-string">"fmt"</span>
    <span class="org-string">"math/rand"</span>
    <span class="org-string">"time"</span>
)

<span class="org-keyword">func</span> <span class="org-function-name">main</span>() {
    rand.<span class="org-function-name">Seed</span>(time.<span class="org-function-name">Now</span>().<span class="org-function-name">Unix</span>())
    fmt.<span class="org-function-name">Println</span>(rand.<span class="org-function-name">Intn</span>(10))
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org0000033" class="outline-3">
<h3 id="org0000033"><span class="section-number-3">1.18.</span> package</h3>
<div class="outline-text-3" id="text-1-18">
<ul class="org-ul">
<li>import "fmt"</li>
<li>import "container/heap"</li>
<li>import ()</li>
<li>import "../util/tree"</li>
<li>import . "util/tree"</li>
<li>import mytree "util/tree"</li>
<li>package 中首字母大写的符号才可以被其它 package 使用</li>
<li>package 是位于 $GOPATH 里指定的某个 {path} 的 src 目录下的目录名</li>
</ul>
</div>
</div>

<div id="outline-container-org0000036" class="outline-3">
<h3 id="org0000036"><span class="section-number-3">1.19.</span> 坑</h3>
<div class="outline-text-3" id="text-1-19">
<ul class="org-ul">
<li>int 类似在 64bit 系统上为 int64, 而 c 一般是 int32</li>
<li>struct 中的指针类型: map, slice 需要单独初始化</li>
<li>slice 有时需要 copy, 防止别处与它共用</li>
<li>x.(Pair).a = 1 失败, 无法对 x.(Pair) 赋值, 需要使用 z:=x.(Pair); z.a=1</li>
<li><p>
lambda 函数递归定义时有问题
</p>
<div class="org-src-container">
<pre class="src src-go"><span class="org-comment-delimiter">// </span><span class="org-comment">&#26080;&#27861;&#32534;&#35793;&#36890;&#36807;:</span>
<span class="org-keyword">package</span> main

<span class="org-keyword">func</span> <span class="org-function-name">test</span>() {
    <span class="org-variable-name">foo</span> := <span class="org-keyword">func</span>() {
        <span class="org-function-name">foo</span>()
    }
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#38656;&#35201;&#20462;&#25913;&#20026;:</span>
<span class="org-keyword">func</span> <span class="org-function-name">test</span>() {
    <span class="org-keyword">var</span> <span class="org-variable-name">foo</span> <span class="org-keyword">func</span>()
    foo = <span class="org-keyword">func</span>() {
        <span class="org-function-name">foo</span>()
    }
}
</pre>
</div></li>
<li><p>
map 无法赋值
</p>
<div class="org-src-container">
<pre class="src src-go"><span class="org-keyword">package</span> main

  <span class="org-keyword">type</span> <span class="org-type">Pair</span> <span class="org-keyword">struct</span> {
      a <span class="org-type">int</span>
      b <span class="org-type">int</span>
  }

  <span class="org-keyword">func</span> <span class="org-function-name">main</span>() {
      <span class="org-variable-name">m</span> := <span class="org-keyword">map</span>[<span class="org-type">int</span>]<span class="org-type">Pair</span>{}
      m[0] = <span class="org-type">Pair</span>{1, 1}
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#32534;&#35793;&#38169;&#35823;: cannot assign to struct field m[0].a in map</span>
      m[0].a = 10
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#20462;&#25913;&#26041;&#27861; 1</span>
      <span class="org-variable-name">tmp</span> := m[0]
      tmp.a = 10
      m[0] = tmp
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#26041;&#27861; 2</span>
      <span class="org-variable-name">m2</span> := <span class="org-keyword">map</span>[<span class="org-type">int</span>]*<span class="org-type">Pair</span>{}
      m2[0] = &amp;<span class="org-type">Pair</span>{1, 1}
      m2[0].a = 10

  }
</pre>
</div>

<p>
无法修改的原因据说是 m[0] 对应的 Pair 的地址并不是固定的, map 会根据需要重新安排它的位置
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org0000039" class="outline-3">
<h3 id="org0000039"><span class="section-number-3">1.20.</span> channel</h3>
<div class="outline-text-3" id="text-1-20">
<ul class="org-ul">
<li>c:=make(chan int, 10)</li>
<li>往 chan 写: c &lt;- 1</li>
<li>从 chan 读: v := &lt;-c</li>
<li><p>
select
</p>
<div class="org-src-container">
<pre class="src src-go"><span class="org-keyword">select</span> {
<span class="org-keyword">case</span> <span class="org-variable-name">msg</span> := &lt;- c1:
    fmt.<span class="org-function-name">Println</span>(<span class="org-string">"from c1"</span>)
<span class="org-keyword">case</span> <span class="org-variable-name">msg</span> := &lt;- c2:
    fmt.<span class="org-function-name">Println</span>(<span class="org-string">"from c2"</span>)
}
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-org000003c" class="outline-3">
<h3 id="org000003c"><span class="section-number-3">1.21.</span> misc</h3>
<div class="outline-text-3" id="text-1-21">
<ul class="org-ul">
<li><p>
const, iota
</p>
<div class="org-src-container">
<pre class="src src-go"><span class="org-keyword">package</span> main

<span class="org-keyword">import</span> <span class="org-string">"fmt"</span>

<span class="org-keyword">const</span> (
    <span class="org-constant">FIRST</span> = <span class="org-constant">iota</span> + 1
    <span class="org-constant">SECOND</span>
    <span class="org-constant">THIRD</span>
)

<span class="org-keyword">func</span> <span class="org-function-name">main</span>() {
    fmt.<span class="org-function-name">Println</span>(FIRST, SECOND, THIRD)
}
</pre>
</div>

<pre class="example">
1 2 3
</pre></li>
<li>go build -gcflags -S xxx.go</li>
<li>go build -gcflags -m xxx.go</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

<p class="author">Author: sunway (sunwayforever@gmail.com)<br />
Date: 2018-01-02 Tue 00:00<br />
Last updated: 2022-07-17 Sun 11:39</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。
<br />

<div id="disqus_thread"></div>
<script>

(function() { // DON'T EDIT BELOW THIS LINE
         var d = document, s = d.createElement('script');
         s.src = '//sunwayforever-github-io.disqus.com/embed.js';
         s.setAttribute('data-timestamp', +new Date());
         (d.head || d.body).appendChild(s);
         })();
</script>
</div>
</body>
</html>
