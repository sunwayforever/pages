<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-01-19 三 12:58 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Coroutine, Async/Await</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wei Sun (孙伟)" />
<link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
<link rel = "icon" href = "/icon.png"  type = "image/x-icon">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">Coroutine, Async/Await</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgbce1fbd">1. Coroutine, Async/Await</a>
<ul>
<li><a href="#org92a16e1">1.1. futures</a>
<ul>
<li><a href="#org296c000">1.1.1. executor</a></li>
<li><a href="#org0178a5c">1.1.2. future</a></li>
<li><a href="#org72388ee">1.1.3. compositor</a></li>
</ul>
</li>
<li><a href="#orgc821d13">1.2. generator</a></li>
<li><a href="#org5f6664e">1.3. coroutine</a></li>
<li><a href="#orgec2cfa1">1.4. async/await</a></li>
<li><a href="#org82cab0b">1.5. coroutine/async/await 的用途</a>
<ul>
<li><a href="#org0721393">1.5.1. 代替 callback</a></li>
<li><a href="#orga92ae82">1.5.2. 和 epoll 结合实现高吞吐量的 IO 操作</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgbce1fbd" class="outline-2">
<h2 id="orgbce1fbd"><span class="section-number-2">1</span> Coroutine, Async/Await</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org92a16e1" class="outline-3">
<h3 id="org92a16e1"><span class="section-number-3">1.1</span> futures</h3>
<div class="outline-text-3" id="text-1-1">
<p>
future 包含三个要素:
</p>

<ol class="org-ol">
<li>executor</li>
<li>future</li>
<li>compositor</li>
</ol>
</div>


<div id="outline-container-org296c000" class="outline-4">
<h4 id="org296c000"><span class="section-number-4">1.1.1</span> executor</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
executor 负责把执行 future 代表的操作, 并得到最终的结果, 例如:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #859900;">let</span> <span style="color: #268bd2;">future</span> = read_from_file<span style="color: #757575;">()</span>;
<span style="color: #859900;">let</span> <span style="color: #268bd2;">data</span> = executor.block_on<span style="color: #757575;">(</span>future<span style="color: #757575;">)</span>;
<span style="color: #859900;">let</span> <span style="color: #268bd2;">data2</span> = executor.thread_pool.run<span style="color: #757575;">(</span>future<span style="color: #757575;">)</span>;
</pre>
</div>

<p>
future 只是定义了一系列操作, 最终需要通过 block_on 和 thread_pool 这些 executor
来执行
</p>
</div>
</div>

<div id="outline-container-org0178a5c" class="outline-4">
<h4 id="org0178a5c"><span class="section-number-4">1.1.2</span> future</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
future 定义了一系列操作, 但不会马上执行, 通常通过 future 定义需要阻塞的操作, 例如 read file. 通常我们可以用 callback 来达到和 future 相同的功能, 例如
</p>

<div class="org-src-container">
<pre class="src src-rust">
<span style="color: #586e75;">// </span><span style="color: #586e75;">use future</span>

<span style="color: #859900;">let</span> <span style="color: #268bd2;">future</span> = read_file<span style="color: #757575;">()</span>;
<span style="color: #859900;">let</span> <span style="color: #268bd2;">data</span> = <span style="color: #268bd2; font-weight: bold;">executor</span>::<span style="color: #268bd2; font-weight: bold;">thread_pool</span>::run<span style="color: #757575;">(</span>future<span style="color: #757575;">)</span>;

<span style="color: #586e75;">//  </span><span style="color: #586e75;">use callback</span>
<span style="color: #859900;">fn</span> <span style="color: #268bd2;">read_data</span><span style="color: #757575;">(</span><span style="color: #268bd2;">f</span>:<span style="color: #b58900;">Fn</span><span style="color: #757575;">)</span> -&gt; <span style="color: #757575;">()</span> <span style="color: #757575;">{</span>
    <span style="color: #859900;">let</span> <span style="color: #859900;">mut</span> <span style="color: #268bd2;">data</span>;
    thread.spawn<span style="color: #757575;">(</span> || <span style="color: #757575;">{</span>
        data = read_file<span style="color: #757575;">()</span>;
    <span style="color: #757575;">})</span>;
    f<span style="color: #757575;">(</span>data<span style="color: #757575;">)</span>;
<span style="color: #757575;">}</span>

read_data<span style="color: #757575;">(</span>|data| <span style="color: #757575;">{</span>
    println<span style="color: #757575;">(</span>data<span style="color: #757575;">)</span>;
<span style="color: #757575;">})</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org72388ee" class="outline-4">
<h4 id="org72388ee"><span class="section-number-4">1.1.3</span> compositor</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
单个的 future 并没有太多意义, 因为异步操作需要都是多个异步操作组合在一起, 例如对于如下的任务:
</p>

<ol class="org-ol">
<li>建立 http 连接 (异步)</li>
<li>读取数据 (异步)</li>
<li>写数据到文件(异步)</li>
</ol>

<p>
使用 callback 方式:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #859900;">fn</span> <span style="color: #268bd2;">connect</span><span style="color: #757575;">()</span> <span style="color: #757575;">{</span>
    setup_http_connection<span style="color: #757575;">(</span>|| read_data<span style="color: #757575;">(</span>|data| write_data<span style="color: #757575;">(</span>data<span style="color: #757575;">)))</span>
<span style="color: #757575;">}</span>
</pre>
</div>

<p>
使用 future 方式:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #268bd2; font-weight: bold;">executor</span>::block_on<span style="color: #757575;">(</span>setup_http_connection<span style="color: #757575;">()</span>.and_then<span style="color: #757575;">(</span>read_data<span style="color: #757575;">())</span>.and_then<span style="color: #757575;">(</span>write_data<span style="color: #757575;">()))</span>;
</pre>
</div>

<p>
通过 and_then 这种方式把 future 组合成一个更大的 future, 最终提交给 executor 执行. 比 callback 的写法更自然也更接近于同步执行的写法.
</p>

<p>
除了 and_then, 还有 else, then, map 等 compositor
</p>
</div>
</div>
</div>

<div id="outline-container-orgc821d13" class="outline-3">
<h3 id="orgc821d13"><span class="section-number-3">1.2</span> generator</h3>
<div class="outline-text-3" id="text-1-2">
<p>
python 的 yield 是一个典型的 generator.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900;">def</span> <span style="color: #268bd2;">get_next</span><span style="color: #757575;">()</span>:
    <span style="color: #268bd2;">i</span> = 0;
    <span style="color: #859900;">while</span> <span style="color: #757575;">(</span>true<span style="color: #757575;">)</span>:
        <span style="color: #859900;">yield</span> i
        i++

<span style="color: #859900;">for</span> i <span style="color: #859900;">in</span> get_next<span style="color: #757575;">()</span>:
    <span style="color: #859900;">print</span><span style="color: #757575;">(</span>i<span style="color: #757575;">)</span>
    <span style="color: #586e75;"># </span><span style="color: #586e75;">&#36755;&#20986; 012345...</span>
</pre>
</div>

<p>
实际上 get_next() 返回了一个 generator, 上面的代码类似于:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #268bd2;">gen</span> = get_next<span style="color: #757575;">()</span>;
<span style="color: #859900;">while</span> <span style="color: #268bd2;">a</span> = gen.resume<span style="color: #757575;">()</span>:
    <span style="color: #859900;">print</span><span style="color: #757575;">(</span>a<span style="color: #757575;">)</span>
</pre>
</div>

<p>
generator yield 会把控制交回给调用都, 并通过一定方式保存了当前的上下文 (局部变量, 指令记数), 下一次 resume 时, 会恢复保存的上下文并直接从上次 yield 的地方开始执行
</p>

<p>
在实现上, 根据保存上下文的方式, 有两种方式来实现 generator:
</p>

<ol class="org-ol">
<li><p>
stackful
</p>

<p>
每次 yield 时直接保存了当前的栈, resume 时恢复保存的栈. 这种方式比较简单直观,
但代价较大
</p></li>

<li><p>
stackless
</p>

<p>
使用一个单独的对象来维护相关局部变量和状态, 例如:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900;">class</span> <span style="color: #b58900;">GetNext</span><span style="color: #757575;">(</span><span style="color: #839496;">object</span><span style="color: #757575;">)</span>:
    <span style="color: #859900;">def</span> <span style="color: #268bd2;">__init__</span><span style="color: #757575;">(</span><span style="color: #859900;">self</span><span style="color: #757575;">)</span>:
        <span style="color: #859900;">self</span>.i = 0

    <span style="color: #859900;">def</span> <span style="color: #268bd2;">resume</span><span style="color: #757575;">()</span>:
        <span style="color: #859900;">while</span> <span style="color: #757575;">(</span>true<span style="color: #757575;">)</span>:
            <span style="color: #859900;">if</span> <span style="color: #859900;">self</span>.yield_point == YIELD1:
                ...
                <span style="color: #859900;">self</span>.yield_point = YIELD2;
                <span style="color: #859900;">return</span> ...
            <span style="color: #859900;">if</span> <span style="color: #859900;">self</span>.yield_point == YIELD2:
                ...
                <span style="color: #859900;">self</span>.yield_point = ...
                <span style="color: #859900;">return</span> ...
            ...
</pre>
</div>

<p>
stackless 的 generator 需要根据 generator 的代码生成相应的对象和代码, 但开销较小.
</p></li>
</ol>
</div>
</div>

<div id="outline-container-org5f6664e" class="outline-3">
<h3 id="org5f6664e"><span class="section-number-3">1.3</span> coroutine</h3>
<div class="outline-text-3" id="text-1-3">
<p>
generator 通常只有被调用者是 generator, 需要有 resume 的能力. 对于 coroutine 来说, 任何一方都可以 resume, 例如:
</p>

<div class="org-src-container">
<pre class="src src-python">__coroutine__ <span style="color: #859900;">def</span> <span style="color: #268bd2;">ping</span><span style="color: #757575;">()</span>:
    yield_to pong

__coroutine__ <span style="color: #859900;">def</span> <span style="color: #268bd2;">pong</span><span style="color: #757575;">()</span>:
    yield_to ping
</pre>
</div>

<p>
实现上, 可以通过 generator 加 dispatcher 的方式来实现 coroutine
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900;">def</span> <span style="color: #268bd2;">dispatcher</span><span style="color: #757575;">(</span>entry<span style="color: #757575;">)</span>:
    <span style="color: #859900;">while</span> <span style="color: #757575;">(</span>true<span style="color: #757575;">)</span>:
      <span style="color: #268bd2;">entry</span> = entry.resume<span style="color: #757575;">()</span>;

<span style="color: #859900;">def</span> <span style="color: #268bd2;">ping</span><span style="color: #757575;">()</span>:
    yield_to pong

<span style="color: #859900;">def</span> <span style="color: #268bd2;">pong</span><span style="color: #757575;">()</span>:
    yield_to ping

dispatcher<span style="color: #757575;">(</span>ping<span style="color: #757575;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgec2cfa1" class="outline-3">
<h3 id="orgec2cfa1"><span class="section-number-3">1.4</span> async/await</h3>
<div class="outline-text-3" id="text-1-4">
<p>
与 generator 类似, async/await 也可以看作是 coroutine 的特殊形式.
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #859900;">async</span> <span style="color: #859900;">fn</span> <span style="color: #268bd2;">hello</span><span style="color: #757575;">()</span> -&gt; <span style="color: #757575;">()</span> <span style="color: #757575;">{</span>
    world<span style="color: #757575;">()</span>.<span style="color: #859900;">await</span>;
<span style="color: #757575;">}</span>

<span style="color: #859900;">async</span> <span style="color: #859900;">fn</span> <span style="color: #268bd2;">world</span><span style="color: #757575;">()</span> -&gt; <span style="color: #757575;">()</span> <span style="color: #757575;">{</span>
    <span style="color: #839496;">println!</span><span style="color: #757575;">(</span><span style="color: #2aa198;">"world"</span><span style="color: #757575;">)</span>;
<span style="color: #757575;">}</span>

<span style="color: #859900;">fn</span> <span style="color: #268bd2;">main</span><span style="color: #757575;">()</span> -&gt; <span style="color: #757575;">()</span> <span style="color: #757575;">{</span>
    block_on<span style="color: #757575;">(</span>hello<span style="color: #757575;">())</span>;
<span style="color: #757575;">}</span>
</pre>
</div>

<p>
await 把控制交给 async, async 返回时会把控制交还给 await: await 处相当于一个隐式的 callback
</p>
</div>
</div>

<div id="outline-container-org82cab0b" class="outline-3">
<h3 id="org82cab0b"><span class="section-number-3">1.5</span> coroutine/async/await 的用途</h3>
<div class="outline-text-3" id="text-1-5">
<p>
coroutine 的用途等同于如下的问题:
</p>

<p>
Q: 单核系统上使用多线程有什么用处?
</p>

<p>
A: 实现并发, 由 kernel 安排多个任务并发执行, 但并非并行执行. 
</p>

<p>
coroutine 与单核上的多线程类似, 可以用来实现单线程的并发, 因为各个函数可以随意的转移控制并 resume.
</p>

<p>
单核多线程与 coroutine 有类似的对应关系:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">单核多线程</th>
<th scope="col" class="org-left">coroutine</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">thread</td>
<td class="org-left">coroutine</td>
</tr>

<tr>
<td class="org-left">进程调度</td>
<td class="org-left">dispatcher</td>
</tr>

<tr>
<td class="org-left">thread 上下文的保存与恢复</td>
<td class="org-left">coroutine 上下文的保存与恢复</td>
</tr>

<tr>
<td class="org-left">IO 中断</td>
<td class="org-left">epoll 轮询</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-org0721393" class="outline-4">
<h4 id="org0721393"><span class="section-number-4">1.5.1</span> 代替 callback</h4>
</div>

<div id="outline-container-orga92ae82" class="outline-4">
<h4 id="orga92ae82"><span class="section-number-4">1.5.2</span> 和 epoll 结合实现高吞吐量的 IO 操作</h4>
<div class="outline-text-4" id="text-1-5-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900;">def</span> <span style="color: #268bd2;">dispatcher</span><span style="color: #757575;">()</span>:
    <span style="color: #859900;">while</span> epoll<span style="color: #757575;">(</span>fdset<span style="color: #757575;">)</span>:
        <span style="color: #268bd2;">fd</span> = getfd<span style="color: #757575;">()</span>
        mapping[fd].resume<span style="color: #757575;">()</span>

<span style="color: #859900;">async def</span> <span style="color: #268bd2;">process</span><span style="color: #757575;">()</span>:
    <span style="color: #859900;">await</span> connect
    <span style="color: #859900;">await</span> get_data

<span style="color: #859900;">async def</span> <span style="color: #268bd2;">connect</span><span style="color: #757575;">()</span>:
    mark<span style="color: #757575;">(</span>fd<span style="color: #757575;">,</span> connect<span style="color: #757575;">)</span>
    yield_to dispatcher

<span style="color: #859900;">async def</span> <span style="color: #268bd2;">get_data</span><span style="color: #757575;">()</span>:
    mark<span style="color: #757575;">(</span>fd<span style="color: #757575;">,</span> get_data<span style="color: #757575;">)</span>
    yield_to dispatcher

</pre>
</div>

<p>
实际上 async/await 是用一种模拟同步执行的写法表示 callback
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

<p class="author">Author: sunway (sunwayforever@gmail.com)<br />
Date: 2019-11-28 四 00:00<br />
Last updated: 2021-09-16 四 11:06</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。
<br />

<div id="disqus_thread"></div>
<script>

(function() { // DON'T EDIT BELOW THIS LINE
         var d = document, s = d.createElement('script');
         s.src = '//sunwayforever-github-io.disqus.com/embed.js';
         s.setAttribute('data-timestamp', +new Date());
         (d.head || d.body).appendChild(s);
         })();
</script>
</div>
</body>
</html>
