<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>Coroutine</title>

<link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
<link rel="stylesheet" type="text/css" href="../main.css" media="screen" />
<link rel="stylesheet" type="text/css" href="./main.css" media="screen" />
<link rel = "icon" href = "/icon.png"  type = "image/x-icon">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">Coroutine</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org000001e">1. Coroutine</a>
<ul>
<li><a href="#org0000009">1.1. futures</a>
<ul>
<li><a href="#org0000000">1.1.1. executor</a></li>
<li><a href="#org0000003">1.1.2. future</a></li>
<li><a href="#org0000006">1.1.3. compositor</a></li>
</ul>
</li>
<li><a href="#ID-e969e80b-4060-4209-91e1-baa79e4076b2">1.2. generator</a></li>
<li><a href="#org000000f">1.3. coroutine</a></li>
<li><a href="#org0000012">1.4. async/await</a></li>
<li><a href="#org000001b">1.5. coroutine/async/await 的用途</a>
<ul>
<li><a href="#org0000015">1.5.1. 代替 callback</a></li>
<li><a href="#org0000018">1.5.2. 和 epoll 结合实现高吞吐量的 IO 操作</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org000001e" class="outline-2">
<h2 id="org000001e"><span class="section-number-2">1</span> Coroutine</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org0000009" class="outline-3">
<h3 id="org0000009"><span class="section-number-3">1.1</span> futures</h3>
<div class="outline-text-3" id="text-1-1">
<p>
future 包含三个要素:
</p>

<ol class="org-ol">
<li>executor</li>
<li>future</li>
<li>compositor</li>
</ol>
</div>


<div id="outline-container-org0000000" class="outline-4">
<h4 id="org0000000"><span class="section-number-4">1.1.1</span> executor</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
executor 负责把执行 future 代表的操作, 并得到最终的结果, 例如:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">let</span> <span class="org-variable-name">future</span> = read_from_file();
<span class="org-keyword">let</span> <span class="org-variable-name">data</span> = executor.block_on(future);
<span class="org-keyword">let</span> <span class="org-variable-name">data2</span> = executor.thread_pool.run(future);
</pre>
</div>

<p>
future 只是定义了一系列操作, 最终需要通过 block_on 和 thread_pool 这些 executor
来执行
</p>
</div>
</div>

<div id="outline-container-org0000003" class="outline-4">
<h4 id="org0000003"><span class="section-number-4">1.1.2</span> future</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
future 定义了一系列操作, 但不会马上执行, 通常通过 future 定义需要阻塞的操作, 例如 read file. 通常我们可以用 callback 来达到和 future 相同的功能, 例如
</p>

<div class="org-src-container">
<pre class="src src-rust">
<span class="org-comment-delimiter">// </span><span class="org-comment">use future</span>

<span class="org-keyword">let</span> <span class="org-variable-name">future</span> = read_file();
<span class="org-keyword">let</span> <span class="org-variable-name">data</span> = <span class="org-constant">executor</span>::<span class="org-constant">thread_pool</span>::run(future);

<span class="org-comment-delimiter">//  </span><span class="org-comment">use callback</span>
<span class="org-keyword">fn</span> <span class="org-function-name">read_data</span>(<span class="org-variable-name">f</span>:<span class="org-type">Fn</span>) -&gt; () {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">data</span>;
    thread.spawn( || {
        data = read_file();
    });
    f(data);
}

read_data(|data| {
    println(data);
})
</pre>
</div>
</div>
</div>

<div id="outline-container-org0000006" class="outline-4">
<h4 id="org0000006"><span class="section-number-4">1.1.3</span> compositor</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
单个的 future 并没有太多意义, 因为异步操作需要都是多个异步操作组合在一起, 例如对于如下的任务:
</p>

<ol class="org-ol">
<li>建立 http 连接 (异步)</li>
<li>读取数据 (异步)</li>
<li>写数据到文件(异步)</li>
</ol>

<p>
使用 callback 方式:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">fn</span> <span class="org-function-name">connect</span>() {
    setup_http_connection(|| read_data(|data| write_data(data)))
}
</pre>
</div>

<p>
使用 future 方式:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span class="org-constant">executor</span>::block_on(setup_http_connection().and_then(read_data()).and_then(write_data()));
</pre>
</div>

<p>
通过 and_then 这种方式把 future 组合成一个更大的 future, 最终提交给 executor 执行. 比 callback 的写法更自然也更接近于同步执行的写法.
</p>

<p>
除了 and_then, 还有 else, then, map 等 compositor
</p>
</div>
</div>
</div>

<div id="outline-container-ID-e969e80b-4060-4209-91e1-baa79e4076b2" class="outline-3">
<h3 id="ID-e969e80b-4060-4209-91e1-baa79e4076b2"><span class="section-number-3">1.2</span> generator</h3>
<div class="outline-text-3" id="text-1-2">
<p>
python 的 yield 是一个典型的 generator.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">get_next</span>():
    <span class="org-variable-name">i</span> = 0;
    <span class="org-keyword">while</span> (true):
        <span class="org-keyword">yield</span> i
        i++

<span class="org-keyword">for</span> i <span class="org-keyword">in</span> get_next():
    <span class="org-keyword">print</span>(i)
    <span class="org-comment-delimiter"># </span><span class="org-comment">&#36755;&#20986; 012345...</span>
</pre>
</div>

<p>
实际上 get_next() 返回了一个 generator, 上面的代码类似于:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">gen</span> = get_next();
<span class="org-keyword">while</span> <span class="org-variable-name">a</span> = gen.resume():
    <span class="org-keyword">print</span>(a)
</pre>
</div>

<p>
generator yield 会把控制交回给调用都, 并通过一定方式保存了当前的上下文 (局部变量, 指令记数), 下一次 resume 时, 会恢复保存的上下文并直接从上次 yield 的地方开始执行
</p>

<p>
在实现上, 根据保存上下文的方式, 有两种方式来实现 generator:
</p>

<ol class="org-ol">
<li><p>
stackful
</p>

<p>
每次 yield 时直接保存了当前的栈, resume 时恢复保存的栈. 这种方式比较简单直观,
但代价较大
</p></li>

<li><p>
stackless
</p>

<p>
使用一个单独的对象来维护相关局部变量和状态, 例如:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">GetNext</span>(<span class="org-builtin">object</span>):
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">self</span>.i = 0

    <span class="org-keyword">def</span> <span class="org-function-name">resume</span>():
        <span class="org-keyword">while</span> (true):
            <span class="org-keyword">if</span> <span class="org-keyword">self</span>.yield_point == YIELD1:
                ...
                <span class="org-keyword">self</span>.yield_point = YIELD2;
                <span class="org-keyword">return</span> ...
            <span class="org-keyword">if</span> <span class="org-keyword">self</span>.yield_point == YIELD2:
                ...
                <span class="org-keyword">self</span>.yield_point = ...
                <span class="org-keyword">return</span> ...
            ...
</pre>
</div>

<p>
stackless 的 generator 需要根据 generator 的代码生成相应的对象和代码, 但开销较小.
</p></li>
</ol>

<p>
不考虑实现细节, generator 在用法上和 iterator 类似, 例如 <a href="../lang/rust/rust_iterator.html#ID-83a00b91-4fca-4486-876e-cf3d75e6c68f">Rust Iterator</a>
</p>
</div>


<div id="outline-container-org000000c" class="outline-4 references">
<h4 id="org000000c">Backlinks</h4>
<div class="outline-text-4" id="text-org000000c">
<p>
<a href="../tensorflow/tensorflow_architecture.html#ID-d4639ca8-9dbc-4207-a196-fc427b7e12fc">Tensorflow Architecture</a>
(<i>Tensorflow Architecture &gt; CPU Parallelism &gt; data parallelism &gt; generator</i>):  tensorflow dataset api 是一个 <a href="#ID-e969e80b-4060-4209-91e1-baa79e4076b2">generator</a> 模式的 api, 用来构造 data pipeline, 例 如:
</p>
</div>
</div>
</div>


<div id="outline-container-org000000f" class="outline-3">
<h3 id="org000000f"><span class="section-number-3">1.3</span> coroutine</h3>
<div class="outline-text-3" id="text-1-3">
<p>
generator 通常只有被调用者是 generator, 需要有 resume 的能力. 对于 coroutine 来说, 任何一方都可以 resume, 例如:
</p>

<div class="org-src-container">
<pre class="src src-python">__coroutine__ <span class="org-keyword">def</span> <span class="org-function-name">ping</span>():
    yield_to pong

__coroutine__ <span class="org-keyword">def</span> <span class="org-function-name">pong</span>():
    yield_to ping
</pre>
</div>

<p>
实现上, 可以通过 generator 加 dispatcher 的方式来实现 coroutine
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">dispatcher</span>(entry):
    <span class="org-keyword">while</span> (true):
      <span class="org-variable-name">entry</span> = entry.resume();

<span class="org-keyword">def</span> <span class="org-function-name">ping</span>():
    yield_to pong

<span class="org-keyword">def</span> <span class="org-function-name">pong</span>():
    yield_to ping

dispatcher(ping)
</pre>
</div>
</div>
</div>

<div id="outline-container-org0000012" class="outline-3">
<h3 id="org0000012"><span class="section-number-3">1.4</span> async/await</h3>
<div class="outline-text-3" id="text-1-4">
<p>
与 generator 类似, async/await 也可以看作是 coroutine 的特殊形式.
</p>

<div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">async</span> <span class="org-keyword">fn</span> <span class="org-function-name">hello</span>() -&gt; () {
    world().<span class="org-keyword">await</span>;
}

<span class="org-keyword">async</span> <span class="org-keyword">fn</span> <span class="org-function-name">world</span>() -&gt; () {
    <span class="org-rust-builtin-formatting-macro">println!</span>(<span class="org-string">"world"</span>);
}

<span class="org-keyword">fn</span> <span class="org-function-name">main</span>() -&gt; () {
    block_on(hello());
}
</pre>
</div>

<p>
await 把控制交给 async, async 返回时会把控制交还给 await: await 处相当于一个隐式的 callback
</p>
</div>
</div>

<div id="outline-container-org000001b" class="outline-3">
<h3 id="org000001b"><span class="section-number-3">1.5</span> coroutine/async/await 的用途</h3>
<div class="outline-text-3" id="text-1-5">
<p>
coroutine 的用途等同于如下的问题:
</p>

<p>
Q: 单核系统上使用多线程有什么用处?
</p>

<p>
A: 实现并发, 由 kernel 安排多个任务并发执行, 但并非并行执行. 
</p>

<p>
coroutine 与单核上的多线程类似, 可以用来实现单线程的并发, 因为各个函数可以随意的转移控制并 resume.
</p>

<p>
单核多线程与 coroutine 有类似的对应关系:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">单核多线程</th>
<th scope="col" class="org-left">coroutine</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">thread</td>
<td class="org-left">coroutine</td>
</tr>

<tr>
<td class="org-left">进程调度</td>
<td class="org-left">dispatcher</td>
</tr>

<tr>
<td class="org-left">thread 上下文的保存与恢复</td>
<td class="org-left">coroutine 上下文的保存与恢复</td>
</tr>

<tr>
<td class="org-left">IO 中断</td>
<td class="org-left">epoll 轮询</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-org0000015" class="outline-4">
<h4 id="org0000015"><span class="section-number-4">1.5.1</span> 代替 callback</h4>
</div>

<div id="outline-container-org0000018" class="outline-4">
<h4 id="org0000018"><span class="section-number-4">1.5.2</span> 和 epoll 结合实现高吞吐量的 IO 操作</h4>
<div class="outline-text-4" id="text-1-5-2">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">dispatcher</span>():
    <span class="org-keyword">while</span> epoll(fdset):
        <span class="org-variable-name">fd</span> = getfd()
        mapping[fd].resume()

<span class="org-keyword">async def</span> <span class="org-function-name">process</span>():
    <span class="org-keyword">await</span> connect
    <span class="org-keyword">await</span> get_data

<span class="org-keyword">async def</span> <span class="org-function-name">connect</span>():
    mark(fd, connect)
    yield_to dispatcher

<span class="org-keyword">async def</span> <span class="org-function-name">get_data</span>():
    mark(fd, get_data)
    yield_to dispatcher

</pre>
</div>

<p>
实际上 async/await 是用一种模拟同步执行的写法表示 callback
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

<p class="author">Author: sunway (sunway@dogdog.run)<br />
Date: 2019-11-28 Thu 00:00<br />
Last updated: 2022-10-24 Mon 12:39</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。
<br />

<div id="disqus_thread"></div>
<script>

(function() { // DON'T EDIT BELOW THIS LINE
         var d = document, s = d.createElement('script');
         s.src = '//sunwayforever-github-io.disqus.com/embed.js';
         s.setAttribute('data-timestamp', +new Date());
         (d.head || d.body).appendChild(s);
         })();
</script>
</div>
</body>
</html>
