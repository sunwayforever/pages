<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-01-25 Tue 18:52 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Coroutine, Async/Await</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wei Sun (孙伟)" />
<link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
<link rel = "icon" href = "/icon.png"  type = "image/x-icon">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">Coroutine, Async/Await</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org3e23d78">1. Coroutine, Async/Await</a>
<ul>
<li><a href="#org538041f">1.1. futures</a>
<ul>
<li><a href="#org2a4d8eb">1.1.1. executor</a></li>
<li><a href="#orgfe43113">1.1.2. future</a></li>
<li><a href="#org28daa5e">1.1.3. compositor</a></li>
</ul>
</li>
<li><a href="#org872a0f9">1.2. generator</a></li>
<li><a href="#orgbfc5a62">1.3. coroutine</a></li>
<li><a href="#org9c79f9d">1.4. async/await</a></li>
<li><a href="#orge1e87df">1.5. coroutine/async/await 的用途</a>
<ul>
<li><a href="#orgfd792df">1.5.1. 代替 callback</a></li>
<li><a href="#org7732870">1.5.2. 和 epoll 结合实现高吞吐量的 IO 操作</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org3e23d78" class="outline-2">
<h2 id="org3e23d78"><span class="section-number-2">1</span> Coroutine, Async/Await</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org538041f" class="outline-3">
<h3 id="org538041f"><span class="section-number-3">1.1</span> futures</h3>
<div class="outline-text-3" id="text-1-1">
<p>
future 包含三个要素:
</p>

<ol class="org-ol">
<li>executor</li>
<li>future</li>
<li>compositor</li>
</ol>
</div>


<div id="outline-container-org2a4d8eb" class="outline-4">
<h4 id="org2a4d8eb"><span class="section-number-4">1.1.1</span> executor</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
executor 负责把执行 future 代表的操作, 并得到最终的结果, 例如:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">future</span> = read_from_file();
<span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">data</span> = executor.block_on(future);
<span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">data2</span> = executor.thread_pool.run(future);
</pre>
</div>

<p>
future 只是定义了一系列操作, 最终需要通过 block_on 和 thread_pool 这些 executor
来执行
</p>
</div>
</div>

<div id="outline-container-orgfe43113" class="outline-4">
<h4 id="orgfe43113"><span class="section-number-4">1.1.2</span> future</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
future 定义了一系列操作, 但不会马上执行, 通常通过 future 定义需要阻塞的操作, 例
如 read file. 通常我们可以用 callback 来达到和 future 相同的功能, 例如
</p>

<div class="org-src-container">
<pre class="src src-rust">
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">use future</span>

<span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">future</span> = read_file();
<span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">data</span> = <span style="font-weight: bold; text-decoration: underline;">executor</span>::<span style="font-weight: bold; text-decoration: underline;">thread_pool</span>::run(future);

<span style="font-weight: bold; font-style: italic;">//  </span><span style="font-weight: bold; font-style: italic;">use callback</span>
<span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">read_data</span>(<span style="font-weight: bold; font-style: italic;">f</span>:<span style="font-weight: bold; text-decoration: underline;">Fn</span>) -&gt; () {
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold;">mut</span> <span style="font-weight: bold; font-style: italic;">data</span>;
    thread.spawn( || {
        data = read_file();
    });
    f(data);
}

read_data(|data| {
    println(data);
})
</pre>
</div>
</div>
</div>

<div id="outline-container-org28daa5e" class="outline-4">
<h4 id="org28daa5e"><span class="section-number-4">1.1.3</span> compositor</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
单个的 future 并没有太多意义, 因为异步操作需要都是多个异步操作组合在一起, 例如对
于如下的任务:
</p>

<ol class="org-ol">
<li>建立 http 连接 (异步)</li>
<li>读取数据 (异步)</li>
<li>写数据到文件(异步)</li>
</ol>

<p>
使用 callback 方式:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">connect</span>() {
    setup_http_connection(|| read_data(|data| write_data(data)))
}
</pre>
</div>

<p>
使用 future 方式:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="font-weight: bold; text-decoration: underline;">executor</span>::block_on(setup_http_connection().and_then(read_data()).and_then(write_data()));
</pre>
</div>

<p>
通过 and_then 这种方式把 future 组合成一个更大的 future, 最终提交给 executor 执
行. 比 callback 的写法更自然也更接近于同步执行的写法.
</p>

<p>
除了 and_then, 还有 else, then, map 等 compositor
</p>
</div>
</div>
</div>

<div id="outline-container-org872a0f9" class="outline-3">
<h3 id="org872a0f9"><span class="section-number-3">1.2</span> generator</h3>
<div class="outline-text-3" id="text-1-2">
<p>
python 的 yield 是一个典型的 generator.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">def</span> <span style="font-weight: bold;">get_next</span>():
    <span style="font-weight: bold; font-style: italic;">i</span> = 0;
    <span style="font-weight: bold;">while</span> (true):
        <span style="font-weight: bold;">yield</span> i
        i++

<span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> get_next():
    <span style="font-weight: bold;">print</span>(i)
    <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">&#36755;&#20986; 012345...</span>
</pre>
</div>

<p>
实际上 get_next() 返回了一个 generator, 上面的代码类似于:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">gen</span> = get_next();
<span style="font-weight: bold;">while</span> <span style="font-weight: bold; font-style: italic;">a</span> = gen.resume():
    <span style="font-weight: bold;">print</span>(a)
</pre>
</div>

<p>
generator yield 会把控制交回给调用都, 并通过一定方式保存了当前的上下文 (局部变
量, 指令记数), 下一次 resume 时, 会恢复保存的上下文并直接从上次 yield 的地方开始
执行
</p>

<p>
在实现上, 根据保存上下文的方式, 有两种方式来实现 generator:
</p>

<ol class="org-ol">
<li><p>
stackful
</p>

<p>
每次 yield 时直接保存了当前的栈, resume 时恢复保存的栈. 这种方式比较简单直观,
但代价较大
</p></li>

<li><p>
stackless
</p>

<p>
使用一个单独的对象来维护相关局部变量和状态, 例如:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">GetNext</span>(<span style="font-weight: bold;">object</span>):
    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">__init__</span>(<span style="font-weight: bold;">self</span>):
        <span style="font-weight: bold;">self</span>.i = 0

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">resume</span>():
        <span style="font-weight: bold;">while</span> (true):
            <span style="font-weight: bold;">if</span> <span style="font-weight: bold;">self</span>.yield_point == YIELD1:
                ...
                <span style="font-weight: bold;">self</span>.yield_point = YIELD2;
                <span style="font-weight: bold;">return</span> ...
            <span style="font-weight: bold;">if</span> <span style="font-weight: bold;">self</span>.yield_point == YIELD2:
                ...
                <span style="font-weight: bold;">self</span>.yield_point = ...
                <span style="font-weight: bold;">return</span> ...
            ...
</pre>
</div>

<p>
stackless 的 generator 需要根据 generator 的代码生成相应的对象和代码, 但开销
较小.
</p></li>
</ol>
</div>
</div>

<div id="outline-container-orgbfc5a62" class="outline-3">
<h3 id="orgbfc5a62"><span class="section-number-3">1.3</span> coroutine</h3>
<div class="outline-text-3" id="text-1-3">
<p>
generator 通常只有被调用者是 generator, 需要有 resume 的能力. 对于 coroutine 来
说, 任何一方都可以 resume, 例如:
</p>

<div class="org-src-container">
<pre class="src src-python">__coroutine__ <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">ping</span>():
    yield_to pong

__coroutine__ <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">pong</span>():
    yield_to ping
</pre>
</div>

<p>
实现上, 可以通过 generator 加 dispatcher 的方式来实现 coroutine
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">def</span> <span style="font-weight: bold;">dispatcher</span>(entry):
    <span style="font-weight: bold;">while</span> (true):
      <span style="font-weight: bold; font-style: italic;">entry</span> = entry.resume();

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">ping</span>():
    yield_to pong

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">pong</span>():
    yield_to ping

dispatcher(ping)
</pre>
</div>
</div>
</div>

<div id="outline-container-org9c79f9d" class="outline-3">
<h3 id="org9c79f9d"><span class="section-number-3">1.4</span> async/await</h3>
<div class="outline-text-3" id="text-1-4">
<p>
与 generator 类似, async/await 也可以看作是 coroutine 的特殊形式.
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="font-weight: bold;">async</span> <span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">hello</span>() -&gt; () {
    world().<span style="font-weight: bold;">await</span>;
}

<span style="font-weight: bold;">async</span> <span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">world</span>() -&gt; () {
    <span style="font-weight: bold;">println!</span>(<span style="font-style: italic;">"world"</span>);
}

<span style="font-weight: bold;">fn</span> <span style="font-weight: bold;">main</span>() -&gt; () {
    block_on(hello());
}
</pre>
</div>

<p>
await 把控制交给 async, async 返回时会把控制交还给 await: await 处相当于一个隐式
的 callback
</p>
</div>
</div>

<div id="outline-container-orge1e87df" class="outline-3">
<h3 id="orge1e87df"><span class="section-number-3">1.5</span> coroutine/async/await 的用途</h3>
<div class="outline-text-3" id="text-1-5">
<p>
coroutine 的用途等同于如下的问题:
</p>

<p>
Q: 单核系统上使用多线程有什么用处?
</p>

<p>
A: 实现并发, 由 kernel 安排多个任务并发执行, 但并非并行执行. 
</p>

<p>
coroutine 与单核上的多线程类似, 可以用来实现单线程的并发, 因为各个函数可以随意的
转移控制并 resume.
</p>

<p>
单核多线程与 coroutine 有类似的对应关系:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">单核多线程</th>
<th scope="col" class="org-left">coroutine</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">thread</td>
<td class="org-left">coroutine</td>
</tr>

<tr>
<td class="org-left">进程调度</td>
<td class="org-left">dispatcher</td>
</tr>

<tr>
<td class="org-left">thread 上下文的保存与恢复</td>
<td class="org-left">coroutine 上下文的保存与恢复</td>
</tr>

<tr>
<td class="org-left">IO 中断</td>
<td class="org-left">epoll 轮询</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-orgfd792df" class="outline-4">
<h4 id="orgfd792df"><span class="section-number-4">1.5.1</span> 代替 callback</h4>
</div>

<div id="outline-container-org7732870" class="outline-4">
<h4 id="org7732870"><span class="section-number-4">1.5.2</span> 和 epoll 结合实现高吞吐量的 IO 操作</h4>
<div class="outline-text-4" id="text-1-5-2">
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">def</span> <span style="font-weight: bold;">dispatcher</span>():
    <span style="font-weight: bold;">while</span> epoll(fdset):
        <span style="font-weight: bold; font-style: italic;">fd</span> = getfd()
        mapping[fd].resume()

<span style="font-weight: bold;">async def</span> <span style="font-weight: bold;">process</span>():
    <span style="font-weight: bold;">await</span> connect
    <span style="font-weight: bold;">await</span> get_data

<span style="font-weight: bold;">async def</span> <span style="font-weight: bold;">connect</span>():
    mark(fd, connect)
    yield_to dispatcher

<span style="font-weight: bold;">async def</span> <span style="font-weight: bold;">get_data</span>():
    mark(fd, get_data)
    yield_to dispatcher

</pre>
</div>

<p>
实际上 async/await 是用一种模拟同步执行的写法表示 callback
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

<p class="author">Author: sunway (sunwayforever@gmail.com)<br />
Date: 2019-11-28 Thu 00:00<br />
Last updated: 2021-09-16 Thu 11:06</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。
<br />

<div id="disqus_thread"></div>
<script>

(function() { // DON'T EDIT BELOW THIS LINE
         var d = document, s = d.createElement('script');
         s.src = '//sunwayforever-github-io.disqus.com/embed.js';
         s.setAttribute('data-timestamp', +new Date());
         (d.head || d.body).appendChild(s);
         })();
</script>
</div>
</body>
</html>
