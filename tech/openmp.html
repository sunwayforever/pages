<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>OpenMP</title>


           <link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
           <link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
           <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
           <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
           <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
           <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
           <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
           <link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
           <link rel="stylesheet" type="text/css" href="../main.css" media="screen" />
           <link rel="stylesheet" type="text/css" href="./main.css" media="screen" />
           <link rel = "icon" href = "/icon.png"  type = "image/x-icon">
</head>
<body>
<div id="content" class="content">
<h1 class="title">OpenMP</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org0000058">1. OpenMP</a>
<ul>
<li><a href="#org0000000">1.1. Overview</a></li>
<li><a href="#org0000003">1.2. Demo</a></li>
<li><a href="#org000004e">1.3. libgomp</a>
<ul>
<li><a href="#org000000a">1.3.1. parallel</a></li>
<li><a href="#org0000027">1.3.2. sync</a></li>
<li><a href="#org0000039">1.3.3. for</a></li>
<li><a href="#org0000040">1.3.4. task</a></li>
<li><a href="#org000004b">1.3.5. target</a></li>
</ul>
</li>
<li><a href="#org0000055">1.4. Compiler Directive</a>
<ul>
<li><a href="#org0000049">1.4.1. Example</a></li>
<li><a href="#org000004c">1.4.2. omplower</a></li>
<li><a href="#org000004f">1.4.3. ompexp</a></li>
<li><a href="#org000005d">1.4.4. omp-builtins</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org0000058" class="outline-2">
<h2 id="org0000058"><span class="section-number-2">1.</span> OpenMP</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org0000000" class="outline-3">
<h3 id="org0000000"><span class="section-number-3">1.1.</span> Overview</h3>
<div class="outline-text-3" id="text-1-1">
<p>
OpenMP 主要包含两部分内容:
</p>

<ol class="org-ol">
<li><p>
compiler directive
</p>

<p>
openmp 的 api 主要是 compiler directive 的形式, 例如 `#pragma omp parallel`,
编译器需要:
</p>

<ol class="org-ol">
<li>识别这些 directive</li>

<li>生成 parallel block 对应的匿名函数</li>

<li>调用 libgomp 中相应 api</li>
</ol></li>

<li><p>
libgomp
</p>

<p>
libgomp 中有少量函数例如 `omp_get_thread_num` 可以由用户代码直接调用, 其它的大部分的调用都是由编译器产生的, 例如 GOMP_parallel, GOMP_critical_start,
GOMP_loop_nonmonotonic_dynamic_next 等
</p></li>
</ol>
</div>
</div>

<div id="outline-container-org0000003" class="outline-3">
<h3 id="org0000003"><span class="section-number-3">1.2.</span> Demo</h3>
<div class="outline-text-3" id="text-1-2">
<p>
<a href="https://github.com/sunwayforever/code/tree/master/hello_world/hello_openmp">https://github.com/sunwayforever/code/tree/master/hello_world/hello_openmp</a>
</p>
</div>
</div>

<div id="outline-container-org000004e" class="outline-3">
<h3 id="org000004e"><span class="section-number-3">1.3.</span> libgomp</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-org000000a" class="outline-4">
<h4 id="org000000a"><span class="section-number-4">1.3.1.</span> parallel</h4>
<div class="outline-text-4" id="text-1-3-1">
<div class="org-src-container">
<pre class="src src-C"><span class="org-comment-delimiter">// </span><span class="org-comment">2022-12-05 14:51</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;omp.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
<span class="org-preprocessor">#pragma</span> omp parallel num_threads(2)
    {
        <span class="org-type">int</span> <span class="org-variable-name">id</span> = omp_get_thread_num();
        printf(<span class="org-string">"hello world %d\n"</span>, id);
    }

    printf(<span class="org-string">"------\n"</span>);
}
</pre>
</div>

<pre class="example" id="org0000006">
$&gt; riscv64-linux-gnu-gcc test.c -O0 -g -fopenmp

$&gt; readelf -a ./a.out|grep NEEDED
 0x0000000000000001 (NEEDED)             Shared library: [libgomp.so.1]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]

$&gt; riscv64-linux-gnu-objdump -d -r ./a.out

000000000000076a &lt;main&gt;:
 76a: 1101                    addi    sp,sp,-32
 76c: ec06                    sd  ra,24(sp)
 76e: e822                    sd  s0,16(sp)
 770: 1000                    addi    s0,sp,32
 772: 87aa                    mv  a5,a0
 774: feb43023            sd  a1,-32(s0)
 778: fef42623            sw  a5,-20(s0)
 77c: 4681                    li  a3,0
 77e: 4609                    li  a2,2
                              ~~~~~~~~
 780: 4581                    li  a1,0
 782: 00000517            auipc   a0,0x0
 786: 02450513            addi    a0,a0,36 # 7a6 &lt;main._omp_fn.0&gt;
                                                  ~~~~~~~~~~~~~~
 78a: f07ff0ef            jal ra,690 &lt;GOMP_parallel@plt&gt;
                                      ~~~~~~~~~~~~~~~~~
 78e: 00000517            auipc   a0,0x0
 792: 0a250513            addi    a0,a0,162 # 830 &lt;__libc_csu_fini+0x2&gt;
 796: edbff0ef            jal ra,670 &lt;puts@plt&gt;
 79a: 4781                    li  a5,0
 79c: 853e                    mv  a0,a5
 79e: 60e2                    ld  ra,24(sp)
 7a0: 6442                    ld  s0,16(sp)
 7a2: 6105                    addi    sp,sp,32
 7a4: 8082                    ret

00000000000007a6 &lt;main._omp_fn.0&gt;:
 7a6: 7179                    addi    sp,sp,-48
 7a8: f406                    sd  ra,40(sp)
 7aa: f022                    sd  s0,32(sp)
 7ac: 1800                    addi    s0,sp,48
 7ae: fca43c23            sd  a0,-40(s0)
 7b2: eafff0ef            jal ra,660 &lt;omp_get_thread_num@plt&gt;
 7b6: 87aa                    mv  a5,a0
 7b8: fef42623            sw  a5,-20(s0)
 7bc: fec42783            lw  a5,-20(s0)
 7c0: 85be                    mv  a1,a5
 7c2: 00000517            auipc   a0,0x0
 7c6: 07650513            addi    a0,a0,118 # 838 &lt;__libc_csu_fini+0xa&gt;
 7ca: eb7ff0ef            jal ra,680 &lt;printf@plt&gt;
 7ce: 70a2                    ld  ra,40(sp)
 7d0: 7402                    ld  s0,32(sp)
 7d2: 6145                    addi    sp,sp,48
 7d4: 8082                    ret

</pre>

<ol class="org-ol">
<li>gcc 会把 `omp parallel` 对应的 block `{int id=&#x2026;.;printf(&#x2026;)}` 编译成一个独立的函数 `main._omp_fn.0`</li>

<li>`omp parallel` 对应 `GOMP_parallel` 函数, 它的实现在 libgomp 中, 并且调用时传递了 `2` 做为参数, 即需要两个线程的并行</li>
</ol>
</div>

<div id="outline-container-org0000007" class="outline-5">
<h5 id="org0000007"><span class="section-number-5">1.3.1.1.</span> GOMP_parallel</h5>
<div class="outline-text-5" id="text-1-3-1-1">
<div class="org-src-container">
<pre class="src src-C"><span class="org-type">void</span> <span class="org-function-name">GOMP_parallel</span>(
    <span class="org-type">void</span> (*<span class="org-function-name">fn</span>)(<span class="org-type">void</span> *), <span class="org-type">void</span> *<span class="org-variable-name">data</span>, <span class="org-type">unsigned</span> <span class="org-variable-name">num_threads</span>, <span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">flags</span>) {
    num_threads = gomp_resolve_num_threads(num_threads, 0);
    gomp_team_start(
        fn, data, num_threads, flags, gomp_new_team(num_threads), <span class="org-constant">NULL</span>);
    <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: fn &#21363; main._omp_fn.0, &#23427;&#22312;&#20027;&#32447;&#31243;&#20250;&#30452;&#25509;&#25191;&#34892;&#19968;&#27425;, &#25152;&#20197;&#21363;&#20351;&#25351;&#23450;</span>
<span class="org-comment">     * num_threads &#20026; 0, &#20063;&#20250;&#25191;&#34892;&#19968;&#27425;</span><span class="org-comment-delimiter"> */</span>
    fn(data);
    ialias_call(GOMP_parallel_end)();
}


<span class="org-constant">gomp_team_start</span>:
  <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: gomp_team_start &#30340; num_threads &#26159;&#20174; 1 &#24320;&#22987;&#35745;&#25968;&#30340;, &#22240;&#20026;&#20027;&#32447;&#31243;&#24050;&#32463;&#25191;&#34892;&#20102;&#19968;&#27425;&#20102;</span><span class="org-comment-delimiter"> */</span>
  <span class="org-keyword">if</span> (nthreads == 1)
    <span class="org-keyword">return</span>;

  i = 1;
  <span class="org-keyword">for</span> (; i &lt; nthreads; ++i):
    start_data-&gt;fn = fn;
    start_data-&gt;fn_data = data;
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
    pthread_create (&amp;start_data-&gt;handle, attr, gomp_thread_start, start_data);

<span class="org-constant">gomp_thread_start</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  local_fn = data-&gt;fn;
  local_data = data-&gt;fn_data;
  <span class="org-function-name">local_fn</span> (local_data);
  <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org0000027" class="outline-4">
<h4 id="org0000027"><span class="section-number-4">1.3.2.</span> sync</h4>
<div class="outline-text-4" id="text-1-3-2">
</div>
<div id="outline-container-org000000e" class="outline-5">
<h5 id="org000000e"><span class="section-number-5">1.3.2.1.</span> atomic</h5>
<div class="outline-text-5" id="text-1-3-2-1">
<div class="org-src-container">
<pre class="src src-C"><span class="org-comment-delimiter">// </span><span class="org-comment">2022-12-05 14:51</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;omp.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
    <span class="org-type">int</span> <span class="org-variable-name">sum</span> = 0;
<span class="org-preprocessor">#pragma</span> omp parallel num_threads(2)
    {
<span class="org-preprocessor">#pragma</span> omp atomic
        sum += 1;
    }

    printf(<span class="org-string">"%d\n"</span>, sum);
}
</pre>
</div>

<pre class="example" id="org000000d">
$&gt; riscv64-linux-gnu-gcc test.c -O0 -g  -fopenmp -c -fno-stack-protector
$&gt; riscv64-linux-gnu-objdump -d -r ./test.o

000000000000005a &lt;main._omp_fn.0&gt;:
  5a:   1101                    addi    sp,sp,-32
  5c:   ec22                    sd      s0,24(sp)
  5e:   1000                    addi    s0,sp,32
  60:   fea43423                sd      a0,-24(s0)
  64:   fe843783                ld      a5,-24(s0)
  68:   639c                    ld      a5,0(a5)
  6a:   4705                    li      a4,1
  6c:   00e7a02f                amoadd.w        zero,a4,(a5)
                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  70:   6462                    ld      s0,24(sp)
  72:   6105                    addi    sp,sp,32
  74:   8082                    ret
</pre>

<p>
`omp atomic` 在 riscv 上实际对应的是 <a href="../riscv/riscv_tutorial.html#ID-c1ffdfa0-c15c-47ae-a7b2-5fdca4e3a53a">AMO</a> 指令
</p>
</div>
</div>

<div id="outline-container-org0000012" class="outline-5">
<h5 id="org0000012"><span class="section-number-5">1.3.2.2.</span> critical</h5>
<div class="outline-text-5" id="text-1-3-2-2">
<div class="org-src-container">
<pre class="src src-C"><span class="org-comment-delimiter">// </span><span class="org-comment">2022-12-05 14:51</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;omp.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
    <span class="org-type">int</span> <span class="org-variable-name">sum</span> = 0;
<span class="org-preprocessor">#pragma</span> omp parallel num_threads(2)
    {
<span class="org-preprocessor">#pragma</span> omp critical
        sum += 1;
    }
    printf(<span class="org-string">"%d\n"</span>, sum);
}
</pre>
</div>

<pre class="example" id="org0000011">
0000000000000062 &lt;main._omp_fn.0&gt;:
  62:   1101                    addi    sp,sp,-32
  64:   ec06                    sd      ra,24(sp)
  66:   e822                    sd      s0,16(sp)
  68:   1000                    addi    s0,sp,32
  6a:   fea43423                sd      a0,-24(s0)
  6e:   00000097                auipc   ra,0x0
                        6e: R_RISCV_CALL_PLT    GOMP_critical_start
                        6e: R_RISCV_RELAX       *ABS*
  72:   000080e7                jalr    ra # 6e &lt;main._omp_fn.0+0xc&gt;
  76:   fe843783                ld      a5,-24(s0)
  7a:   439c                    lw      a5,0(a5)
  7c:   2785                    addiw   a5,a5,1
  7e:   0007871b                sext.w  a4,a5
  82:   fe843783                ld      a5,-24(s0)
  86:   c398                    sw      a4,0(a5)
  88:   00000097                auipc   ra,0x0
                        88: R_RISCV_CALL_PLT    GOMP_critical_end
                        88: R_RISCV_RELAX       *ABS*
  8c:   000080e7                jalr    ra # 88 &lt;main._omp_fn.0+0x26&gt;
  90:   60e2                    ld      ra,24(sp)
  92:   6442                    ld      s0,16(sp)
  94:   6105                    addi    sp,sp,32
  96:   8082                    ret
</pre>

<p>
`omp critical` 对应 `GOMP_critical_start` 和 `GOMP_critical_end`, 后者对应 posix
的 `pthread_mutex_lock` 或者 linux 的 `futex_wait`
</p>
</div>
</div>

<div id="outline-container-org0000019" class="outline-5">
<h5 id="org0000019"><span class="section-number-5">1.3.2.3.</span> barrier</h5>
<div class="outline-text-5" id="text-1-3-2-3">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;omp.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
<span class="org-preprocessor">#pragma</span> omp parallel num_threads(2)
    {
        printf(<span class="org-string">"%d\n"</span>, omp_get_thread_num());
<span class="org-preprocessor">#pragma</span> omp barrier
        printf(<span class="org-string">"%d\n"</span>, omp_get_thread_num());
    }
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<pre class="example" id="org0000015">
0000000000000000 &lt;main._omp_fn.0&gt;:
   0: 1141                    addi    sp,sp,-16
   2: e406                    sd  ra,8(sp)
   4: e022                    sd  s0,0(sp)
   6: 00000097            auipc   ra,0x0
            6: R_RISCV_CALL_PLT   omp_get_thread_num
            6: R_RISCV_RELAX  *ABS*
   a: 000080e7            jalr    ra # 6 &lt;main._omp_fn.0+0x6&gt;
   e: 862a                    mv  a2,a0
  10: 842a                    mv  s0,a0
  12: 00000597            auipc   a1,0x0
            12: R_RISCV_PCREL_HI20    .LC0
            12: R_RISCV_RELAX *ABS*
  16: 00058593            mv  a1,a1
            16: R_RISCV_PCREL_LO12_I  .L0
            16: R_RISCV_RELAX *ABS*
  1a: 4505                    li  a0,1
  1c: 00000097            auipc   ra,0x0
            1c: R_RISCV_CALL_PLT  __printf_chk
            1c: R_RISCV_RELAX *ABS*
  20: 000080e7            jalr    ra # 1c &lt;main._omp_fn.0+0x1c&gt;
  24: 00000097            auipc   ra,0x0
            24: R_RISCV_CALL_PLT  GOMP_barrier
                                  ~~~~~~~~~~~~

            24: R_RISCV_RELAX *ABS*
  28: 000080e7            jalr    ra # 24 &lt;main._omp_fn.0+0x24&gt;
  2c: 8622                    mv  a2,s0
  2e: 6402                    ld  s0,0(sp)
  30: 60a2                    ld  ra,8(sp)
  32: 00000597            auipc   a1,0x0
            32: R_RISCV_PCREL_HI20    .LC0
            32: R_RISCV_RELAX *ABS*
  36: 00058593            mv  a1,a1
            36: R_RISCV_PCREL_LO12_I  .L0
            36: R_RISCV_RELAX *ABS*
  3a: 4505                    li  a0,1
  3c: 0141                    addi    sp,sp,16
  3e: 00000317            auipc   t1,0x0
            3e: R_RISCV_CALL_PLT  __printf_chk
            3e: R_RISCV_RELAX *ABS*
  42: 00030067            jr  t1 # 3e &lt;main._omp_fn.0+0x3e&gt;

</pre>
</div>

<div id="outline-container-org0000016" class="outline-6">
<h6 id="org0000016"><span class="section-number-6">1.3.2.3.1.</span> GOMP_barrier</h6>
<div class="outline-text-6" id="text-1-3-2-3-1">
<p>
GOMP_barrier 需要保证:
</p>

<ol class="org-ol">
<li>插入一个 memory fence</li>

<li>已经执行到 barrier 的线程需要等待其它尚未执行到 barrier 的线程</li>
</ol>

<div class="org-src-container">
<pre class="src src-C"><span class="org-type">void</span> <span class="org-function-name">GOMP_barrier</span>():
  gomp_team_barrier_wait(&amp;team-&gt;barrier);
    <span class="org-function-name">gomp_team_barrier_wait_end</span> (bar, <span class="org-type">gomp_barrier_wait_start</span> (<span class="org-variable-name">bar</span>));

<span class="org-type">gomp_barrier_state_t</span> <span class="org-function-name">gomp_barrier_wait_start</span> (<span class="org-type">gomp_barrier_t</span> *<span class="org-variable-name">bar</span>):
  <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: __atomic_xx &#21518;&#30340; MEMMODEL &#30456;&#24403;&#20110; memory fench</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">unsigned</span> <span class="org-type">int</span> ret = __atomic_load_n (&amp;bar-&gt;generation, MEMMODEL_ACQUIRE);
  ret &amp;= -BAR_INCR | BAR_CANCELLED;
  <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: &#24403; awaited &#20943;&#23567;&#21040; 0 &#26102;, &#24847;&#21619;&#30528;&#26368;&#21518;&#19968;&#20010;&#32447;&#31243;&#21040;&#36798; barrier, &#36825;&#20010;&#24102;&#26377;</span>
<span class="org-comment">   * BAR_WAS_LAST &#26631;&#35760;&#30340;&#32447;&#31243;&#20250;&#36127;&#36131;&#21796;&#37266;&#21069;&#38754;&#31561;&#24453;&#30340;&#32447;&#31243;</span><span class="org-comment-delimiter"> */</span>
  <span class="org-keyword">if</span> (__atomic_add_fetch (&amp;bar-&gt;awaited, -1, MEMMODEL_ACQ_REL) == 0):
    ret |= BAR_WAS_LAST;
  <span class="org-keyword">return</span> ret;

<span class="org-type">void</span> <span class="org-function-name">gomp_team_barrier_wait_end</span> (<span class="org-type">gomp_barrier_t</span> *<span class="org-variable-name">bar</span>, <span class="org-type">gomp_barrier_state_t</span> <span class="org-variable-name">state</span>):
  <span class="org-type">unsigned</span> <span class="org-type">int</span> generation, gen;

<span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: if (__builtin_expect (x, 0)) {xxx} &#30456;&#24403;&#20110; if (x) {xxx}, &#20854;&#20013;&#30340; 0 &#21482;&#26159;&#32473;</span>
<span class="org-comment"> * compiler &#30340; hint, &#21578;&#35785;&#23427; x &#20026; 0 &#30340;&#27010;&#29575;&#36739;&#22823;, &#21487;&#20197;&#35753; compiler &#20135;&#29983;&#26377;&#21033;&#20110; branch</span>
<span class="org-comment"> * prediction &#30340;&#20195;&#30721;</span><span class="org-comment-delimiter"> */</span>
<span class="org-keyword">if</span> (__builtin_expect (state &amp; BAR_WAS_LAST, 0)):
    bar-&gt;awaited = bar-&gt;total;
    team-&gt;work_share_cancelled = 0;
    __atomic_store_n (&amp;bar-&gt;generation, state, MEMMODEL_RELEASE);
    <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: &#22914;&#26524;&#24403;&#21069;&#32447;&#31243;&#26159; BAR_WAS_LAST, &#21017;&#23427;&#20250; wake &#20854;&#23427;&#32447;&#31243;</span><span class="org-comment-delimiter"> */</span>
    <span class="org-function-name">futex_wake</span> ((<span class="org-type">int</span> *) &amp;bar-&gt;generation, INT_MAX);
    <span class="org-keyword">return</span>;

generation = state;
state &amp;= ~BAR_CANCELLED;
<span class="org-keyword">do</span>:
  <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: &#38750; BAR_WAS_LAST &#30340;&#32447;&#31243;&#20250;&#31561;&#24453; BAR_WAS_LAST &#32447;&#31243;&#30340; wake</span><span class="org-comment-delimiter"> */</span>
  do_wait ((<span class="org-type">int</span> *) &amp;bar-&gt;generation, generation);
  gen = __atomic_load_n (&amp;bar-&gt;generation, MEMMODEL_ACQUIRE);
  <span class="org-keyword">if</span> (__builtin_expect (gen &amp; BAR_TASK_PENDING, 0)):
    gomp_barrier_handle_tasks (state);
    gen = __atomic_load_n (&amp;bar-&gt;generation, MEMMODEL_ACQUIRE);

  generation |= gen &amp; BAR_WAITING_FOR_TASK;
<span class="org-keyword">while</span> (gen != state + BAR_INCR);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org0000020" class="outline-5">
<h5 id="org0000020"><span class="section-number-5">1.3.2.4.</span> single</h5>
<div class="outline-text-5" id="text-1-3-2-4">
<p>
single 要求只有一个线程能执行相应代码, 但并没有要求是哪一个线程
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;omp.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
<span class="org-preprocessor">#pragma</span> omp parallel num_threads(2)
    {
<span class="org-preprocessor">#pragma</span> omp single
        { printf(<span class="org-string">"single %d\n"</span>, omp_get_thread_num()); }
        printf(<span class="org-string">"single %d\n"</span>, omp_get_thread_num());
    }
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<pre class="example" id="org000001c">
0000000000000000 &lt;main._omp_fn.0&gt;:
   0:   1101                    addi    sp,sp,-32
   2:   ec06                    sd  ra,24(sp)
   4:   e822                    sd  s0,16(sp)
   6:   e426                    sd  s1,8(sp)
   8:   00000097            auipc   ra,0x0
            8: R_RISCV_CALL_PLT GOMP_single_start
                                ~~~~~~~~~~~~~~~~~

            8: R_RISCV_RELAX  *ABS*
   c: 000080e7            jalr    ra # 8 &lt;main._omp_fn.0+0x8&gt;
  10: 84aa                    mv  s1,a0
  12: 00000097            auipc   ra,0x0
            12: R_RISCV_CALL_PLT  omp_get_thread_num
            12: R_RISCV_RELAX *ABS*
  16: 000080e7            jalr    ra # 12 &lt;main._omp_fn.0+0x12&gt;
  1a: 842a                    mv  s0,a0
  1c: e09d                    bnez    s1,42 &lt;.L2&gt;
            1c: R_RISCV_RVC_BRANCH    .L2

000000000000001e &lt;.L3&gt;:
  1e: 00000097            auipc   ra,0x0
            1e: R_RISCV_CALL_PLT  GOMP_barrier
                                  ~~~~~~~~~~~~
                                  single 后有一个隐式的 barrier

            1e: R_RISCV_RELAX *ABS*
  22: 000080e7            jalr    ra # 1e &lt;.L3&gt;
  26: 8622                    mv  a2,s0
  28: 6442                    ld  s0,16(sp)
  2a: 60e2                    ld  ra,24(sp)
  2c: 64a2                    ld  s1,8(sp)
  2e: 00000597            auipc   a1,0x0
            2e: R_RISCV_PCREL_HI20    .LC0
            2e: R_RISCV_RELAX *ABS*
  32: 00058593            mv  a1,a1
            32: R_RISCV_PCREL_LO12_I  .L0
            32: R_RISCV_RELAX *ABS*
  36: 4505                    li  a0,1
  38: 6105                    addi    sp,sp,32
  3a: 00000317            auipc   t1,0x0
            3a: R_RISCV_CALL_PLT  __printf_chk
            3a: R_RISCV_RELAX *ABS*
  3e: 00030067            jr  t1 # 3a &lt;.L3+0x1c&gt;

0000000000000042 &lt;.L2&gt;:
  42: 862a                    mv  a2,a0
  44: 00000597            auipc   a1,0x0
            44: R_RISCV_PCREL_HI20    .LC0
            44: R_RISCV_RELAX *ABS*
  48: 00058593            mv  a1,a1
            48: R_RISCV_PCREL_LO12_I  .L0
            48: R_RISCV_RELAX *ABS*
  4c: 4505                    li  a0,1
  4e: 00000097            auipc   ra,0x0
            4e: R_RISCV_CALL_PLT  __printf_chk
            4e: R_RISCV_RELAX *ABS*
  52: 000080e7            jalr    ra # 4e &lt;.L2+0xc&gt;
  56: b7e1                    j   1e &lt;.L3&gt;
            56: R_RISCV_RVC_JUMP  .L3

</pre>
</div>

<div id="outline-container-org000001d" class="outline-6">
<h6 id="org000001d"><span class="section-number-6">1.3.2.4.1.</span> GOMP_single_start</h6>
<div class="outline-text-6" id="text-1-3-2-4-1">
<div class="org-src-container">
<pre class="src src-C"><span class="org-type">bool</span> <span class="org-function-name">GOMP_single_start</span>(<span class="org-type">void</span>):
  <span class="org-keyword">struct</span> gomp_thread *thr = gomp_thread();
  <span class="org-keyword">struct</span> <span class="org-type">gomp_team</span> *<span class="org-variable-name">team</span> = thr-&gt;ts.team;
  <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">single_count</span>;

  <span class="org-keyword">if</span> (__builtin_expect(team == <span class="org-constant">NULL</span>, 0)) <span class="org-keyword">return</span> <span class="org-constant">true</span>;

  single_count = thr-&gt;ts.single_count++;
  <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: __sync_bool_compare_and_swap (a,b,c) &#30340;&#25805;&#20316;&#26159;: &#27604;&#36739; a, b, &#33509;&#30456;&#31561;, &#21017;</span>
<span class="org-comment">   * &#25226; c &#36171;&#32473;a, &#24182;&#36820;&#22238; true, &#19988;&#25972;&#20010;&#36807;&#31243;&#26159;&#21407;&#23376;&#25805;&#20316;.</span>
<span class="org-comment">   *</span>
<span class="org-comment">   * N &#20010;&#32447;&#31243;&#31454;&#20105;, &#21482;&#26377;&#19968;&#20010;&#20250;&#32988;&#20986;. &#20294;&#19981;&#35770;&#26159;&#21542;&#32988;&#20986; ,&#25152;&#26377;&#32447;&#31243;&#30340; single_count &#20197;&#21450;</span>
<span class="org-comment">   * team &#30340; single_count &#37117;&#20250;&#21152; 1, &#20197;&#20415;&#33021;&#20849;&#21516;&#31454;&#20105;&#19979;&#19968;&#19979; single, &#25152;&#20197; single &#19981;</span>
<span class="org-comment">   * &#20250;&#22266;&#23450;&#32473;&#26576;&#19968;&#20010;&#32447;&#31243;&#25191;&#34892;</span><span class="org-comment-delimiter"> */</span>
  <span class="org-keyword">return</span> __sync_bool_compare_and_swap(
        &amp;team-&gt;single_count, single_count, single_count + 1L);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org0000024" class="outline-5">
<h5 id="org0000024"><span class="section-number-5">1.3.2.5.</span> master</h5>
<div class="outline-text-5" id="text-1-3-2-5">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;omp.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
<span class="org-preprocessor">#pragma</span> omp parallel num_threads(2)
    {
<span class="org-preprocessor">#pragma</span> omp master
        { printf(<span class="org-string">"%d\n"</span>, omp_get_thread_num()); }
        printf(<span class="org-string">"%d\n"</span>, omp_get_thread_num());
    }
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<pre class="example" id="org0000023">
0000000000000000 &lt;main._omp_fn.0&gt;:
   0: 1141                    addi    sp,sp,-16
   2: e022                    sd  s0,0(sp)
   4: e406                    sd  ra,8(sp)
   6: 00000097            auipc   ra,0x0
            6: R_RISCV_CALL_PLT   omp_get_thread_num
            6: R_RISCV_RELAX  *ABS*
   a: 000080e7            jalr    ra # 6 &lt;main._omp_fn.0+0x6&gt;
   e: 842a                    mv  s0,a0
  10: cd11                    beqz    a0,2c &lt;.L2&gt;
                              ~~~~~~~~~~~~~~~~~~~~
                              由于 master 只能由主线程执行, 所以这里简单判断 omp_get_thread_num 是否
                              为 0 即可, 不需要像 single 那样有复杂的同步操作

            10: R_RISCV_RVC_BRANCH    .L2
  12: 8622                    mv  a2,s0
  14: 6402                    ld  s0,0(sp)
  16: 60a2                    ld  ra,8(sp)
  18: 00000597            auipc   a1,0x0
            18: R_RISCV_PCREL_HI20    .LC0
            18: R_RISCV_RELAX *ABS*
  1c: 00058593            mv  a1,a1
            1c: R_RISCV_PCREL_LO12_I  .L0
            1c: R_RISCV_RELAX *ABS*
  20: 4505                    li  a0,1
  22: 0141                    addi    sp,sp,16
  24: 00000317            auipc   t1,0x0
            24: R_RISCV_CALL_PLT  __printf_chk
            24: R_RISCV_RELAX *ABS*
  28: 00030067            jr  t1 # 24 &lt;main._omp_fn.0+0x24&gt;

000000000000002c &lt;.L2&gt;:
  2c: 4601                    li  a2,0
  2e: 00000597            auipc   a1,0x0
            2e: R_RISCV_PCREL_HI20    .LC0
            2e: R_RISCV_RELAX *ABS*
  32: 00058593            mv  a1,a1
            32: R_RISCV_PCREL_LO12_I  .L0
            32: R_RISCV_RELAX *ABS*
  36: 4505                    li  a0,1
  38: 00000097            auipc   ra,0x0
            38: R_RISCV_CALL_PLT  __printf_chk
            38: R_RISCV_RELAX *ABS*
  3c: 000080e7            jalr    ra # 38 &lt;.L2+0xc&gt;
  40: 8622                    mv  a2,s0
  42: 6402                    ld  s0,0(sp)
  44: 60a2                    ld  ra,8(sp)
  46: 00000597            auipc   a1,0x0
            46: R_RISCV_PCREL_HI20    .LC0
            46: R_RISCV_RELAX *ABS*
  4a: 00058593            mv  a1,a1
            4a: R_RISCV_PCREL_LO12_I  .L0
            4a: R_RISCV_RELAX *ABS*
  4e: 4505                    li  a0,1
  50: 0141                    addi    sp,sp,16
  52: 00000317            auipc   t1,0x0
            52: R_RISCV_CALL_PLT  __printf_chk
            52: R_RISCV_RELAX *ABS*
  56: 00030067            jr  t1 # 52 &lt;.L2+0x26&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-org0000039" class="outline-4">
<h4 id="org0000039"><span class="section-number-4">1.3.3.</span> for</h4>
<div class="outline-text-4" id="text-1-3-3">
</div>
<div id="outline-container-org000002b" class="outline-5">
<h5 id="org000002b"><span class="section-number-5">1.3.3.1.</span> static schedule</h5>
<div class="outline-text-5" id="text-1-3-3-1">
<div class="org-src-container">
<pre class="src src-C"><span class="org-comment-delimiter">// </span><span class="org-comment">2022-12-05 14:51</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;omp.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
    <span class="org-type">int</span> <span class="org-variable-name">sum</span> = 0;
<span class="org-preprocessor">#pragma</span> omp parallel <span class="org-keyword">for</span> num_threads(2)
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 10; i++) {
        printf(<span class="org-string">"%d\n"</span>, i);
    }
    printf(<span class="org-string">"%d\n"</span>, sum);
}
</pre>
</div>

<p>
默认情况下 `omp for` 使用 `schedule (static, N/num_threads)`, work sharing 是静态的, 由编译器直接完成
</p>

<pre class="example" id="org000002a">
$&gt; riscv64-linux-gnu-gcc test.c -O2  -fopenmp -c -fno-stack-protector
$&gt; riscv64-linux-gnu-objdump -d -r ./test.o

0000000000000000 &lt;main._omp_fn.0&gt;:
   0: 1101                    addi    sp,sp,-32
   2: ec06                    sd  ra,24(sp)
   4: e822                    sd  s0,16(sp)
   6: e426                    sd  s1,8(sp)
   8: e04a                    sd  s2,0(sp)
   a: 00000097            auipc   ra,0x0
            a: R_RISCV_CALL   omp_get_num_threads
            a: R_RISCV_RELAX  *ABS*
   e: 000080e7            jalr    ra # a &lt;main._omp_fn.0+0xa&gt;
  12: 842a                    mv  s0,a0
  14: 00000097            auipc   ra,0x0
            14: R_RISCV_CALL  omp_get_thread_num
            14: R_RISCV_RELAX *ABS*
  18: 000080e7            jalr    ra # 14 &lt;main._omp_fn.0+0x14&gt;
  1c: 47a9                    li  a5,10
  1e: 0287e73b            remw    a4,a5,s0
  22: 0287c6bb            divw    a3,a5,s0
                          ~~~~~~~~~~~~~~~~
                          a3=10/(omp_get_num_threads()), a3 表示 schedcule(static, step) 中的 step

  26: 02e54c63            blt a0,a4,5e &lt;.L2&gt;
                          ~~~~~~~~~~~~~~~~~~
                          如果 step 不能整除, 会把多余的部分平摊到前面的 thread, 例如 10%4=2, 则 4 线程分到的任务为 3,3,2,2

            26: R_RISCV_BRANCH    .L2

000000000000002a &lt;.L5&gt;:
  2a: 02a684bb            mulw    s1,a3,a0
                          ~~~~~~~~~~~~~~~~
                          a0 是 omp_get_thread_num(), s1 表示 begin=omp_get_thread_num()*step

  2e: 00e4843b            addw    s0,s1,a4
  32: 00d404bb            addw    s1,s0,a3
                          ~~~~~~~~~~~~~~~~
                          s0 是 begin, s1 是 begin+step, 即 end, 当前 thread 处理的范围是 [s0, s1]

  36: 00945e63            bge s0,s1,52 &lt;.L1&gt;
            36: R_RISCV_BRANCH    .L1
  3a: 00000937            lui s2,0x0
            3a: R_RISCV_HI20  .LC0
            3a: R_RISCV_RELAX *ABS*

000000000000003e &lt;.L4&gt;:
  3e: 85a2                    mv  a1,s0
  40: 00090513            mv  a0,s2
            40: R_RISCV_LO12_I    .LC0
            40: R_RISCV_RELAX *ABS*
  44: 2405                    addiw   s0,s0,1
  46: 00000097            auipc   ra,0x0
            46: R_RISCV_CALL  printf
            46: R_RISCV_RELAX *ABS*
  4a: 000080e7            jalr    ra # 46 &lt;.L4+0x8&gt;
  4e: fe8498e3            bne s1,s0,3e &lt;.L4&gt;
            4e: R_RISCV_BRANCH    .L4
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.L4 对应的代码是 for (i=start; i&lt;end; i++) {printf("%d\n",i);}

0000000000000052 &lt;.L1&gt;:
  52: 60e2                    ld  ra,24(sp)
  54: 6442                    ld  s0,16(sp)
  56: 64a2                    ld  s1,8(sp)
  58: 6902                    ld  s2,0(sp)
  5a: 6105                    addi    sp,sp,32
  5c: 8082                    ret

000000000000005e &lt;.L2&gt;:
  5e: 2685                    addiw   a3,a3,1
  60: 4701                    li  a4,0
  62: b7e1                    j   2a &lt;.L5&gt;
            62: R_RISCV_RVC_JUMP  .L5
</pre>
</div>
</div>

<div id="outline-container-org0000032" class="outline-5">
<h5 id="org0000032"><span class="section-number-5">1.3.3.2.</span> dynamic schedule</h5>
<div class="outline-text-5" id="text-1-3-3-2">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;omp.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
    <span class="org-type">int</span> <span class="org-variable-name">sum</span> = 0;
<span class="org-preprocessor">#pragma</span> omp parallel <span class="org-keyword">for</span> num_threads(2) schedule(dynamic, 1)
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 10; i++) {
        printf(<span class="org-string">"%d\n"</span>, i);
    }
}
</pre>
</div>

<pre class="example" id="org000002e">
0000000000000000 &lt;main&gt;:
   0: 00000537            lui a0,0x0
            0: R_RISCV_HI20   main._omp_fn.0
            0: R_RISCV_RELAX  *ABS*
   4: 1141                    addi    sp,sp,-16
   6: 4881                    li  a7,0
   8: 4805                    li  a6,1
   a: 4785                    li  a5,1
   c: 4729                    li  a4,10
   e: 4681                    li  a3,0
  10: 4609                    li  a2,2
  12: 4581                    li  a1,0
  14: 00050513            mv  a0,a0
            14: R_RISCV_LO12_I    main._omp_fn.0
            14: R_RISCV_RELAX *ABS*
  18: e406                    sd  ra,8(sp)
  1a: 00000097            auipc   ra,0x0
            1a: R_RISCV_CALL  GOMP_parallel_loop_nonmonotonic_dynamic
                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                              设置 dynmic schedule 的参数, 例如 chunk size (1)

            1a: R_RISCV_RELAX *ABS*
  1e: 000080e7            jalr    ra # 1a &lt;main+0x1a&gt;


0000000000000000 &lt;main._omp_fn.0&gt;:
   0: 7179                    addi    sp,sp,-48
   2: 002c                    addi    a1,sp,8
   4: 850a                    mv  a0,sp
   6: f406                    sd  ra,40(sp)
   8: f022                    sd  s0,32(sp)
   a: ec26                    sd  s1,24(sp)
   c: e84a                    sd  s2,16(sp)
   e: 00000097            auipc   ra,0x0
            e: R_RISCV_CALL   GOMP_loop_nonmonotonic_dynamic_next
            e: R_RISCV_RELAX  *ABS*
  12: 000080e7            jalr    ra # e &lt;main._omp_fn.0+0xe&gt;
  16: c515                    beqz    a0,42 &lt;.L2&gt;
            16: R_RISCV_RVC_BRANCH    .L2
  18: 00000937            lui s2,0x0
            18: R_RISCV_HI20  .LC0
            18: R_RISCV_RELAX *ABS*

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.L4, .L3 的代码相当于:
while (GOMP_loop_nonmonotonic_dynamic_next(*start,*end)) {
      for (i=start;i&lt;end;i++) {
          printf("%d\n",i);
      }
}


000000000000001c &lt;.L4&gt;:
  1c: 4402                    lw  s0,0(sp)
  1e: 44a2                    lw  s1,8(sp)
                              ~~~~~~~~~~~~
                              s0 是 start, s1 是 end, 由于 GOMP_loop_nonmonotonic_dynamic_next 的参数是 (*start,*end)
                              所以它使用栈来传递参数

0000000000000020 &lt;.L3&gt;:
  20: 85a2                    mv  a1,s0
  22: 00090513            mv  a0,s2
            22: R_RISCV_LO12_I    .LC0
            22: R_RISCV_RELAX *ABS*
  26: 2405                    addiw   s0,s0,1
  28: 00000097            auipc   ra,0x0
            28: R_RISCV_CALL  printf
            28: R_RISCV_RELAX *ABS*
  2c: 000080e7            jalr    ra # 28 &lt;.L3+0x8&gt;
  30: fe9448e3            blt s0,s1,20 &lt;.L3&gt;
                          ~~~~~~~~~~~~~~~~~~~
                          .L3 对应内层的 for (i=start;i&lt;end;i++) {xxx} 循环

            30: R_RISCV_BRANCH    .L3
  34: 002c                    addi    a1,sp,8
                              ~~~~~~~~~~~~~~~ end 的地址
  36: 850a                    mv  a0,sp
                              ~~~~~~~~~ start 的地址

  38: 00000097            auipc   ra,0x0
            38: R_RISCV_CALL  GOMP_loop_nonmonotonic_dynamic_next
            38: R_RISCV_RELAX *ABS*
  3c: 000080e7            jalr    ra # 38 &lt;.L3+0x18&gt;
  40: fd71                    bnez    a0,1c &lt;.L4&gt;
            40: R_RISCV_RVC_BRANCH    .L4
                                     ~~~~~
                                     .L4 对应外层的 while (GOMP_loop_nonmonotonic_dynamic_next(*start,*end) 循环

</pre>

<p>
可见 dynamic schedule 有额外的运行时开销
</p>
</div>

<div id="outline-container-org000002f" class="outline-6">
<h6 id="org000002f"><span class="section-number-6">1.3.3.2.1.</span> GOMP_loop_nonmonotonic_dynamic_next</h6>
<div class="outline-text-6" id="text-1-3-3-2-1">
<div class="org-src-container">
<pre class="src src-C"><span class="org-type">bool</span> <span class="org-function-name">GOMP_loop_nonmonotonic_dynamic_next</span>(<span class="org-type">long</span> *<span class="org-variable-name">istart</span>, <span class="org-type">long</span> *<span class="org-variable-name">iend</span>)
  <span class="org-keyword">return</span> gomp_loop_dynamic_next (istart, iend);
    <span class="org-keyword">return</span> gomp_iter_dynamic_next (istart, iend);
      <span class="org-type">long</span> <span class="org-variable-name">tmp</span> = __sync_fetch_and_add (&amp;ws-&gt;next, chunk);
      <span class="org-keyword">if</span> (tmp &gt;= end) <span class="org-keyword">return</span> <span class="org-constant">false</span>;
      nend = tmp + chunk;
      <span class="org-keyword">if</span> (nend &gt; end) nend = end;
      *pstart = tmp;
      *pend = nend;
      <span class="org-keyword">return</span> <span class="org-constant">true</span>;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org0000036" class="outline-5">
<h5 id="org0000036"><span class="section-number-5">1.3.3.3.</span> reduction</h5>
<div class="outline-text-5" id="text-1-3-3-3">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;omp.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
    <span class="org-type">int</span> <span class="org-variable-name">sum</span> = 0;
<span class="org-preprocessor">#pragma</span> omp parallel <span class="org-keyword">for</span> reduction(+ : sum) num_threads(2)
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 10; i++) {
        sum += i;
    }
    printf(<span class="org-string">"%d\n"</span>, sum);
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<pre class="example" id="org0000035">
0000000000000000 &lt;main._omp_fn.0&gt;:
   0: 1101                    addi    sp,sp,-32
   2: ec06                    sd  ra,24(sp)
   4: e822                    sd  s0,16(sp)
   6: e426                    sd  s1,8(sp)
   8: 842a                    mv  s0,a0
   a: 00000097            auipc   ra,0x0
            a: R_RISCV_CALL_PLT   omp_get_num_threads
            a: R_RISCV_RELAX  *ABS*
   e: 000080e7            jalr    ra # a &lt;main._omp_fn.0+0xa&gt;
  12: 84aa                    mv  s1,a0
  14: 00000097            auipc   ra,0x0
            14: R_RISCV_CALL_PLT  omp_get_thread_num
            14: R_RISCV_RELAX *ABS*
  18: 000080e7            jalr    ra # 14 &lt;main._omp_fn.0+0x14&gt;
  1c: 46a9                    li  a3,10
  1e: 0296e63b            remw    a2,a3,s1
  22: 87aa                    mv  a5,a0
  24: 0296c5bb            divw    a1,a3,s1
  28: 02c54e63            blt a0,a2,64 &lt;.L2&gt;
            28: R_RISCV_BRANCH    .L2

000000000000002c &lt;.L5&gt;:
  2c: 4681                    li  a3,0
  2e: 02f5873b            mulw    a4,a1,a5
  32: 00c707bb            addw    a5,a4,a2
  36: 00b7873b            addw    a4,a5,a1
                          ~~~~~~~~~~~~~~~~
                          当前线程要处理的范围是 [a5, a4]

  3a: 00e7c963            blt a5,a4,4c &lt;.L4&gt;
            3a: R_RISCV_BRANCH    .L4
  3e: 00d4202f            amoadd.w    zero,a3,(s0)
                          ~~~~~~~~~~~~~~~~~~~~~~~~
                          线程处理完以后把 a3 (当前线程的 partial sum 累加到 (s0)

  42: 60e2                    ld  ra,24(sp)
  44: 6442                    ld  s0,16(sp)
  46: 64a2                    ld  s1,8(sp)
  48: 6105                    addi    sp,sp,32
  4a: 8082                    ret

000000000000004c &lt;.L4&gt;:
  4c: 9ebd                    addw    a3,a3,a5
  4e: 2785                    addiw   a5,a5,1
                              ~~~~~~~~~~~~~~~~
                              a3 是 partial sum, 不断的累加 a5 (i)

  50:	fef71ee3          	bne	a4,a5,4c &lt;.L4&gt;

            50: R_RISCV_BRANCH	.L4
  54:	2681                	sext.w	a3,a3
  56:	00d4202f          	amoadd.w	zero,a3,(s0)
  5a:	60e2                	ld	ra,24(sp)
  5c:	6442                	ld	s0,16(sp)
  5e:	64a2                	ld	s1,8(sp)
  60:	6105                	addi	sp,sp,32
  62:	8082                	ret

0000000000000064 &lt;.L2&gt;:
  64:	2585                	addiw	a1,a1,1
  66:	4601                	li	a2,0
  68:	b7d1                	j	2c &lt;.L5&gt;
            68: R_RISCV_RVC_JUMP	.L5

</pre>

<p>
reduction 的代码是由编译器直接生成的, 不需要调用 libgomp. 生成的代码和手写的不用
reduction 的代码 (例如 hello_openmp 中的 pi_parallel_for) 基本相同
</p>
</div>
</div>
</div>

<div id="outline-container-org0000040" class="outline-4">
<h4 id="org0000040"><span class="section-number-4">1.3.4.</span> task</h4>
<div class="outline-text-4" id="text-1-3-4">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;omp.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
<span class="org-preprocessor">#pragma</span> omp parallel num_threads(2)
    {
<span class="org-preprocessor">#pragma</span> omp single
        {
<span class="org-preprocessor">#pragma</span> omp task
            printf(<span class="org-string">"%d\n"</span>, omp_get_thread_num());
<span class="org-preprocessor">#pragma</span> omp task
            printf(<span class="org-string">"%d\n"</span>, omp_get_thread_num());
        }
    }
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<pre class="example" id="org000003c">
0000000000000014 &lt;.L6&gt;:
  14:	4881                	li	a7,0
  16:	4801                	li	a6,0
  18:	4785                	li	a5,1
  1a:	4705                	li	a4,1
  1c:	4681                	li	a3,0
  1e:	4601                	li	a2,0
  20:	4581                	li	a1,0
  22:	00000517          	auipc	a0,0x0
            22: R_RISCV_PCREL_HI20	main._omp_fn.1
            22: R_RISCV_RELAX	*ABS*
  26:	00050513          	mv	a0,a0
            26: R_RISCV_PCREL_LO12_I	.L0
            26: R_RISCV_RELAX	*ABS*
  2a:	e002                	sd	zero,0(sp)
  2c:	00000097          	auipc	ra,0x0
            2c: R_RISCV_CALL_PLT	GOMP_task
                                    ~~~~~~~~~
                                    GOMP_task(main._omp_fn.1)

            2c: R_RISCV_RELAX	*ABS*
  30:	000080e7          	jalr	ra # 2c &lt;.L6+0x18&gt;
  34:	4881                	li	a7,0
  36:	e002                	sd	zero,0(sp)
  38:	4801                	li	a6,0
  3a:	4785                	li	a5,1
  3c:	4705                	li	a4,1
  3e:	4681                	li	a3,0
  40:	4601                	li	a2,0
  42:	4581                	li	a1,0
  44:	00000517          	auipc	a0,0x0
            44: R_RISCV_PCREL_HI20	main._omp_fn.2
            44: R_RISCV_RELAX	*ABS*
  48:	00050513          	mv	a0,a0
            48: R_RISCV_PCREL_LO12_I	.L0
            48: R_RISCV_RELAX	*ABS*
  4c:	00000097          	auipc	ra,0x0
            4c: R_RISCV_CALL_PLT	GOMP_task
                                    ~~~~~~~~~
                                    GOMP_task(main._omp_fn.1)

            4c: R_RISCV_RELAX	*ABS*
  50:	000080e7          	jalr	ra # 4c &lt;.L6+0x38&gt;
  54:	60e2                	ld	ra,24(sp)
  56:	6105                	addi	sp,sp,32
  58:	8082                	ret

000000000000005a &lt;main._omp_fn.1&gt;:
  5a:	1141                	addi	sp,sp,-16
  5c:	e406                	sd	ra,8(sp)
  5e:	00000097          	auipc	ra,0x0
            5e: R_RISCV_CALL_PLT	omp_get_thread_num
            5e: R_RISCV_RELAX	*ABS*
  62:	000080e7          	jalr	ra # 5e &lt;main._omp_fn.1+0x4&gt;
  66:	60a2                	ld	ra,8(sp)
  68:	862a                	mv	a2,a0
  6a:	00000597          	auipc	a1,0x0
            6a: R_RISCV_PCREL_HI20	.LC0
            6a: R_RISCV_RELAX	*ABS*
  6e:	00058593          	mv	a1,a1
            6e: R_RISCV_PCREL_LO12_I	.L0
            6e: R_RISCV_RELAX	*ABS*
  72:	4505                	li	a0,1
  74:	0141                	addi	sp,sp,16
  76:	00000317          	auipc	t1,0x0
            76: R_RISCV_CALL_PLT	__printf_chk
            76: R_RISCV_RELAX	*ABS*
  7a:	00030067          	jr	t1 # 76 &lt;main._omp_fn.1+0x1c&gt;

000000000000007e &lt;main._omp_fn.2&gt;:
  7e:	00000317          	auipc	t1,0x0
            7e: R_RISCV_CALL	main._omp_fn.1
            7e: R_RISCV_RELAX	*ABS*
  82:	00030067          	jr	t1 # 7e &lt;main._omp_fn.2&gt;
</pre>

<p>
每个 task 对应一个单独的 main._omp_fn.x, 通过 GOMP_task 放在某个线程里执行
</p>
</div>

<div id="outline-container-org000003d" class="outline-5">
<h5 id="org000003d"><span class="section-number-5">1.3.4.1.</span> GOMP_task</h5>
<div class="outline-text-5" id="text-1-3-4-1">
<div class="org-src-container">
<pre class="src src-C"><span class="org-type">void</span> <span class="org-function-name">GOMP_task</span>(
    <span class="org-type">void</span> (*<span class="org-function-name">fn</span>)(<span class="org-type">void</span> *), <span class="org-type">void</span> *<span class="org-variable-name">data</span>, <span class="org-type">void</span> (*<span class="org-function-name">cpyfn</span>)(<span class="org-type">void</span> *, <span class="org-type">void</span> *),
    <span class="org-type">long</span> <span class="org-variable-name">arg_size</span>, <span class="org-type">long</span> <span class="org-variable-name">arg_align</span>, <span class="org-type">bool</span> <span class="org-variable-name">if_clause</span>, <span class="org-type">unsigned</span> <span class="org-variable-name">flags</span>,
    <span class="org-type">void</span> **<span class="org-variable-name">depend</span>, <span class="org-type">int</span> <span class="org-variable-name">priority_arg</span>, <span class="org-type">void</span> *<span class="org-variable-name">detach</span>):
  priority_queue_insert (PQ_TEAM, &amp;team-&gt;task_queue,
        task, priority,
        PRIORITY_INSERT_END,
        <span class="org-comment-delimiter">/*</span><span class="org-comment">adjust_parent_depends_on=</span><span class="org-comment-delimiter">*/</span><span class="org-constant">false</span>,
        task-&gt;parent_depends_on);
  gomp_team_barrier_set_task_pending (&amp;team-&gt;barrier);
  do_wake = team-&gt;task_running_count + <span class="org-negation-char">!</span>parent-&gt;in_tied_task &lt; team-&gt;nthreads;
  <span class="org-keyword">if</span> (do_wake) gomp_team_barrier_wake (&amp;team-&gt;barrier, 1);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org000004b" class="outline-4">
<h4 id="org000004b"><span class="section-number-4">1.3.5.</span> target</h4>
<div class="outline-text-4" id="text-1-3-5">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;omp.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>
<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">x</span> = 1;
<span class="org-preprocessor">#pragma</span> omp target map(tofrom : x)
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 10; i++) {
        x += i;
    }
    printf(<span class="org-string">"x = %d\n"</span>, x);
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<p>
openmp 从 4.0 开始支持 offload 到不同的 target, 例如 nvptx 和 amd gcn.
</p>

<p>
offload 过程与 <a href="../dpcpp.html#ID-20a0a544-85db-4e76-82bc-7c7fb7dc0d20">DPC++</a>, <a href="../tvm/tvm_byoc_codegen.html#ID-c41f9aeb-2da9-4550-8b0d-c2e34b67c932">TVM BYOC Codegen</a> 以及 <a href="https://github.com/sunwayforever/code/tree/master/hello_world/hello_sycl">ComputeCpp</a> 类似, 以 nvptx 为例, 主要步骤是:
</p>

<ol class="org-ol">
<li>gcc 编译出 block 对应的 ptx 汇编</li>

<li>使用 mkoffload 生成一个头文件, 它会包含 ptx 汇编, 用于注册的初始化函数以及一些 mapping 信息, 确保运行时 gomp 可以找到对应的 ptx 并调用 cuda 去编译和执行它. 这个头文件与 ComputeCpp 生成的 <a href="https://github.com/sunwayforever/code/blob/92bb25dd6cdbfd13570e3f4c758cc27e74b3583b/hello_world/hello_sycl/Makefile#L24">sycl</a> 文件类似</li>
</ol>
</div>

<div id="outline-container-org0000044" class="outline-5">
<h5 id="org0000044"><span class="section-number-5">1.3.5.1.</span> GOMP_offload_register_ver</h5>
<div class="outline-text-5" id="text-1-3-5-1">
<p>
GOMP_offload_register_ver 负责向 runtime 注册 offload 相关的信息
</p>

<p>
通过 `&#x2013;save-temps` 可以看到这个生成的 offload 头文件:
</p>

<pre class="example" id="org0000043">
$&gt; gcc test.c -O0 -fopenmp -fcf-protection=none -foffload=-misa=sm_35 -fno-stack-protector --save-temps
$&gt; cat ccuL4e4U.i

static const char ptx_code_0[] =
 "// BEGIN PREAMBLE\n"
 ".version 3.1\n"
 ".target sm_35\n"
 ".address_size 64\n"
 "// BEGIN FUNCTION DECL: main$_omp_fn$0$impl\n"
 ".func main$_omp_fn$0$impl (.param .u64 %in_ar0);\n"
 "// BEGIN GLOBAL FUNCTION DECL: gomp_nvptx_main\n"
 ".extern .func gomp_nvptx_main (.param .u64 %in_ar1, .param .u64 %in_ar2);\n"
 "// BEGIN GLOBAL VAR DECL: __nvptx_stacks\n"
 ".extern .shared .u64 __nvptx_stacks[32];\n"
 "// BEGIN GLOBAL VAR DECL: __nvptx_uni\n"
 ".extern .shared .u32 __nvptx_uni[32];\n"
 "// END PREAMBLE\n"
 ".visible .entry main$_omp_fn$0 (.param .u64 %arg, .param .u64 %stack, .param .u64 %sz)\n"
 "{\n"
 ".reg .u32 %r&lt;3&gt;;\n"
 ".reg .u64 %R&lt;4&gt;;\n"
        /* ... */
 "mov.u32 %r0,%tid.y;\n"
        /* ... */
static const char ptx_code_19[] = ""  /* ... */

static const struct ptx_obj {
  const char *code;
  long unsigned int size;
} ptx_objs[] = {
 {ptx_code_0, sizeof (ptx_code_0)},
 {ptx_code_1, sizeof (ptx_code_1)},
 {ptx_code_2, sizeof (ptx_code_2)},
 {ptx_code_3, sizeof (ptx_code_3)},
 {ptx_code_4, sizeof (ptx_code_4)},
 {ptx_code_5, sizeof (ptx_code_5)},
 {ptx_code_6, sizeof (ptx_code_6)},
 {ptx_code_7, sizeof (ptx_code_7)},
 {ptx_code_8, sizeof (ptx_code_8)},
 {ptx_code_9, sizeof (ptx_code_9)},
 {ptx_code_10, sizeof (ptx_code_10)},
 {ptx_code_11, sizeof (ptx_code_11)},
 {ptx_code_12, sizeof (ptx_code_12)},
 {ptx_code_13, sizeof (ptx_code_13)},
 {ptx_code_14, sizeof (ptx_code_14)},
 {ptx_code_15, sizeof (ptx_code_15)},
 {ptx_code_16, sizeof (ptx_code_16)},
 {ptx_code_17, sizeof (ptx_code_17)},
 {ptx_code_18, sizeof (ptx_code_18)},
 {ptx_code_19, sizeof (ptx_code_19)}
};

static const char *const var_mappings[] = {
};

static const struct nvptx_fn {
  const char *name;
  unsigned short dim[3];
} func_mappings[] = {

 {"main$_omp_fn$0"}
};

static const struct nvptx_tdata {
  const struct ptx_obj *ptx_objs;
  unsigned ptx_num;
  const char *const *var_names;
  unsigned var_num;
  const struct nvptx_fn *fn_names;
  unsigned fn_num;
} target_data = {
  ptx_objs, sizeof (ptx_objs) / sizeof (ptx_objs[0]),
  var_mappings, sizeof (var_mappings) / sizeof (var_mappings[0]),
  func_mappings, sizeof (func_mappings) / sizeof (func_mappings[0])
};

extern void GOMP_offload_register_ver (unsigned, const void *, int, const void *);
extern void GOMP_offload_unregister_ver (unsigned, const void *, int, const void *);

extern const void *const __OFFLOAD_TABLE__[];

static __attribute__((constructor)) void init (void)
{
  GOMP_offload_register_ver (0x10001, __OFFLOAD_TABLE__, 5 , &amp;target_data);
};
static __attribute__((destructor)) void fini (void)
{
  GOMP_offload_unregister_ver (0x10001, __OFFLOAD_TABLE__, 5 , &amp;target_data);
};
</pre>

<p>
通过注册的 target_data 中的 func_mappings 和 ptx_objs, 运行时可以找到函数 (例如
main._omp_fn.0) 对应的 ptx code (例如 ptx_code_0)
</p>
</div>
</div>

<div id="outline-container-org0000048" class="outline-5">
<h5 id="org0000048"><span class="section-number-5">1.3.5.2.</span> GOMP_target_ext</h5>
<div class="outline-text-5" id="text-1-3-5-2">
<pre class="example" id="org0000047">
0000000000001169 &lt;main&gt;:
    # ...
    11a7:       6a 00                   pushq  $0x0
    11a9:       4c 8d 0d 68 ee 06 00    lea    0x6ee68(%rip),%r9        # 70018 &lt;.omp_data_kinds.6.2657&gt;
    11b0:       4c 8d 05 59 ee 06 00    lea    0x6ee59(%rip),%r8        # 70010 &lt;.omp_data_sizes.5.2656&gt;
    11b7:       48 89 c1                mov    %rax,%rcx
    11ba:       ba 01 00 00 00          mov    $0x1,%edx
    11bf:       48 8d 35 2b 00 00 00    lea    0x2b(%rip),%rsi        # 11f1 &lt;main._omp_fn.0&gt;
                                                                      ~~~~~~~~~~~~~~~~~~~~~~~
    11c6:       bf ff ff ff ff          mov    $0xffffffff,%edi
    11cb:       e8 60 fe ff ff          callq  1030 &lt;GOMP_target_ext@plt&gt;
                                                     ~~~~~~~~~~~~~~~~~~~~
                                                     GOMP_target_ext 会负责调用 ptx runtime 相关代码去找 main._omp_fn.0
                                                     对应的 ptx code 并执行, 但如果没有成功, 可以 fallback 到 cpu 代码
                                                     所以下面有 main._omp_fn.0 完整的 cpu 实现

    11d0:       48 83 c4 20             add    $0x20,%rsp
    11d4:       8b 45 d4                mov    -0x2c(%rbp),%eax
    11d7:       89 c6                   mov    %eax,%esi
    11d9:       48 8d 3d 24 0e 00 00    lea    0xe24(%rip),%rdi        # 2004 &lt;_IO_stdin_used+0x4&gt;
    11e0:       b8 00 00 00 00          mov    $0x0,%eax
    11e5:       e8 66 fe ff ff          callq  1050 &lt;printf@plt&gt;
    11ea:       b8 00 00 00 00          mov    $0x0,%eax
    11ef:       c9                      leaveq
    11f0:       c3                      retq


00000000000011f1 &lt;main._omp_fn.0&gt;:
    11f1:       55                      push   %rbp
    11f2:       48 89 e5                mov    %rsp,%rbp
    11f5:       48 89 7d e8             mov    %rdi,-0x18(%rbp)
    11f9:       c7 45 fc 00 00 00 00    movl   $0x0,-0x4(%rbp)
    1200:       83 7d fc 09             cmpl   $0x9,-0x4(%rbp)
                                        ~~~~~~~~~~~~~~~~~~~~~~ 循环 10 次

    1204:       7f 1d                   jg     1223 &lt;main._omp_fn.0+0x32&gt;
    1206:       48 8b 45 e8             mov    -0x18(%rbp),%rax
    120a:       48 8b 00                mov    (%rax),%rax
    120d:       8b 10                   mov    (%rax),%edx
    120f:       8b 45 fc                mov    -0x4(%rbp),%eax
    1212:       01 c2                   add    %eax,%edx
    1214:       48 8b 45 e8             mov    -0x18(%rbp),%rax
    1218:       48 8b 00                mov    (%rax),%rax
    121b:       89 10                   mov    %edx,(%rax)
    121d:       83 45 fc 01             addl   $0x1,-0x4(%rbp)
    1221:       eb dd                   jmp    1200 &lt;main._omp_fn.0+0xf&gt;
    1223:       5d                      pop    %rbp
    1224:       c3                      retq
    1225:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    122c:       00 00 00
    122f:       90                      nop
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org0000055" class="outline-3">
<h3 id="org0000055"><span class="section-number-3">1.4.</span> Compiler Directive</h3>
<div class="outline-text-3" id="text-1-4">
<p>
gcc 对 openmp 的支持主要在两个 tree pass:
</p>

<ol class="org-ol">
<li>omplower</li>

<li>ompexp</li>
</ol>
</div>

<div id="outline-container-org0000049" class="outline-4">
<h4 id="org0000049"><span class="section-number-4">1.4.1.</span> Example</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
以下面的代码为例:
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;omp.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
<span class="org-preprocessor">#pragma</span> omp parallel <span class="org-keyword">for</span> num_threads(2)
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 10; i++) {
        printf(<span class="org-string">"%d\n"</span>, omp_get_thread_num());
    }
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<pre class="example" id="org0000051">
$&gt; riscv64-linux-gnu-gcc test.c -O2  -fopenmp -c -fno-stack-protector -fdump-tree-all
</pre>

<p>
test.c.007t.omplower:
</p>

<pre class="example" id="org0000052">
;; Function main (main, funcdef_no=23, decl_uid=2425, cgraph_uid=24, symbol_order=23)

Introduced new external node (main._omp_fn.0/24).
main (int argc, char * * argv)
{
  int D.2430;

  {
    {
      #pragma omp parallel num_threads(2) [child fn: main._omp_fn.0 (???)]
        {
          int i;

          {
            #pragma omp for nowait
            for (i = 0; i &lt; 10; i = i + 1)
            D.2429 = omp_get_thread_num ();
            printf ("%d\n", D.2429);
            #pragma omp continue (i, i)
            #pragma omp return(nowait)
          }
        }
        #pragma omp return
    }
    D.2430 = 0;
    return D.2430;
  }
  D.2430 = 0;
  return D.2430;
}
</pre>

<p>
test.c.013t.ompexp:
</p>

<pre class="example" id="org0000053">
;; Function main._omp_fn.0 (main._omp_fn.0, funcdef_no=24, decl_uid=2432, cgraph_uid=25, symbol_order=24)

main._omp_fn.0 (void * .omp_data_i)
{
  int D.2451;
  int i;
  int D.2449;
  int D.2448;
  int D.2447;
  int tt.2;
  int q.1;
  int D.2444;
  int D.2443;

  &lt;bb 11&gt; :

  &lt;bb 3&gt; :
  D.2443 = __builtin_omp_get_num_threads ();
  D.2444 = __builtin_omp_get_thread_num ();
  q.1 = 10 / D.2443;
  tt.2 = 10 % D.2443;
  if (D.2444 &lt; tt.2)
    goto &lt;bb 9&gt;; [25.00%]
  else
    goto &lt;bb 10&gt;; [75.00%]

  &lt;bb 10&gt; :
  D.2447 = q.1 * D.2444;
  D.2448 = D.2447 + tt.2;
  D.2449 = D.2448 + q.1;
  if (D.2448 &gt;= D.2449)
    goto &lt;bb 5&gt;; [INV]
  else
    goto &lt;bb 8&gt;; [INV]

  &lt;bb 8&gt; :
  i = D.2448;

  &lt;bb 4&gt; :
  D.2451 = __builtin_omp_get_thread_num ();
  printf ("%d\n", D.2451);
  i = i + 1;
  if (i &lt; D.2449)
    goto &lt;bb 4&gt;; [INV]
  else
    goto &lt;bb 5&gt;; [INV]

  &lt;bb 5&gt; :

  &lt;bb 6&gt; :
  return;

  &lt;bb 9&gt; :
  tt.2 = 0;
  q.1 = q.1 + 1;
  goto &lt;bb 10&gt;; [100.00%]

}

;; Function main (main, funcdef_no=23, decl_uid=2425, cgraph_uid=24, symbol_order=23)

Merging blocks 2 and 12
Merging blocks 2 and 7
main (int argc, char * * argv)
{
  int D.2442;
  int D.2440;
  int D.2441;
  int tt.2;
  int q.1;
  int D.2437;
  int D.2436;
  int i;
  int D.2430;

  &lt;bb 2&gt; :
  __builtin_GOMP_parallel (main._omp_fn.0, 0B, 2, 0);
  D.2430 = 0;
  return D.2430;

}
</pre>
</div>
</div>

<div id="outline-container-org000004c" class="outline-4">
<h4 id="org000004c"><span class="section-number-4">1.4.2.</span> omplower</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
TBD
</p>
</div>
</div>

<div id="outline-container-org000004f" class="outline-4">
<h4 id="org000004f"><span class="section-number-4">1.4.3.</span> ompexp</h4>
<div class="outline-text-4" id="text-1-4-3">
<p>
TBD
</p>
</div>
</div>

<div id="outline-container-org000005d" class="outline-4">
<h4 id="org000005d"><span class="section-number-4">1.4.4.</span> omp-builtins</h4>
<div class="outline-text-4" id="text-1-4-4">
<p>
生成代码中对 libgomp 函数的调用是以 builtin 的形式, 例如
`__builtin_GOMP_parallel (main._omp_fn.0, 0B, 2, 0)`, 这些 omp builtins 不需要定义 optab 和 rtl insn, 它们会在 rtl expand 时变成对 libgomp 函数的调用.
</p>

<p>
所有的 omp builtin 定义在 `omp-builtins.def`, `expand_builtin` 负责把它们变成函数调用.
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="org-type">rtx</span>
<span class="org-function-name">expand_builtin</span> (<span class="org-type">tree</span> <span class="org-variable-name">exp</span>, <span class="org-type">rtx</span> <span class="org-variable-name">target</span>, <span class="org-type">rtx</span> <span class="org-variable-name">subtarget</span>, <span class="org-type">machine_mode</span> <span class="org-variable-name">mode</span>,
        <span class="org-type">int</span> <span class="org-variable-name">ignore</span>)
{
  <span class="org-type">tree</span> <span class="org-variable-name">fndecl</span> = get_callee_fndecl (exp);
  <span class="org-type">machine_mode</span> <span class="org-variable-name">target_mode</span> = TYPE_MODE (TREE_TYPE (exp));
  <span class="org-type">int</span> <span class="org-variable-name">flags</span>;

  <span class="org-keyword">switch</span> (fcode)
    {
    CASE_FLT_FN (BUILT_IN_FABS):
    CASE_FLT_FN_FLOATN_NX (BUILT_IN_FABS):
    <span class="org-keyword">case</span> BUILT_IN_FABSD32:
    <span class="org-keyword">case</span> BUILT_IN_FABSD64:
    <span class="org-keyword">case</span> BUILT_IN_FABSD128:
      target = expand_builtin_fabs (exp, target, subtarget);
      <span class="org-keyword">if</span> (target) <span class="org-keyword">return</span> target;
      <span class="org-keyword">break</span>;
      ...
    <span class="org-keyword">default</span>: <span class="org-comment-delimiter">/* </span><span class="org-comment">just do library call, if unknown builtin</span><span class="org-comment-delimiter"> */</span>
      <span class="org-keyword">break</span>;
    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">NOTE: &#36825;&#37324;&#29983;&#25104;&#23545; libgomp &#30340;&#35843;&#29992;</span>
    <span class="org-keyword">return</span> expand_call(exp, target, ignore);
}
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

<p class="author">Author: sunway@dogdog.run<br />
Date: 2022-12-06 Tue 17:50<br />
Last updated: 2022-12-12 Mon 10:05</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
</div>
</body>
</html>
