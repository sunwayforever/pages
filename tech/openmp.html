<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>OpenMP</title>


           <link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
           <link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
           <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
           <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
           <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
           <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
           <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
           <link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
           <link rel="stylesheet" type="text/css" href="../main.css" media="screen" />
           <link rel="stylesheet" type="text/css" href="./main.css" media="screen" />
           <link rel = "icon" href = "/icon.png"  type = "image/x-icon">
</head>
<body>
<div id="content" class="content">
<h1 class="title">OpenMP</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org0000049">1. OpenMP</a>
<ul>
<li><a href="#org0000000">1.1. Overview</a></li>
<li><a href="#org0000003">1.2. Demo</a></li>
<li><a href="#org0000043">1.3. libgomp</a>
<ul>
<li><a href="#org000000a">1.3.1. parallel</a></li>
<li><a href="#org0000027">1.3.2. sync</a></li>
<li><a href="#org0000039">1.3.3. for</a></li>
<li><a href="#org0000040">1.3.4. task</a></li>
</ul>
</li>
<li><a href="#org0000046">1.4. Compiler Directive</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org0000049" class="outline-2">
<h2 id="org0000049"><span class="section-number-2">1.</span> OpenMP</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org0000000" class="outline-3">
<h3 id="org0000000"><span class="section-number-3">1.1.</span> Overview</h3>
<div class="outline-text-3" id="text-1-1">
<p>
OpenMP 包含两部分内容:
</p>

<ol class="org-ol">
<li><p>
compiler directive
</p>

<p>
openmp 的 api 主要是 compiler directive 的形式, 例如 `#pragma omp parallel`,
编译器需要:
</p>

<ol class="org-ol">
<li>识别这些 directive</li>

<li>生成 parallel block 对应的匿名函数</li>

<li>调用 libgomp 中相应 api</li>
</ol></li>

<li><p>
libgomp
</p>

<p>
libgomp 中有少量函数例如 `omp_get_thread_num` 可以由用户代码直接调用, 其它的大部分的调用都是由编译器产生的, 例如 GOMP_parallel, GOMP_critical_start,
GOMP_loop_nonmonotonic_dynamic_next 等
</p></li>
</ol>
</div>
</div>

<div id="outline-container-org0000003" class="outline-3">
<h3 id="org0000003"><span class="section-number-3">1.2.</span> Demo</h3>
<div class="outline-text-3" id="text-1-2">
<p>
<a href="https://github.com/sunwayforever/code/tree/master/hello_world/hello_openmp">https://github.com/sunwayforever/code/tree/master/hello_world/hello_openmp</a>
</p>
</div>
</div>

<div id="outline-container-org0000043" class="outline-3">
<h3 id="org0000043"><span class="section-number-3">1.3.</span> libgomp</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-org000000a" class="outline-4">
<h4 id="org000000a"><span class="section-number-4">1.3.1.</span> parallel</h4>
<div class="outline-text-4" id="text-1-3-1">
<div class="org-src-container">
<pre class="src src-C"><span class="org-comment-delimiter">// </span><span class="org-comment">2022-12-05 14:51</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;omp.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
<span class="org-preprocessor">#pragma</span> omp parallel num_threads(2)
    {
        <span class="org-type">int</span> <span class="org-variable-name">id</span> = omp_get_thread_num();
        printf(<span class="org-string">"hello world %d\n"</span>, id);
    }

    printf(<span class="org-string">"------\n"</span>);
}
</pre>
</div>

<pre class="example" id="org0000006">
$&gt; riscv64-linux-gnu-gcc test.c -O0 -g -fopenmp

$&gt; readelf -a ./a.out|grep NEEDED
 0x0000000000000001 (NEEDED)             Shared library: [libgomp.so.1]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]

$&gt; riscv64-linux-gnu-objdump -d -r ./a.out

000000000000076a &lt;main&gt;:
 76a:	1101                	addi	sp,sp,-32
 76c:	ec06                	sd	ra,24(sp)
 76e:	e822                	sd	s0,16(sp)
 770:	1000                	addi	s0,sp,32
 772:	87aa                	mv	a5,a0
 774:	feb43023          	sd	a1,-32(s0)
 778:	fef42623          	sw	a5,-20(s0)
 77c:	4681                	li	a3,0
 77e:	4609                	li	a2,2
                                ~~~~~~~~ 
 780: 4581                    li  a1,0
 782: 00000517            auipc   a0,0x0
 786: 02450513            addi    a0,a0,36 # 7a6 &lt;main._omp_fn.0&gt;
                                                  ~~~~~~~~~~~~~~
 78a: f07ff0ef            jal ra,690 &lt;GOMP_parallel@plt&gt;
                                      ~~~~~~~~~~~~~~~~~
 78e: 00000517            auipc   a0,0x0
 792: 0a250513            addi    a0,a0,162 # 830 &lt;__libc_csu_fini+0x2&gt;
 796: edbff0ef            jal ra,670 &lt;puts@plt&gt;
 79a: 4781                    li  a5,0
 79c: 853e                    mv  a0,a5
 79e: 60e2                    ld  ra,24(sp)
 7a0: 6442                    ld  s0,16(sp)
 7a2: 6105                    addi    sp,sp,32
 7a4: 8082                    ret

00000000000007a6 &lt;main._omp_fn.0&gt;:
 7a6: 7179                    addi    sp,sp,-48
 7a8: f406                    sd  ra,40(sp)
 7aa: f022                    sd  s0,32(sp)
 7ac: 1800                    addi    s0,sp,48
 7ae: fca43c23            sd  a0,-40(s0)
 7b2: eafff0ef            jal ra,660 &lt;omp_get_thread_num@plt&gt;
 7b6: 87aa                    mv  a5,a0
 7b8: fef42623            sw  a5,-20(s0)
 7bc:	fec42783          	lw	a5,-20(s0)
 7c0:	85be                	mv	a1,a5
 7c2:	00000517          	auipc	a0,0x0
 7c6:	07650513          	addi	a0,a0,118 # 838 &lt;__libc_csu_fini+0xa&gt;
 7ca:	eb7ff0ef          	jal	ra,680 &lt;printf@plt&gt;
 7ce:	70a2                	ld	ra,40(sp)
 7d0:	7402                	ld	s0,32(sp)
 7d2:	6145                	addi	sp,sp,48
 7d4:	8082                	ret

</pre>

<ol class="org-ol">
<li>gcc 会把 `omp parallel` 对应的 block `{int id=&#x2026;.;printf(&#x2026;)}` 编译成一个独立的函数 `main._omp_fn.0`</li>

<li>`omp parallel` 对应 `GOMP_parallel` 函数, 它的实现在 libgomp 中, 并且调用时传递了 `2` 做为参数, 即需要两个线程的并行</li>
</ol>
</div>

<div id="outline-container-org0000007" class="outline-5">
<h5 id="org0000007"><span class="section-number-5">1.3.1.1.</span> GOMP_parallel</h5>
<div class="outline-text-5" id="text-1-3-1-1">
<div class="org-src-container">
<pre class="src src-C"><span class="org-type">void</span> <span class="org-function-name">GOMP_parallel</span>(
    <span class="org-type">void</span> (*<span class="org-function-name">fn</span>)(<span class="org-type">void</span> *), <span class="org-type">void</span> *<span class="org-variable-name">data</span>, <span class="org-type">unsigned</span> <span class="org-variable-name">num_threads</span>, <span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">flags</span>) {
    num_threads = gomp_resolve_num_threads(num_threads, 0);
    gomp_team_start(
        fn, data, num_threads, flags, gomp_new_team(num_threads), <span class="org-constant">NULL</span>);
    <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: fn &#21363; main._omp_fn.0, &#23427;&#22312;&#20027;&#32447;&#31243;&#20250;&#30452;&#25509;&#25191;&#34892;&#19968;&#27425;, &#25152;&#20197;&#21363;&#20351;&#25351;&#23450;</span>
<span class="org-comment">     * num_threads &#20026; 0, &#20063;&#20250;&#25191;&#34892;&#19968;&#27425;</span><span class="org-comment-delimiter"> */</span>
    fn(data);
    ialias_call(GOMP_parallel_end)();
}


<span class="org-constant">gomp_team_start</span>:
  <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: gomp_team_start &#30340; num_threads &#26159;&#20174; 1 &#24320;&#22987;&#35745;&#25968;&#30340;, &#22240;&#20026;&#20027;&#32447;&#31243;&#24050;&#32463;&#25191;&#34892;&#20102;&#19968;&#27425;&#20102;</span><span class="org-comment-delimiter"> */</span>
  <span class="org-keyword">if</span> (nthreads == 1)
    <span class="org-keyword">return</span>;

  i = 1;
  <span class="org-keyword">for</span> (; i &lt; nthreads; ++i):
    start_data-&gt;fn = fn;
    start_data-&gt;fn_data = data;
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
    pthread_create (&amp;start_data-&gt;handle, attr, gomp_thread_start, start_data);

<span class="org-constant">gomp_thread_start</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  local_fn = data-&gt;fn;
  local_data = data-&gt;fn_data;
  <span class="org-function-name">local_fn</span> (local_data);
  <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org0000027" class="outline-4">
<h4 id="org0000027"><span class="section-number-4">1.3.2.</span> sync</h4>
<div class="outline-text-4" id="text-1-3-2">
</div>
<div id="outline-container-org000000e" class="outline-5">
<h5 id="org000000e"><span class="section-number-5">1.3.2.1.</span> atomic</h5>
<div class="outline-text-5" id="text-1-3-2-1">
<div class="org-src-container">
<pre class="src src-C"><span class="org-comment-delimiter">// </span><span class="org-comment">2022-12-05 14:51</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;omp.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
    <span class="org-type">int</span> <span class="org-variable-name">sum</span> = 0;
<span class="org-preprocessor">#pragma</span> omp parallel num_threads(2)
    {
<span class="org-preprocessor">#pragma</span> omp atomic
        sum += 1;
    }

    printf(<span class="org-string">"%d\n"</span>, sum);
}
</pre>
</div>

<pre class="example" id="org000000d">
$&gt; riscv64-linux-gnu-gcc test.c -O0 -g  -fopenmp -c -fno-stack-protector
$&gt; riscv64-linux-gnu-objdump -d -r ./test.o

000000000000005a &lt;main._omp_fn.0&gt;:
  5a:   1101                    addi    sp,sp,-32
  5c:   ec22                    sd      s0,24(sp)
  5e:   1000                    addi    s0,sp,32
  60:   fea43423                sd      a0,-24(s0)
  64:   fe843783                ld      a5,-24(s0)
  68:   639c                    ld      a5,0(a5)
  6a:   4705                    li      a4,1
  6c:   00e7a02f                amoadd.w        zero,a4,(a5)
                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  70:   6462                    ld      s0,24(sp)
  72:   6105                    addi    sp,sp,32
  74:   8082                    ret
</pre>

<p>
`omp atomic` 在 riscv 上实际对应的是 <a href="../riscv/riscv_tutorial.html#ID-c1ffdfa0-c15c-47ae-a7b2-5fdca4e3a53a">AMO</a> 指令
</p>
</div>
</div>

<div id="outline-container-org0000012" class="outline-5">
<h5 id="org0000012"><span class="section-number-5">1.3.2.2.</span> critical</h5>
<div class="outline-text-5" id="text-1-3-2-2">
<div class="org-src-container">
<pre class="src src-C"><span class="org-comment-delimiter">// </span><span class="org-comment">2022-12-05 14:51</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;omp.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
    <span class="org-type">int</span> <span class="org-variable-name">sum</span> = 0;
<span class="org-preprocessor">#pragma</span> omp parallel num_threads(2)
    {
<span class="org-preprocessor">#pragma</span> omp critical
        sum += 1;
    }
    printf(<span class="org-string">"%d\n"</span>, sum);
}
</pre>
</div>

<pre class="example" id="org0000011">
0000000000000062 &lt;main._omp_fn.0&gt;:
  62:   1101                    addi    sp,sp,-32
  64:   ec06                    sd      ra,24(sp)
  66:   e822                    sd      s0,16(sp)
  68:   1000                    addi    s0,sp,32
  6a:   fea43423                sd      a0,-24(s0)
  6e:   00000097                auipc   ra,0x0
                        6e: R_RISCV_CALL_PLT    GOMP_critical_start
                        6e: R_RISCV_RELAX       *ABS*
  72:   000080e7                jalr    ra # 6e &lt;main._omp_fn.0+0xc&gt;
  76:   fe843783                ld      a5,-24(s0)
  7a:   439c                    lw      a5,0(a5)
  7c:   2785                    addiw   a5,a5,1
  7e:   0007871b                sext.w  a4,a5
  82:   fe843783                ld      a5,-24(s0)
  86:   c398                    sw      a4,0(a5)
  88:   00000097                auipc   ra,0x0
                        88: R_RISCV_CALL_PLT    GOMP_critical_end
                        88: R_RISCV_RELAX       *ABS*
  8c:   000080e7                jalr    ra # 88 &lt;main._omp_fn.0+0x26&gt;
  90:   60e2                    ld      ra,24(sp)
  92:   6442                    ld      s0,16(sp)
  94:   6105                    addi    sp,sp,32
  96:   8082                    ret
</pre>

<p>
`omp critical` 对应 `GOMP_critical_start` 和 `GOMP_critical_end`, 后者对应 posix
的 `pthread_mutex_lock` 或者 linux 的 `futex_wait`
</p>
</div>
</div>

<div id="outline-container-org0000019" class="outline-5">
<h5 id="org0000019"><span class="section-number-5">1.3.2.3.</span> barrier</h5>
<div class="outline-text-5" id="text-1-3-2-3">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;omp.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
<span class="org-preprocessor">#pragma</span> omp parallel num_threads(2)
    {
        printf(<span class="org-string">"%d\n"</span>, omp_get_thread_num());
<span class="org-preprocessor">#pragma</span> omp barrier
        printf(<span class="org-string">"%d\n"</span>, omp_get_thread_num());
    }
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<pre class="example" id="org0000015">
0000000000000000 &lt;main._omp_fn.0&gt;:
   0:	1141                	addi	sp,sp,-16
   2:	e406                	sd	ra,8(sp)
   4:	e022                	sd	s0,0(sp)
   6:	00000097          	auipc	ra,0x0
            6: R_RISCV_CALL_PLT	omp_get_thread_num
            6: R_RISCV_RELAX	*ABS*
   a:	000080e7          	jalr	ra # 6 &lt;main._omp_fn.0+0x6&gt;
   e:	862a                	mv	a2,a0
  10:	842a                	mv	s0,a0
  12:	00000597          	auipc	a1,0x0
            12: R_RISCV_PCREL_HI20	.LC0
            12: R_RISCV_RELAX	*ABS*
  16:	00058593          	mv	a1,a1
            16: R_RISCV_PCREL_LO12_I	.L0 
            16: R_RISCV_RELAX	*ABS*
  1a:	4505                	li	a0,1
  1c:	00000097          	auipc	ra,0x0
            1c: R_RISCV_CALL_PLT	__printf_chk
            1c: R_RISCV_RELAX	*ABS*
  20:	000080e7          	jalr	ra # 1c &lt;main._omp_fn.0+0x1c&gt;
  24:	00000097          	auipc	ra,0x0
            24: R_RISCV_CALL_PLT	GOMP_barrier
                                    ~~~~~~~~~~~~

            24: R_RISCV_RELAX	*ABS*
  28:	000080e7          	jalr	ra # 24 &lt;main._omp_fn.0+0x24&gt;
  2c:	8622                	mv	a2,s0
  2e:	6402                	ld	s0,0(sp)
  30:	60a2                	ld	ra,8(sp)
  32:	00000597          	auipc	a1,0x0
            32: R_RISCV_PCREL_HI20	.LC0
            32: R_RISCV_RELAX	*ABS*
  36:	00058593          	mv	a1,a1
            36: R_RISCV_PCREL_LO12_I	.L0 
            36: R_RISCV_RELAX	*ABS*
  3a:	4505                	li	a0,1
  3c:	0141                	addi	sp,sp,16
  3e:	00000317          	auipc	t1,0x0
            3e: R_RISCV_CALL_PLT	__printf_chk
            3e: R_RISCV_RELAX	*ABS*
  42:	00030067          	jr	t1 # 3e &lt;main._omp_fn.0+0x3e&gt;

</pre>
</div>

<div id="outline-container-org0000016" class="outline-6">
<h6 id="org0000016"><span class="section-number-6">1.3.2.3.1.</span> GOMP_barrier</h6>
<div class="outline-text-6" id="text-1-3-2-3-1">
<p>
GOMP_barrier 需要保证:
</p>

<ol class="org-ol">
<li>插入一个 memory fence</li>

<li>已经执行到 barrier 的线程需要等待其它尚未执行到 barrier 的线程</li>
</ol>

<div class="org-src-container">
<pre class="src src-C"><span class="org-type">void</span> <span class="org-function-name">GOMP_barrier</span>():
  gomp_team_barrier_wait(&amp;team-&gt;barrier);
    <span class="org-function-name">gomp_team_barrier_wait_end</span> (bar, <span class="org-type">gomp_barrier_wait_start</span> (<span class="org-variable-name">bar</span>));

<span class="org-type">gomp_barrier_state_t</span> <span class="org-function-name">gomp_barrier_wait_start</span> (<span class="org-type">gomp_barrier_t</span> *<span class="org-variable-name">bar</span>):
  <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: __atomic_xx &#21518;&#30340; MEMMODEL &#30456;&#24403;&#20110; memory fench</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">unsigned</span> <span class="org-type">int</span> ret = __atomic_load_n (&amp;bar-&gt;generation, MEMMODEL_ACQUIRE);
  ret &amp;= -BAR_INCR | BAR_CANCELLED;
  <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: &#24403; awaited &#20943;&#23567;&#21040; 0 &#26102;, &#24847;&#21619;&#30528;&#26368;&#21518;&#19968;&#20010;&#32447;&#31243;&#21040;&#36798; barrier, &#36825;&#20010;&#24102;&#26377;</span>
<span class="org-comment">   * BAR_WAS_LAST &#26631;&#35760;&#30340;&#32447;&#31243;&#20250;&#36127;&#36131;&#21796;&#37266;&#21069;&#38754;&#31561;&#24453;&#30340;&#32447;&#31243;</span><span class="org-comment-delimiter"> */</span>
  <span class="org-keyword">if</span> (__atomic_add_fetch (&amp;bar-&gt;awaited, -1, MEMMODEL_ACQ_REL) == 0):
    ret |= BAR_WAS_LAST;
  <span class="org-keyword">return</span> ret;

<span class="org-type">void</span> <span class="org-function-name">gomp_team_barrier_wait_end</span> (<span class="org-type">gomp_barrier_t</span> *<span class="org-variable-name">bar</span>, <span class="org-type">gomp_barrier_state_t</span> <span class="org-variable-name">state</span>):
  <span class="org-type">unsigned</span> <span class="org-type">int</span> generation, gen;

<span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: if (__builtin_expect (x, 0)) {xxx} &#30456;&#24403;&#20110; if (x) {xxx}, &#20854;&#20013;&#30340; 0 &#21482;&#26159;&#32473;</span>
<span class="org-comment"> * compiler &#30340; hint, &#21578;&#35785;&#23427; x &#20026; 0 &#30340;&#27010;&#29575;&#36739;&#22823;, &#21487;&#20197;&#35753; compiler &#20135;&#29983;&#26377;&#21033;&#20110; branch</span>
<span class="org-comment"> * prediction &#30340;&#20195;&#30721;</span><span class="org-comment-delimiter"> */</span>
<span class="org-keyword">if</span> (__builtin_expect (state &amp; BAR_WAS_LAST, 0)):
    bar-&gt;awaited = bar-&gt;total;
    team-&gt;work_share_cancelled = 0;
    __atomic_store_n (&amp;bar-&gt;generation, state, MEMMODEL_RELEASE);
    <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: &#22914;&#26524;&#24403;&#21069;&#32447;&#31243;&#26159; BAR_WAS_LAST, &#21017;&#23427;&#20250; wake &#20854;&#23427;&#32447;&#31243;</span><span class="org-comment-delimiter"> */</span>
    <span class="org-function-name">futex_wake</span> ((<span class="org-type">int</span> *) &amp;bar-&gt;generation, INT_MAX);
    <span class="org-keyword">return</span>;

generation = state;
state &amp;= ~BAR_CANCELLED;
<span class="org-keyword">do</span>:
  <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: &#38750; BAR_WAS_LAST &#30340;&#32447;&#31243;&#20250;&#31561;&#24453; BAR_WAS_LAST &#32447;&#31243;&#30340; wake</span><span class="org-comment-delimiter"> */</span>
  do_wait ((<span class="org-type">int</span> *) &amp;bar-&gt;generation, generation);
  gen = __atomic_load_n (&amp;bar-&gt;generation, MEMMODEL_ACQUIRE);
  <span class="org-keyword">if</span> (__builtin_expect (gen &amp; BAR_TASK_PENDING, 0)):
    gomp_barrier_handle_tasks (state);
    gen = __atomic_load_n (&amp;bar-&gt;generation, MEMMODEL_ACQUIRE);

  generation |= gen &amp; BAR_WAITING_FOR_TASK;
<span class="org-keyword">while</span> (gen != state + BAR_INCR);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org0000020" class="outline-5">
<h5 id="org0000020"><span class="section-number-5">1.3.2.4.</span> single</h5>
<div class="outline-text-5" id="text-1-3-2-4">
<p>
single 要求只有一个线程能执行相应代码, 但并没有要求是哪一个线程
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;omp.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
<span class="org-preprocessor">#pragma</span> omp parallel num_threads(2)
    {
<span class="org-preprocessor">#pragma</span> omp single
        { printf(<span class="org-string">"single %d\n"</span>, omp_get_thread_num()); }
        printf(<span class="org-string">"single %d\n"</span>, omp_get_thread_num());
    }
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<pre class="example" id="org000001c">
0000000000000000 &lt;main._omp_fn.0&gt;:
   0:   1101                    addi    sp,sp,-32
   2:   ec06                    sd  ra,24(sp)
   4:   e822                    sd  s0,16(sp)
   6:   e426                    sd  s1,8(sp)
   8:   00000097            auipc   ra,0x0
            8: R_RISCV_CALL_PLT GOMP_single_start
                                ~~~~~~~~~~~~~~~~~

            8: R_RISCV_RELAX  *ABS*
   c: 000080e7            jalr    ra # 8 &lt;main._omp_fn.0+0x8&gt;
  10: 84aa                    mv  s1,a0
  12: 00000097            auipc   ra,0x0
            12: R_RISCV_CALL_PLT  omp_get_thread_num
            12: R_RISCV_RELAX *ABS*
  16: 000080e7            jalr    ra # 12 &lt;main._omp_fn.0+0x12&gt;
  1a: 842a                    mv  s0,a0
  1c: e09d                    bnez    s1,42 &lt;.L2&gt;
            1c: R_RISCV_RVC_BRANCH    .L2

000000000000001e &lt;.L3&gt;:
  1e: 00000097            auipc   ra,0x0
            1e: R_RISCV_CALL_PLT  GOMP_barrier
                                    ~~~~~~~~~~~~
                                    single 后有一个隐式的 barrier

            1e: R_RISCV_RELAX *ABS*
  22: 000080e7            jalr    ra # 1e &lt;.L3&gt;
  26: 8622                    mv  a2,s0
  28: 6442                    ld  s0,16(sp)
  2a: 60e2                    ld  ra,24(sp)
  2c: 64a2                    ld  s1,8(sp)
  2e: 00000597            auipc   a1,0x0
            2e: R_RISCV_PCREL_HI20    .LC0
            2e: R_RISCV_RELAX *ABS*
  32: 00058593            mv  a1,a1
            32: R_RISCV_PCREL_LO12_I  .L0 
            32: R_RISCV_RELAX *ABS*
  36: 4505                    li  a0,1
  38: 6105                    addi    sp,sp,32
  3a: 00000317            auipc   t1,0x0
            3a: R_RISCV_CALL_PLT  __printf_chk
            3a: R_RISCV_RELAX *ABS*
  3e: 00030067            jr  t1 # 3a &lt;.L3+0x1c&gt;

0000000000000042 &lt;.L2&gt;:
  42: 862a                    mv  a2,a0
  44: 00000597            auipc   a1,0x0
            44: R_RISCV_PCREL_HI20    .LC0
            44: R_RISCV_RELAX *ABS*
  48: 00058593            mv  a1,a1
            48: R_RISCV_PCREL_LO12_I  .L0 
            48: R_RISCV_RELAX *ABS*
  4c: 4505                    li  a0,1
  4e: 00000097            auipc   ra,0x0
            4e: R_RISCV_CALL_PLT  __printf_chk
            4e: R_RISCV_RELAX *ABS*
  52: 000080e7            jalr    ra # 4e &lt;.L2+0xc&gt;
  56: b7e1                    j   1e &lt;.L3&gt;
            56: R_RISCV_RVC_JUMP  .L3

</pre>
</div>

<div id="outline-container-org000001d" class="outline-6">
<h6 id="org000001d"><span class="section-number-6">1.3.2.4.1.</span> GOMP_single_start</h6>
<div class="outline-text-6" id="text-1-3-2-4-1">
<div class="org-src-container">
<pre class="src src-C"><span class="org-type">bool</span> <span class="org-function-name">GOMP_single_start</span>(<span class="org-type">void</span>):
  <span class="org-keyword">struct</span> gomp_thread *thr = gomp_thread();
  <span class="org-keyword">struct</span> <span class="org-type">gomp_team</span> *<span class="org-variable-name">team</span> = thr-&gt;ts.team;
  <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">single_count</span>;

  <span class="org-keyword">if</span> (__builtin_expect(team == <span class="org-constant">NULL</span>, 0)) <span class="org-keyword">return</span> <span class="org-constant">true</span>;

  single_count = thr-&gt;ts.single_count++;
  <span class="org-comment-delimiter">/* </span><span class="org-comment">NOTE: __sync_bool_compare_and_swap (a,b,c) &#30340;&#25805;&#20316;&#26159;: &#27604;&#36739; a, b, &#33509;&#30456;&#31561;, &#21017;</span>
<span class="org-comment">   * &#25226; c &#36171;&#32473;a, &#24182;&#36820;&#22238; true, &#19988;&#25972;&#20010;&#36807;&#31243;&#26159;&#21407;&#23376;&#25805;&#20316;.</span>
<span class="org-comment">   *</span>
<span class="org-comment">   * N &#20010;&#32447;&#31243;&#31454;&#20105;, &#21482;&#26377;&#19968;&#20010;&#20250;&#32988;&#20986;. &#20294;&#19981;&#35770;&#26159;&#21542;&#32988;&#20986; ,&#25152;&#26377;&#32447;&#31243;&#30340; single_count &#20197;&#21450;</span>
<span class="org-comment">   * team &#30340; single_count &#37117;&#20250;&#21152; 1, &#20197;&#20415;&#33021;&#20849;&#21516;&#31454;&#20105;&#19979;&#19968;&#19979; single, &#25152;&#20197; single &#19981;</span>
<span class="org-comment">   * &#20250;&#22266;&#23450;&#32473;&#26576;&#19968;&#20010;&#32447;&#31243;&#25191;&#34892;</span><span class="org-comment-delimiter"> */</span>
  <span class="org-keyword">return</span> __sync_bool_compare_and_swap(
        &amp;team-&gt;single_count, single_count, single_count + 1L);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org0000024" class="outline-5">
<h5 id="org0000024"><span class="section-number-5">1.3.2.5.</span> master</h5>
<div class="outline-text-5" id="text-1-3-2-5">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;omp.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
<span class="org-preprocessor">#pragma</span> omp parallel num_threads(2)
    {
<span class="org-preprocessor">#pragma</span> omp master
        { printf(<span class="org-string">"%d\n"</span>, omp_get_thread_num()); }
        printf(<span class="org-string">"%d\n"</span>, omp_get_thread_num());
    }
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<pre class="example" id="org0000023">
0000000000000000 &lt;main._omp_fn.0&gt;:
   0: 1141                    addi    sp,sp,-16
   2: e022                    sd  s0,0(sp)
   4: e406                    sd  ra,8(sp)
   6: 00000097            auipc   ra,0x0
            6: R_RISCV_CALL_PLT   omp_get_thread_num
            6: R_RISCV_RELAX  *ABS*
   a: 000080e7            jalr    ra # 6 &lt;main._omp_fn.0+0x6&gt;
   e: 842a                    mv  s0,a0
  10: cd11                    beqz    a0,2c &lt;.L2&gt;
                              ~~~~~~~~~~~~~~~~~~~~
                              由于 master 只能由主线程执行, 所以这里简单判断 omp_get_thread_num 是否
                              为 0 即可, 不需要像 single 那样有复杂的同步操作

            10: R_RISCV_RVC_BRANCH	.L2
  12:	8622                	mv	a2,s0
  14:	6402                	ld	s0,0(sp)
  16:	60a2                	ld	ra,8(sp)
  18:	00000597          	auipc	a1,0x0
            18: R_RISCV_PCREL_HI20	.LC0
            18: R_RISCV_RELAX	*ABS*
  1c:	00058593          	mv	a1,a1
            1c: R_RISCV_PCREL_LO12_I	.L0 
            1c: R_RISCV_RELAX	*ABS*
  20:	4505                	li	a0,1
  22:	0141                	addi	sp,sp,16
  24:	00000317          	auipc	t1,0x0
            24: R_RISCV_CALL_PLT	__printf_chk
            24: R_RISCV_RELAX	*ABS*
  28:	00030067          	jr	t1 # 24 &lt;main._omp_fn.0+0x24&gt;

000000000000002c &lt;.L2&gt;:
  2c:	4601                	li	a2,0
  2e:	00000597          	auipc	a1,0x0
            2e: R_RISCV_PCREL_HI20	.LC0
            2e: R_RISCV_RELAX	*ABS*
  32:	00058593          	mv	a1,a1
            32: R_RISCV_PCREL_LO12_I	.L0 
            32: R_RISCV_RELAX	*ABS*
  36:	4505                	li	a0,1
  38:	00000097          	auipc	ra,0x0
            38: R_RISCV_CALL_PLT	__printf_chk
            38: R_RISCV_RELAX	*ABS*
  3c:	000080e7          	jalr	ra # 38 &lt;.L2+0xc&gt;
  40:	8622                	mv	a2,s0
  42:	6402                	ld	s0,0(sp)
  44:	60a2                	ld	ra,8(sp)
  46:	00000597          	auipc	a1,0x0
            46: R_RISCV_PCREL_HI20	.LC0
            46: R_RISCV_RELAX	*ABS*
  4a:	00058593          	mv	a1,a1
            4a: R_RISCV_PCREL_LO12_I	.L0 
            4a: R_RISCV_RELAX	*ABS*
  4e:	4505                	li	a0,1
  50:	0141                	addi	sp,sp,16
  52:	00000317          	auipc	t1,0x0
            52: R_RISCV_CALL_PLT	__printf_chk
            52: R_RISCV_RELAX	*ABS*
  56:	00030067          	jr	t1 # 52 &lt;.L2+0x26&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-org0000039" class="outline-4">
<h4 id="org0000039"><span class="section-number-4">1.3.3.</span> for</h4>
<div class="outline-text-4" id="text-1-3-3">
</div>
<div id="outline-container-org000002b" class="outline-5">
<h5 id="org000002b"><span class="section-number-5">1.3.3.1.</span> static schedule</h5>
<div class="outline-text-5" id="text-1-3-3-1">
<div class="org-src-container">
<pre class="src src-C"><span class="org-comment-delimiter">// </span><span class="org-comment">2022-12-05 14:51</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;omp.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
    <span class="org-type">int</span> <span class="org-variable-name">sum</span> = 0;
<span class="org-preprocessor">#pragma</span> omp parallel <span class="org-keyword">for</span> num_threads(2)
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 10; i++) {
        printf(<span class="org-string">"%d\n"</span>, i);
    }
    printf(<span class="org-string">"%d\n"</span>, sum);
}
</pre>
</div>

<p>
默认情况下 `omp for` 使用 `schedule (static, N/num_threads)`, work sharing 是静态的, 由编译器直接完成
</p>

<pre class="example" id="org000002a">
$&gt; riscv64-linux-gnu-gcc test.c -O2  -fopenmp -c -fno-stack-protector
$&gt; riscv64-linux-gnu-objdump -d -r ./test.o

0000000000000000 &lt;main._omp_fn.0&gt;:
   0:	1101                	addi	sp,sp,-32
   2:	ec06                	sd	ra,24(sp)
   4:	e822                	sd	s0,16(sp)
   6:	e426                	sd	s1,8(sp)
   8:	e04a                	sd	s2,0(sp)
   a:	00000097          	auipc	ra,0x0
            a: R_RISCV_CALL	omp_get_num_threads
            a: R_RISCV_RELAX	*ABS*
   e:	000080e7          	jalr	ra # a &lt;main._omp_fn.0+0xa&gt;
  12:	842a                	mv	s0,a0
  14:	00000097          	auipc	ra,0x0
            14: R_RISCV_CALL	omp_get_thread_num
            14: R_RISCV_RELAX	*ABS*
  18:	000080e7          	jalr	ra # 14 &lt;main._omp_fn.0+0x14&gt;
  1c:	47a9                	li	a5,10
  1e:	0287e73b          	remw	a4,a5,s0
  22:	0287c6bb          	divw	a3,a5,s0
                            ~~~~~~~~~~~~~~~~ 
                            a3=10/(omp_get_num_threads()), a3 表示 schedcule(static, step) 中的 step

  26:	02e54c63          	blt	a0,a4,5e &lt;.L2&gt;
                            ~~~~~~~~~~~~~~~~~~
                            如果 step 不能整除, 会把多余的部分平摊到前面的 thread, 例如 10%4=2, 则 4 线程分到的任务为 3,3,2,2

            26: R_RISCV_BRANCH	.L2

000000000000002a &lt;.L5&gt;:
  2a:	02a684bb          	mulw	s1,a3,a0
                            ~~~~~~~~~~~~~~~~
                            a0 是 omp_get_thread_num(), s1 表示 begin=omp_get_thread_num()*step

  2e: 00e4843b            addw    s0,s1,a4
  32: 00d404bb            addw    s1,s0,a3
                            ~~~~~~~~~~~~~~~~
                            s0 是 begin, s1 是 begin+step, 即 end, 当前 thread 处理的范围是 [s0, s1]

  36: 00945e63            bge s0,s1,52 &lt;.L1&gt;
            36: R_RISCV_BRANCH    .L1
  3a: 00000937            lui s2,0x0
            3a: R_RISCV_HI20  .LC0
            3a: R_RISCV_RELAX *ABS*

000000000000003e &lt;.L4&gt;:
  3e: 85a2                    mv  a1,s0
  40: 00090513            mv  a0,s2
            40: R_RISCV_LO12_I    .LC0
            40: R_RISCV_RELAX *ABS*
  44: 2405                    addiw   s0,s0,1
  46: 00000097            auipc   ra,0x0
            46: R_RISCV_CALL  printf
            46: R_RISCV_RELAX *ABS*
  4a: 000080e7            jalr    ra # 46 &lt;.L4+0x8&gt;
  4e: fe8498e3            bne s1,s0,3e &lt;.L4&gt;
            4e: R_RISCV_BRANCH    .L4
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.L4 对应的代码是 for (i=start; i&lt;end; i++) {printf("%d\n",i);}

0000000000000052 &lt;.L1&gt;:
  52: 60e2                    ld  ra,24(sp)
  54: 6442                    ld  s0,16(sp)
  56: 64a2                    ld  s1,8(sp)
  58: 6902                    ld  s2,0(sp)
  5a: 6105                    addi    sp,sp,32
  5c: 8082                    ret

000000000000005e &lt;.L2&gt;:
  5e: 2685                    addiw   a3,a3,1
  60: 4701                    li  a4,0
  62: b7e1                    j   2a &lt;.L5&gt;
            62: R_RISCV_RVC_JUMP  .L5
</pre>
</div>
</div>

<div id="outline-container-org0000032" class="outline-5">
<h5 id="org0000032"><span class="section-number-5">1.3.3.2.</span> dynamic schedule</h5>
<div class="outline-text-5" id="text-1-3-3-2">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;omp.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
    <span class="org-type">int</span> <span class="org-variable-name">sum</span> = 0;
<span class="org-preprocessor">#pragma</span> omp parallel <span class="org-keyword">for</span> num_threads(2) schedule(dynamic, 1)
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 10; i++) {
        printf(<span class="org-string">"%d\n"</span>, i);
    }
}
</pre>
</div>

<pre class="example" id="org000002e">
0000000000000000 &lt;main&gt;:
   0: 00000537            lui a0,0x0
            0: R_RISCV_HI20   main._omp_fn.0
            0: R_RISCV_RELAX  *ABS*
   4: 1141                    addi    sp,sp,-16
   6: 4881                    li  a7,0
   8: 4805                    li  a6,1
   a: 4785                    li  a5,1
   c: 4729                    li  a4,10
   e: 4681                    li  a3,0
  10: 4609                    li  a2,2
  12: 4581                    li  a1,0
  14: 00050513            mv  a0,a0
            14: R_RISCV_LO12_I    main._omp_fn.0
            14: R_RISCV_RELAX *ABS*
  18: e406                    sd  ra,8(sp)
  1a: 00000097            auipc   ra,0x0
            1a: R_RISCV_CALL  GOMP_parallel_loop_nonmonotonic_dynamic
                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                设置 dynmic schedule 的参数, 例如 chunk size (1)
            1a: R_RISCV_RELAX *ABS*
  1e: 000080e7            jalr    ra # 1a &lt;main+0x1a&gt;


0000000000000000 &lt;main._omp_fn.0&gt;:
   0: 7179                    addi    sp,sp,-48
   2: 002c                    addi    a1,sp,8
   4: 850a                    mv  a0,sp
   6: f406                    sd  ra,40(sp)
   8: f022                    sd  s0,32(sp)
   a: ec26                    sd  s1,24(sp)
   c: e84a                    sd  s2,16(sp)
   e: 00000097            auipc   ra,0x0
            e: R_RISCV_CALL   GOMP_loop_nonmonotonic_dynamic_next
            e: R_RISCV_RELAX  *ABS*
  12: 000080e7            jalr    ra # e &lt;main._omp_fn.0+0xe&gt;
  16: c515                    beqz    a0,42 &lt;.L2&gt;
            16: R_RISCV_RVC_BRANCH    .L2
  18: 00000937            lui s2,0x0
            18: R_RISCV_HI20  .LC0
            18: R_RISCV_RELAX *ABS*

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.L4, .L3 的代码相当于:
while (GOMP_loop_nonmonotonic_dynamic_next(*start,*end)) {
      for (i=start;i&lt;end;i++) {
          printf("%d\n",i);
      }
}


000000000000001c &lt;.L4&gt;:
  1c: 4402                    lw  s0,0(sp)
  1e: 44a2                    lw  s1,8(sp)
                                ~~~~~~~~~~~~
                                s0 是 start, s1 是 end, 由于 GOMP_loop_nonmonotonic_dynamic_next 的参数是 (*start,*end)
                                所以它使用栈来传递参数   

0000000000000020 &lt;.L3&gt;:
  20: 85a2                    mv  a1,s0
  22: 00090513            mv  a0,s2
            22: R_RISCV_LO12_I    .LC0
            22: R_RISCV_RELAX *ABS*
  26: 2405                    addiw   s0,s0,1
  28: 00000097            auipc   ra,0x0
            28: R_RISCV_CALL  printf
            28: R_RISCV_RELAX *ABS*
  2c: 000080e7            jalr    ra # 28 &lt;.L3+0x8&gt;
  30: fe9448e3            blt s0,s1,20 &lt;.L3&gt;
                            ~~~~~~~~~~~~~~~~~~~
                            .L3 对应内层的 for (i=start;i&lt;end;i++) {xxx} 循环

            30: R_RISCV_BRANCH    .L3
  34: 002c                    addi    a1,sp,8
                                ~~~~~~~~~~~~~~~ end 的地址
  36: 850a                    mv  a0,sp
                                ~~~~~~~~~ start 的地址
  38: 00000097            auipc   ra,0x0
            38: R_RISCV_CALL  GOMP_loop_nonmonotonic_dynamic_next
            38: R_RISCV_RELAX *ABS*
  3c: 000080e7            jalr    ra # 38 &lt;.L3+0x18&gt;
  40: fd71                    bnez    a0,1c &lt;.L4&gt;
            40: R_RISCV_RVC_BRANCH    .L4
                                ~~~~~~~~~~~~~~~~~~~~
                                .L4 对应外层的 while (GOMP_loop_nonmonotonic_dynamic_next(*start,*end) 循环

</pre>

<p>
可见 dynamic schedule 有额外的运行时开销
</p>
</div>

<div id="outline-container-org000002f" class="outline-6">
<h6 id="org000002f"><span class="section-number-6">1.3.3.2.1.</span> GOMP_loop_nonmonotonic_dynamic_next</h6>
<div class="outline-text-6" id="text-1-3-3-2-1">
<div class="org-src-container">
<pre class="src src-C"><span class="org-type">bool</span> <span class="org-function-name">GOMP_loop_nonmonotonic_dynamic_next</span>(<span class="org-type">long</span> *<span class="org-variable-name">istart</span>, <span class="org-type">long</span> *<span class="org-variable-name">iend</span>)
  <span class="org-keyword">return</span> gomp_loop_dynamic_next (istart, iend);
    <span class="org-keyword">return</span> gomp_iter_dynamic_next (istart, iend);
      <span class="org-type">long</span> <span class="org-variable-name">tmp</span> = __sync_fetch_and_add (&amp;ws-&gt;next, chunk);
      <span class="org-keyword">if</span> (tmp &gt;= end) <span class="org-keyword">return</span> <span class="org-constant">false</span>;
      nend = tmp + chunk;
      <span class="org-keyword">if</span> (nend &gt; end) nend = end;
      *pstart = tmp;
      *pend = nend;
      <span class="org-keyword">return</span> <span class="org-constant">true</span>;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org0000036" class="outline-5">
<h5 id="org0000036"><span class="section-number-5">1.3.3.3.</span> reduction</h5>
<div class="outline-text-5" id="text-1-3-3-3">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;omp.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
    <span class="org-type">int</span> <span class="org-variable-name">sum</span> = 0;
<span class="org-preprocessor">#pragma</span> omp parallel <span class="org-keyword">for</span> reduction(+ : sum) num_threads(2)
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 10; i++) {
        sum += i;
    }
    printf(<span class="org-string">"%d\n"</span>, sum);
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<pre class="example" id="org0000035">
0000000000000000 &lt;main._omp_fn.0&gt;:
   0: 1101                    addi    sp,sp,-32
   2: ec06                    sd  ra,24(sp)
   4: e822                    sd  s0,16(sp)
   6: e426                    sd  s1,8(sp)
   8: 842a                    mv  s0,a0
   a: 00000097            auipc   ra,0x0
            a: R_RISCV_CALL_PLT   omp_get_num_threads
            a: R_RISCV_RELAX  *ABS*
   e: 000080e7            jalr    ra # a &lt;main._omp_fn.0+0xa&gt;
  12: 84aa                    mv  s1,a0
  14: 00000097            auipc   ra,0x0
            14: R_RISCV_CALL_PLT  omp_get_thread_num
            14: R_RISCV_RELAX *ABS*
  18: 000080e7            jalr    ra # 14 &lt;main._omp_fn.0+0x14&gt;
  1c: 46a9                    li  a3,10
  1e: 0296e63b            remw    a2,a3,s1
  22: 87aa                    mv  a5,a0
  24: 0296c5bb            divw    a1,a3,s1
  28: 02c54e63            blt a0,a2,64 &lt;.L2&gt;
            28: R_RISCV_BRANCH    .L2

000000000000002c &lt;.L5&gt;:
  2c: 4681                    li  a3,0
  2e: 02f5873b            mulw    a4,a1,a5
  32: 00c707bb            addw    a5,a4,a2
  36: 00b7873b            addw    a4,a5,a1
                          ~~~~~~~~~~~~~~~~
                          当前线程要处理的范围是 [a5, a4]

  3a: 00e7c963            blt a5,a4,4c &lt;.L4&gt;
            3a: R_RISCV_BRANCH    .L4
  3e: 00d4202f            amoadd.w    zero,a3,(s0)
                          ~~~~~~~~~~~~~~~~~~~~~~~~
                          线程处理完以后把 a3 (当前线程的 partial sum 累加到 (s0)

  42: 60e2                    ld  ra,24(sp)
  44: 6442                    ld  s0,16(sp)
  46: 64a2                    ld  s1,8(sp)
  48: 6105                    addi    sp,sp,32
  4a: 8082                    ret

000000000000004c &lt;.L4&gt;:
  4c: 9ebd                    addw    a3,a3,a5
  4e: 2785                    addiw   a5,a5,1
                              ~~~~~~~~~~~~~~~~
                              a3 是 partial sum, 不断的累加 a5 (i)

  50:	fef71ee3          	bne	a4,a5,4c &lt;.L4&gt;

            50: R_RISCV_BRANCH	.L4
  54:	2681                	sext.w	a3,a3
  56:	00d4202f          	amoadd.w	zero,a3,(s0)
  5a:	60e2                	ld	ra,24(sp)
  5c:	6442                	ld	s0,16(sp)
  5e:	64a2                	ld	s1,8(sp)
  60:	6105                	addi	sp,sp,32
  62:	8082                	ret

0000000000000064 &lt;.L2&gt;:
  64:	2585                	addiw	a1,a1,1
  66:	4601                	li	a2,0
  68:	b7d1                	j	2c &lt;.L5&gt;
            68: R_RISCV_RVC_JUMP	.L5

</pre>

<p>
reduction 的代码是由编译器直接生成的, 不需要调用 libgomp. 生成的代码和手写的不用
reduction 的代码 (例如 hello_openmp 中的 pi_parallel_for) 基本相同
</p>
</div>
</div>
</div>

<div id="outline-container-org0000040" class="outline-4">
<h4 id="org0000040"><span class="section-number-4">1.3.4.</span> task</h4>
<div class="outline-text-4" id="text-1-3-4">
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;omp.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
<span class="org-preprocessor">#pragma</span> omp parallel num_threads(2)
    {
<span class="org-preprocessor">#pragma</span> omp single
        {
<span class="org-preprocessor">#pragma</span> omp task
            printf(<span class="org-string">"%d\n"</span>, omp_get_thread_num());
<span class="org-preprocessor">#pragma</span> omp task
            printf(<span class="org-string">"%d\n"</span>, omp_get_thread_num());
        }
    }
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<pre class="example" id="org000003c">
0000000000000014 &lt;.L6&gt;:
  14:	4881                	li	a7,0
  16:	4801                	li	a6,0
  18:	4785                	li	a5,1
  1a:	4705                	li	a4,1
  1c:	4681                	li	a3,0
  1e:	4601                	li	a2,0
  20:	4581                	li	a1,0
  22:	00000517          	auipc	a0,0x0
            22: R_RISCV_PCREL_HI20	main._omp_fn.1
            22: R_RISCV_RELAX	*ABS*
  26:	00050513          	mv	a0,a0
            26: R_RISCV_PCREL_LO12_I	.L0 
            26: R_RISCV_RELAX	*ABS*
  2a:	e002                	sd	zero,0(sp)
  2c:	00000097          	auipc	ra,0x0
            2c: R_RISCV_CALL_PLT	GOMP_task
                                    ~~~~~~~~~
                                    GOMP_task(main._omp_fn.1)

            2c: R_RISCV_RELAX	*ABS*
  30:	000080e7          	jalr	ra # 2c &lt;.L6+0x18&gt;
  34:	4881                	li	a7,0
  36:	e002                	sd	zero,0(sp)
  38:	4801                	li	a6,0
  3a:	4785                	li	a5,1
  3c:	4705                	li	a4,1
  3e:	4681                	li	a3,0
  40:	4601                	li	a2,0
  42:	4581                	li	a1,0
  44:	00000517          	auipc	a0,0x0
            44: R_RISCV_PCREL_HI20	main._omp_fn.2
            44: R_RISCV_RELAX	*ABS*
  48:	00050513          	mv	a0,a0
            48: R_RISCV_PCREL_LO12_I	.L0 
            48: R_RISCV_RELAX	*ABS*
  4c:	00000097          	auipc	ra,0x0
            4c: R_RISCV_CALL_PLT	GOMP_task
                                    ~~~~~~~~~
                                    GOMP_task(main._omp_fn.1)

            4c: R_RISCV_RELAX	*ABS*
  50:	000080e7          	jalr	ra # 4c &lt;.L6+0x38&gt;
  54:	60e2                	ld	ra,24(sp)
  56:	6105                	addi	sp,sp,32
  58:	8082                	ret

000000000000005a &lt;main._omp_fn.1&gt;:
  5a:	1141                	addi	sp,sp,-16
  5c:	e406                	sd	ra,8(sp)
  5e:	00000097          	auipc	ra,0x0
            5e: R_RISCV_CALL_PLT	omp_get_thread_num
            5e: R_RISCV_RELAX	*ABS*
  62:	000080e7          	jalr	ra # 5e &lt;main._omp_fn.1+0x4&gt;
  66:	60a2                	ld	ra,8(sp)
  68:	862a                	mv	a2,a0
  6a:	00000597          	auipc	a1,0x0
            6a: R_RISCV_PCREL_HI20	.LC0
            6a: R_RISCV_RELAX	*ABS*
  6e:	00058593          	mv	a1,a1
            6e: R_RISCV_PCREL_LO12_I	.L0 
            6e: R_RISCV_RELAX	*ABS*
  72:	4505                	li	a0,1
  74:	0141                	addi	sp,sp,16
  76:	00000317          	auipc	t1,0x0
            76: R_RISCV_CALL_PLT	__printf_chk
            76: R_RISCV_RELAX	*ABS*
  7a:	00030067          	jr	t1 # 76 &lt;main._omp_fn.1+0x1c&gt;

000000000000007e &lt;main._omp_fn.2&gt;:
  7e:	00000317          	auipc	t1,0x0
            7e: R_RISCV_CALL	main._omp_fn.1
            7e: R_RISCV_RELAX	*ABS*
  82:	00030067          	jr	t1 # 7e &lt;main._omp_fn.2&gt;
</pre>

<p>
每个 task 对应一个单独的 main._omp_fn.x, 通过 GOMP_task 放在某个线程里执行
</p>
</div>

<div id="outline-container-org000003d" class="outline-5">
<h5 id="org000003d"><span class="section-number-5">1.3.4.1.</span> GOMP_task</h5>
<div class="outline-text-5" id="text-1-3-4-1">
<div class="org-src-container">
<pre class="src src-C"><span class="org-type">void</span> <span class="org-function-name">GOMP_task</span>(
    <span class="org-type">void</span> (*<span class="org-function-name">fn</span>)(<span class="org-type">void</span> *), <span class="org-type">void</span> *<span class="org-variable-name">data</span>, <span class="org-type">void</span> (*<span class="org-function-name">cpyfn</span>)(<span class="org-type">void</span> *, <span class="org-type">void</span> *),
    <span class="org-type">long</span> <span class="org-variable-name">arg_size</span>, <span class="org-type">long</span> <span class="org-variable-name">arg_align</span>, <span class="org-type">bool</span> <span class="org-variable-name">if_clause</span>, <span class="org-type">unsigned</span> <span class="org-variable-name">flags</span>,
    <span class="org-type">void</span> **<span class="org-variable-name">depend</span>, <span class="org-type">int</span> <span class="org-variable-name">priority_arg</span>, <span class="org-type">void</span> *<span class="org-variable-name">detach</span>):
  priority_queue_insert (PQ_TEAM, &amp;team-&gt;task_queue,
        task, priority,
        PRIORITY_INSERT_END,
        <span class="org-comment-delimiter">/*</span><span class="org-comment">adjust_parent_depends_on=</span><span class="org-comment-delimiter">*/</span><span class="org-constant">false</span>,
        task-&gt;parent_depends_on);
  gomp_team_barrier_set_task_pending (&amp;team-&gt;barrier);
  do_wake = team-&gt;task_running_count + <span class="org-negation-char">!</span>parent-&gt;in_tied_task &lt; team-&gt;nthreads;
  <span class="org-keyword">if</span> (do_wake) gomp_team_barrier_wake (&amp;team-&gt;barrier, 1);
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org0000046" class="outline-3">
<h3 id="org0000046"><span class="section-number-3">1.4.</span> Compiler Directive</h3>
</div>
</div>
</div>
<div id="postamble" class="status">

<p class="author">Author: sunway@dogdog.run<br />
Date: 2022-12-06 Tue 17:50<br />
Last updated: 2022-12-07 Wed 13:58</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
</div>
</body>
</html>
