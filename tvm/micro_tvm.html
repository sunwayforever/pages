<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>Micro TVM</title>


<link rel="stylesheet" type="text/css" href="/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="./htmlize.css"/>
<link rel="stylesheet" type="text/css" href="../htmlize.css"/>
<link rel="stylesheet" type="text/css" href="../../htmlize.css"/>
<link rel="stylesheet" type="text/css" href="/readtheorg.css"/>
<link rel="stylesheet" type="text/css" href="./readtheorg.css"/>
<link rel="stylesheet" type="text/css" href="../readtheorg.css"/>
<link rel="stylesheet" type="text/css" href="../../readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
<link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
<link rel="stylesheet" type="text/css" href="../main.css" media="screen" />
<link rel="stylesheet" type="text/css" href="../../main.css" media="screen" />
<link rel="stylesheet" type="text/css" href="./main.css" media="screen" />
<link rel = "icon" href = "/icon.png"  type = "image/x-icon">
</head>
<body>
<div id="content" class="content">
<h1 class="title">Micro TVM</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org000005c">1. Micro TVM</a>
<ul>
<li><a href="#org0000010">1.1. system-lib</a>
<ul>
<li><a href="#org0000000">1.1.1. The Problem of DSO</a></li>
<li><a href="#org0000009">1.1.2. C++ Runtime</a></li>
<li><a href="#org000000d">1.1.3. C Runtime</a></li>
</ul>
</li>
<li><a href="#org000001c">1.2. Static Deploy</a>
<ul>
<li><a href="#org0000013">1.2.1. C++ Runtime</a></li>
<li><a href="#org0000016">1.2.2. C Runtime</a></li>
<li><a href="#org0000019">1.2.3. 交叉编译</a></li>
</ul>
</li>
<li><a href="#org0000047">1.3. Micro TVM</a>
<ul>
<li><a href="#org0000028">1.3.1. Project API</a></li>
<li><a href="#org0000044">1.3.2. RPC</a></li>
</ul>
</li>
<li><a href="#org0000001">1.4. MicroTVM 与 AutoTVM</a>
<ul>
<li><a href="#org000004a">1.4.1. Impl</a></li>
</ul>
</li>
<li><a href="#org0000059">1.5. Micro TVM &amp; BYOC</a>
<ul>
<li><a href="#org0000050">1.5.1. system-lib &amp; c++ runtime 注册 __tvm_dev_mblob</a></li>
<li><a href="#org0000053">1.5.2. system-lib &amp; c runtime 不支持注册和解析 __tvm_dev_mblob</a></li>
<li><a href="#org0000056">1.5.3. ModulePackImportsToLLVM 的 Bug</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org000005c" class="outline-2">
<h2 id="org000005c"><span class="section-number-2">1.</span> Micro TVM</h2>
<div class="outline-text-2" id="text-1">
<p>
<code>tvm/docs/dev/microtvm_design.rst</code>
</p>
</div>

<div id="outline-container-org0000010" class="outline-3">
<h3 id="org0000010"><span class="section-number-3">1.1.</span> system-lib</h3>
<div class="outline-text-3" id="text-1-1">
</div>
<div id="outline-container-org0000000" class="outline-4">
<h4 id="org0000000"><span class="section-number-4">1.1.1.</span> The Problem of DSO</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
library 正常是通过 DSO 的形式保存, 并在运行时通过 dlsym 方式来查找符号,
system-lib 机制是为了解决有些系统不支持 dlopen, dlsym 的问题. 如果无法用 dlsym
来查找, 那用什么方式来找到 `tvmgen_default_fused_add`?
</p>

<p>
有两种方案: c++ runtime 或 c runtime
</p>
</div>
</div>

<div id="outline-container-org0000009" class="outline-4">
<h4 id="org0000009"><span class="section-number-4">1.1.2.</span> C++ Runtime</h4>
<div class="outline-text-4" id="text-1-1-2">
<div class="org-src-container">
<pre class="src src-ipython">import tvm
from tvm import relay

x = relay.var("x", shape=(1, 1000), dtype="float32")
y = relay.add(x, x)
func = relay.Function([x], y)
mod = tvm.IRModule.from_expr(func)
print(mod)

with tvm.transform.PassContext(opt_level=1):
    mod = relay.build(mod, target="llvm --system-lib --runtime=c++", params=None)

mod.lib.save("/tmp/a.o")
</pre>
</div>

<p>
def @main(%x: Tensor[(1, 1000), float32]) {
  add(%x, %x)
}
</p>

<div class="org-src-container">
<pre class="src src-shell">readelf -s /tmp/a.o
<span class="org-builtin">echo</span> <span class="org-string">"------"</span>
readelf -a /tmp/a.o|grep <span class="org-string">"Relocation section '.rela.ctors'"</span> -A 3
</pre>
</div>

<p>

</p>

<p>
Symbol table '.symtab' contains 14 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS TVMMod
     2: 0000000000000330    40 FUNC    LOCAL  DEFAULT    2 <span class="underline">_tvm_module_startup
     3: 0000000000000210   284 FUNC    LOCAL  DEFAULT    2 tvmgen_default_fused_add</span>
     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    2
     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5
     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    8
     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    9
     8: 0000000000000000     0 SECTION LOCAL  DEFAULT   10
     9: 0000000000000000     0 SECTION LOCAL  DEFAULT   19
    10: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND TVMAPISetLastError
    11: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND TVMBackendRegisterSystemL
    12: 0000000000000000     8 OBJECT  WEAK   DEFAULT    4 __tvm_module_ctx
    13: 0000000000000000   523 FUNC    GLOBAL DEFAULT    2 tvmgen_default_fused_add
</p>
<hr />
<p>
Relocation section '.rela.ctors' at offset 0x1228 contains 1 entry:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000000  000400000001 R_X86_64_64       0000000000000000 .text + 330
</p>

<p>
相比没有加 system-lib 的情形, a.o 多了几个 symbol:
</p>

<ol class="org-ol">
<li><p>
__tvm_module_startup
</p>

<p>
利用 elf 的 ctor 在应用启动时调用 __tvm_module_startup
</p></li>

<li><p>
TVMBackendRegisterSystemLibSymbol
</p>

<p>
__tvm_module_startup 的代码会通过
TVMBackendRegisterSystemLibSymbol("tvmgen_default_fused_add",tvmgen_default_fused_add)
的方式把 tvmgen_default_fused_add 函数注册到一个 runtime 负责的全局的 `SystemLibrary` 上
</p></li>
</ol>
</div>

<div id="outline-container-org0000003" class="outline-5">
<h5 id="org0000003"><span class="section-number-5">1.1.2.1.</span> __tvm_module_startup</h5>
<div class="outline-text-5" id="text-1-1-2-1">
<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">void</span> <span class="org-constant">CodeGenCPU</span>::<span class="org-function-name">AddStartupFunction</span>() {
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>target_c_runtime_) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#26500;&#36896; __tvm_module_startup &#20989;&#25968;</span>
    function_ = <span class="org-constant">llvm</span>::<span class="org-constant">Function</span>::Create(ftype, <span class="org-constant">llvm</span>::<span class="org-constant">Function</span>::InternalLinkage,
                                       <span class="org-string">"__tvm_module_startup"</span>, module_.get());
    <span class="org-constant">llvm</span>::<span class="org-type">BasicBlock</span>* <span class="org-variable-name">startup_entry</span> = <span class="org-constant">llvm</span>::<span class="org-constant">BasicBlock</span>::Create(*ctx_, <span class="org-string">"entry"</span>, function_);
    <span class="org-comment-delimiter">// </span><span class="org-comment">__tvm_module_startup &#35843;&#29992; f_tvm_register_system_symbol_</span>
    <span class="org-keyword">for</span> (<span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">kv</span> : export_system_symbols_) {
      builder_-&gt;CreateCall(f_tvm_register_system_symbol_,
                           {name, builder_-&gt;CreateBitCast(kv.second, t_void_p_)});
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#25226; __tvm_module_startup &#21152;&#21040; elf &#30340; .ctor &#20013;</span>
    <span class="org-constant">llvm</span>::appendToGlobalCtors(*module_, function_, 65535);
  }
}

f_tvm_register_system_symbol_ = <span class="org-constant">llvm</span>::<span class="org-constant">Function</span>::Create(
    <span class="org-constant">llvm</span>::<span class="org-constant">FunctionType</span>::get(t_int_, {t_char_-&gt;getPointerTo(), t_void_p_}, <span class="org-constant">false</span>),
    <span class="org-constant">llvm</span>::<span class="org-constant">Function</span>::ExternalLinkage, <span class="org-string">"TVMBackendRegisterSystemLibSymbol"</span>, module_.get());
</pre>
</div>

<p>
对应生成的代码为:
</p>

<div class="org-src-container">
<pre class="src src-asm"><span class="org-function-name">.text</span>:0000000000000340 __tvm_module_startup proc near          <span class="org-comment-delimiter">; </span><span class="org-comment">DATA XREF: .ctors:0000000000000D50</span>
<span class="org-function-name">.text</span>:0000000000000340                 push    rax
<span class="org-function-name">.text</span>:0000000000000341                 lea     rdi, a__tvm_module_c <span class="org-comment-delimiter">; </span><span class="org-comment">"__tvm_module_ctx"</span>
<span class="org-function-name">.text</span>:0000000000000348                 mov     rsi, cs:__tvm_module_ctx_ptr
<span class="org-function-name">.text</span>:000000000000034F                 call    TVMBackendRegisterSystemLibSymbol <span class="org-comment-delimiter">; </span><span class="org-comment">PIC mode</span>
<span class="org-function-name">.text</span>:0000000000000354                 lea     rdi, aTvmgen_default <span class="org-comment-delimiter">; </span><span class="org-comment">"tvmgen_default_fused_add"</span>
<span class="org-function-name">.text</span>:000000000000035B                 mov     rsi, cs:tvmgen_default_fused_add_ptr
<span class="org-function-name">.text</span>:0000000000000362                 pop     rax
<span class="org-function-name">.text</span>:0000000000000363
<span class="org-function-name">.text</span>:0000000000000363 loc_363:                                <span class="org-comment-delimiter">; </span><span class="org-comment">DATA XREF: .eh_frame:0000000000000D78</span>
<span class="org-function-name">.text</span>:0000000000000363                 jmp     TVMBackendRegisterSystemLibSymbol <span class="org-comment-delimiter">; </span><span class="org-comment">PIC mode</span>
<span class="org-function-name">.text</span>:0000000000000363 __tvm_module_startup endp
</pre>
</div>
</div>
</div>

<div id="outline-container-org0000006" class="outline-5">
<h5 id="org0000006"><span class="section-number-5">1.1.2.2.</span> TVMBackendRegisterSystemLibSymbol</h5>
<div class="outline-text-5" id="text-1-1-2-2">
<p>
TVMBackendRegisterSystemLibSymbol 是 tvm runtime 提供的函数
</p>

<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">int</span> <span class="org-function-name">TVMBackendRegisterSystemLibSymbol</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span>, <span class="org-type">void</span>* <span class="org-variable-name">ptr</span>) {
  <span class="org-constant">tvm</span>::<span class="org-constant">runtime</span>::<span class="org-constant">SystemLibrary</span>::Global()-&gt;RegisterSymbol(name, ptr);
  <span class="org-keyword">return</span> 0;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">system_library.cc</span>
<span class="org-type">void</span> <span class="org-function-name">RegisterSymbol</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span>, <span class="org-type">void</span>* <span class="org-variable-name">ptr</span>) {
    <span class="org-constant">std</span>::<span class="org-type">lock_guard</span>&lt;<span class="org-constant">std</span>::mutex&gt; <span class="org-variable-name">lock</span>(mutex_);
    <span class="org-keyword">auto</span> <span class="org-variable-name">it</span> = tbl_.find(name);
    <span class="org-keyword">if</span> (it != tbl_.end() &amp;&amp; ptr != it-&gt;second) {
      LOG(WARNING) &lt;&lt; <span class="org-string">"SystemLib symbol "</span> &lt;&lt; name &lt;&lt; <span class="org-string">" get overriden to a different address "</span> &lt;&lt; ptr
                   &lt;&lt; <span class="org-string">"-&gt;"</span> &lt;&lt; it-&gt;second;
    }
    tbl_[name] = ptr;
  }

</pre>
</div>

<p>
SystemLibrary 并是不是一个真正的 `library`: 它的 RegisterSymbol 只是保存了一个
symbol -&gt; function 的 mapping, 但它与 DSOLibrary 一样提供了 GetSymbol 接口:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">void</span>* <span class="org-function-name">GetSymbol</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span>) <span class="org-keyword">final</span> {
    <span class="org-constant">std</span>::<span class="org-type">lock_guard</span>&lt;<span class="org-constant">std</span>::mutex&gt; <span class="org-variable-name">lock</span>(mutex_);
    <span class="org-keyword">auto</span> <span class="org-variable-name">it</span> = tbl_.find(name);
    <span class="org-keyword">if</span> (it != tbl_.end()) {
        <span class="org-keyword">return</span> it-&gt;second;
    } <span class="org-keyword">else</span> {
        <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>;
    }
}
</pre>
</div>

<p>
有了这个全局的 SystemLibrary 做为 registry, 便不再需要依赖 dso 的 dlsym 了
</p>
</div>
</div>
</div>

<div id="outline-container-org000000d" class="outline-4">
<h4 id="org000000d"><span class="section-number-4">1.1.3.</span> C Runtime</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
当 TVM 需要跑在开发板上时，会有几个问题：
</p>

<ol class="org-ol">
<li>板子可能没有支持 ctor 的环境</li>
<li>板子上关于内存分配，log 等功能需要有特定的实现</li>
</ol>

<p>
为此，TVM 以提出一个 c runtime.
</p>

<p>
c runtime 的目标场景是那些无法支持 ctor (即 .init/.init_array) 的环境, 例如不支持 rtld 或没有 startfiles 的情况 <a href="toolchain/elf.html#org0000023">init_array 如何被调用</a>
</p>

<p>
c runtime 无法利用 ctor 来注册 mapping, 所以它实现了一个函数
`TVMSystemLibEntryPoint`, 这个函数会返回一个包含 {names, functions} 的结构体,用来初始化 SystemLib
</p>

<p>
C Runtime 会利用 tvm::codegen::CreateMetadataModule 完成与 c++ 的 __tvm_module_startup 类似的功能.
</p>

<p>
<code>tvm/src/relay/backend/build_module.cc::ret_.mod = tvm::codegen::CreateMetadataModule(ret_.params, ret_.mod, ext_mods, GetTargetHost(),</code>
</p>

<div class="org-src-container">
<pre class="src src-ipython">import tvm
from tvm import relay

x = relay.var("x", shape=(1, 1000), dtype="float32")
y = relay.add(x, x)
func = relay.Function([x], y)
mod = tvm.IRModule.from_expr(func)

with tvm.transform.PassContext(opt_level=1):
    mod = relay.build(mod, target="llvm  --system-lib --runtime=c", params=None)

mod.lib.export_library("/tmp/a.tar")

</pre>
</div>

<div class="org-src-container">
<pre class="src src-shell">tar zxvf /tmp/a.tar
<span class="org-builtin">echo</span> <span class="org-string">"------lib0.o"</span>
readelf -s /tmp/lib0.o
<span class="org-builtin">echo</span> <span class="org-string">"------lib1.o"</span>
readelf -s /tmp/lib1.o
</pre>
</div>

<p>
lib0.o
devc.o
lib1.o
-&#x2013;&#x2014;lib0.o
</p>

<p>
Symbol table '.symtab' contains 15 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS TVMMetadataMod
     2: 0000000000000008    16 OBJECT  LOCAL  DEFAULT    4 _tvm_crt_func_registry
     3: 0000000000000018     8 OBJECT  LOCAL  DEFAULT    4 _tvm_crt_module
     4: 0000000000000000     8 OBJECT  LOCAL  DEFAULT    4 _tvm_func_registry_ptrs
     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    2
     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    4
     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    6
     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    7
     9: 0000000000000000     0 SECTION LOCAL  DEFAULT    8
    10: 0000000000000000     0 SECTION LOCAL  DEFAULT    9
    11: 0000000000000000     0 SECTION LOCAL  DEFAULT   16
    12: 0000000000000000     0 SECTION LOCAL  DEFAULT   18
    13: 0000000000000000     8 FUNC    GLOBAL DEFAULT    2 TVMSystemLibEntryPoint
    14: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND tvmgen_default_fused_add
-&#x2013;&#x2014;lib1.o
</p>

<p>
Symbol table '.symtab' contains 11 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS TVMMod
     2: 0000000000000210   284 FUNC    LOCAL  DEFAULT    2 tvmgen_default_fused_add_
     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    2
     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4
     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5
     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    6
     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    7
     8: 0000000000000000     0 SECTION LOCAL  DEFAULT   16
     9: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND TVMAPISetLastError
    10: 0000000000000000   523 FUNC    GLOBAL DEFAULT    2 tvmgen_default_fused_add
</p>

<ul class="org-ul">
<li>lib1.o 有 tvmgen_default_fused_add 的实现</li>
<li>lib0.o 中的 TVMSystemLibEntryPoint 是用来返回 {"names",funcs} 的数据的</li>
</ul>


<div id="org000000c" class="figure">
<p><img src="../extra/tvm_c_runtime_reg.png" alt="tvm_c_runtime_reg.png" />
</p>
</div>

<p>
图中的 unk_28 实际上就是指向 .rodata 上的字符串 "tvmgen_default_fused_add", 所以
lib0.o 中的 TVMSystemLibEntryPoint 最终会返回
</p>

<p>
{"tvmgen_default_fused_add", tvmgen_default_fused_add}
</p>

<div class="org-src-container">
<pre class="src src-c++"><span class="org-comment-delimiter">// </span><span class="org-comment">crt_runtime_api.c</span>
<span class="org-type">int</span> <span class="org-function-name">SystemLibraryCreate</span>(<span class="org-type">TVMValue</span>* <span class="org-variable-name">args</span>, <span class="org-type">int</span>* <span class="org-variable-name">type_codes</span>, <span class="org-type">int</span> <span class="org-variable-name">num_args</span>, <span class="org-type">TVMValue</span>* <span class="org-variable-name">ret_val</span>,
                        <span class="org-type">int</span>* <span class="org-variable-name">ret_type_codes</span>) {

  <span class="org-keyword">const</span> <span class="org-type">TVMModule</span>* <span class="org-variable-name">system_lib</span>;
  system_lib = TVMSystemLibEntryPoint();
  TVMModCreateFromCModule(system_lib, &amp;system_lib_handle);

  ret_val[0].v_handle = system_lib_handle;
  ret_type_codes[0] = kTVMModuleHandle;
  <span class="org-keyword">return</span> 0;
}

</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org000001c" class="outline-3">
<h3 id="org000001c"><span class="section-number-3">1.2.</span> Static Deploy</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-org0000013" class="outline-4">
<h4 id="org0000013"><span class="section-number-4">1.2.1.</span> C++ Runtime</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
<a href="file:///home/sunway/Gitbox/code/hello_world/hello_tvm/cpp_runtime">file:~/Gitbox/code/hello_world/hello_tvm/cpp_runtime</a>
</p>
</div>
</div>

<div id="outline-container-org0000016" class="outline-4">
<h4 id="org0000016"><span class="section-number-4">1.2.2.</span> C Runtime</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
<a href="file:///home/sunway/Gitbox/code/hello_world/hello_tvm/c_runtime">file:~/Gitbox/code/hello_world/hello_tvm/c_runtime</a>
</p>
</div>
</div>

<div id="outline-container-org0000019" class="outline-4">
<h4 id="org0000019"><span class="section-number-4">1.2.3.</span> 交叉编译</h4>
<div class="outline-text-4" id="text-1-2-3">
<ol class="org-ol">
<li><p>
在 target 中使用 mtriple, mcpu 指定, 由 llvm 负责交叉编译.
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">mod</span> <span class="org-operator">=</span> relay.build(
    mod,
    target<span class="org-operator">=</span><span class="org-string">"llvm  --system-lib --runtime=c, -mtriple=armv8l-linux-gnueabihf -mcpu=cortex-m7"</span>,
    params<span class="org-operator">=</span><span class="org-constant">None</span>,
)
</pre>
</div></li>

<li><p>
使用 c target, 生成 c 代码后自己做交叉编译
</p>

<p>
但看起来 c target 没有生成向量化的代码
</p></li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org0000047" class="outline-3">
<h3 id="org0000047"><span class="section-number-3">1.3.</span> Micro TVM</h3>
<div class="outline-text-3" id="text-1-3">
<p>
使用 c_runtime + system_lib, 已经可以编译出一个静态链接的可以在 mcu 上运行的实例了, 实际上 tvm.target.target.micro("stm32f746xx") 返回的 target 字符串基本上为:
"c -system-lib -runtime=c -mcpu=cortex-m7"
</p>

<p>
更多 Micro TVM 相关的内容和 RPC 有关, 即 host 的 python 代码可以像本地模型一样用
graph_runner 运行 mcu 上的实例.
<a href="https://tvm.apache.org/docs/tutorials/micro/micro_tflite.html?highlight=microtvm">https://tvm.apache.org/docs/tutorials/micro/micro_tflite.html?highlight=microtvm</a>
</p>

<p>
<del>具体的</del>
</p>

<ol class="org-ol">
<li><del>用户需要自己提供一个 tvm.micro.Compiler 的实现, 用来把 tvm 编译生成的 c 代码</del>
<del>编译成最终在 mcu 上执行的 bin. 因为 Micro TVM 期望用户自己实现 Compiler 来生</del>
<del>成最终的 bin, 所以 tvm.target.target.micro 使用的 target 是 "c", 而不是</del>
<del>"llvm"</del></li>

<li><del>用户需要自己提供一个 tvm.micro.Flasher, 同时需要自己提供一个</del>
<del>tvm.micro.Transport. 在 host 上用 Flasher 把 bin flash 到 mcu 上, 用</del>
<del>Transport控制 mcu 的执行并拿到结果. host 端的 Transport 需要与 mcu 上的</del>
<del>MicroRPCServer进行通信, 并在通信的基础上封装成一个 RPC 服务, 以便 host 以通过</del>
<del>RPC 直接在mcu 上执行代码.</del></li>
</ol>

<p>
新的 TVM 代码把 Compiler, Flasher, Transport 功能重写了 Project API, 功能与之前的类似
<code>tvm/python/tvm/micro/project.py</code>
</p>

<p>
<a href="https://tvm.apache.org/docs/dev/microtvm_design.html?highlight=microtvm%20design">https://tvm.apache.org/docs/dev/microtvm_design.html?highlight=microtvm%20design</a>
</p>
</div>

<div id="outline-container-org0000028" class="outline-4">
<h4 id="org0000028"><span class="section-number-4">1.3.1.</span> Project API</h4>
<div class="outline-text-4" id="text-1-3-1">
</div>
<div id="outline-container-org000001f" class="outline-5">
<h5 id="org000001f"><span class="section-number-5">1.3.1.1.</span> Overview</h5>
<div class="outline-text-5" id="text-1-3-1-1">
<p>
Project API 要求每个板子提供一个 template_project_dir, 例如:
</p>

<p>
tvm/build/standalone_crt/template/host
tvm/apps/microtvm/zephyr/template_project
</p>

<p>
每个 template dir 都需要有一个 microtvm_api_server.py, 这个模块以 popen+pipe 的形式对外提供 build, flash, transport 等功能. 另外, build 时编译出来的 bin 需要在代码中调用 MicroTVMRpcServerLoop 以启动 microtvm RPC server
</p>

<p>
有了这个抽象的 project, TVM 可以:
</p>

<ol class="org-ol">
<li>用 host-driven 的方式在板子上执行 MicroTVM model</li>
<li>使 MicroTVM 支持 AutoTVM</li>
</ol>
</div>
</div>

<div id="outline-container-org0000022" class="outline-5">
<h5 id="org0000022"><span class="section-number-5">1.3.1.2.</span> Example</h5>
<div class="outline-text-5" id="text-1-3-1-2">
<p>
<code>tvm/gallery/how_to/work_with_microtvm/micro_autotune.py</code>
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> tvm
<span class="org-keyword">from</span> tvm <span class="org-keyword">import</span> relay

<span class="org-keyword">import</span> tempfile


<span class="org-keyword">def</span> <span class="org-function-name">get_model</span>():
    <span class="org-variable-name">x</span> <span class="org-operator">=</span> relay.var(<span class="org-string">"x"</span>, relay.TensorType([1, 10], <span class="org-string">"float32"</span>))
    <span class="org-variable-name">y</span> <span class="org-operator">=</span> relay.add(x, x)
    <span class="org-variable-name">f</span> <span class="org-operator">=</span> relay.Function([x], y)

    <span class="org-variable-name">relay_mod</span> <span class="org-operator">=</span> tvm.IRModule.from_expr(f)
    <span class="org-variable-name">relay_mod</span> <span class="org-operator">=</span> relay.transform.InferType()(relay_mod)
    <span class="org-keyword">return</span> relay_mod


<span class="org-keyword">def</span> <span class="org-function-name">run_model</span>():
    <span class="org-variable-name">relay_mod</span> <span class="org-operator">=</span> get_model()
    <span class="org-keyword">with</span> tvm.transform.PassContext(opt_level<span class="org-operator">=</span>3, config<span class="org-operator">=</span>{<span class="org-string">"tir.disable_vectorize"</span>: <span class="org-constant">True</span>}):
        <span class="org-variable-name">model</span> <span class="org-operator">=</span> relay.build(
            relay_mod, target<span class="org-operator">=</span>tvm.target.target.micro(<span class="org-string">"host"</span>), params<span class="org-operator">=</span><span class="org-constant">None</span>
        )

    <span class="org-variable-name">project</span> <span class="org-operator">=</span> tvm.micro.generate_project(
        <span class="org-string">"/home/sunway/source/tvm/build/standalone_crt/template/host"</span>,
        model,
        tempfile.TemporaryDirectory().name,
    )

    project.build()
    project.flash()

    <span class="org-keyword">with</span> tvm.micro.Session(project.transport()) <span class="org-keyword">as</span> session:
        <span class="org-variable-name">debug_module</span> <span class="org-operator">=</span> tvm.micro.create_local_debug_executor(
            model.get_graph_json(), session.get_system_lib(), session.device
        )
        debug_module.set_input(<span class="org-string">"x"</span>, np.ones((1, 10)))
        debug_module.run()
        <span class="org-builtin">print</span>(debug_module.get_output(0))


<span class="org-keyword">if</span> <span class="org-builtin">__name__</span> <span class="org-operator">==</span> <span class="org-string">"__main__"</span>:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Project API &#21487;&#20197;&#29992;&#26469;&#22312; pc &#19978;&#36828;&#31243;&#22312;&#26495;&#23376;&#19978;&#25191;&#34892; model</span>
    run_model()
</pre>
</div>

<p>
Node Name                 Ops                       Time(us)  Time(%)  Shape    Inputs  Outputs  
----&#x2013;&#x2014;                 &#x2014;                       ---&#x2013;&#x2014;  --&#x2013;&#x2014;  &#x2013;&#x2014;    -&#x2013;&#x2014;  --&#x2013;&#x2014;  
tvmgen_default_fused_add  tvmgen_default_fused_add  0.0       100.0    (1, 10)  1       1        
Total_time                -                         0.0       -        -        -       -        

</p>
</div>
</div>

<div id="outline-container-org0000025" class="outline-5">
<h5 id="org0000025"><span class="section-number-5">1.3.1.3.</span> Impl</h5>
<div class="outline-text-5" id="text-1-3-1-3">
<p>
Project API 对外提供的主要接口是 generate_project, host-driven 时会直接调用该接口, AutoTVM 使用的 AutoTvmModuleLoader 也需要调用该接口
</p>

<ol class="org-ol">
<li><p>
使用 popen 方式启动 template_project_dir 中的 microtvm_api_server.py 做为 client
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">generate_project</span>(
    template_project_dir: Union[pathlib.Path, <span class="org-builtin">str</span>],
    module: ExportableModule,
    generated_project_dir: Union[pathlib.Path, <span class="org-builtin">str</span>],
    options: <span class="org-builtin">dict</span> <span class="org-operator">=</span> <span class="org-constant">None</span>,
):
    <span class="org-variable-name">template</span> <span class="org-operator">=</span> TemplateProject.from_directory(<span class="org-builtin">str</span>(template_project_dir))
    <span class="org-keyword">return</span> template.generate_project(module, <span class="org-builtin">str</span>(generated_project_dir), options)


<span class="org-keyword">class</span> <span class="org-type">TemplateProject</span>:
    @<span class="org-builtin">classmethod</span>
    <span class="org-keyword">def</span> <span class="org-function-name">from_directory</span>(cls, template_project_dir):
        <span class="org-keyword">return</span> cls(client.instantiate_from_dir(template_project_dir))

<span class="org-comment-delimiter"># </span><span class="org-comment">&#22312; template_project_dir &#26159;&#26597;&#25214; microtvm_api_server.py &#25110;</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">launch_microtvm_api_server.sh&#29992; popen &#21551;&#21160;&#19968;&#20010;&#23376;&#36827;&#31243;&#25191;&#34892;&#36825;&#20010; script, &#36825;&#20010;</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">script &#20250;&#22312;&#19968;&#20010; while loop &#20013;&#31561;&#24453;&#21518;&#32493;&#21629;&#20196;, &#27604;&#22914; generate_project</span>

<span class="org-keyword">def</span> <span class="org-function-name">instantiate_from_dir</span>(project_dir: typing.Union[pathlib.Path, <span class="org-builtin">str</span>], debug: <span class="org-builtin">bool</span> <span class="org-operator">=</span> <span class="org-constant">False</span>):
    <span class="org-variable-name">args</span> <span class="org-operator">=</span> <span class="org-constant">None</span>
    <span class="org-variable-name">project_dir</span> <span class="org-operator">=</span> pathlib.Path(project_dir)

    <span class="org-variable-name">python_script</span> <span class="org-operator">=</span> project_dir <span class="org-operator">/</span> SERVER_PYTHON_FILENAME
    <span class="org-keyword">if</span> python_script.is_file():
        <span class="org-variable-name">args</span> <span class="org-operator">=</span> [sys.executable, <span class="org-builtin">str</span>(python_script)]

    <span class="org-variable-name">launch_script</span> <span class="org-operator">=</span> project_dir <span class="org-operator">/</span> SERVER_LAUNCH_SCRIPT_FILENAME
    <span class="org-keyword">if</span> launch_script.is_file():
        <span class="org-variable-name">args</span> <span class="org-operator">=</span> [<span class="org-builtin">str</span>(launch_script)]

    <span class="org-variable-name">api_server_read_fd</span>, <span class="org-variable-name">tvm_write_fd</span> <span class="org-operator">=</span> os.pipe()
    <span class="org-variable-name">tvm_read_fd</span>, <span class="org-variable-name">api_server_write_fd</span> <span class="org-operator">=</span> os.pipe()

    args.extend([<span class="org-string">"--read-fd"</span>, <span class="org-builtin">str</span>(api_server_read_fd), <span class="org-string">"--write-fd"</span>, <span class="org-builtin">str</span>(api_server_write_fd)])
    <span class="org-variable-name">api_server_proc</span> <span class="org-operator">=</span> subprocess.Popen(  <span class="org-comment-delimiter"># </span><span class="org-comment">pylint: disable=unused-variable</span>
        args, bufsize<span class="org-operator">=</span>0, pass_fds<span class="org-operator">=</span>(api_server_read_fd, api_server_write_fd), cwd<span class="org-operator">=</span>project_dir
    )
    os.close(api_server_read_fd)
    os.close(api_server_write_fd)

    <span class="org-keyword">return</span> ProjectAPIClient(
        os.fdopen(tvm_read_fd, <span class="org-string">"rb"</span>, buffering<span class="org-operator">=</span>0), os.fdopen(tvm_write_fd, <span class="org-string">"wb"</span>, buffering<span class="org-operator">=</span>0)
    )

</pre>
</div></li>

<li><p>
通过调用 client 的 generate_project 生成新的 GeneratedProject 目录
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">&#20808; export_model_library, &#28982;&#21518;&#35843;&#29992; client &#30340; generate_project</span>
<span class="org-keyword">def</span> <span class="org-function-name">generate_project</span>(<span class="org-keyword">self</span>, graph_executor_factory, project_dir, options):
    <span class="org-variable-name">model_library_dir</span> <span class="org-operator">=</span> utils.tempdir()
    <span class="org-variable-name">model_library_format_path</span> <span class="org-operator">=</span> model_library_dir.relpath(<span class="org-string">"model.tar"</span>)
    export_model_library_format(graph_executor_factory, model_library_format_path)

    <span class="org-keyword">return</span> <span class="org-keyword">self</span>.generate_project_from_mlf(model_library_format_path, project_dir, options)


<span class="org-keyword">def</span> <span class="org-function-name">generate_project_from_mlf</span>(<span class="org-keyword">self</span>, model_library_format_path, project_dir, options):
    <span class="org-keyword">self</span>._api_client.generate_project(
        model_library_format_path<span class="org-operator">=</span><span class="org-builtin">str</span>(model_library_format_path),
        standalone_crt_dir<span class="org-operator">=</span>get_standalone_crt_dir(),
        project_dir<span class="org-operator">=</span>project_dir,
        options<span class="org-operator">=</span>options,
    )
    <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">_api_client &#30340; generate_project (&#20197; host &#30340; microtvm_api_server.py &#20026;&#20363;), &#23454;&#38469;</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">&#23601;&#26159;&#22797;&#21046;&#20102;&#19968;&#22534;&#25991;&#20214;&#21040; GeneratedProject &#30446;&#24405;</span>
<span class="org-keyword">def</span> <span class="org-function-name">generate_project</span>(<span class="org-keyword">self</span>, model_library_format_path, standalone_crt_dir, project_dir, options):
    shutil.copy2(__file__, project_dir <span class="org-operator">/</span> os.path.basename(__file__))

    <span class="org-variable-name">project_model_library_format_path</span> <span class="org-operator">=</span> project_dir <span class="org-operator">/</span> MODEL_LIBRARY_FORMAT_RELPATH
    shutil.copy2(model_library_format_path, project_model_library_format_path)

    <span class="org-variable-name">extract_path</span> <span class="org-operator">=</span> project_dir <span class="org-operator">/</span> project_model_library_format_path.stem
    <span class="org-keyword">with</span> tarfile.TarFile(project_model_library_format_path) <span class="org-keyword">as</span> tf:
        os.makedirs(extract_path)
        tf.extractall(path<span class="org-operator">=</span>extract_path)

    <span class="org-variable-name">crt_path</span> <span class="org-operator">=</span> project_dir <span class="org-operator">/</span> <span class="org-string">"crt"</span>
    os.mkdir(crt_path)
    <span class="org-keyword">for</span> item <span class="org-keyword">in</span> <span class="org-keyword">self</span>.CRT_COPY_ITEMS:
        <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Populate Makefile.</span>
    shutil.copy2(pathlib.Path(__file__).parent <span class="org-operator">/</span> <span class="org-string">"Makefile"</span>, project_dir <span class="org-operator">/</span> <span class="org-string">"Makefile"</span>)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Populate crt-config.h</span>
    <span class="org-variable-name">crt_config_dir</span> <span class="org-operator">=</span> project_dir <span class="org-operator">/</span> <span class="org-string">"crt_config"</span>
    crt_config_dir.mkdir()
    shutil.copy2(
        os.path.join(os.path.dirname(__file__), <span class="org-string">".."</span>, <span class="org-string">"crt_config-template.h"</span>),
        os.path.join(crt_config_dir, <span class="org-string">"crt_config.h"</span>),
    )

    <span class="org-comment-delimiter"># </span><span class="org-comment">Populate src/</span>
    <span class="org-variable-name">src_dir</span> <span class="org-operator">=</span> os.path.join(project_dir, <span class="org-string">"src"</span>)
    os.mkdir(src_dir)
    shutil.copy2(
        os.path.join(os.path.dirname(__file__), <span class="org-string">"main.cc"</span>), os.path.join(src_dir, <span class="org-string">"main.cc"</span>)
    )

</pre>
</div></li>

<li><p>
generate_project 完成后使用 GeneratedProject 目录中的 microtvm_api_server.py 做为新的 client
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">generate_project_from_mlf</span>(<span class="org-keyword">self</span>, model_library_format_path, project_dir, options):
    <span class="org-keyword">self</span>._api_client.generate_project(
        <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
    )

    <span class="org-keyword">return</span> GeneratedProject.from_directory(project_dir, options)
</pre>
</div></li>

<li>可以通过最后获得的 project 完成 build, flash, transport 等功能</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org0000044" class="outline-4">
<h4 id="org0000044"><span class="section-number-4">1.3.2.</span> RPC</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
RPC 的结构为:
</p>

<pre class="example" id="org000002b">
                                         |
Session (Flasher/Transport) [python]     |
   -&gt; RPCSession [c++]                   |
     -&gt; MicroTransportChannel [c++]      -&gt;   MicroTVMRpcServerLoop
                                         |        -&gt; Session
                                         |           -&gt; MinRPCServer
                                         |               -&gt; HandleNormalCallFunc, ...
                                         |
</pre>
</div>

<div id="outline-container-org0000041" class="outline-5">
<h5 id="org0000041"><span class="section-number-5">1.3.2.1.</span> RPC Impl</h5>
<div class="outline-text-5" id="text-1-3-2-1">
</div>
<div id="outline-container-org0000032" class="outline-6">
<h6 id="org0000032"><span class="section-number-6">1.3.2.1.1.</span> Client</h6>
<div class="outline-text-6" id="text-1-3-2-1-1">
</div>
<ol class="org-ol">
<li><a id="org000002c"></a>初始化 session<br />
<div class="outline-text-7" id="text-1-3-2-1-1-1">
<div class="org-src-container">
<pre class="src src-python">tvm.micro.Session(binary<span class="org-operator">=</span>micro_binary, flasher<span class="org-operator">=</span>flasher)
    <span class="org-keyword">def</span> <span class="org-function-name">Session</span>.__enter__(<span class="org-keyword">self</span>):
        <span class="org-keyword">self</span>.<span class="org-variable-name">transport_context_manager</span> <span class="org-operator">=</span> <span class="org-keyword">self</span>.flasher.flash(<span class="org-keyword">self</span>.binary)

        <span class="org-keyword">self</span>.<span class="org-variable-name">transport</span> <span class="org-operator">=</span> TransportLogger(
            <span class="org-keyword">self</span>.session_name, <span class="org-keyword">self</span>.transport_context_manager, level<span class="org-operator">=</span>logging.DEBUG
        ).__enter__()

        <span class="org-keyword">self</span>.<span class="org-variable-name">_rpc</span> <span class="org-operator">=</span> RPCSession(
            _rpc_connect(
                <span class="org-keyword">self</span>.session_name,
                <span class="org-keyword">self</span>._wrap_transport_write,
                <span class="org-keyword">self</span>._wrap_transport_read,
                <span class="org-builtin">int</span>(timeouts.session_start_retry_timeout_sec <span class="org-operator">*</span> 1e6),
                <span class="org-builtin">int</span>(timeouts.session_start_timeout_sec <span class="org-operator">*</span> 1e6),
                <span class="org-builtin">int</span>(timeouts.session_established_timeout_sec <span class="org-operator">*</span> 1e6),
            )
        )

<span class="org-comment-delimiter"># </span><span class="org-comment">&#20854;&#20013; _wrap_transport_write, _wrap_transport_read &#26159;&#23545; transport &#30340;&#31616;&#21333;&#23553;&#35013;</span>

<span class="org-keyword">def</span> <span class="org-function-name">_wrap_transport_read</span>(<span class="org-keyword">self</span>, n, timeout_microsec):
    <span class="org-keyword">return</span> <span class="org-keyword">self</span>.transport.read(
        n, <span class="org-builtin">float</span>(timeout_microsec) <span class="org-operator">/</span> 1e6 <span class="org-keyword">if</span> timeout_microsec <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span> <span class="org-keyword">else</span> <span class="org-constant">None</span>
    )    


<span class="org-keyword">def</span> <span class="org-function-name">_wrap_transport_write</span>(<span class="org-keyword">self</span>, data, timeout_microsec):
    <span class="org-keyword">return</span> <span class="org-keyword">self</span>.transport.write(
        data, <span class="org-builtin">float</span>(timeout_microsec) <span class="org-operator">/</span> 1e6 <span class="org-keyword">if</span> timeout_microsec <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span> <span class="org-keyword">else</span> <span class="org-constant">None</span>
    )    


TVM_REGISTER_GLOBAL(<span class="org-string">"micro._rpc_connect"</span>).set_body([](TVMArgs args, TVMRetValue<span class="org-operator">*</span> rv) {
  MicroTransportChannel<span class="org-operator">*</span> micro_channel <span class="org-operator">=</span>
      new MicroTransportChannel(args[1], args[2], ::std::chrono::microseconds(uint64_t(args[3])),
                                ::std::chrono::microseconds(uint64_t(args[4])),
                                ::std::chrono::microseconds(uint64_t(args[5])));
  std::unique_ptr<span class="org-operator">&lt;</span>RPCChannel<span class="org-operator">&gt;</span> channel(micro_channel);
  auto ep <span class="org-operator">=</span> RPCEndpoint::Create(std::move(channel), args[0], <span class="org-string">""</span>);
  auto sess <span class="org-operator">=</span> CreateClientSession(ep);
  <span class="org-operator">*</span>rv <span class="org-operator">=</span> CreateRPCSessionModule(sess);
});
</pre>
</div>
</div>
</li>

<li><a id="org000002f"></a>调用 session.get_system_lib<br />
<div class="outline-text-7" id="text-1-3-2-1-1-2">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">session</span>.get_system_lib(<span class="org-keyword">self</span>):
    <span class="org-keyword">return</span> <span class="org-keyword">self</span>._rpc.get_function(<span class="org-string">"runtime.SystemLib"</span>)()

PackedFunc RPCModuleNode::GetFunction(const std::string<span class="org-operator">&amp;</span> name, const ObjectPtr<span class="org-operator">&lt;</span>Object<span class="org-operator">&gt;&amp;</span> sptr_to_self) final {
    <span class="org-keyword">return</span> WrapRemoteFunc(sess_<span class="org-operator">-&gt;</span>GetFunction(name));                                          
}

<span class="org-comment-delimiter"># </span><span class="org-comment">&#20889;&#20837;&#21040; stream &#30340; RPCCode &#20026; kGetGlobalFunc</span>
PackedFuncHandle RPCClientSession::GetFunction(const std::string<span class="org-operator">&amp;</span> name) final {
    <span class="org-keyword">return</span> endpoint_<span class="org-operator">-&gt;</span>SysCallRemote(RPCCode::kGetGlobalFunc, name);
}

<span class="org-variable-name">syscall_remote_</span> <span class="org-operator">=</span> PackedFunc([this](TVMArgs all_args, TVMRetValue<span class="org-operator">*</span> rv) {
    RPCCode code <span class="org-operator">=</span> static_cast<span class="org-operator">&lt;</span>RPCCode<span class="org-operator">&gt;</span>(all_args[0].operator <span class="org-builtin">int</span>());
    TVMArgs args(all_args.values <span class="org-operator">+</span> 1, all_args.type_codes <span class="org-operator">+</span> 1, all_args.num_args <span class="org-operator">-</span> 1);

    uint64_t packet_nbytes <span class="org-operator">=</span> sizeof(code) <span class="org-operator">+</span> handler_<span class="org-operator">-&gt;</span>PackedSeqGetNumBytes(
                                                args.values, args.type_codes, args.num_args, true);

    <span class="org-operator">//</span> All packet begins <span class="org-keyword">with</span> packet nbytes
    handler_<span class="org-operator">-&gt;</span>Write(packet_nbytes);
    handler_<span class="org-operator">-&gt;</span>Write(code);
    handler_<span class="org-operator">-&gt;</span>SendPackedSeq(args.values, args.type_codes, args.num_args, true);

    code <span class="org-operator">=</span> HandleUntilReturnEvent(true, [rv](TVMArgs args) {
      ICHECK_EQ(args.size(), 1);
      <span class="org-operator">*</span>rv <span class="org-operator">=</span> args[0];
    });
    ICHECK(code <span class="org-operator">==</span> RPCCode::kReturn) <span class="org-operator">&lt;&lt;</span> <span class="org-string">"code="</span> <span class="org-operator">&lt;&lt;</span> static_cast<span class="org-operator">&lt;</span><span class="org-builtin">int</span><span class="org-operator">&gt;</span>(code);
  });

<span class="org-comment-delimiter"># </span><span class="org-comment">handler &#26159; EventHandler &#23454;&#20363;</span>
void RPCEndpoint::Init() {
  <span class="org-operator">//</span> ...
  handler_ <span class="org-operator">=</span> std::make_shared<span class="org-operator">&lt;</span>EventHandler<span class="org-operator">&gt;</span>(<span class="org-operator">&amp;</span>reader_, <span class="org-operator">&amp;</span>writer_, name_, <span class="org-operator">&amp;</span>remote_key_, flush_writer);
  <span class="org-operator">//</span> ...
}

<span class="org-keyword">class</span> <span class="org-type">RPCEndpoint</span>::EventHandler : public dmlc::Stream {
 public:
  EventHandler(support::RingBuffer<span class="org-operator">*</span> reader, support::RingBuffer<span class="org-operator">*</span> writer, std::string name,
               std::string<span class="org-operator">*</span> remote_key, std::function<span class="org-operator">&lt;</span>void()<span class="org-operator">&gt;</span> flush_writer)
      : reader_(reader),
        writer_(writer),
        name_(name),
        remote_key_(remote_key),
        flush_writer_(flush_writer) {}

void EventHandler::Write(const void<span class="org-operator">*</span> data, size_t size) final { writer_<span class="org-operator">-&gt;</span>Write(data, size); }        

<span class="org-comment-delimiter"># </span><span class="org-comment">&#26368;&#32456;&#22312; stream &#37324;&#20889;&#20102;&#19968;&#20010; "{kGetGlobalFunc}runtime.SystemLib..."</span>

</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org000003b" class="outline-6">
<h6 id="org000003b"><span class="section-number-6">1.3.2.1.2.</span> Server</h6>
<div class="outline-text-6" id="text-1-3-2-1-2">
<p>
server 端 (mcu 端) 需要应用自己启动 loop, 从transport (例如 serial port) 获得数据后交给 MicroRPCServer 处理
</p>
</div>

<ol class="org-ol">
<li><a id="org0000035"></a>初始化 rpc_server<br />
<div class="outline-text-7" id="text-1-3-2-1-2-1">
<div class="org-src-container">
<pre class="src src-c++"><span class="org-comment-delimiter">// </span><span class="org-comment">writer_func &#26159;&#29992;&#25143;&#33258;&#24049;&#25552;&#20379;&#30340; function, &#29992;&#26469;&#25226; rpc_server &#38656;&#35201;&#36820;&#22238;&#30340;&#25968;&#25454;&#36890;&#36807;&#36825;</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#20010; function &#20889;&#21040; transport &#19978;</span>
rpc_server = MicroTVMRpcServerInit(&amp;writer_func, <span class="org-constant">nullptr</span>);
<span class="org-constant">tvm</span>::<span class="org-constant">runtime</span>::<span class="org-constant">micro_rpc</span>::g_write_func = write_func;

<span class="org-type">tvm_crt_error_t</span> <span class="org-variable-name">err</span> = TVMInitializeRuntime();
TVMPlatformMemoryAllocate(
    TVM_CRT_MAX_PACKET_SIZE_BYTES, dev, &amp;receive_buffer_memory);
<span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
rpc_server-&gt;Initialize();

<span class="org-comment-delimiter">// </span><span class="org-comment">MicroRPCServer &#21021;&#22987;&#21270;&#26102;&#35760;&#24405;&#20102;&#19968;&#20010; unframer_ &#19982; session_ &#32465;&#23450;, &#21518;&#32493;&#29992;&#25143;&#38656;&#35201;&#36890;</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#36807; MicroTVMRpcServerLoop &#25163;&#21160;&#32473; unframer_ &#21890;&#25968;&#25454;, session_ &#25343;&#21040;&#35299;&#26512;&#25968;&#25454;&#21518;&#20250;&#35843;</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#29992; HandleCompleteMessageCb</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#21478;&#19968;&#26041;&#38754;, &#19982; framer_ &#32465;&#23450;&#30340; send_stream_ &#20250;&#29992;&#21040; writer_func (&#36890;&#36807;&#19968;&#20010;&#20840;&#23616;&#21464;&#37327;)</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#25226;&#20135;&#29983;&#30340;&#25968;&#25454;&#20889;&#22238;&#21040; transport &#19978;</span>
<span class="org-keyword">class</span> <span class="org-type">MicroRPCServer</span> {
   <span class="org-keyword">public</span>:
    <span class="org-function-name">MicroRPCServer</span>(
        <span class="org-type">uint8_t</span>* <span class="org-variable-name">receive_storage</span>, <span class="org-type">size_t</span> <span class="org-variable-name">receive_storage_size_bytes</span>,
        <span class="org-type">microtvm_rpc_channel_write_t</span> <span class="org-variable-name">write_func</span>, <span class="org-type">void</span>* <span class="org-variable-name">write_func_ctx</span>)
        : receive_buffer_{receive_storage, receive_storage_size_bytes},
          framer_{&amp;send_stream_},
          session_{&amp;framer_, &amp;receive_buffer_, &amp;HandleCompleteMessageCb, <span class="org-keyword">this</span>},
          io_{&amp;session_, &amp;receive_buffer_},
          unframer_{session_.Receiver()},
          rpc_server_{&amp;io_},
          is_running_{<span class="org-constant">true</span>} {}

    <span class="org-type">void</span> <span class="org-function-name">Initialize</span>() {
        <span class="org-type">uint8_t</span> <span class="org-variable-name">initial_session_nonce</span> = <span class="org-constant">Session</span>::kInvalidNonce;
        session_.Initialize(initial_session_nonce);
    }
</pre>
</div>
</div>
</li>

<li><a id="org0000038"></a>rpc_server loop<br />
<div class="outline-text-7" id="text-1-3-2-1-2-2">
<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">tvm_crt_error_t</span> <span class="org-function-name">MicroTVMRpcServerLoop</span>(<span class="org-type">microtvm_rpc_server_t</span> <span class="org-variable-name">server_ptr</span>, <span class="org-type">uint8_t</span>** <span class="org-variable-name">new_data</span>, <span class="org-type">size_t</span>* <span class="org-variable-name">new_data_size_bytes</span>):
  server-&gt;Loop(new_data, new_data_size_bytes);

<span class="org-type">tvm_crt_error_t</span> <span class="org-function-name">Loop</span>(<span class="org-type">uint8_t</span>** <span class="org-variable-name">new_data</span>, <span class="org-type">size_t</span>* <span class="org-variable-name">new_data_size_bytes</span>): 
  err = unframer_.Write(*new_data, *new_data_size_bytes, &amp;bytes_consumed);

<span class="org-type">tvm_crt_error_t</span> <span class="org-constant">Unframer</span>::<span class="org-function-name">Write</span>(<span class="org-keyword">const</span> <span class="org-type">uint8_t</span>* <span class="org-variable-name">data</span>, <span class="org-type">size_t</span> <span class="org-variable-name">data_size_bytes</span>,<span class="org-type">size_t</span>* <span class="org-variable-name">bytes_consumed</span>):
    <span class="org-keyword">switch</span> (state_) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
      <span class="org-keyword">case</span> <span class="org-constant">State</span>::kFindCrcEnd:
        return_code = FindCrcEnd();
          stream_-&gt;PacketDone(crc_ == *<span class="org-keyword">reinterpret_cast</span>&lt;<span class="org-type">uint16_t</span>*&gt;(buffer_));
            <span class="org-keyword">switch</span> (header.message_type) {
              <span class="org-keyword">default</span>:
                session_-&gt;message_received_func_(session_-&gt;message_received_func_context_,
                                         header.message_type, session_-&gt;receive_buffer_);

<span class="org-comment-delimiter">// </span><span class="org-comment">message_received_func_ &#21363; session &#21021;&#22987;&#21270;&#26102;&#30340; HandleCompleteMessageCb</span>

<span class="org-type">void</span> <span class="org-constant">MicroRPCServer</span>::<span class="org-variable-name">HandleCompleteMessage</span>(MessageType message_type, FrameBuffer* buf) {
  rpc_server_.ProcessOnePacket();
    <span class="org-keyword">this</span>-&gt;Read(&amp;packet_len);
    <span class="org-keyword">this</span>-&gt;Read(&amp;code);

    <span class="org-keyword">if</span> (code &gt;= <span class="org-constant">RPCCode</span>::kSyscallCodeStart) {
      <span class="org-keyword">this</span>-&gt;HandleSyscallFunc(code);
    } <span class="org-keyword">else</span> {
      <span class="org-keyword">switch</span> (code) {
        <span class="org-keyword">case</span> <span class="org-constant">RPCCode</span>::kCallFunc: {
          HandleNormalCallFunc();
            TVMFuncCall(<span class="org-keyword">reinterpret_cast</span>&lt;<span class="org-type">void</span>*&gt;(call_handle), values, tcodes, num_args, &amp;(ret_value[1]), &amp;(ret_tcode[1]));

          <span class="org-keyword">break</span>;
        }
      <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>

</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org000003e" class="outline-6">
<h6 id="org000003e"><span class="section-number-6">1.3.2.1.3.</span> To summarize</h6>
<div class="outline-text-6" id="text-1-3-2-1-3">
<p>
为了实现基于串口的 RPC, TVM 已经实现了大部分功能, 剩余需要自己实现的包括:
</p>

<ol class="org-ol">
<li><p>
client (python) 端需要实现一个串口的 tranport, 通过 Flasher 返回
</p>

<p>
<code>tvm/python/tvm/micro/contrib/zephyr.py</code>
</p></li>

<li><p>
server (mcu) 端需要:
</p>

<p>
<code>tvm/apps/microtvm/zephyr/host_driven/src/main.c</code>
</p>

<ol class="org-ol">
<li>实现一个写串口数据的 writer_func, 在 MicroTVMRpcServerInit 时注册上去</li>

<li>自己从串口读数据, 然后调用 MicroTVMRpcServerLoop</li>
</ol></li>
</ol>

<p>
Project API 的 host template 实现了一个基于 popen+pipe 的 RPC 的 demo:
<code>tvm/build/standalone_crt/template/host/main.cc</code>
</p>

<p>
Project API 的 zephyr template 实现了一个基于 uart 的 RPC 的 demo:
<code>tvm/apps/microtvm/zephyr/template_project/src/host_driven/main.c</code>
</p>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org0000001" class="outline-3">
<h3 id="org0000001"><span class="section-number-3">1.4.</span> MicroTVM 与 AutoTVM</h3>
<div class="outline-text-3" id="text-1-4">
<p>
MicroTVM 通过 Proejct API 和 MicroTVM RPC 支持 AutoTVM
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> tvm
<span class="org-keyword">from</span> tvm <span class="org-keyword">import</span> relay

<span class="org-keyword">import</span> tempfile


<span class="org-keyword">def</span> <span class="org-function-name">get_model</span>():
    <span class="org-variable-name">x</span> <span class="org-operator">=</span> relay.var(<span class="org-string">"x"</span>, relay.TensorType([1, 10], <span class="org-string">"float32"</span>))
    <span class="org-variable-name">y</span> <span class="org-operator">=</span> relay.add(x, x)
    <span class="org-variable-name">f</span> <span class="org-operator">=</span> relay.Function([x], y)

    <span class="org-variable-name">relay_mod</span> <span class="org-operator">=</span> tvm.IRModule.from_expr(f)
    <span class="org-variable-name">relay_mod</span> <span class="org-operator">=</span> relay.transform.InferType()(relay_mod)
    <span class="org-keyword">return</span> relay_mod


<span class="org-keyword">def</span> <span class="org-function-name">tune</span>():
    <span class="org-variable-name">relay_mod</span> <span class="org-operator">=</span> get_model()
    <span class="org-keyword">with</span> tvm.transform.PassContext(opt_level<span class="org-operator">=</span>3, config<span class="org-operator">=</span>{<span class="org-string">"tir.disable_vectorize"</span>: <span class="org-constant">True</span>}):
        <span class="org-variable-name">tasks</span> <span class="org-operator">=</span> tvm.autotvm.task.extract_from_program(
            relay_mod[<span class="org-string">"main"</span>], {}, tvm.target.target.micro(<span class="org-string">"host"</span>)
        )

    <span class="org-variable-name">module_loader</span> <span class="org-operator">=</span> tvm.micro.AutoTvmModuleLoader(
        template_project_dir<span class="org-operator">=</span><span class="org-string">"~/source/tvm/build/standalone_crt/template/host"</span>,
        project_options<span class="org-operator">=</span>{<span class="org-string">"verbose"</span>: <span class="org-constant">False</span>},
    )
    <span class="org-variable-name">runner</span> <span class="org-operator">=</span> tvm.autotvm.LocalRunner(
        number<span class="org-operator">=</span>1, repeat<span class="org-operator">=</span>1, timeout<span class="org-operator">=</span>100, module_loader<span class="org-operator">=</span>module_loader
    )

    <span class="org-variable-name">builder</span> <span class="org-operator">=</span> tvm.autotvm.LocalBuilder(
        n_parallel<span class="org-operator">=</span>1,
        build_kwargs<span class="org-operator">=</span>{<span class="org-string">"build_option"</span>: {<span class="org-string">"tir.disable_vectorize"</span>: <span class="org-constant">True</span>}},
        build_func<span class="org-operator">=</span>tvm.micro.autotvm_build_func,
    )

    <span class="org-keyword">for</span> task <span class="org-keyword">in</span> tasks:
        <span class="org-variable-name">tuner</span> <span class="org-operator">=</span> tvm.autotvm.tuner.GATuner(task)
        tuner.tune(
            n_trial<span class="org-operator">=</span>1,
            measure_option<span class="org-operator">=</span>tvm.autotvm.measure_option(builder<span class="org-operator">=</span>builder, runner<span class="org-operator">=</span>runner),
        )


<span class="org-keyword">if</span> <span class="org-builtin">__name__</span> <span class="org-operator">==</span> <span class="org-string">"__main__"</span>:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Project API &#20063;&#21487;&#20197;&#29992;&#26469;&#20570; autotvm</span>
    tune()

</pre>
</div>
</div>

<div id="outline-container-org000004a" class="outline-4">
<h4 id="org000004a"><span class="section-number-4">1.4.1.</span> Impl</h4>
<div class="outline-text-4" id="text-1-4-1">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">AutoTvmModuleLoader</span>:
    <span class="org-type">@contextlib.contextmanager</span>
    <span class="org-keyword">def</span> <span class="org-function-name">__call__</span>(<span class="org-keyword">self</span>, remote_kw, build_result):
        <span class="org-keyword">with</span> <span class="org-builtin">open</span>(build_result.filename, <span class="org-string">"rb"</span>) <span class="org-keyword">as</span> build_file:
            <span class="org-variable-name">build_result_bin</span> <span class="org-operator">=</span> build_file.read()

        <span class="org-variable-name">tracker</span> <span class="org-operator">=</span> _rpc.connect_tracker(remote_kw[<span class="org-string">"host"</span>], remote_kw[<span class="org-string">"port"</span>])
        <span class="org-variable-name">remote</span> <span class="org-operator">=</span> tracker.request(
            remote_kw[<span class="org-string">"device_key"</span>],
            priority<span class="org-operator">=</span>remote_kw[<span class="org-string">"priority"</span>],
            session_timeout<span class="org-operator">=</span>remote_kw[<span class="org-string">"timeout"</span>],
            session_constructor_args<span class="org-operator">=</span>[
                <span class="org-string">"tvm.micro.compile_and_create_micro_session"</span>,
                build_result_bin,
                <span class="org-keyword">self</span>._template_project_dir,
                json.dumps(<span class="org-keyword">self</span>._project_options),
            ],
        )
        <span class="org-variable-name">system_lib</span> <span class="org-operator">=</span> remote.get_function(<span class="org-string">"runtime.SystemLib"</span>)()
        <span class="org-keyword">yield</span> remote, system_lib


<span class="org-keyword">def</span> <span class="org-function-name">compile_and_create_micro_session</span>(
    mod_src_bytes: <span class="org-builtin">bytes</span>,
    template_project_dir: <span class="org-builtin">str</span>,
    project_options: <span class="org-builtin">dict</span> <span class="org-operator">=</span> <span class="org-constant">None</span>,
):
    <span class="org-variable-name">temp_dir</span> <span class="org-operator">=</span> utils.tempdir()
    <span class="org-comment-delimiter"># </span><span class="org-comment">Keep temp directory for generate project</span>
    temp_dir.set_keep_for_debug(<span class="org-constant">True</span>)
    <span class="org-variable-name">model_library_format_path</span> <span class="org-operator">=</span> temp_dir <span class="org-operator">/</span> <span class="org-string">"model.tar.gz"</span>
    <span class="org-keyword">with</span> <span class="org-builtin">open</span>(model_library_format_path, <span class="org-string">"wb"</span>) <span class="org-keyword">as</span> mlf_f:
        mlf_f.write(mod_src_bytes)

    <span class="org-comment-delimiter"># </span><span class="org-comment">&#36825;&#37324;&#20351;&#29992;&#20102; Project API &#36827;&#34892; build, flash</span>
    <span class="org-variable-name">template_project</span> <span class="org-operator">=</span> project.TemplateProject.from_directory(template_project_dir)
    <span class="org-variable-name">generated_project</span> <span class="org-operator">=</span> template_project.generate_project_from_mlf(
        model_library_format_path,
        <span class="org-builtin">str</span>(temp_dir <span class="org-operator">/</span> <span class="org-string">"generated-project"</span>),
        options<span class="org-operator">=</span>json.loads(project_options),
    )

    generated_project.build()
    generated_project.flash()
    <span class="org-variable-name">transport</span> <span class="org-operator">=</span> generated_project.transport()

    <span class="org-comment-delimiter"># </span><span class="org-comment">&#36825;&#37324;&#20351;&#29992;&#20102; transport &#21644; bin &#20013;&#30340; microtvm rpc server &#20132;&#20114;</span>
    <span class="org-variable-name">rpc_session</span> <span class="org-operator">=</span> Session(transport_context_manager<span class="org-operator">=</span>transport)
    rpc_session.__enter__()
    <span class="org-keyword">return</span> rpc_session._rpc._sess
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org0000059" class="outline-3">
<h3 id="org0000059"><span class="section-number-3">1.5.</span> Micro TVM &amp; BYOC</h3>
<div class="outline-text-3" id="text-1-5">
<p>
先说结论: Micro TVM 不支持 基于 __tvm_dev_mblob 方式的 BYOC, 但可以支持 c_src 形式的 BYOC <a href="#org0000016">C Runtime</a>
</p>

<p>
为了支持 __tvm_dev_mblob, 最重要的一点是把 __tvm_dev_mblob 注册到 SystemLib 上.
</p>

<p>
TVM Runtime 的启动有三种方式:
</p>

<ol class="org-ol">
<li>通过 LoadFromFile 加载 DSOLibrary, 具体实现是 CreateModuleFromLibrary</li>
<li>通过 runtime.SystemLib 加载 SystemLibrary
<ol class="org-ol">
<li>c++ runtime 的 runtime.SystemLib 的实现与 DSOLibrary 一样, 是 CreateModuleFromLibrary</li>
<li>c runtime 的 runtime.SystemLib 的实现是 SystemLibraryCreate</li>
</ol></li>
</ol>

<p>
编译时: 1 和 2.1 编译时会注册 __tvm_dev_mblob, 而 2.2 不支持运行时: 1 和 2.1 在运行时都会去加载 __tvm_dev_mblob, 而 2.2 则不支持.
</p>
</div>

<div id="outline-container-org0000050" class="outline-4">
<h4 id="org0000050"><span class="section-number-4">1.5.1.</span> system-lib &amp; c++ runtime 注册 __tvm_dev_mblob</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
2.1 (system-lib &amp; c++ runtime) 是支持注册 __tvm_dev_mblob 的
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">export_library</span>(<span class="org-keyword">self</span>, file_name, fcompile<span class="org-operator">=</span><span class="org-constant">None</span>, addons<span class="org-operator">=</span><span class="org-constant">None</span>, workspace_dir<span class="org-operator">=</span><span class="org-constant">None</span>, <span class="org-operator">**</span>kwargs):
    <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
    <span class="org-keyword">if</span> <span class="org-keyword">self</span>.imported_modules:
        <span class="org-keyword">if</span> enabled(<span class="org-string">"llvm"</span>) <span class="org-keyword">and</span> llvm_target_triple:
            <span class="org-variable-name">path_obj</span> <span class="org-operator">=</span> os.path.join(workspace_dir, f<span class="org-string">"devc.</span>{object_format}<span class="org-string">"</span>)
            <span class="org-variable-name">m</span> <span class="org-operator">=</span> _ffi_api.ModulePackImportsToLLVM(<span class="org-keyword">self</span>, is_system_lib, llvm_target_triple)
            m.save(path_obj)
            files.append(path_obj)
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">path_cc</span> <span class="org-operator">=</span> os.path.join(workspace_dir, <span class="org-string">"devc.c"</span>)
            <span class="org-keyword">with</span> <span class="org-builtin">open</span>(path_cc, <span class="org-string">"w"</span>) <span class="org-keyword">as</span> f:
                f.write(_ffi_api.ModulePackImportsToC(<span class="org-keyword">self</span>, is_system_lib))
            files.append(path_cc)

</pre>
</div>

<p>
ModulePackImportsToLLVM 和 ModulePackImportsToC 会生成类似下面的代码:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span class="org-keyword">extern</span> <span class="org-type">int</span> <span class="org-function-name">TVMBackendRegisterSystemLibSymbol</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>*, <span class="org-type">void</span>*);
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">__tvm_dev_mblob_reg_</span> = TVMBackendRegisterSystemLibSymbol(
    <span class="org-string">"__tvm_dev_mblob"</span>, (<span class="org-type">void</span>*)__tvm_dev_mblob);
</pre>
</div>

<p>
通过 c++ 的 ctor 完成对 TVMBackendRegisterSystemLibSymbol 的调用.
</p>
</div>
</div>

<div id="outline-container-org0000053" class="outline-4">
<h4 id="org0000053"><span class="section-number-4">1.5.2.</span> system-lib &amp; c runtime 不支持注册和解析 __tvm_dev_mblob</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
从当前的代码来看:
</p>

<ol class="org-ol">
<li>在 export_library 时不会针对 c_runtime 生成注册 __tvm_dev_mblob 的代码 (例如
ModulePackImportsToLLVM)</li>
<li>运行时 c runtime 也不会解析 __tvm_dev_mblob</li>
<li>以及一些其它的问题例如: <code>tvm/src/target/metadata_module.cc::if (is_targeting_crt)</code></li>
</ol>

<p>
所以 microtvm 无法支持 BYOC.
</p>

<p>
但是如果 c runtime 只是为了解决 c++ runtime ctor 的问题, 我们其实可以手动调用
c++ ctor:
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>
<span class="org-keyword">class</span> <span class="org-type">A</span> {
   <span class="org-keyword">public</span>:
    <span class="org-function-name">A</span>() { printf(<span class="org-string">"hello\n"</span>); }
};

<span class="org-type">A</span> <span class="org-variable-name">a</span>, <span class="org-variable-name">b</span>, <span class="org-variable-name">c</span>;

<span class="org-keyword">typedef</span> <span class="org-type">void</span> (*<span class="org-type">FP</span>)();

<span class="org-comment-delimiter">// </span><span class="org-comment">__init_array_start, __init_array_end &#26159;&#36890;&#36807; linker script &#23450;&#20041;&#30340;&#31526;&#21495;</span>
<span class="org-keyword">extern</span> <span class="org-type">FP</span> <span class="org-variable-name">__init_array_start</span>;
<span class="org-keyword">extern</span> <span class="org-type">FP</span> <span class="org-variable-name">__init_array_end</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[]) {
    printf(<span class="org-string">"----------main----------\n"</span>);
    <span class="org-keyword">for</span> (<span class="org-type">FP</span> *<span class="org-variable-name">p</span> = &amp;__init_array_start; p &lt; &amp;__init_array_end; p++) {
        (*p)();
    }
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<p>
hello
hello
hello
-----&#x2013;&#x2014;main-----&#x2013;&#x2014;
hello
hello
hello
</p>
</div>
</div>

<div id="outline-container-org0000056" class="outline-4">
<h4 id="org0000056"><span class="section-number-4">1.5.3.</span> ModulePackImportsToLLVM 的 Bug</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
ModulePackImportsToLLVM 时如果 is_system_lib 为 False, 则不会生成注册
__tvm_dev_mblob 的代码, 但 is_system_lib 的判断条件是:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">is_system_lib</span> <span class="org-operator">=</span> (
    module.type_key <span class="org-operator">==</span> <span class="org-string">"llvm"</span> <span class="org-keyword">and</span> module.get_function(<span class="org-string">"__tvm_is_system_module"</span>)()
)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">PackedFunc</span> <span class="org-function-name">GetFunction</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span>, <span class="org-keyword">const</span> <span class="org-type">ObjectPtr</span>&lt;Object&gt;&amp; <span class="org-variable-name">sptr_to_self</span>) <span class="org-keyword">final</span> {
    <span class="org-keyword">if</span> (name == <span class="org-string">"__tvm_is_system_module"</span>) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#21028;&#26029;&#26377;&#27809;&#26377; __tvm_module_startup        </span>
      <span class="org-type">bool</span> <span class="org-variable-name">flag</span> = (mptr_-&gt;getFunction(<span class="org-string">"__tvm_module_startup"</span>) != <span class="org-constant">nullptr</span>);
      <span class="org-keyword">return</span> PackedFunc([<span class="org-constant">flag</span>](<span class="org-type">TVMArgs</span> <span class="org-variable-name">args</span>, <span class="org-type">TVMRetValue</span>* <span class="org-variable-name">rv</span>) { *rv = flag; });
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#28155;&#21152; __tvm_module_startup &#30340;&#20195;&#30721;</span>
<span class="org-type">void</span> <span class="org-constant">CodeGenCPU</span>::<span class="org-function-name">AddStartupFunction</span>() {
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>target_c_runtime_) {
    <span class="org-constant">llvm</span>::<span class="org-type">FunctionType</span>* <span class="org-variable-name">ftype</span> = <span class="org-constant">llvm</span>::<span class="org-constant">FunctionType</span>::get(t_void_, {}, <span class="org-constant">false</span>);
    function_ = <span class="org-constant">llvm</span>::<span class="org-constant">Function</span>::Create(ftype, <span class="org-constant">llvm</span>::<span class="org-constant">Function</span>::InternalLinkage,
                                       <span class="org-string">"__tvm_module_startup"</span>, module_.get());
    <span class="org-keyword">for</span> (<span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">kv</span> : export_system_symbols_) {
      <span class="org-constant">llvm</span>::<span class="org-type">Value</span>* <span class="org-variable-name">name</span> = GetConstString(kv.first);
      builder_-&gt;CreateCall(f_tvm_register_system_symbol_,
                           {name, builder_-&gt;CreateBitCast(kv.second, t_void_p_)});
    }    
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  }
}

<span class="org-constant">std</span>::<span class="org-type">unique_ptr</span>&lt;<span class="org-constant">llvm</span>::Module&gt; <span class="org-constant">CodeGenLLVM</span>::<span class="org-function-name">Finish</span>() {
  <span class="org-keyword">this</span>-&gt;AddStartupFunction();
  <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">optimize</span>
  <span class="org-keyword">this</span>-&gt;Optimize();
  <span class="org-keyword">return</span> <span class="org-constant">std</span>::move(module_);
}

</pre>
</div>

<p>
问题出在最后那个 llvm::Optimize
</p>

<p>
当 relay IR 时没有任何函数需要在 CPU 执行时 (所有代码都交给 dnnl 执行),
export_system_symbols_ 会为空, 这时虽然已经在 llvm module 里生成了一个
__tvm_module_startup 函数, 但因为它的函数体为空且函数是 InternalLinkage,
llvm::Optimize 会把它删除&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter">#</span><span class="org-comment">!/usr/bin/env python3</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">-*- coding: utf-8 -*-</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">2021-08-03 11:11</span>
<span class="org-keyword">import</span> tvm
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> tvm <span class="org-keyword">import</span> te
<span class="org-keyword">from</span> tvm <span class="org-keyword">import</span> relay
<span class="org-keyword">import</span> os


<span class="org-keyword">def</span> <span class="org-function-name">get_good_mod</span>():
    <span class="org-variable-name">d1</span> <span class="org-operator">=</span> relay.var(<span class="org-string">"d1"</span>, shape<span class="org-operator">=</span>(1, 32, 56, 56), dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>)
    <span class="org-variable-name">w1</span> <span class="org-operator">=</span> relay.var(<span class="org-string">"w1"</span>, shape<span class="org-operator">=</span>(32, 32, 3, 3), dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>)
    <span class="org-variable-name">b1</span> <span class="org-operator">=</span> relay.var(<span class="org-string">"b1"</span>, shape<span class="org-operator">=</span>(32,), dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>)
    <span class="org-variable-name">conv</span> <span class="org-operator">=</span> relay.nn.conv2d(d1, w1, strides<span class="org-operator">=</span>(1, 1), padding<span class="org-operator">=</span>(1, 1))
    <span class="org-variable-name">bias</span> <span class="org-operator">=</span> relay.nn.bias_add(conv, b1)
    <span class="org-variable-name">relu</span> <span class="org-operator">=</span> relay.nn.relu(bias)

    <span class="org-variable-name">func</span> <span class="org-operator">=</span> relay.Function([d1, w1, b1], relu)
    <span class="org-variable-name">mod</span> <span class="org-operator">=</span> tvm.IRModule.from_expr(func)
    <span class="org-variable-name">mod</span> <span class="org-operator">=</span> relay.transform.InferType()(mod)
    <span class="org-keyword">return</span> mod


<span class="org-keyword">def</span> <span class="org-function-name">get_bug_mod</span>():
    <span class="org-variable-name">x</span> <span class="org-operator">=</span> relay.var(<span class="org-string">"x"</span>, shape<span class="org-operator">=</span>(10,), dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>)
    <span class="org-variable-name">y</span> <span class="org-operator">=</span> relay.add(x, x)
    <span class="org-variable-name">func</span> <span class="org-operator">=</span> relay.Function([x], y)
    <span class="org-variable-name">mod</span> <span class="org-operator">=</span> tvm.IRModule.from_expr(func)
    <span class="org-keyword">return</span> mod


<span class="org-keyword">def</span> <span class="org-function-name">prepare_relay_libs</span>():
    <span class="org-variable-name">mod</span> <span class="org-operator">=</span> get_bug_mod()
    <span class="org-variable-name">mod</span> <span class="org-operator">=</span> relay.transform.AnnotateTarget(<span class="org-string">"dnnl"</span>)(mod)
    <span class="org-variable-name">mod</span> <span class="org-operator">=</span> relay.transform.PartitionGraph()(mod)
    <span class="org-keyword">with</span> tvm.transform.PassContext(opt_level<span class="org-operator">=</span>1):
        <span class="org-variable-name">mod</span> <span class="org-operator">=</span> relay.build(mod, target<span class="org-operator">=</span><span class="org-string">"llvm --system-lib --runtime=c++"</span>, params<span class="org-operator">=</span><span class="org-constant">None</span>)
    mod.lib.export_library(<span class="org-string">"/tmp/libdouble_bug.tar"</span>)

    <span class="org-variable-name">mod</span> <span class="org-operator">=</span> get_good_mod()
    <span class="org-variable-name">mod</span> <span class="org-operator">=</span> relay.transform.AnnotateTarget(<span class="org-string">"dnnl"</span>)(mod)
    <span class="org-variable-name">mod</span> <span class="org-operator">=</span> relay.transform.PartitionGraph()(mod)
    <span class="org-keyword">with</span> tvm.transform.PassContext(opt_level<span class="org-operator">=</span>1):
        <span class="org-variable-name">mod</span> <span class="org-operator">=</span> relay.build(mod, target<span class="org-operator">=</span><span class="org-string">"llvm --system-lib --runtime=c++"</span>, params<span class="org-operator">=</span><span class="org-constant">None</span>)
    mod.lib.export_library(<span class="org-string">"/tmp/libdouble_good.tar"</span>)


<span class="org-keyword">if</span> <span class="org-builtin">__name__</span> <span class="org-operator">==</span> <span class="org-string">"__main__"</span>:
    prepare_relay_libs()
</pre>
</div>

<div class="org-src-container">
<pre class="src src-bash"><span class="org-builtin">echo</span> <span class="org-string">"----------good----------"</span>
tar xvf /tmp/libdouble_good.tar -C /tmp
readelf -s /tmp/lib0.o
readelf -s /tmp/devc.o
<span class="org-builtin">echo</span> <span class="org-string">"----------bug----------"</span>
tar xvf /tmp/libdouble_bug.tar -C /tmp
readelf -s /tmp/lib0.o
readelf -s /tmp/devc.o
</pre>
</div>

<p>
-----&#x2013;&#x2014;good-----&#x2013;&#x2014;
lib0.o
devc.o
</p>

<p>
Symbol table '.symtab' contains 16 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS TVMMod
     2: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    4 .LCPI0_0
     3: 00000000000005f0    40 FUNC    LOCAL  DEFAULT    2 __tvm_module_startup
     4: 0000000000000370    40 FUNC    LOCAL  DEFAULT    2 tvmgen_default_fused_nn_b
     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    2 
     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 
     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    9 
     8: 0000000000000000     0 SECTION LOCAL  DEFAULT   10 
     9: 0000000000000000     0 SECTION LOCAL  DEFAULT   11 
    10: 0000000000000000     0 SECTION LOCAL  DEFAULT   20 
    11: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND TVMAPISetLastError
    12: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND TVMBackendParallelLaunch
    13: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND TVMBackendRegisterSystemL
    14: 0000000000000000     8 OBJECT  WEAK   DEFAULT    5 __tvm_module_ctx
    15: 0000000000000000   869 FUNC    GLOBAL DEFAULT    2 tvmgen_default_fused_nn_b
</p>

<p>
Symbol table '.symtab' contains 10 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS devc
     2: 0000000000000000     8 FUNC    LOCAL  DEFAULT    3 <span class="underline">GLOBAL__sub_I_devc
     3: 0000000000000010    28 FUNC    LOCAL  DEFAULT    3 __cxx_global_var_init
     4: 0000000000000000     4 OBJECT  LOCAL  DEFAULT    6 __tvm_dev_mblob_reg</span>
     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 
     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 
     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 
     8: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND TVMBackendRegisterSystemL
     9: 0000000000000000  2990 OBJECT  GLOBAL DEFAULT    5 __tvm_dev_mblob
-----&#x2013;&#x2014;bug-----&#x2013;&#x2014;
lib0.o
devc.o
</p>

<p>
Symbol table '.symtab' contains 6 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS TVMMod
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 
     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 
     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 
     5: 0000000000000000     0 SECTION LOCAL  DEFAULT   12 
</p>

<p>
Symbol table '.symtab' contains 3 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS devc
     2: 0000000000000000  1015 OBJECT  GLOBAL DEFAULT    3 __tvm_dev_mblob
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

<p class="author">Author: <a href="mailto:sunway@dogdog.run">sunway@dogdog.run</a><br />
Date: 2021-08-03 Tue 00:00<br />
Last updated: 2023-12-01 Fri 18:28</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
</div>
</body>
</html>
