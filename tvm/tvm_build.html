<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>TVM Build</title>


<link rel="stylesheet" type="text/css" href="/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="./htmlize.css"/>
<link rel="stylesheet" type="text/css" href="../htmlize.css"/>
<link rel="stylesheet" type="text/css" href="../../htmlize.css"/>
<link rel="stylesheet" type="text/css" href="/readtheorg.css"/>
<link rel="stylesheet" type="text/css" href="./readtheorg.css"/>
<link rel="stylesheet" type="text/css" href="../readtheorg.css"/>
<link rel="stylesheet" type="text/css" href="../../readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
<link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
<link rel="stylesheet" type="text/css" href="../main.css" media="screen" />
<link rel="stylesheet" type="text/css" href="../../main.css" media="screen" />
<link rel="stylesheet" type="text/css" href="./main.css" media="screen" />
<link rel = "icon" href = "/icon.png"  type = "image/x-icon">
</head>
<body>
<div id="content" class="content">
<h1 class="title">TVM Build</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org0000062">1. TVM Build</a>
<ul>
<li><a href="#org0000018">1.1. Relay Optimizations</a>
<ul>
<li><a href="#org0000000">1.1.1. Overview</a></li>
<li><a href="#org0000003">1.1.2. optimize</a></li>
<li><a href="#org0000012">1.1.3. PassContext</a></li>
<li><a href="#org0000015">1.1.4. Relay Transform</a></li>
</ul>
</li>
<li><a href="#org0000043">1.2. Relay IR -&gt; TE -&gt; TIR</a>
<ul>
<li><a href="#org000001b">1.2.1. Relay IR -&gt; OpRegistry</a></li>
<li><a href="#org000002d">1.2.2. OpRegistry -&gt; TE</a></li>
<li><a href="#org0000040">1.2.3. TE -&gt; TIR</a></li>
</ul>
</li>
<li><a href="#org000004b">1.3. TIR -&gt; Codegen</a>
<ul>
<li><a href="#org0000048">1.3.1. Example</a></li>
</ul>
</li>
<li><a href="#org000005f">1.4. Build Target</a>
<ul>
<li><a href="#org0000050">1.4.1. target 参数是如何被解析和使用的</a></li>
<li><a href="#org0000053">1.4.2. LLVMTargetToString</a></li>
<li><a href="#org000005c">1.4.3. arm_cpu 针对 arm 的特殊处理</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org0000062" class="outline-2">
<h2 id="org0000062"><span class="section-number-2">1.</span> TVM Build</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org0000018" class="outline-3">
<h3 id="org0000018"><span class="section-number-3">1.1.</span> Relay Optimizations</h3>
<div class="outline-text-3" id="text-1-1">
</div>
<div id="outline-container-org0000000" class="outline-4">
<h4 id="org0000000"><span class="section-number-4">1.1.1.</span> Overview</h4>
<div class="outline-text-4" id="text-1-1-1">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">with</span> tvm.transform.PassContext(
    opt_level<span class="org-operator">=</span>3, disabled_pass<span class="org-operator">=</span>[], required_pass<span class="org-operator">=</span>[], config<span class="org-operator">=</span>{}
):
    <span class="org-variable-name">graph</span>, <span class="org-variable-name">lib</span>, <span class="org-variable-name">params</span> <span class="org-operator">=</span> relay.build(mod, target<span class="org-operator">=</span><span class="org-string">"c"</span>, params<span class="org-operator">=</span><span class="org-constant">None</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">build_module.py@relay:</span>
relay.build():
  <span class="org-variable-name">bld_mod</span> <span class="org-operator">=</span> BuildModule()
  bld_mod.build(mod<span class="org-operator">=</span>ir_mod, target<span class="org-operator">=</span>target, params<span class="org-operator">=</span>params, executor<span class="org-operator">=</span>executor,
                mod_name<span class="org-operator">=</span>mod_name)
    <span class="org-keyword">self</span>._build(mod, target, target_host, executor, mod_name)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c++">
<span class="org-preprocessor"># build_module</span>.cc@relay.backend
<span class="org-type">void</span> <span class="org-function-name">Build</span>(<span class="org-type">IRModule</span> <span class="org-variable-name">mod</span>, <span class="org-keyword">const</span> <span class="org-type">TargetsMap</span>&amp; <span class="org-variable-name">targets</span>, <span class="org-keyword">const</span> <span class="org-constant">tvm</span>::<span class="org-type">Target</span>&amp; <span class="org-variable-name">target_host</span>,
             <span class="org-keyword">const</span> <span class="org-type">String</span> <span class="org-variable-name">executor</span>, <span class="org-keyword">const</span> <span class="org-type">String</span> <span class="org-variable-name">mod_name</span>) {
  targets_ = targets;
  target_host_ = target_host;
  executor_ = executor;
  BuildRelay(mod, params_, mod_name);

<span class="org-constant">BuildRelay</span>:
  relay_module = Optimize(relay_module, targets_, params);
</pre>
</div>
</div>
</div>

<div id="outline-container-org0000003" class="outline-4">
<h4 id="org0000003"><span class="section-number-4">1.1.2.</span> optimize</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
所有的针对 relay 的 optimizations pass 在 tvm::relay::transform 下.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">IRModule</span> <span class="org-function-name">Optimize</span>(
    <span class="org-type">IRModule</span> <span class="org-variable-name">relay_module</span>, <span class="org-keyword">const</span> <span class="org-type">TargetsMap</span>&amp; <span class="org-variable-name">targets</span>,
    <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">unordered_map</span>&lt;<span class="org-constant">std</span>::string, <span class="org-constant">runtime</span>::NDArray&gt;&amp; <span class="org-variable-name">params</span>) {
    <span class="org-type">Array</span>&lt;Pass&gt; <span class="org-variable-name">pass_seqs</span> = GetPassPrefix(targets, <span class="org-constant">false</span>);
    <span class="org-constant">transform</span>::<span class="org-type">Pass</span> <span class="org-variable-name">seq</span> = <span class="org-constant">transform</span>::Sequential(pass_seqs);
    relay_module = seq(relay_module);

    <span class="org-comment-delimiter">// </span><span class="org-comment">Handle heterogeneous compilation.</span>
    <span class="org-comment-delimiter">//</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#21482;&#26377; targets &#25351;&#23450;&#20102;&#22810;&#20010;&#26102;&#25165;&#20250;&#25191;&#34892; RunDeviceAnnotationPass, &#21363;&#22788;&#29702;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">on_device annotation, &#20363;&#22914; build vta &#26102;&#38656;&#35201;&#25351;&#23450;</span>
    <span class="org-comment-delimiter">//   </span><span class="org-comment">target={"cpu": env.target_vta_cpu, "ext_dev": env.target},</span>
    <span class="org-constant">transform</span>::<span class="org-type">PassContext</span> <span class="org-variable-name">pass_ctx</span> = <span class="org-constant">PassContext</span>::Current();
    <span class="org-keyword">if</span> (targets_.size() &gt; 1) {
        <span class="org-type">Optional</span>&lt;Integer&gt; <span class="org-variable-name">opt_fallback_dev</span> = pass_ctx-&gt;GetConfig(
            <span class="org-string">"relay.fallback_device_type"</span>, Integer(<span class="org-keyword">static_cast</span>&lt;<span class="org-type">int</span>&gt;(kDLCPU)));
        <span class="org-keyword">auto</span> <span class="org-variable-name">fallback_dev</span> = opt_fallback_dev.value();
        relay_module =
            RunDeviceAnnotationPass(relay_module, fallback_dev-&gt;value);
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
    relay_module = <span class="org-constant">transform</span>::FuseOps()(relay_module);
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
    relay_module = <span class="org-constant">transform</span>::Inline()(relay_module);
    relay_module = <span class="org-constant">transform</span>::InferType()(relay_module);
    relay_module = <span class="org-constant">transform</span>::LabelOps()(relay_module);

    <span class="org-keyword">return</span> relay_module;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">Array</span>&lt;Pass&gt; <span class="org-function-name">GetPassPrefix</span>(
    <span class="org-keyword">const</span> <span class="org-type">Map</span>&lt;<span class="org-constant">tvm</span>::Integer, <span class="org-constant">tvm</span>::Target&gt;&amp; <span class="org-variable-name">targets</span>, <span class="org-type">bool</span> <span class="org-variable-name">is_vm</span>) {
    <span class="org-type">Array</span>&lt;Pass&gt; <span class="org-variable-name">pass_seqs</span>;
    <span class="org-type">Array</span>&lt;<span class="org-constant">runtime</span>::String&gt; <span class="org-variable-name">entry_functions</span>{<span class="org-string">"main"</span>};
    pass_seqs.push_back(<span class="org-constant">transform</span>::RemoveUnusedFunctions(entry_functions));
    pass_seqs.push_back(<span class="org-constant">transform</span>::ToBasicBlockNormalForm());
    pass_seqs.push_back(<span class="org-constant">relay</span>::<span class="org-constant">qnn</span>::<span class="org-constant">transform</span>::Legalize());
    pass_seqs.push_back(<span class="org-constant">transform</span>::SimplifyInference());
    pass_seqs.push_back(<span class="org-constant">transform</span>::DynamicToStatic());
    pass_seqs.push_back(<span class="org-constant">transform</span>::EliminateCommonSubexpr(fskip));
    pass_seqs.push_back(<span class="org-constant">transform</span>::SimplifyExpr());
    pass_seqs.push_back(<span class="org-constant">transform</span>::CombineParallelConv2D(3));
    pass_seqs.push_back(<span class="org-constant">transform</span>::CombineParallelDense(3));
    pass_seqs.push_back(<span class="org-constant">transform</span>::CombineParallelBatchMatmul(3));
    pass_seqs.push_back(<span class="org-constant">transform</span>::FoldConstant());
    pass_seqs.push_back(<span class="org-constant">transform</span>::FoldScaleAxis());
    pass_seqs.push_back(<span class="org-constant">transform</span>::CanonicalizeCast());
    pass_seqs.push_back(<span class="org-constant">transform</span>::CanonicalizeOps());
    pass_seqs.push_back(<span class="org-constant">transform</span>::FastMath());
    pass_seqs.push_back(<span class="org-constant">transform</span>::FoldConstant());
    <span class="org-keyword">return</span> pass_seqs;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org0000012" class="outline-4">
<h4 id="org0000012"><span class="section-number-4">1.1.3.</span> PassContext</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
PassContext 可以控制 pass 的开关, 包括 relay 和 tir 相关的 pass. 有时会需要关掉某个 pass, 例如: batchnorm 正常会被 SimplifyInference Pass 转换成 mul/add, 也许对某些 target 有更高效的实现
</p>
</div>

<div id="outline-container-org0000006" class="outline-5">
<h5 id="org0000006"><span class="section-number-5">1.1.3.1.</span> opt_level</h5>
</div>

<div id="outline-container-org0000009" class="outline-5">
<h5 id="org0000009"><span class="section-number-5">1.1.3.2.</span> disabled_pass</h5>
</div>

<div id="outline-container-org000000c" class="outline-5">
<h5 id="org000000c"><span class="section-number-5">1.1.3.3.</span> required_pass</h5>
</div>

<div id="outline-container-org000000f" class="outline-5">
<h5 id="org000000f"><span class="section-number-5">1.1.3.4.</span> config</h5>
<div class="outline-text-5" id="text-1-1-3-4">
<div class="org-src-container">
<pre class="src src-c++">TVM_REGISTER_PASS_CONFIG_OPTION(<span class="org-string">"tir.noalias"</span>, Bool);
TVM_REGISTER_PASS_CONFIG_OPTION(<span class="org-string">"tir.detect_global_barrier"</span>, Bool);
TVM_REGISTER_PASS_CONFIG_OPTION(<span class="org-string">"tir.instrument_bound_checkers"</span>, Bool);
TVM_REGISTER_PASS_CONFIG_OPTION(<span class="org-string">"tir.disable_assert"</span>, Bool);
TVM_REGISTER_PASS_CONFIG_OPTION(<span class="org-string">"tir.disable_vectorize"</span>, Bool);
TVM_REGISTER_PASS_CONFIG_OPTION(<span class="org-string">"tir.add_lower_pass"</span>, <span class="org-type">Array</span>&lt;<span class="org-type">Array</span>&lt;ObjectRef&gt;&gt;);
</pre>
</div>

<p>
<a href="tvm_vta.html#org0000007">tir.add_lower_pass</a>
</p>
</div>
</div>
</div>

<div id="outline-container-org0000015" class="outline-4">
<h4 id="org0000015"><span class="section-number-4">1.1.4.</span> <a href="relay_transform.html#org0000036">Relay Transform</a></h4>
</div>
</div>

<div id="outline-container-org0000043" class="outline-3">
<h3 id="org0000043"><span class="section-number-3">1.2.</span> Relay IR -&gt; TE -&gt; TIR</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-org000001b" class="outline-4">
<h4 id="org000001b"><span class="section-number-4">1.2.1.</span> Relay IR -&gt; OpRegistry</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>

</p>

<p>
Relay IR 例如 relay.op.sort() 返回的实际上是 Relay Expr:
tvm::relay::Call(Op::Get("sort"))
</p>
</div>
</div>

<div id="outline-container-org000002d" class="outline-4">
<h4 id="org000002d"><span class="section-number-4">1.2.2.</span> OpRegistry -&gt; TE</h4>
<div class="outline-text-4" id="text-1-2-2">
</div>
<div id="outline-container-org000001e" class="outline-5">
<h5 id="org000001e"><span class="section-number-5">1.2.2.1.</span> BuildRelay</h5>
<div class="outline-text-5" id="text-1-2-2-1">
<div class="org-src-container">
<pre class="src src-c++"><span class="org-constant">BuildRelay</span>:
  executor_codegen_ = MakeExecutorCodegen(executor_);
  executor_codegen_-&gt;Init(<span class="org-constant">nullptr</span>, targets_);
  executor_codegen_-&gt;Codegen(func, mod_name);
    <span class="org-keyword">auto</span> <span class="org-variable-name">lowered_module</span> = <span class="org-constant">tec</span>::LowerTE()
  executor_codegen_-&gt;UpdateOutput(&amp;ret_);
  ret_.params = executor_codegen_-&gt;GetParams();

  <span class="org-keyword">auto</span> <span class="org-variable-name">lowered_funcs</span> = executor_codegen_-&gt;GetIRModule();

</pre>
</div>
</div>
</div>

<div id="outline-container-org0000027" class="outline-5">
<h5 id="org0000027"><span class="section-number-5">1.2.2.2.</span> ExecutorCodegen</h5>
<div class="outline-text-5" id="text-1-2-2-2">
</div>
<div id="outline-container-org0000021" class="outline-6">
<h6 id="org0000021"><span class="section-number-6">1.2.2.2.1.</span> GraphExecutorCodegen</h6>
</div>

<div id="outline-container-org0000024" class="outline-6">
<h6 id="org0000024"><span class="section-number-6">1.2.2.2.2.</span> AOTExecutorCodegen</h6>
</div>
</div>

<div id="outline-container-org000002a" class="outline-5">
<h5 id="org000002a"><span class="section-number-5">1.2.2.3.</span> LowerTE</h5>
<div class="outline-text-5" id="text-1-2-2-3">
<div class="org-src-container">
<pre class="src src-c++"><span class="org-constant">LowerTE</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324; VisitExpr &#22788;&#29702;&#30340;&#37117;&#26159; Relay IR</span>
  LowerTensorExpr.VisitExpr()
    LowerInternal()
      <span class="org-keyword">auto</span> <span class="org-variable-name">cfunc</span> = PrimFuncFor(key-&gt;source_func, key-&gt;target, [&amp;](<span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span>) {
        <span class="org-keyword">auto</span> <span class="org-variable-name">mangled</span> = mangle_fn(name);
        <span class="org-keyword">return</span> GetUniqueName(mangled, &amp;name_map_);
      });
        <span class="org-keyword">return</span> ScheduleBuilder(target).Create(source_func, renamer);
          <span class="org-keyword">this</span>-&gt;VisitExpr(prim_func-&gt;body);
            <span class="org-comment-delimiter">// </span><span class="org-comment">VisitExpr_(xxx)</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324;&#20250;&#35843;&#29992;&#21040; python, &#26597;&#25214; strategy,</span>
            <span class="org-keyword">static</span> <span class="org-keyword">auto</span> <span class="org-variable-name">flower_call</span> = <span class="org-constant">tvm</span>::<span class="org-constant">runtime</span>::<span class="org-constant">Registry</span>::Get(<span class="org-string">"relay.backend.lower_call"</span>);
            <span class="org-type">LoweredOutput</span> <span class="org-variable-name">lowered_out</span> = (*flower_call)(GetRef&lt;Call&gt;(call_node), inputs, target_);
            <span class="org-comment-delimiter">// </span><span class="org-comment">!!! outputs &#26159; relay &#23545;&#24212;&#30340; te</span>
            outputs = lowered_out-&gt;outputs;
            <span class="org-comment-delimiter">// </span><span class="org-comment">!!! impl &#20013;&#21253;&#25324; schedule</span>
            impl = lowered_out-&gt;implementation;
  <span class="org-comment-delimiter">// </span><span class="org-comment">external functional, &#21442;&#32771;  [[file:tvm_byoc_codegen.org::*&#32534;&#35793; external functions][&#32534;&#35793; external functions]]</span>
  lowered_module.external_mods = compiler-&gt;LowerExternalFunctions();

</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org0000040" class="outline-4">
<h4 id="org0000040"><span class="section-number-4">1.2.3.</span> TE -&gt; TIR</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
TE 是没有经过 schedule 的 TIR， 因为 te.compute 返回的已经是 TIR 了.
</p>

<p>
以下面代码为例：
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">M</span> <span class="org-operator">=</span> 10
<span class="org-variable-name">A</span> <span class="org-operator">=</span> te.placeholder((M, ), name<span class="org-operator">=</span><span class="org-string">"A"</span>)
<span class="org-variable-name">B</span> <span class="org-operator">=</span> te.placeholder((M, ), name<span class="org-operator">=</span><span class="org-string">"B"</span>)
<span class="org-keyword">import</span> ipdb; ipdb.set_trace()
<span class="org-variable-name">C</span> <span class="org-operator">=</span> te.compute((M, ), <span class="org-keyword">lambda</span> x: A[x] <span class="org-operator">+</span> B[x])
</pre>
</div>

<p>
当 te.compute 返回后， C.op 是由 TIR 组成的 ComputeOp:
</p>

<p>
加了些 log 后打印出来的 ComputeOp 中的表达式类型为:
</p>
<pre class="example" id="org0000030">
&lt;Array&gt;
  &lt;tir.Add&gt;
    &lt;tir.ProducerLoad&gt;A[{&lt;tir.Var&gt;x}
    &lt;tir.ProducerLoad&gt;B[{&lt;tir.Var&gt;x}
</pre>

<p>
te.compute 执行时会直接执行 lambda 产生 Op, 具体过程依赖于 python 的 operator
overloading, 例如:
</p>

<ol class="org-ol">
<li>A 的类型为 Tensor, A[x] 会调用 Tensor.__getitem__, 产生一个 tir:ProducerLoad</li>
<li>A[x]+B[x] 会调用 ExprOp.__add__， 产生一个 tir::Add</li>
</ol>
</div>


<div id="outline-container-org0000034" class="outline-5">
<h5 id="org0000034"><span class="section-number-5">1.2.3.1.</span> Schedule</h5>
<div class="outline-text-5" id="text-1-2-3-1">
<p>
Schedule 的原理: <a href="tvm_schedule.html#org000003c">Schedule</a>
</p>

<div class="org-src-container">
<pre class="src src-c++"><span class="org-constant">LowerInternal</span> :
    <span class="org-comment-delimiter">// </span><span class="org-comment">LowerSchedule &#25226; TE &#26681;&#25454; schedule &#32763;&#35793;&#25104; TIR</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">tvm.build, tvm.lower &#20063;&#26159;&#35843;&#29992;&#30340;&#36825;&#20010;&#20989;&#25968;&#25226; te.schedule &#32763;&#35793;&#25104; TIR</span>
    cfunc-&gt;funcs-&gt;Update(
        <span class="org-constant">tvm</span>::LowerSchedule(cfunc-&gt;schedule, all_args, func_name, binds));
</pre>
</div>

<p>
以一个简单的 split 为例:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter">#</span><span class="org-comment">!/usr/bin/env python3</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">-*- coding: utf-8 -*-</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">2021-08-03 11:11</span>
<span class="org-keyword">import</span> tvm
<span class="org-keyword">from</span> tvm <span class="org-keyword">import</span> te

<span class="org-variable-name">M</span> <span class="org-operator">=</span> 10
<span class="org-variable-name">A</span> <span class="org-operator">=</span> te.placeholder((M,), name<span class="org-operator">=</span><span class="org-string">"A"</span>)
<span class="org-variable-name">B</span> <span class="org-operator">=</span> te.placeholder((M,), name<span class="org-operator">=</span><span class="org-string">"B"</span>)

<span class="org-variable-name">C</span> <span class="org-operator">=</span> te.compute((M,), <span class="org-keyword">lambda</span> x: A[x] <span class="org-operator">+</span> B[x])
<span class="org-variable-name">s</span> <span class="org-operator">=</span> te.create_schedule(C.op)
s[C].split(C.op.axis[0], factor<span class="org-operator">=</span>5)

<span class="org-variable-name">f</span> <span class="org-operator">=</span> tvm.build(s, [A, B, C], target<span class="org-operator">=</span><span class="org-string">"c"</span>, name<span class="org-operator">=</span><span class="org-string">"hello"</span>)
</pre>
</div>
</div>

<div id="outline-container-org0000031" class="outline-6">
<h6 id="org0000031"><span class="section-number-6">1.2.3.1.1.</span> ScheduleToModule</h6>
<div class="outline-text-6" id="text-1-2-3-1-1">
<div class="org-src-container">
<pre class="src src-c++"><span class="org-constant">LowerSchedule</span>:
  <span class="org-type">IRModule</span> <span class="org-variable-name">mod</span> = ScheduleToModule(<span class="org-constant">std</span>::move(sch), args, name, binds);
  <span class="org-type">Array</span>&lt;<span class="org-constant">transform</span>::Pass&gt; <span class="org-variable-name">pass_list</span> = CreatePassList(simple_mode, <span class="org-constant">true</span>);
  <span class="org-keyword">return</span> LowerWithPassList(mod, pass_list);

<span class="org-constant">ScheduleToModule</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">InferBound &#26681;&#25454; split &#30340; factor &#24471;&#21040; itervar &#21450;&#20854;&#24490;&#29615;&#30340;&#33539;&#22260;&#65292; &#27604;&#22914;&#36825;&#37324;&#25171;&#21360;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20986; bounds &#30340;&#20449;&#24687;:</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">for (auto&amp; p : bounds) {</span>
  <span class="org-comment-delimiter">//     </span><span class="org-comment">LOG_INFO &lt;&lt; p.first &lt;&lt; p.second;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">}</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#25171;&#21360;&#20986;&#32467;&#26524;&#20026;:</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">bound.cc:262: {&lt;tir.IterVar&gt;iter_var(x.outer, )}{&lt;Range&gt;range(min={&lt;IntImm&gt;0}, ext={&lt;IntImm&gt;2})}</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">bound.cc:262: {&lt;tir.IterVar&gt;iter_var(x, {&lt;Range&gt;range(min={&lt;IntImm&gt;0}, ext={&lt;IntImm&gt;10})})}{&lt;Range&gt;range(min={&lt;IntImm&gt;0}, ext={&lt;IntImm&gt;10})}</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">bound.cc:262: {&lt;tir.IterVar&gt;iter_var(x.inner, )}{&lt;Range&gt;range(min={&lt;IntImm&gt;0}, ext={&lt;IntImm&gt;5})}</span>
  <span class="org-type">Map</span>&lt;<span class="org-constant">tir</span>::IterVar, Range&gt; <span class="org-variable-name">bounds</span> = <span class="org-constant">te</span>::InferBound(sch);
  <span class="org-constant">tir</span>::<span class="org-type">Stmt</span> <span class="org-variable-name">stmt</span> = <span class="org-constant">te</span>::ScheduleOps(sch, <span class="org-constant">std</span>::move(bounds), <span class="org-constant">false</span>);
    body = MakePipeline(s, dom_map, body, debug_keep_trivial_loop);
      <span class="org-type">Stmt</span> <span class="org-variable-name">producer</span> = s-&gt;op-&gt;BuildProvide(s, dom_map,  debug_keep_trivial_loop);
        MakeComputeStmt(<span class="org-keyword">this</span>, stage, dom_map, debug_ keep_trivial_loop);
          <span class="org-comment-delimiter">// </span><span class="org-comment">&#21021;&#22987; body &#20013;&#21482;&#26377;&#19968;&#26465; stmt, &#21363; lambda(x) :A[x]+B[x] &#36890;&#36807; compute &#29983;&#25104; &#30340; stmt</span>
          <span class="org-comment-delimiter">// </span><span class="org-comment">{&lt;tir.ProducerStore&gt;compute[{&lt;tir.Var&gt;x }] ={&lt;tir.Add&gt;({&lt;tir.ProducerLoad&gt;A[{&lt;tir.Var&gt;x}]} + {&lt;tir.ProducerLoad&gt;B[{&lt;tir.Var&gt;x}]})}</span>
          <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; self-&gt;body.size(); ++i) {
            provides.emplace_back(MakeProvide(self, stage-&gt;op.output(i)));
          }
          <span class="org-comment-delimiter">// </span><span class="org-comment">MergeNest &#26368;&#32456;&#26681;&#25454; bounds (&#21363; dom_map)  &#29983;&#25104;&#39069;&#22806;&#30340;&#24490;&#29615;&#35821;&#21477;&#65292;</span>
          <span class="org-comment-delimiter">// </span><span class="org-comment">MergeNest &#36820;&#22238;&#30340; stmt &#20026;:</span>
          <span class="org-comment-delimiter">//</span>
          <span class="org-comment-delimiter">// </span><span class="org-comment">{&lt;tir.For&gt;for ({&lt;tir.Var&gt;x.outer}, {&lt;In tImm&gt;0}, {&lt;IntImm&gt;2}) {</span>
          <span class="org-comment-delimiter">//   </span><span class="org-comment">{&lt;tir.AttrStmt&gt;  // attr [{&lt;tir.IterV ar&gt;iter_var(x.outer, )}] loop_scope = {&lt;tir.Var&gt;x.outer}</span>
          <span class="org-comment-delimiter">//   </span><span class="org-comment">{&lt;tir.For&gt;  for ({&lt;tir.Var&gt;x.inner},  {&lt;IntImm&gt;0}, {&lt;IntImm&gt;5}) {</span>
          <span class="org-comment-delimiter">//     </span><span class="org-comment">{&lt;tir.AttrStmt&gt;    // attr [{&lt;tir.I terVar&gt;iter_var(x.inner, )}] loop_scope = {&lt;tir.Var&gt;x.inner}</span>
          <span class="org-comment-delimiter">//     </span><span class="org-comment">{&lt;tir.ProducerStore&gt;    compute[{&lt;t ir.Var&gt;x}] ={&lt;tir.Add&gt;({&lt;tir.ProducerLoad&gt;A[{&lt;tir.Var&gt;x}]} + {&lt;tir.ProducerLoad&gt;B[{&lt;tir.Var&gt;x}]})}}}</span>
          <span class="org-comment-delimiter">//   </span><span class="org-comment">}}}}</span>
          <span class="org-comment-delimiter">// </span><span class="org-comment">}</span>
          provide = MergeNest(n.main_nest, provide);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org000003d" class="outline-5">
<h5 id="org000003d"><span class="section-number-5">1.2.3.2.</span> TIR Optimizations</h5>
<div class="outline-text-5" id="text-1-2-3-2">
</div>
<div id="outline-container-org0000037" class="outline-6">
<h6 id="org0000037"><span class="section-number-6">1.2.3.2.1.</span> LowerWithPassList</h6>
<div class="outline-text-6" id="text-1-2-3-2-1">
<p>
ScheduleToModule 得到 tir 后, LowerWithPassList 可以对 tir 做进一步的修改和优化,
每一种修改称为一个 pass, 针对 tir 的 pass 在 tvm::tir::transform 下
</p>

<p>
其中 tir.add_lower_pass 是用户自己添加的 pass, 通过 add_lower_pass 机制, 上层可以定制生成的 tir. VTA 就是通过 add_lower_pass 添加自定义的 pass, 把一个 tir (例如 tir.add) 转换为对 vta runtime 的调用的 (例如 VTAPushALUOp)
</p>

<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">Array</span>&lt;<span class="org-constant">tvm</span>::<span class="org-constant">transform</span>::Pass&gt; <span class="org-function-name">CreatePassList</span>(<span class="org-type">bool</span> <span class="org-variable-name">disable_loop_partition</span>, <span class="org-type">bool</span> <span class="org-variable-name">for_te_schedule</span>) {
  <span class="org-constant">transform</span>::<span class="org-type">PassContext</span> <span class="org-variable-name">pass_ctx</span> = <span class="org-constant">transform</span>::<span class="org-constant">PassContext</span>::Current();

  <span class="org-comment-delimiter">// </span><span class="org-comment">Get any user-added passes</span>
  <span class="org-type">Array</span>&lt;<span class="org-type">Array</span>&lt;ObjectRef&gt;&gt; <span class="org-variable-name">add_lower_pass</span> =
      pass_ctx-&gt;GetConfig&lt;<span class="org-type">Array</span>&lt;<span class="org-type">Array</span>&lt;ObjectRef&gt;&gt;&gt;(<span class="org-string">"tir.add_lower_pass"</span>, Array&lt;<span class="org-type">Array</span>&lt;ObjectRef&gt;&gt;())
          .value();

  <span class="org-type">Array</span>&lt;<span class="org-constant">transform</span>::Pass&gt; <span class="org-variable-name">user_lower_phase0</span> = Array&lt;<span class="org-constant">transform</span>::Pass&gt;();
  <span class="org-type">Array</span>&lt;<span class="org-constant">transform</span>::Pass&gt; <span class="org-variable-name">user_lower_phase1</span> = Array&lt;<span class="org-constant">transform</span>::Pass&gt;();
  <span class="org-type">Array</span>&lt;<span class="org-constant">transform</span>::Pass&gt; <span class="org-variable-name">user_lower_phase2</span> = Array&lt;<span class="org-constant">transform</span>::Pass&gt;();
  <span class="org-type">Array</span>&lt;<span class="org-constant">transform</span>::Pass&gt; <span class="org-variable-name">user_lower_phase3</span> = Array&lt;<span class="org-constant">transform</span>::Pass&gt;();

  <span class="org-comment-delimiter">// </span><span class="org-comment">phase pasees is of the form</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">[[phase_number, pass], [phase_number, pass]... ]</span>
  <span class="org-keyword">for</span> (<span class="org-type">Array</span>&lt;ObjectRef&gt; <span class="org-variable-name">phase_pass</span> : add_lower_pass) {
    <span class="org-keyword">const</span> <span class="org-type">IntImmNode</span>* <span class="org-variable-name">phase_num</span> = phase_pass[0].as&lt;<span class="org-type">IntImmNode</span>&gt;();
    ICHECK(phase_num)
        &lt;&lt; <span class="org-string">"Expected the first entry in the inner Array of tir.add_lower_pass to be an integer"</span>;
    <span class="org-type">int</span> <span class="org-variable-name">phase_num_val</span> = phase_num-&gt;value;

    CHECK_GE(phase_num_val, 0);

    <span class="org-keyword">const</span> <span class="org-constant">tvm</span>::<span class="org-constant">transform</span>::<span class="org-type">PassNode</span>* <span class="org-variable-name">pass_node</span> = phase_pass[1].as&lt;<span class="org-constant">tvm</span>::<span class="org-constant">transform</span>::<span class="org-type">PassNode</span>&gt;();
    <span class="org-constant">tvm</span>::<span class="org-constant">transform</span>::<span class="org-type">Pass</span> <span class="org-variable-name">pass</span> = GetRef&lt;<span class="org-constant">tvm</span>::<span class="org-constant">transform</span>::<span class="org-type">Pass</span>&gt;(pass_node);
    <span class="org-comment-delimiter">// </span><span class="org-comment">Copy the pass into the correct phase</span>
    <span class="org-keyword">if</span> (phase_num_val == 0) {
      user_lower_phase0.push_back(pass);
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (phase_num_val == 1) {
      user_lower_phase1.push_back(pass);
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (phase_num_val == 2) {
      user_lower_phase2.push_back(pass);
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (phase_num_val &gt;= 3) {
      user_lower_phase3.push_back(pass);
    }
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Construct the pass list, inserting the user provided passes at the end of the phase</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">PHASE 0</span>
  <span class="org-type">Array</span>&lt;<span class="org-constant">tvm</span>::<span class="org-constant">transform</span>::<span class="org-type">Pass</span>&gt; <span class="org-variable-name">pass_list</span> = user_lower_phase0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">PHASE 1</span>
  <span class="org-keyword">if</span> (for_te_schedule) {
    pass_list.push_back(<span class="org-constant">tir</span>::<span class="org-constant">transform</span>::InjectPrefetch());
    pass_list.push_back(<span class="org-constant">tir</span>::<span class="org-constant">transform</span>::StorageFlatten(64, instrument_bound_checkers));
  } <span class="org-keyword">else</span> {
    pass_list.push_back(<span class="org-constant">tir</span>::<span class="org-constant">transform</span>::LowerInitBlock());
    pass_list.push_back(<span class="org-constant">tir</span>::<span class="org-constant">transform</span>::PlanAndUpdateBufferAllocationLocation());
    pass_list.push_back(<span class="org-constant">tir</span>::<span class="org-constant">transform</span>::ConvertBlocksToOpaque());
    pass_list.push_back(<span class="org-constant">tir</span>::<span class="org-constant">transform</span>::CompactBufferAllocation());
    pass_list.push_back(<span class="org-constant">tir</span>::<span class="org-constant">transform</span>::LowerMatchBuffer());
    pass_list.push_back(<span class="org-constant">tir</span>::<span class="org-constant">transform</span>::FlattenBuffer());
  }
  pass_list.push_back(<span class="org-constant">tir</span>::<span class="org-constant">transform</span>::BF16Legalize());
  pass_list.push_back(<span class="org-constant">tir</span>::<span class="org-constant">transform</span>::NarrowDataType(32));
  pass_list.push_back(<span class="org-constant">tir</span>::<span class="org-constant">transform</span>::Simplify());

  <span class="org-comment-delimiter">// </span><span class="org-comment">Add user-defined phase-1 passes</span>
  pass_list.insert(pass_list.end(), user_lower_phase1.begin(), user_lower_phase1.end());

  <span class="org-comment-delimiter">// </span><span class="org-comment">PHASE 2</span>
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>disable_loop_partition) {
    pass_list.push_back(<span class="org-constant">tir</span>::<span class="org-constant">transform</span>::LoopPartition());
  }

  pass_list.push_back(<span class="org-constant">tir</span>::<span class="org-constant">transform</span>::VectorizeLoop(<span class="org-negation-char">!</span>disable_vectorize));
  pass_list.push_back(<span class="org-constant">tir</span>::<span class="org-constant">transform</span>::InjectVirtualThread());
  pass_list.push_back(<span class="org-constant">tir</span>::<span class="org-constant">transform</span>::InjectDoubleBuffer());
  pass_list.push_back(<span class="org-constant">tir</span>::<span class="org-constant">transform</span>::StorageRewrite());
  pass_list.push_back(<span class="org-constant">tir</span>::<span class="org-constant">transform</span>::UnrollLoop());

  <span class="org-comment-delimiter">// </span><span class="org-comment">Add user-defined phase-2 passes</span>
  pass_list.insert(pass_list.end(), user_lower_phase2.begin(), user_lower_phase2.end());

  <span class="org-comment-delimiter">// </span><span class="org-comment">PHASE 3</span>
  pass_list.push_back(<span class="org-constant">tir</span>::<span class="org-constant">transform</span>::Simplify());
  pass_list.push_back(<span class="org-constant">tir</span>::<span class="org-constant">transform</span>::RemoveNoOp());
  pass_list.push_back(<span class="org-constant">tir</span>::<span class="org-constant">transform</span>::RewriteUnsafeSelect());
  pass_list.push_back(<span class="org-constant">tir</span>::<span class="org-constant">transform</span>::HoistIfThenElse());

  <span class="org-comment-delimiter">// </span><span class="org-comment">Add user-defined phase-3 passes</span>
  pass_list.insert(pass_list.end(), user_lower_phase3.begin(), user_lower_phase3.end());

  <span class="org-keyword">if</span> (instrument_bound_checkers) {
    pass_list.push_back(<span class="org-constant">tir</span>::<span class="org-constant">transform</span>::InstrumentBoundCheckers());
  }
  <span class="org-keyword">return</span> pass_list;
}

</pre>
</div>
</div>
</div>

<div id="outline-container-org000003a" class="outline-6">
<h6 id="org000003a"><span class="section-number-6">1.2.3.2.2.</span> TIR Transform</h6>
</div>
</div>
</div>
</div>

<div id="outline-container-org000004b" class="outline-3">
<h3 id="org000004b"><span class="section-number-3">1.3.</span> TIR -&gt; Codegen</h3>
<div class="outline-text-3" id="text-1-3">
<div class="org-src-container">
<pre class="src src-c++"><span class="org-constant">BuildRelay</span>:
  ret_.mod = <span class="org-constant">tvm</span>::build(lowered_funcs, target_host_);

<span class="org-comment-delimiter">// </span><span class="org-comment">driver_api.cc</span>
<span class="org-constant">runtime</span>::<span class="org-type">Module</span> <span class="org-function-name">build</span>(<span class="org-keyword">const</span> <span class="org-type">Map</span>&lt;Target, IRModule&gt;&amp; <span class="org-variable-name">inputs_arg</span>, <span class="org-keyword">const</span> <span class="org-type">Target</span>&amp; <span class="org-variable-name">target_host_arg</span>) :
  <span class="org-keyword">for</span> (<span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">it</span> : inputs) {
    <span class="org-keyword">if</span> (mdevice-&gt;functions.size() != 0) {
      device_modules.push_back(<span class="org-constant">codegen</span>::Build(mdevice, it.first));

  <span class="org-constant">runtime</span>::<span class="org-type">Module</span> <span class="org-variable-name">mhost</span> = <span class="org-constant">codegen</span>::Build(mhost_all, target_host);

<span class="org-comment-delimiter">// </span><span class="org-comment">codegen.cc @ src/target/</span>
<span class="org-constant">runtime</span>::<span class="org-type">Module</span> <span class="org-variable-name">Build</span>(IRModule mod, Target target) {
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">build_f_name</span> = <span class="org-string">"target.build."</span> + target-&gt;kind-&gt;name;
  <span class="org-keyword">const</span> <span class="org-type">PackedFunc</span>* <span class="org-variable-name">bf</span> = <span class="org-constant">runtime</span>::<span class="org-constant">Registry</span>::Get(build_f_name);
  <span class="org-keyword">return</span> (*bf)(mod, target);

<span class="org-comment-delimiter">// </span><span class="org-comment">"target.build.llvm" @ src/target/llvm/llvm_module.cc</span>
TVM_REGISTER_GLOBAL(<span class="org-string">"target.build.llvm"</span>)
    .set_body_typed([](<span class="org-type">IRModule</span> <span class="org-variable-name">mod</span>, <span class="org-type">Target</span> <span class="org-variable-name">target</span>) -&gt; <span class="org-constant">runtime</span>::Module {
      <span class="org-keyword">auto</span> <span class="org-variable-name">n</span> = make_object&lt;LLVMModuleNode&gt;();
      n-&gt;Init(mod, target);
      <span class="org-keyword">return</span> <span class="org-constant">runtime</span>::Module(n);
    });

<span class="org-type">void</span> <span class="org-constant">LLVMModuleNode</span>::<span class="org-variable-name">Init</span>(<span class="org-keyword">const</span> IRModule&amp; mod, <span class="org-keyword">const</span> Target&amp; target):
  InitializeLLVM();
  tm_ = GetLLVMTargetMachine(target);
  <span class="org-type">bool</span> <span class="org-variable-name">system_lib</span> = target-&gt;GetAttr&lt;Bool&gt;(<span class="org-string">"system-lib"</span>).value_or(Bool(<span class="org-constant">false</span>));
  <span class="org-type">bool</span> <span class="org-variable-name">target_c_runtime</span> = (target-&gt;GetAttr&lt;String&gt;(<span class="org-string">"runtime"</span>).value_or(<span class="org-string">""</span>) == kTvmRuntimeCrt);
  ctx_ = <span class="org-constant">std</span>::make_shared&lt;<span class="org-constant">llvm</span>::LLVMContext&gt;();
  <span class="org-constant">std</span>::<span class="org-type">unique_ptr</span>&lt;CodeGenLLVM&gt; <span class="org-variable-name">cg</span> = <span class="org-constant">CodeGenLLVM</span>::Create(tm_.get());
  <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  <span class="org-keyword">for</span> (<span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">f</span> : funcs):
    cg-&gt;AddFunction(f);
  <span class="org-comment-delimiter">// </span><span class="org-comment">....</span>
  module_ = cg-&gt;Finish();

</pre>
</div>

<div class="org-src-container">
<pre class="src src-c++"><span class="org-comment-delimiter">// </span><span class="org-comment">codegen_llvm.cc @ src/target/llvm</span>
<span class="org-constant">AddFunction</span>:
  <span class="org-type">void</span> <span class="org-constant">CodeGenLLVM</span>::<span class="org-function-name">AddFunctionInternal</span>(<span class="org-keyword">const</span> <span class="org-type">PrimFunc</span>&amp; <span class="org-variable-name">f</span>, <span class="org-type">bool</span> <span class="org-variable-name">ret_void</span>):
    function_ = <span class="org-constant">llvm</span>::<span class="org-constant">Function</span>::Create(ftype, <span class="org-constant">llvm</span>::<span class="org-constant">Function</span>::ExternalLinkage,
                                     global_symbol.value().<span class="org-keyword">operator</span> <span class="org-constant">std</span>::<span class="org-type">string</span>(), module_.get());
    <span class="org-keyword">this</span>-&gt;VisitStmt(f-&gt;body);
      <span class="org-comment-delimiter">// </span><span class="org-comment">.....</span>
      <span class="org-constant">CodeGenLLVM</span>::VisitStmt_()
        MakeValue()
          VisitExpr()
            VisitExpr_()
</pre>
</div>
</div>

<div id="outline-container-org0000048" class="outline-4">
<h4 id="org0000048"><span class="section-number-4">1.3.1.</span> Example</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
由于 relay.build 时无法看到对应的 TIR,
<a href="https://discuss.tvm.apache.org/t/capture-tensor-level-ir-and-schedule-from-relay/9630">https://discuss.tvm.apache.org/t/capture-tensor-level-ir-and-schedule-from-relay/9630</a>,
所以直接使用一段 TE 来展示 codegen 的过程
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter">#</span><span class="org-comment">!/usr/bin/env python3</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">-*- coding: utf-8 -*-</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">2021-08-03 11:11</span>
<span class="org-keyword">import</span> tvm
<span class="org-keyword">from</span> tvm <span class="org-keyword">import</span> te

<span class="org-variable-name">M</span> <span class="org-operator">=</span> 10
<span class="org-variable-name">N</span> <span class="org-operator">=</span> 10
<span class="org-variable-name">A</span> <span class="org-operator">=</span> te.placeholder((M, N), name<span class="org-operator">=</span><span class="org-string">"A"</span>)
<span class="org-variable-name">B</span> <span class="org-operator">=</span> te.placeholder((M, N), name<span class="org-operator">=</span><span class="org-string">"B"</span>)
<span class="org-variable-name">C</span> <span class="org-operator">=</span> te.compute((M, N), <span class="org-keyword">lambda</span> x, y: A[x, y] <span class="org-operator">+</span> B[x, y])

<span class="org-variable-name">s</span> <span class="org-operator">=</span> te.create_schedule(C.op)
<span class="org-builtin">print</span>(tvm.lower(s, [A, B, C]))
<span class="org-variable-name">f</span> <span class="org-operator">=</span> tvm.build(s, [A, B, C], target <span class="org-operator">=</span> <span class="org-string">"c"</span>, name <span class="org-operator">=</span> <span class="org-string">"hello"</span>)
<span class="org-comment-delimiter"># </span><span class="org-comment">print(f.get_source())</span>
</pre>
</div>

<p>
primfn(A_1: handle, B_1: handle, compute_1: handle) -&gt; ()
  attr = {"global_symbol": "main", "tir.noalias": True}
  buffers = {A: Buffer(A_2: Pointer(float32), float32, [10, 10], []),
             compute: Buffer(compute_2: Pointer(float32), float32, [10, 10], []),
             B: Buffer(B_2: Pointer(float32), float32, [10, 10], [])}
  buffer_map = {A_1: A, B_1: B, compute_1: compute} {
  for (x: int32, 0, 10) {
    for (y: int32, 0, 10) {
      compute_2[((x*10) + y)] = ((float32*)A_2[((x*10) + y)] + (float32*)B_2[((x*10) + y)])
    }
  }
}
</p>

<p>
下面的 log 展示的是 codegen_c.cc 生成如下的 TE 的过程
</p>

<pre class="example" id="org0000046">
for (x: int32, 0, 10) {
  for (y: int32, 0, 10) {
    compute_2[((x*10) + y)] = ((float32*)A_2[((x*10) + y)] + (float32*)B_2[((x*10) + y)])
  }
}
</pre>

<pre class="example" id="org0000047">
tvm/src/target/source/codegen_c.cc:920: &gt;&gt;VisitStmt_:ForNode
tvm/src/target/source/codegen_c.cc:469:   VisitExpr_: IntImmNode: 10
tvm/src/target/source/codegen_c.cc:922:   extent: 10
tvm/src/target/source/codegen_c.cc:925:   vid: x name_hint: x
tvm/src/target/source/codegen_c.cc:920:   &gt;&gt;VisitStmt_:ForNode
tvm/src/target/source/codegen_c.cc:469:     VisitExpr_: IntImmNode: 10
tvm/src/target/source/codegen_c.cc:922:     extent: 10
tvm/src/target/source/codegen_c.cc:925:     vid: y name_hint: y
tvm/src/target/source/codegen_c.cc:754:     &gt;&gt;VisitStmt_:StoreNode
tvm/src/target/source/codegen_c.cc:526:       &gt;&gt;VisitExpr_:ADD
tvm/src/target/source/codegen_c.cc:159:         &gt;&gt;GetBufferRef
tvm/src/target/source/codegen_c.cc:526:           &gt;&gt;VisitExpr_:ADD
tvm/src/target/source/codegen_c.cc:534:             &gt;&gt;VisitExpr_:MUL
tvm/src/target/source/codegen_c.cc:469:               VisitExpr_: IntImmNode: 10
tvm/src/target/source/codegen_c.cc:536:             &lt;&lt;VisitExpr_:MUL
tvm/src/target/source/codegen_c.cc:528:           &lt;&lt;VisitExpr_:ADD
tvm/src/target/source/codegen_c.cc:231:         &lt;&lt;GetBufferRef:((float*)A)[(((x * 10) + y))]
tvm/src/target/source/codegen_c.cc:159:         &gt;&gt;GetBufferRef
tvm/src/target/source/codegen_c.cc:526:           &gt;&gt;VisitExpr_:ADD
tvm/src/target/source/codegen_c.cc:534:             &gt;&gt;VisitExpr_:MUL
tvm/src/target/source/codegen_c.cc:469:               VisitExpr_: IntImmNode: 10
tvm/src/target/source/codegen_c.cc:536:             &lt;&lt;VisitExpr_:MUL
tvm/src/target/source/codegen_c.cc:528:           &lt;&lt;VisitExpr_:ADD
tvm/src/target/source/codegen_c.cc:231:         &lt;&lt;GetBufferRef:((float*)B)[(((x * 10) + y))]
tvm/src/target/source/codegen_c.cc:528:       &lt;&lt;VisitExpr_:ADD
tvm/src/target/source/codegen_c.cc:758:     &lt;&lt;VisitStmt_:StoreNode: (((float*)A)[(((x * 10) + y))] + ((float*)B)[(((x * 10) + y))])
tvm/src/target/source/codegen_c.cc:159:     &gt;&gt;GetBufferRef
tvm/src/target/source/codegen_c.cc:526:       &gt;&gt;VisitExpr_:ADD
tvm/src/target/source/codegen_c.cc:534:         &gt;&gt;VisitExpr_:MUL
tvm/src/target/source/codegen_c.cc:469:           VisitExpr_: IntImmNode: 10
tvm/src/target/source/codegen_c.cc:536:         &lt;&lt;VisitExpr_:MUL
tvm/src/target/source/codegen_c.cc:528:       &lt;&lt;VisitExpr_:ADD
tvm/src/target/source/codegen_c.cc:231:     &lt;&lt;GetBufferRef:((float*)compute)[(((x * 10) + y))]
tvm/src/target/source/codegen_c.cc:935:   &lt;&lt;VisitStmt_:ForNode
tvm/src/target/source/codegen_c.cc:935: &lt;&lt;VisitStmt_:ForNode

</pre>
</div>
</div>
</div>

<div id="outline-container-org000005f" class="outline-3">
<h3 id="org000005f"><span class="section-number-3">1.4.</span> Build Target</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-org0000050" class="outline-4">
<h4 id="org0000050"><span class="section-number-4">1.4.1.</span> target 参数是如何被解析和使用的</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
build 时的 target 参数, 例如
</p>

<pre class="example" id="org000004e">
llvm --device=arm_cpu --mtriple=armv7a-linux-gnueabihf,
</pre>

<p>
会通过 TargetInternal::FromConfig 进行解析, 变成一个 Target 对象, 打印出来是
</p>

<pre class="example" id="org000004f">
llvm -keys=arm_cpu,cpu -device=arm_cpu -link-params=0 -mtriple=armv7a-linux-gnueabihf
</pre>

<p>
keys 中的 `arm_cpu, cpu` 是 TargetInternal::FromConfig 补上去的.
</p>

<p>
后续代码可能会根据需求访问 target 中的成员, 例如 x86 相关的 topi 会通过 "mcpu"
成员确定 simd 宽度:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">get_simd_32bit_lanes</span>():
    <span class="org-variable-name">mcpu</span> <span class="org-operator">=</span> tvm.target.Target.current().mcpu
    <span class="org-variable-name">fp32_vec_len</span> <span class="org-operator">=</span> 4
    <span class="org-keyword">if</span> target_has_avx512(mcpu):
        <span class="org-variable-name">fp32_vec_len</span> <span class="org-operator">=</span> 16
    <span class="org-keyword">elif</span> target_has_avx2(mcpu):
        <span class="org-variable-name">fp32_vec_len</span> <span class="org-operator">=</span> 8
    <span class="org-keyword">return</span> fp32_vec_len
</pre>
</div>

<p>
Target 的支持的成员通过 target_kind 定义的, 主要包括:
</p>

<ol class="org-ol">
<li>kind</li>
<li>keys</li>
<li>device</li>
<li>mcpu</li>
<li>mtriple</li>
<li>runtime</li>
<li>system-lib</li>
</ol>

<div class="org-src-container">
<pre class="src src-C++">TVM_REGISTER_TARGET_KIND(<span class="org-string">"llvm"</span>, kDLCPU)
    .add_attr_option&lt;<span class="org-type">Array</span>&lt;String&gt;&gt;(<span class="org-string">"mattr"</span>)
    .add_attr_option&lt;String&gt;(<span class="org-string">"mcpu"</span>)
    .add_attr_option&lt;String&gt;(<span class="org-string">"mtriple"</span>)
    .add_attr_option&lt;String&gt;(<span class="org-string">"mfloat-abi"</span>)
    .add_attr_option&lt;String&gt;(<span class="org-string">"mabi"</span>)
    .add_attr_option&lt;Bool&gt;(<span class="org-string">"system-lib"</span>)
    .add_attr_option&lt;String&gt;(<span class="org-string">"runtime"</span>)
    .add_attr_option&lt;Bool&gt;(<span class="org-string">"link-params"</span>, Bool(<span class="org-constant">false</span>))
    .add_attr_option&lt;Bool&gt;(<span class="org-string">"unpacked-api"</span>)
    .add_attr_option&lt;String&gt;(<span class="org-string">"interface-api"</span>)
    .set_default_keys({<span class="org-string">"cpu"</span>});

<span class="org-preprocessor">#define</span> <span class="org-function-name">TVM_REGISTER_TARGET_KIND</span>(<span class="org-variable-name">TargetKindName</span>, <span class="org-variable-name">DeviceType</span>)      \
  TVM_STR_CONCAT(TVM_TARGET_KIND_REGISTER_VAR_DEF, __COUNTER__) = \
      ::<span class="org-constant">tvm</span>::<span class="org-constant">TargetKindRegEntry</span>::RegisterOrGet(TargetKindName)    \
          .set_name()                                             \
          .set_device_type(DeviceType)                            \
          .add_attr_option&lt;Array&lt;String&gt;&gt;(<span class="org-string">"keys"</span>)                 \
          .add_attr_option&lt;String&gt;(<span class="org-string">"tag"</span>)                         \
          .add_attr_option&lt;String&gt;(<span class="org-string">"device"</span>)                      \
          .add_attr_option&lt;String&gt;(<span class="org-string">"model"</span>)                       \
          .add_attr_option&lt;Array&lt;String&gt;&gt;(<span class="org-string">"libs"</span>)                 \
          .add_attr_option&lt;Target&gt;(<span class="org-string">"host"</span>)                        \
          .add_attr_option&lt;Integer&gt;(<span class="org-string">"from_device"</span>)

}  <span class="org-comment-delimiter">// </span><span class="org-comment">namespace tvm</span>

</pre>
</div>

<p>
Target 中最重要的成员是 kind 和 keys:
</p>

<ol class="org-ol">
<li><p>
kind 决定了 target codegen
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">build_f_name</span> = <span class="org-string">"target.build."</span> + target-&gt;kind-&gt;name;
</pre>
</div></li>

<li>keys 决定了查找哪些 strategy
<code>tvm/python/tvm/target/generic_func.py::for k in target.keys:</code></li>
</ol>
</div>
</div>

<div id="outline-container-org0000053" class="outline-4">
<h4 id="org0000053"><span class="section-number-4">1.4.2.</span> LLVMTargetToString</h4>
</div>

<div id="outline-container-org000005c" class="outline-4">
<h4 id="org000005c"><span class="section-number-4">1.4.3.</span> arm_cpu 针对 arm 的特殊处理</h4>
<div class="outline-text-4" id="text-1-4-3">
</div>
<div id="outline-container-org0000056" class="outline-5">
<h5 id="org0000056"><span class="section-number-5">1.4.3.1.</span> vectorize</h5>
<div class="outline-text-5" id="text-1-4-3-1">
<p>
<a href="https://community.arm.com/arm-community-blogs/b/operating-systems-blog/posts/arm-neon-programming-quick-reference">https://community.arm.com/arm-community-blogs/b/operating-systems-blog/posts/arm-neon-programming-quick-reference</a>
</p>

<p>
neon 最多支持 16 字节的向量操作, 所以 tvm 使用 vectorize shedule 时需要使用特定大小的 split
</p>

<p>
arm_cpu 对应的 schedule_injective 为:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">schedule_injective</span>(outs):
    <span class="org-variable-name">outs</span> <span class="org-operator">=</span> [outs] <span class="org-keyword">if</span> <span class="org-builtin">isinstance</span>(outs, te.tensor.Tensor) <span class="org-keyword">else</span> outs
    <span class="org-variable-name">s</span> <span class="org-operator">=</span> te.create_schedule([x.op <span class="org-keyword">for</span> x <span class="org-keyword">in</span> outs])
    <span class="org-variable-name">x</span> <span class="org-operator">=</span> outs[0]

    <span class="org-keyword">if</span> <span class="org-builtin">list</span>(s[x].op.axis):
        <span class="org-comment-delimiter"># </span><span class="org-comment">split &#22823;&#23567;&#20026; 4, &#22240;&#20026; 4 &#20010; float32 &#30340;&#22823;&#23567;&#21363;&#20026; 16</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">&#36825;&#37324;&#30340;&#20195;&#30721;&#26377;&#38382;&#39064;: &#33509;&#25968;&#25454;&#31867;&#22411;&#26159; int8, &#36825;&#37324;&#30340; split &#35774;&#32622;&#20026; 16 &#24615;&#33021;&#25165;&#26159;&#26368;&#22909;&#30340;</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">https://github.com/apache/tvm/pull/9339</span>
        (<span class="org-variable-name">io</span>, <span class="org-variable-name">ii</span>) <span class="org-operator">=</span> s[x].split(<span class="org-builtin">list</span>(s[x].op.axis)[<span class="org-operator">-</span>1], 4)
        s[x].vectorize(ii)
    tvm.te.schedule.AutoInlineInjective(s)

    <span class="org-keyword">if</span> <span class="org-keyword">not</span> is_empty_shape(x.shape):
        schedule_injective_from_existing(s, x)
    <span class="org-keyword">return</span> s

</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter">#</span><span class="org-comment">!/usr/bin/env python3</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">-*- coding: utf-8 -*-</span>
<span class="org-keyword">import</span> tvm
<span class="org-keyword">from</span> tvm <span class="org-keyword">import</span> relay

<span class="org-variable-name">x</span> <span class="org-operator">=</span> relay.var(<span class="org-string">"x"</span>, shape<span class="org-operator">=</span>(1, 1024), dtype<span class="org-operator">=</span><span class="org-string">"float32"</span>)
<span class="org-variable-name">y</span> <span class="org-operator">=</span> relay.add(x, x)
<span class="org-variable-name">func</span> <span class="org-operator">=</span> relay.Function([x], y)
<span class="org-variable-name">mod</span> <span class="org-operator">=</span> tvm.IRModule.from_expr(func)

<span class="org-keyword">with</span> tvm.transform.PassContext(opt_level<span class="org-operator">=</span>3):
    <span class="org-variable-name">graph</span>, <span class="org-variable-name">lib</span>, <span class="org-variable-name">params</span> <span class="org-operator">=</span> relay.build(
        mod,
        <span class="org-comment-delimiter"># </span><span class="org-comment">target &#20013;&#30340; `-mtriple=armv7a-linux-gnueabihf -mattr=+neon` &#20250;&#30452;&#25509;&#20256;&#32473; llvm</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">(LLVMTargetToString), &#20854;&#20013;armv7a &#30340; neon &#26159;&#21487;&#36873;&#25903;&#25345;, &#25152;&#20197;&#19981;&#20351;&#29992; +neon</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">&#30340;&#35805; llvm &#20250;&#20351;&#29992; vfp. &#22914;&#26524; triple &#25913;&#25104; armv8l &#21017;&#19981;&#38656;&#35201;&#25351;&#23450; +neon, &#22240;&#20026;</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">neon &#23545;&#20110; armv8l &#26159;&#24517;&#36873;&#25903;&#25345;</span>
        target<span class="org-operator">=</span><span class="org-string">"llvm --device=arm_cpu -mtriple=armv7a-linux-gnueabihf -mattr=+neon"</span>,
        params<span class="org-operator">=</span><span class="org-constant">None</span>,
    )

lib.save(<span class="org-string">"/tmp/a.o"</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-bash">arm-linux-gnueabihf-objdump -d /tmp/a.o|tail -n 12
</pre>
</div>

<p>

</p>

<p>
000002a8 &lt;tvmgen_default_fused_add_compute_&gt;:
 2a8:	e3a02000 	mov	r2, #0
 2ac:	e0813002 	add	r3, r1, r2
 2b0:	f4630aef 	vld1.64	{d16-d17}, [r3 :128]
 2b4:	e0803002 	add	r3, r0, r2
 2b8:	f2400de0 	vadd.f32	q8, q8, q8
 2bc:	e2822010 	add	r2, r2, #16
 2c0:	e3520a01 	cmp	r2, #4096	; 0x1000
 2c4:	f4430aef 	vst1.64	{d16-d17}, [r3 :128]
 2c8:	1afffff7 	bne	2ac &lt;tvmgen_default_fused_add_compute_+0x4&gt;
 2cc:	e12fff1e 	bx	lr
</p>
</div>
</div>

<div id="outline-container-org0000059" class="outline-5">
<h5 id="org0000059"><span class="section-number-5">1.4.3.2.</span> tensorize</h5>
<div class="outline-text-5" id="text-1-4-3-2">
<p>
<a href="https://stackoverflow.com/questions/2268562/what-are-intrinsics">what are intrinsics</a>
</p>

<p>
为了加速 arm_cpu 的 conv2d, TVM 会直接使用 neon 相关的 llvm_intrin 进行
tensorize, 例如:
</p>

<ul class="org-ul">
<li>llvm.aarch64.neon.sdot</li>
<li>llvm.aarch64.neon.udot</li>
<li>llvm.aarch64.neon.ummla</li>
<li>llvm.aarch64.neon.smmla</li>
<li>llvm.aarch64.neon.umull</li>
<li>llvm.aarch64.neon.smull</li>
<li>llvm.aarch64.neon.saddlp</li>
<li>llvm.aarch64.neon.uaddlp</li>
<li>llvm.aarch64.neon.addp</li>
<li>llvm.aarch64.neon.sqrdmulh</li>
<li>llvm.aarch64.neon.srshl</li>
<li>llvm.arm.neon.vpadd.v8i8</li>
<li>llvm.arm.neon.vpadd.v8u8</li>
<li>llvm.arm.neon.vpadals.v16i8.v8i16</li>
<li>llvm.arm.neon.vpadalu.v16u8.v8u16</li>
</ul>

<p>
最终 llvm 会生成对 ummla/smmla/udot/sdot 等指令的调用
</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

<p class="author">Author: <a href="mailto:sunway@dogdog.run">sunway@dogdog.run</a><br />
Date: 2021-08-16 Mon 00:00<br />
Last updated: 2024-02-01 Thu 14:04</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
</div>
</body>
</html>
