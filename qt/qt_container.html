<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-01-26 Wed 01:16 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Qt Container</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wei Sun (孙伟)" />
<link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
<link rel = "icon" href = "/icon.png"  type = "image/x-icon">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">Qt Container</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org1a14dc9">1. Qt Container</a>
<ul>
<li><a href="#org7fa455a">1.1. Overview</a>
<ul>
<li><a href="#org79603db">1.1.1. shadow copy</a></li>
<li><a href="#orgf6d2822">1.1.2. copy on write</a></li>
</ul>
</li>
<li><a href="#org160c620">1.2. shadow copy</a>
<ul>
<li><a href="#orge53b106">1.2.1. setSharable</a></li>
</ul>
</li>
<li><a href="#org7d45f43">1.3. copy on write</a>
<ul>
<li><a href="#org789d5df">1.3.1. removeLast</a></li>
<li><a href="#org4db3362">1.3.2. operatror []</a></li>
</ul>
</li>
<li><a href="#org0f44240">1.4. detach 导致的问题</a>
<ul>
<li><a href="#org68f0e7c">1.4.1. 隐含的 detach</a></li>
<li><a href="#orgabf3b57">1.4.2. 修改的不一致</a></li>
</ul>
</li>
<li><a href="#org2d6bd8f">1.5. foreach</a>
<ul>
<li><a href="#org3da390f">1.5.1. foreach 宏会隐式的在 data 的 copy 上迭代:</a></li>
<li><a href="#org0e67d8b">1.5.2. foreach 在 data 的 const copy 上迭代</a></li>
</ul>
</li>
<li><a href="#org5f3964d">1.6. c++ range-based for loop</a></li>
<li><a href="#org407a1d9">1.7. foreach 与 for(;) 的比较</a></li>
<li><a href="#orgb8a0bb7">1.8. Recap</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org1a14dc9" class="outline-2">
<h2 id="org1a14dc9"><span class="section-number-2">1</span> Qt Container</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org7fa455a" class="outline-3">
<h3 id="org7fa455a"><span class="section-number-3">1.1</span> Overview</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Qt 的 container 与 Rust Box 类似, 它们本身只是一个 wrapper, 真正的数据是在堆上分
配的.
</p>

<p>
这种 wrapper 有两个好处:
</p>

<ol class="org-ol">
<li>shadow copy, 复制一个 container 的开销很小</li>
<li>copy on write, 只在需要的时候才 copy 堆上的数据</li>
</ol>

<p>
每种 container 底层都有一个 XxxData 代表堆上数据, 同时包含引用计数负责堆上数据的
释放, 另外, 对于所有可能修改堆上数据的操作, 都会通过 detach 触发 copy on write
</p>
</div>

<div id="outline-container-org79603db" class="outline-4">
<h4 id="org79603db"><span class="section-number-4">1.1.1</span> shadow copy</h4>
<div class="outline-text-4" id="text-1-1-1">
<div class="org-src-container">
<pre class="src src-cpp"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">case 1:</span>
<span style="font-weight: bold; text-decoration: underline;">QVector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt; <span style="font-weight: bold; font-style: italic;">data</span> {1, 2, 3};
<span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">data2</span> = data;

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">case 2:</span>
<span style="font-weight: bold; text-decoration: underline;">QVector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt; <span style="font-weight: bold;">getData</span>() {
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">QVector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt; {1, 2, 3};
}
<span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">data</span> = getData();

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">case 3:</span>
<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">check</span>(<span style="font-weight: bold; text-decoration: underline;">QVector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt; <span style="font-weight: bold; font-style: italic;">data</span>) {}
check(<span style="font-weight: bold; text-decoration: underline;">QVector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt; {1, 2, 3})
</pre>
</div>

<p>
上面三种情况下, data 都是 shadow copy, 其底层的 QTypedArrayData 会指向相同的堆上数
据 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="font-weight: bold; text-decoration: underline;">QVector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt; <span style="font-weight: bold; font-style: italic;">data</span> {1, 2, 3};
printf(<span style="font-style: italic;">"%p\n"</span>, &amp;data[0]);

<span style="font-weight: bold;">const</span> <span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">data2</span> = data;
printf(<span style="font-style: italic;">"%p\n"</span>, &amp;data2[0]);

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36755;&#20986;&#20026;:</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0x1191e68</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0x1191e68</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf6d2822" class="outline-4">
<h4 id="orgf6d2822"><span class="section-number-4">1.1.2</span> copy on write</h4>
<div class="outline-text-4" id="text-1-1-2">
<div class="org-src-container">
<pre class="src src-cpp"><span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">main</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">argc</span>, <span style="font-weight: bold; text-decoration: underline;">char</span> *<span style="font-weight: bold; font-style: italic;">argv</span>[]) {
    <span style="font-weight: bold; text-decoration: underline;">QVector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt; <span style="font-weight: bold; font-style: italic;">data</span> {1, 2, 3};
    printf(<span style="font-style: italic;">"%p\n"</span>, &amp;data[0]);

    <span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">data2</span> = data;
    printf(<span style="font-style: italic;">"%p\n"</span>, &amp;data2[0]);

    <span style="font-weight: bold;">return</span> 0;
}

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36755;&#20986;&#20026;:</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0x1219e68</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0x1219e98</span>
</pre>
</div>

<p>
虽然 data2 并没有显式的修改数据, 但从 qt 看来, 还是有可能发生潜在的 write:
因为 data2 通过 operator[] 返回了堆上数据的引用, 为了防止代码在别处修改这个引用
的数据导致的 write, qt 会针对非 const 的 operator[] 进行 copy
</p>
</div>
</div>
</div>

<div id="outline-container-org160c620" class="outline-3">
<h3 id="org160c620"><span class="section-number-3">1.2</span> shadow copy</h3>
<div class="outline-text-3" id="text-1-2">
<div class="org-src-container">
<pre class="src src-cpp"><span style="font-weight: bold;">template</span> &lt;<span style="font-weight: bold;">typename</span> <span style="font-weight: bold; text-decoration: underline;">T</span>&gt;
<span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">QVector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">T</span>&gt;::<span style="font-weight: bold;">QVector</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">QVector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">T</span>&gt; &amp;<span style="font-weight: bold; font-style: italic;">v</span>)
{
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#33509; ref() &#20026; true, &#34920;&#31034; v &#26159; shareable &#30340;, &#21017;&#36890;&#36807;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">ref() inc &#24341;&#29992;&#35745;&#25968;&#21518;, &#30452;&#25509;&#35753; this.d = v.d &#21363;&#21487;,</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20854;&#20013; d &#21363;&#22534;&#19978;&#30340; QTypedArrayData</span>
    <span style="font-weight: bold;">if</span> (v.d-&gt;ref.ref()) {
        d = v.d;
    } <span style="font-weight: bold;">else</span> {
        <span style="font-weight: bold;">if</span> (v.d-&gt;capacityReserved) {
            d = <span style="font-weight: bold; text-decoration: underline;">Data</span>::allocate(v.d-&gt;alloc);
            Q_CHECK_PTR(d);
            d-&gt;capacityReserved = <span style="font-weight: bold; text-decoration: underline;">true</span>;
        } <span style="font-weight: bold;">else</span> {
            <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">d &#26159;&#22312;&#22534;&#19978;&#20998;&#37197;&#30340;</span>
            d = <span style="font-weight: bold; text-decoration: underline;">Data</span>::allocate(v.d-&gt;size);
            Q_CHECK_PTR(d);
        }
        <span style="font-weight: bold;">if</span> (d-&gt;alloc) {
            copyConstruct(v.d-&gt;begin(), v.d-&gt;end(), d-&gt;begin());
            d-&gt;size = v.d-&gt;size;
        }
    }
}
</pre>
</div>

<p>
shadow copy 是通过 RefCount 实现的, 和 c++ 的 shared_ptr 类似.
</p>
</div>

<div id="outline-container-orge53b106" class="outline-4">
<h4 id="orge53b106"><span class="section-number-4">1.2.1</span> setSharable</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
默认情况下 container 都是 shareable 的, 拷贝构造函数会是 shadow copy. 通过
setSharable(false), 可以阻止这种行为.
</p>
</div>
</div>
</div>

<div id="outline-container-org7d45f43" class="outline-3">
<h3 id="org7d45f43"><span class="section-number-3">1.3</span> copy on write</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>根据 RefCount 决定是否需要通过 detach 进行 copy</li>

<li>针对所有可能修改对象的方法进行 copy on write, 包括显式的 remove, insert 等操作,
operator [] 也有可能导致 detach. 理论上, 所有非 const 方法都应该 detach</li>
</ul>
</div>

<div id="outline-container-org789d5df" class="outline-4">
<h4 id="org789d5df"><span class="section-number-4">1.3.1</span> removeLast</h4>
<div class="outline-text-4" id="text-1-3-1">
<div class="org-src-container">
<pre class="src src-cpp"><span style="font-weight: bold;">template</span> &lt;<span style="font-weight: bold;">typename</span> <span style="font-weight: bold; text-decoration: underline;">T</span>&gt;
<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">QVector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">T</span>&gt;::<span style="font-weight: bold;">removeLast</span>()
{
    <span style="font-weight: bold;">if</span> (d-&gt;ref.isShared())
        detach();
    --d-&gt;size;
    <span style="font-weight: bold;">if</span> (<span style="font-weight: bold; text-decoration: underline;">QTypeInfo</span>&lt;<span style="font-weight: bold; text-decoration: underline;">T</span>&gt;::isComplex)
        (d-&gt;data() + d-&gt;size)-&gt;~T();
}
</pre>
</div>

<p>
detach 会负责:
</p>

<ol class="org-ol">
<li>将原始的 d deref, 即减小原来对象的引用计数</li>
<li>通过 realloc 分配新的内存, 复制旧对象的所有数据(而非仅仅是修改的数据)</li>
</ol>
</div>
</div>

<div id="outline-container-org4db3362" class="outline-4">
<h4 id="org4db3362"><span class="section-number-4">1.3.2</span> operatror []</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
operator [] 会导致 detach:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">T</span> &amp;<span style="font-weight: bold; text-decoration: underline;">QVector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">T</span>&gt;::<span style="font-weight: bold;">operator</span><span style="font-weight: bold;">[]</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span>) {
    <span style="font-weight: bold;">return</span> data()[i];
}

<span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">T</span> *<span style="font-weight: bold;">data</span>() { detach(); <span style="font-weight: bold;">return</span> d-&gt;begin(); }
</pre>
</div>

<p>
const operator [] 并不需要 detach:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="font-weight: bold;">template</span> &lt;<span style="font-weight: bold;">typename</span> <span style="font-weight: bold; text-decoration: underline;">T</span>&gt;
<span style="font-weight: bold;">inline</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">T</span> &amp;<span style="font-weight: bold; text-decoration: underline;">QVector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">T</span>&gt;::<span style="font-weight: bold;">operator</span><span style="font-weight: bold;">[]</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span>) <span style="font-weight: bold;">const</span> {
    <span style="font-weight: bold;">return</span> d-&gt;begin()[i];
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org0f44240" class="outline-3">
<h3 id="org0f44240"><span class="section-number-3">1.4</span> detach 导致的问题</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-org68f0e7c" class="outline-4">
<h4 id="org68f0e7c"><span class="section-number-4">1.4.1</span> 隐含的 detach</h4>
<div class="outline-text-4" id="text-1-4-1">
<div class="org-src-container">
<pre class="src src-cpp"><span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">main</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">argc</span>, <span style="font-weight: bold; text-decoration: underline;">char</span> *<span style="font-weight: bold; font-style: italic;">argv</span>[]) {
    <span style="font-weight: bold; text-decoration: underline;">QVector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt; <span style="font-weight: bold; font-style: italic;">data</span> {1, 2, 3};
    printf(<span style="font-style: italic;">"%p\n"</span>, &amp;data[0]);

    <span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">dataCopy</span> = data;
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> &amp;<span style="font-weight: bold; font-style: italic;">i</span> : dataCopy) {
        printf(<span style="font-style: italic;">"%p\n"</span>, &amp;i);
    }
    <span style="font-weight: bold;">return</span> 0;
}

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0x14f3e68</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">-------</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0x14f3e98</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0x14f3e9c</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0x14f3ea0</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22240;&#20026; dataCopy &#36827;&#34892;&#36941;&#21382;&#26102;, &#38544;&#21547;&#30340;&#20351;&#29992;&#20102; dataCopy.begin() &#26041;&#27861;,</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#32780;&#38750; const &#30340; iterator &#20250;&#38544;&#21547;&#30528; detach</span>
</pre>
</div>

<p>
为避免隐含的 detach, 应尽量使用 const 对象
</p>
</div>
</div>

<div id="outline-container-orgabf3b57" class="outline-4">
<h4 id="orgabf3b57"><span class="section-number-4">1.4.2</span> 修改的不一致</h4>
<div class="outline-text-4" id="text-1-4-2">
<div class="org-src-container">
<pre class="src src-cpp"><span style="font-weight: bold; text-decoration: underline;">QVector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt; <span style="font-weight: bold; font-style: italic;">data</span>{1, 2, 3};
<span style="font-weight: bold; text-decoration: underline;">int</span> &amp;<span style="font-weight: bold; font-style: italic;">first</span> = data[0];

<span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">data2</span> = data;
first = 2;

<span style="font-weight: bold;">foreach</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span>, data2) {
    printf(<span style="font-style: italic;">"%d\n"</span>, i);
}
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">2</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">2</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">3</span>
<span style="font-weight: bold; font-style: italic;">// </span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#34429;&#28982; data2 &#21487;&#20197;&#36879;&#26126;&#30340;&#30475;&#20316;&#26159; data &#30340; deep copy, &#20294;&#20854; data2[0] &#36824;&#26159;&#34987;&#20462;&#25913;&#20102;</span>
</pre>
</div>

<p>
之所以发生问题, 是因为 qt 无法针对 first = 2 这种操作自动 detach
</p>
</div>
</div>
</div>

<div id="outline-container-org2d6bd8f" class="outline-3">
<h3 id="org2d6bd8f"><span class="section-number-3">1.5</span> foreach</h3>
<div class="outline-text-3" id="text-1-5">
</div>
<div id="outline-container-org3da390f" class="outline-4">
<h4 id="org3da390f"><span class="section-number-4">1.5.1</span> foreach 宏会隐式的在 data 的 copy 上迭代:</h4>
<div class="outline-text-4" id="text-1-5-1">
<div class="org-src-container">
<pre class="src src-cpp"><span style="font-weight: bold; text-decoration: underline;">QVector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt; <span style="font-weight: bold; font-style: italic;">data</span>{1, 2};
data.reserve(100);

<span style="font-weight: bold;">for</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> &amp;<span style="font-weight: bold; font-style: italic;">i</span> : data) {
    printf(<span style="font-style: italic;">"%p %d\n"</span>, &amp;i, i);
}
printf(<span style="font-style: italic;">"---\n"</span>);
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">foreach &#20250;&#38544;&#24335;&#22312; data &#30340; copy &#19978;&#36845;&#20195;</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25152;&#20197; foreach &#37324;&#21487;&#20197;&#33258;&#30001;&#30340;&#20462;&#25913; data, &#32780;&#19988;&#20462;&#25913;&#20250;&#23548;&#33268; detach</span>
<span style="font-weight: bold;">foreach</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span>, data) {
    data.insert(0, i);
}

<span style="font-weight: bold;">for</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> &amp;<span style="font-weight: bold; font-style: italic;">i</span> : data) {
    printf(<span style="font-style: italic;">"%p %d\n"</span>, &amp;i, i);
}

printf(<span style="font-style: italic;">"---\n"</span>);

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">range-based loop &#24182;&#19981;&#20250;&#23545; data &#20570; copy, &#26412;&#36136;&#19978;&#23427;&#26159;&#22522;&#20110; iterator &#30340;, &#23427;&#23545; data &#20462;&#25913;&#26159;&#19981;&#21487;&#39044;&#27979;&#30340;</span>
<span style="font-weight: bold;">for</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> &amp;<span style="font-weight: bold; font-style: italic;">i</span> : data) {
    data.insert(0, i);
}

<span style="font-weight: bold;">for</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> &amp;<span style="font-weight: bold; font-style: italic;">i</span> : data) {
    printf(<span style="font-style: italic;">"%p %d\n"</span>, &amp;i, i);
}
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0xd90438 1</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0xd9043c 2</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">---</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0xd79e68 2</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0xd79e6c 1</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0xd79e70 1</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0xd79e74 2</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">---</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0xd79e68 2</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0xd79e6c 2</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0xd79e70 2</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0xd79e74 2</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0xd79e78 2</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0xd79e7c 1</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0xd79e80 1</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0xd79e84 2</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org0e67d8b" class="outline-4">
<h4 id="org0e67d8b"><span class="section-number-4">1.5.2</span> foreach 在 data 的 const copy 上迭代</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
由于 foreach 操作的实际是原数据的 copy, 所以修改 iterator 是没有意义的, 因此, 这
里的 copy 实际上是 const copy
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="font-weight: bold;">foreach</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> &amp;<span style="font-weight: bold; font-style: italic;">i</span>, data) {
    i += 1;
}
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">/home/ANT.AMAZON.COM/waysun/program/qt/5.14.0/gcc_64/include/QtCore/qglobal.h:1110:34: error: binding &#8216;const int&#8217; to reference of type &#8216;int&amp;&#8217; discards qualifiers</span>
<span style="font-weight: bold; font-style: italic;">//      </span><span style="font-weight: bold; font-style: italic;">for (variable = *_container_.i; _container_.control; _container_.control = 0)</span>
</pre>
</div>

<p>
这里的 i 是 const int, 无法被修改
</p>
</div>
</div>
</div>

<div id="outline-container-org5f3964d" class="outline-3">
<h3 id="org5f3964d"><span class="section-number-3">1.6</span> c++ range-based for loop</h3>
<div class="outline-text-3" id="text-1-6">
<p>
range-based for 是通过 iterator 直接操作数据:
</p>

<ol class="org-ol">
<li>不需要 copy</li>
<li>可以修改 iterator</li>
<li>不可以修改 container</li>
<li>begin() 会隐含一个 detach</li>
</ol>

<div class="org-src-container">
<pre class="src src-cpp"><span style="font-weight: bold; text-decoration: underline;">QVector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt; <span style="font-weight: bold; font-style: italic;">data</span>{1, 2, 3};
<span style="font-weight: bold;">for</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> &amp;<span style="font-weight: bold; font-style: italic;">i</span> : data) {
    printf(<span style="font-style: italic;">"%p %d\n"</span>, &amp;i, i);
}
printf(<span style="font-style: italic;">"---\n"</span>);
<span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">data2</span> = data;
<span style="font-weight: bold;">for</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> &amp;<span style="font-weight: bold; font-style: italic;">i</span> : qAsConst(data2)) {
    printf(<span style="font-style: italic;">"%p %d\n"</span>, &amp;i, i);
}
printf(<span style="font-style: italic;">"---\n"</span>);
<span style="font-weight: bold;">for</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> &amp;<span style="font-weight: bold; font-style: italic;">i</span> : data2) {
    printf(<span style="font-style: italic;">"%p %d\n"</span>, &amp;i, i);
}
printf(<span style="font-style: italic;">"---\n"</span>);
<span style="font-weight: bold;">for</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> &amp;<span style="font-weight: bold; font-style: italic;">i</span> : data2) {
    i += 1;
}
<span style="font-weight: bold;">for</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> &amp;<span style="font-weight: bold; font-style: italic;">i</span> : data2) {
    printf(<span style="font-style: italic;">"%p %d\n"</span>, &amp;i, i);
}
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0x65ee68 1</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0x65ee6c 2</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0x65ee70 3</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">---</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0x65ee68 1</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0x65ee6c 2</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0x65ee70 3</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">---</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0x65ee98 1</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0x65ee9c 2</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0x65eea0 3</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">---</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0x65ee98 2</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0x65ee9c 3</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0x65eea0 4</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org407a1d9" class="outline-3">
<h3 id="org407a1d9"><span class="section-number-3">1.7</span> foreach 与 for(;) 的比较</h3>
<div class="outline-text-3" id="text-1-7">
<ul class="org-ul">
<li>foreach 会复制, 可以修改原 container, 由于使用了 const copy, 所以 iterator 不
能修改, 但 iterator 也不会导致 detach</li>

<li>ranged-based for 不复制, 不可以修改原 container, 由于使用了 iterator, 所以
iterator 可以修改, 但 iterator 也会导致 detach</li>

<li>foreach (QPair&lt;int,int&gt; p, list) 无法编译通过, 因为宏无法自理多余的 `,`</li>

<li>foreach 隐含的复制行为, 可以会引起不注意的 bug</li>

<li>for(;) 虽然会导致 detach, 但通过 qAsConst 可以避免</li>

<li>foreach 已经 deprecated</li>
</ul>
</div>
</div>

<div id="outline-container-orgb8a0bb7" class="outline-3">
<h3 id="orgb8a0bb7"><span class="section-number-3">1.8</span> Recap</h3>
<div class="outline-text-3" id="text-1-8">
<ul class="org-ul">
<li>通过 setSharable 可以控制是否使用 implicit sharing</li>

<li>由于 container 使用 RefCount 实现了 shadow copy 和 copy on write, 通常不再需要
在堆上分配 Container, 直接在栈上分配即可. qt 保证了底层数据是在堆上分配的</li>

<li>使用 const 对象或 qAsConst 避免隐含的 detach</li>

<li>foreach 与 for(;) 的区别</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

<p class="author">Author: sunway (sunwayforever@gmail.com)<br />
Date: 2020-01-07 Tue 00:00<br />
Last updated: 2021-08-28 Sat 23:12</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。
<br />

<div id="disqus_thread"></div>
<script>

(function() { // DON'T EDIT BELOW THIS LINE
         var d = document, s = d.createElement('script');
         s.src = '//sunwayforever-github-io.disqus.com/embed.js';
         s.setAttribute('data-timestamp', +new Date());
         (d.head || d.body).appendChild(s);
         })();
</script>
</div>
</body>
</html>
